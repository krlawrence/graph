// vim: set tw=85 cc=+1 wrap spell redrawtime=20000:

[[gremlinserver]]
== INTRODUCING GREMLIN SERVER

We have now explored a few ways to set up a TinkerPop enabled graph store. We've
focused on running TinkerGraph locally as an in-memory graph. It's the easiest place
to start because it's packaged with Gremlin Console, but also because it requires
minimal configuration and environmental dependencies to begin use.

Not all graphs are this simple. Many graphs have underlying data stores with separate
indexing components. Others are backed by extensive cloud infrastructure and run as
a managed service. In these cases, it is desirable, or even required, that most of
the implementation details be hidden and access secured. This is where Gremlin Server
comes in.

Gremlin Server, as its name suggests, offers a way of setting up access to a graph
that via a front end web server. In this way the user of the graph only has to
know the host name or IP address of Gremlin Server to communicate with a graph. You
can set Gremlin Server up on your local machine, which is useful for testing, but you
can also use it to set up a graph on a remote server and allow users to access it. A
graph may even just expose Gremlin Server interfaces for you to connect to as the
only way to have access.

Gremlin Server supports a number of different connection protocols and methods. You
can connect to it from a Gremlin Console, from a command line using 'curl' commands
or from an application. Gremlin Server has a second advantage over allowing us to
hide the graph implementation details. It allows people using programming languages
that do not yet have Apache TinkerPop language bindings to work with a graph using
simple HTTP protocols.

NOTE: The official Apache TinkerPop documentation includes in-depth coverage of
configuring and using Gremlin Server.
https://tinkerpop.apache.org/docs/current/reference/#gremlin-server

Gremlin Server offers a lot of valuable capabilities. In this section we are going to
explain how to customize a local Gremlin Server setup with TinkerGraph. There are
many other useful ways that Gremlin Server can be configured, deployed and used. If
you plan to experiment further with Gremlin Server, we very much encourage you to
read the official documentation.

NOTE: For managed graph services that expose a Gremlin Server interface, there
typically isn't any access to the low-level configuration options mentioned here.
While some options may be exposed, most are hidden and maintained internally.

[[serverconfig]]
=== Configuring Gremlin Server

We've mentioned that Gremlin Server interfaces are often exposed by various graph
databases that have complicated underlying configurations and environments. While a
helpful advantage for production workloads, it is less helpful when doing
development, particularly when writing tests. Gremlin Server therefore presents a
helpful way for programmers to do local development without requiring the associated
infrastructure of their production graph. TinkerGraph can be configured within
Gremlin Server to try to closely mimic the behavior of the that production graph.

You can download Gremlin Server from the official Apache TinkerPop website at
https://tinkerpop.apache.org/

It only takes a few minutes to get Gremlin Server installed and running. You
download the ZIP, 'unzip' it and you are all set. As with Gremlin Console,
Gremlin Server also requires Java to be at version 11 or higher.

If you look at the files that were unzipped on your machine, you will find a path of
'conf/gremlin-server'. Inside this directory you will find a set of YAML and
properties files that can be used to start a Gremlin Server working with TinkerGraph
in and a variety of different ways.

For the rest of this discussion, we are going to use the 'gremlin-server.yaml' file
as our starting point and make minor modifications to it. Gremlin Server by default
is configured for a WebSockets connection, and that is how Gremlin Console connects
to it. Using WebSockets is the recommended approach when possible as it allows for a
long-running full duplex connection. However, there are still many use cases where
supporting an HTTP connection is desirable. There is also a third option that allows
both WebSockets and HTTP connections. In the YAML file used when starting Gremlin
Server, you need to specify one of the following.

org.apache.tinkerpop.gremlin.server.channel.WebSocketChannelizer::
- The server will expect a WebSockets connection (this is the default).
org.apache.tinkerpop.gremlin.server.channel.HttpChannelizer::
- The server will expect an HTTP connection.
org.apache.tinkerpop.gremlin.server.channel.WsAndHttpChannelizer::
- The server will accept both WebSockets and HTTP connections.

The first part of the 'gremlin-server.yaml' file, modified to meet our needs, is
shown below. We did not modify the parts of the file that are not shown, but we
encourage you to look at the whole file and study the settings. For our current needs
the defaults are fine, but this may not be true for your environment. The TinkerPop
documentation has detailed coverage of the settings and what they do.

OK, so let's look at the parts of the YAML file that are relevant to this experiment.
Note that we have chosen to use the 'WsAndHttpChannelizer'. This is because we want
our development environment to connect with both TinkerPop's drivers in our Java
application over WebSockets and other applications such as 'curl' and 'Ruby' over
HTTP to connect to our new Gremlin Server.

Notice also that the 'tinkergraph-empty.properties' file is specified in the 'graphs'
section. This is a file provided as part of the Gremlin Server download. This is the
file that Gremlin Server will use to configure the TinkerGraph to use for our
unit testing. We will examine that more closely a bit later.

The 'evaluationTimeout' setting is important. It tells Gremlin Server how long to let
a query run before terminating it. This essentially establishes the maximum amount of
time any query will be allowed to run, regardless of whether it has completed or not.
For this experiment the default setting of '30000' should be more than adequate. The
value represents the number of milliseconds allowed. If you want to allow queries
sent to the server to run for longer, you can increase this value. Keep in mind for a
production environment that if you have multiple users using the same Gremlin Server,
you may not want to allow someone to run a really complex query that might take a
long time to complete. If you want to disable the timeout feature, you can do that by
specifying a timeout value of '0'.

.gremlin-server.yaml
[source,yaml]
----
host: 0.0.0.0
port: 8182
evaluationTimeout: 30000
channelizer: org.apache.tinkerpop.gremlin.server.channel.WsAndHttpChannelizer
graphs: {
  graph: conf/tinkergraph-empty.properties }
scriptEngines: {
  gremlin-groovy: {
    plugins: { org.apache.tinkerpop.gremlin.server.jsr223.GremlinServerGremlinPlugin: {},
               org.apache.tinkerpop.gremlin.tinkergraph.jsr223.TinkerGraphGremlinPlugin: {},
               org.apache.tinkerpop.gremlin.groovy.jsr223.GroovyCompilerGremlinPlugin: {enableThreadInterrupt: true},
               org.apache.tinkerpop.gremlin.jsr223.ImportGremlinPlugin: {classImports: [java.lang.Math], methodImports: [java.lang.Math#*]},
               org.apache.tinkerpop.gremlin.jsr223.ScriptFileGremlinPlugin: {files: [scripts/empty-sample.groovy]}}}}
# The rest of the file is not shown
----

As well as the YAML file and the properties file, there is a third file that we need
to provide when starting a Gremlin Server. This file can contain Groovy code that
will be run when the server starts. For our purposes the default file is all we need.
These files should be placed in the 'scripts' directory that is part of the standard
Gremlin Server. We will take a look at the default script in a moment.

By default, Gremlin Server includes a Groovy script called 'empty-sample.groovy'.
That name is a bit misleading as the file actually does some interesting things. For
our purposes the most useful thing that the script does is to configure and make
available to us in Gremlin Console, the graph traversal source, 'g' object that
hopefully by now you are very familiar with. This provides you with a template for
any other 'global' variables that you may want to make available to the user of the
console connected to your Gremlin Server. The file also configures some default
log messages that will be generated when the server starts and stops. Note that you
can add your own code to this script or replace it with your own script entirely. You
will find additional example scripts included as part of Gremlin Server download.
These scripts do things such as create a TinkerGraph instance and load some graph
data as part of the server startup process. Using this technique, we could easily add
a line to the script so that when the server starts, an empty TinkerGraph is created
and the 'air-routes' data loaded.

.empty-sample.groovy
[source,groovy]
----
// an init script that returns a Map allows explicit setting of global bindings.
def globals = [:]

// defines a sample LifeCycleHook that prints some output to Gremlin Server console.
// note that the name of the key in the "global" map is unimportant.
globals << [hook : [
        onStartUp: { ctx ->
            ctx.logger.info("Executed once at startup of Gremlin Server.")
        },
        onShutDown: { ctx ->
            ctx.logger.info("Executed once at shutdown of Gremlin Server.")
        }
] as LifeCycleHook]

// define the default TraversalSource to bind queries to - this one will be named "g".
globals << [g : traversal().with(graph)]
----

Now that we have all of our configuration files in place, we can start the Gremlin
Server by typing the following command into a terminal window. The
'gremlin-server.sh' file is located in the 'bin' directory of your Gremlin Server
installation.

[source,shell]
----
$ gremlin-server.sh conf/gremlin-server/gremlin-server.yaml
----

If all goes well, you should see output from Gremlin Server displayed. The server
will keep running until you kill it. In this case a simple CTRL-C is all you need to
do to kill the server. After you press CTRL-C the server will do a bit of cleaning
up.

TIP: You can use the 'start' keyword to start Gremlin Server as a background task.

You can also start Gremlin Server in the background rather than have it take over
your current terminal window by adding the 'start' keyword as part of the invocation
command as shown below. The examples below assume that you are starting the server
from the place where you installed the Gremlin Server zip file.

[source,shell]
----
$ bin/gremlin-server.sh start

Server started 25897
----

By default, the configuration information for the server being started will look for
`conf/gremlin-server.yaml`. If you want to override the default, you need to provide
an environment variable called 'GREMLIN_YAML' before starting the server as shown
below.

[source,shell]
----
$ export GREMLIN_YAML='conf/mysettings.yaml'
$ bin/gremlin-server.sh start

Server started 25897
----

As an alternative to defining an environment variable, you can instead create a file
called `bin/gremlin-server.conf` and put the name of your YAML file in it. An example
is shown below.

[source,shell]
----
GREMLIN_YAML='conf/mysettings.yaml'
----

If you want to check whether Gremlin Server is currently running, you can use the
'status' keyword.

[source,shell]
----
$ bin/gremlin-server.sh status

Server running with PID 25897
----

To stop the server, you can use the 'stop' keyword as follows.

[source,shell]
----
$ bin/gremlin-server.sh stop

Server stopped [25897]
----

=== Loading air-routes In Gremlin Server

We've now started and stopped Gremlin Server with an empty TinkerGraph, but we also
alluded to being able to load data at the server startup by making changes to Gremlin
Server's configuration files. Let's load the air-routes dataset so that our
TinkerGraph has some data ready for querying when Gremlin Server starts. To load the
data, we need to edit 'empty-sample.groovy', which is the initializer for the server.
Since TinkerPop packages the air-routes dataset starting at TinkerPop 3.8.0, we will
also use the 'TinkerFactory' as a convenient way to load this data.

[source,groovy]
----
// an init script that returns a Map allows explicit setting of global bindings.
def globals = [:]

// defines a sample LifeCycleHook that prints some output to the Gremlin Server console.
// note that the name of the key in the "global" map is unimportant.
globals << [hook : [
        onStartUp: { ctx ->
            ctx.logger.info("Executed once at startup of Gremlin Server.")
            org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerFactory.generateAirRoutes(graph)
        },
        onShutDown: { ctx ->
            ctx.logger.info("Executed once at shutdown of Gremlin Server.")
        }
] as LifeCycleHook]

// define the default TraversalSource to bind queries to - this one will be named "g".
globals << [g : traversal().with(graph)]
----

We can see in the above script that we added a line to 'onStartUp' that will load the
air-routes data into the 'graph'. While this example made use of 'TinkerFactory' for
an easy way to load the data, we could have equally chosen to use any other means
we'd like to set up the graph.

[[serverconsole]]
=== Connecting to a Gremlin Server from the Gremlin Console

It is fairly straightforward to connect to a running Gremlin Server from a Gremlin
Console. Gremlin Server very nicely hides the back end implementation details from
us. As far as we are concerned, it is just an HTTP or WebSockets endpoint that can
handle Gremlin queries.

There is perhaps one exception to our statement about not needing to worry about
server side implementation details. This exception is a result of potential version
mismatches. Typically, the TinkerPop download, assuming you have the very latest,
will be at least a few minor point releases ahead of any given graph store release.
This is purely the case because whenever TinkerPop has a release, it takes a bit of
time for the graph database maintainers to catch up. We will give a concrete example
of this in a moment.

As with Gremlin Server, YAML files can be used to configure a remote connection from
the Gremlin Console. The Gremlin Console includes a set of YAML files that can be
used as-is or edited as needed. To connect the Gremlin Console to the Gremlin Server
that we just configured, the file 'remote.yaml' can be used. It is essential that the
console and the server be using the same version. If they are not, Gremlin  Console
and Gremlin Server may not be able to correctly communicate. Note that in the
'remote.yaml' file we also specify the name and port of the Gremlin Server host that
we will be connecting to. As we are running everything locally, the default host name
of 'localhost' is fine. If you are connecting to a remote Gremlin Server, the 'hosts'
value needs to be edited to correctly identify name or IP address of the server where
Gremlin Server is running. Also we can use the default port of 8182. By default, a
Gremlin Server listens on port 8182. The only reason you would need to change this
value is if you are connecting to a Gremlin Server using a different port.

.remote.yaml
[source,yaml]
----
hosts: [localhost]
port: 8182
serializer: { className: org.apache.tinkerpop.gremlin.util.ser.GraphBinaryMessageSerializerV1, config: { serializeResultToString: true }}
----

NOTE: Be sure that you align the version of TinkerPop you are using with the one
supported for the version of the graph database you have chosen. Consult the provider
documentation for these details.

[[remoteconn]]
==== Making the remote connection

Now that we have our YAML file ready, all that we have to do to establish a
connection between our Gremlin Console and Gremlin Server is to issue the following
command once the console is running. Be sure that Gremlin Server is running before
issuing this command.

[source,text]
----
gremlin> :remote connect tinkerpop.server conf/remote.yaml
----

Now that we are connected to Gremlin Server, we can send some Gremlin commands.
Given that the 'air-routes' graph is already loaded into our remote graph, we can
immediately start to issue some queries. To make sure the query goes to the remote
graph, the query needs to be prefixed with '":>"'.

[source,groovy]
----
gremlin> :> g.V().count()

3749
----

[[resultvar]]
==== Gremlin Console's 'result' variable

When working within Gremlin Console, it is useful to be aware of the fact that
results of queries sent to a server when the console is in '"local mode"', are made
available in two ways. They are displayed as a result but are also stored in a
variable called 'result'. Take a look at the query below.

[source,groovy]
----
gremlin> :>  g.V().hasLabel('continent').group().by('desc').by(out().count())

==>{South America=313, Asia=971, Europe=605, Africa=321, Antarctica=0, North America=989, Oceania=305}
----

If we were to print the contents of the 'result' variable we would find it contains
the results from the query.

[source,groovy]
----
gremlin> println result

[result{object={South America=313, Asia=971, Europe=605, Africa=321, Antarctica=0, North America=989, Oceania=305} class=java.lang.String}]
----

As the console is still in local mode, we can use some inline Groovy code to
post-process, in this case pretty print, the contents of 'result'. This capability is
worth keeping in mind. There are some interesting things it allows you to do, such as
doing local analysis on the results and saving them to a file locally when working
with a remote server.

[source,groovy]
----
gremlin> for (x in result['object'][0][1..-2].split(', ')) println x

South America=313
Asia=971
Europe=605
Africa=321
Antarctica=0
North America=989
Oceania=305
----

[[remotemode]]
==== Working in remote mode

As useful as keeping the console in '"local mode"' can be, if you are going to be
issuing a lot of queries to the remote graph, We find it more convenient to put the
console into '"remote mode"'. This can be done as follows.

[source,groovy]
----
gremlin> :remote console

All scripts will now be sent to Gremlin Server - [localhost/127.0.0.1:8182] - type ':remote console' to return to local mode
----

The console is now in '"remote mode"'. All queries that you enter will be sent to
Gremlin Server, and there is no need to use the '":>"' prefix.

[source,groovy]
----
gremlin> g.V().count()

3749
----

One thing to notice is that the output that comes back from Gremlin Server looks a
little different at times from when you use the commands using the Gremlin Console
attached to a local TinkerGraph. This is because Gremlin Console essentially does a
'toString()' on the output before it is shown to the user in these cases.

[source,groovy]
----
gremlin> g.V().has('code','AUS').valueMap()

{country=[US], code=[AUS], longest=[12250], city=[Austin], elev=[542], icao=[KAUS], lon=[-97.6698989868164], type=[airport], region=[US-TX], runways=[2], lat=[30.1944999694824], desc=[Austin Bergstrom International Airport]}
----

As an example of the slight differences in the output format, below you will find the
results from the same query when the graph was running as a local, in memory,
TinkerGraph.

[source,text]
----
[country:[US],code:[AUS],longest:[12250],city:[Austin],elev:[542],icao:[KAUS],lon:[-97.6698989868164],type:[airport],region:[US-TX],runways:[2],lat:[30.1944999694824],desc:[Austin Bergstrom International Airport]]
----

Once you are done sending all commands to Gremlin Server you can switch out of that
mode as follows. Commands will now be sent to your local console. This means that you
can work with a local and remote graph at the same time. The ':remote console'
command is therefore a toggle. Each time you use the command the console will switch
between local mode and remote mode or vice versa.

[source,text]
----
gremlin> :remote console

==>All scripts will now be evaluated locally - type ':remote console' to return to
remote mode for Gremlin Server - [localhost/127.0.0.1:8182]
----

If you are completely done with the remote connection for this console session you can
truly close it as follows. Having done this you will need to reestablish the
connection before the ':remote console' will work again.

[source,text]
----
gremlin> :remote close

==>Removed - Gremlin Server - [localhost/127.0.0.1:8182]

----

[[servercli]]
=== Connecting to a Gremlin Server from the command line

Now that we have a Gremlin Server up and running that supports both HTTP and Web
Sockets connections, we can, if we wish, communicate with it using nothing more than
a 'curl' command. The 'curl' command below uses an HTTP GET to send a query to our
Gremlin Server.

[source,text]
----
$ curl "http://localhost:8182?gremlin=g.V().has('code','AUS').valueMap()"
----

In response to the HTTP GET request, the server sends back the result packaged as
JSON as follows. We have formatted the output in a way that makes it easier to read.
What was actually returned did not have any line breaks in it at all and was quite
hard to read.

[source,json]
----
{"requestId":"a8ad654a-a5a3-4bb9-8474-69aca3c3db1e",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"country":["US"],
                       "code":["AUS"],
                    "longest":[12250],
                       "city":["Austin"],
                       "elev":[542],
                       "icao":["KAUS"],
                        "lon":[-97.6698989868164],
                       "type":["airport"],
                     "region":["US-TX"],
                    "runways":[2],
                        "lat":[30.1944999694824],
                       "desc":["Austin Bergstrom International Airport"]}],
           "meta":{}}}

----

The following example shows how to send the same query, but with the 'valueMap' step
removed, using an HTTP POST. The Apache TinkerPop documentation states that using
POST is the recommended way to send queries over HTTP to a Gremlin Server. Note how
in this case we are sending the query packaged as JSON and that we have to escape the
quote characters.

[source,shell]
----
$ curl -X POST -d "{\"gremlin\":\"g.V().has('code','AUS')\"}" \
            "http://localhost:8182"
----

As with the prior query, the HTTP POST form of the query also returns the result
packaged as JSON. However, in this case, because we left off the 'valueMap' step, the
JSON includes additional information in the form of the ID values and labels for the
vertex and its properties. This is because the result represents a vertex this time
rather than a map. We have again formatted the output in a way that is easier
to read.

[source,json]
----
{"requestId":"64c757b8-27a6-4509-a54c-ea35ba517667",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{
   "data":[
     {"id":12352,
      "label":"airport",
      "type":"vertex",
      "properties":
        {"country":[{"id":"8p4-9j4-8p1", "value":"US"}],
            "code":[{"id":"93c-9j4-5j9", "value":"AUS"}],
         "longest":[{"id":"9hk-9j4-mx1", "value":12250}],
            "city":[{"id":"9vs-9j4-7wl", "value":"Austin"}],
            "elev":[{"id":"aa0-9j4-but", "value":542}],
            "icao":[{"id":"ao8-9j4-6bp", "value":"KAUS"}],
             "lon":[{"id":"b2g-9j4-dfp", "value":-97.6698989868164}],
            "type":[{"id":"bgo-9j4-745", "value":"airport"}],
          "region":[{"id":"buw-9j4-9hh", "value":"US-TX"}],
         "runways":[{"id":"c94-9j4-b2d", "value":2}],
             "lat":[{"id":"cnc-9j4-cn9", "value":30.1944999694824}],
            "desc":[{"id":"d1k-9j4-a9x",
                  "value":"Austin Bergstrom International Airport"}]}}],
            "meta":{}}}

----

We have included examples of the different types of JSON results that you are likely
to have to process in the "<<serverjson>>" section that is coming up soon.

[[javagsclient]]
=== Connecting to a Gremlin Server from Java using 'with'

While it is perfectly possible to work directly with the JSON returned from Gremlin
Server, it is often more desirable to have the results placed directly into
variables of the appropriate type. If the appropriate Gremlin language driver exists
for the programming language that you are using, this is quite easy to set up. In
this section we will look at connecting to a Gremlin Server from a Java application
and taking advantage of the remote connection capability that TinkerPop provides.

NOTE: The source code in this section comes from the 'RemoteClient.java' sample
located at https://github.com/krlawrence/graph/tree/main/sample-code/java.

Let's look at the small application in sections. First, it is necessary to import the
required classes that we will need to make the connection to the server and retrieve
the query results.

[source,java]
----
import org.apache.tinkerpop.gremlin.driver.Cluster;
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;
import org.apache.tinkerpop.gremlin.driver.remote.DriverRemoteConnection;
import org.apache.tinkerpop.gremlin.util.ser.GraphBinaryMessageSerializerV1;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;

import static org.apache.tinkerpop.gremlin.process.traversal.AnonymousTraversalSource.traversal;
----

We can now define a small Java class that we will call 'RemoteClient' and set up the
connection to Gremlin Server. This is done by first creating a 'Cluster.Builder'
instance that will be used to describe the server we are connecting to and the
protocol we want to use. It is important that these settings match what Gremlin
Server is configured to use. For this basic example we are just using 'localhost' as
the host name, but the name of any Gremlin Server that you have access to can be used
instead. The default Gremlin Server port of '8182' is specified, and the
'GraphBinaryMessageSerializerV1' serialization format is selected. Again, this needs
to match both the protocol and the version of the protocol that your Gremlin Server
is supporting.

[source,java]
----
public class RemoteClient
{
  public static void main( String[] args )
  {
    Cluster.Builder builder = Cluster.build();
    builder.addContactPoint("localhost");
    builder.port(8182);
    builder.serializer(new GraphBinaryMessageSerializerV1());
----

Once the 'Cluster.Builder' instance has been set up we can use it to create our
'Cluster' instance.

[source,java]
----
Cluster cluster = builder.create();
----

Lastly, we need to set up a 'GraphTraversalSource' object for Gremlin Server hosted
graph that we will be working with. This object is often named "g" by convention and
is typically created using the statically imported 'traversal()' method which in turn
allows the call to 'with' to bind the traversal source to a graph. We've seen 'with'
take a graph instance before, but this time we will use it with a reference to a
remote connection to a graph in Gremlin Server. Note that the cluster instance that
we just created is passed in as a parameter. While this looks a little complicated,
it is really not a lot different from when we connect to a local graph using the
Gremlin Console. The only difference is that by setting up the remote connection this
way, when we start to issue queries against the graph, rather than getting JSON
objects back, the results will automatically be serialized into Java variables for
us. This makes our code a lot easier to write and essentially is the same code from
this point onwards that would also work with a local graph that we are directly
connected to.

[source,java]
----
GraphTraversalSource g = traversal().
        with(DriverRemoteConnection.using(cluster));
----

We can now use our new 'GraphTraversalSource' object to issue a Gremlin query. The
results will be placed directly into the 'List' called 'vmaps'. The query finds the
first 10 airports with a region code of 'GB-ENG' which is short for Great Britain
- England.

[source,java]
----
    List <Map<String,Object>> vmaps =
      g.V().has("airport","region","GB-ENG").limit(10).valueMap().toList();

    System.out.println("\n\nThe following airports were found\n");
    for (Map <String,Object> m : vmaps) {
      ArrayList code = (ArrayList) m.get("code");
      ArrayList desc = (ArrayList) m.get("desc");
      System.out.println(code.get(0) + " , " + desc.get(0));
    }

    cluster.close();
  }
}
----

When the Java application is compiled and run the output should look similar to that
shown below.

[source,text]
----
LEQ , Land's End Airport
LGW , London Gatwick
MAN , Manchester Airport
LHR , London Heathrow
LCY , London City Airport
STN , London Stansted Airport
EMA , East Midlands Airport
LPL , Liverpool John Lennon Airport
LBA , Leeds Bradford Airport
NCL , Newcastle Airport
----

[[rubyclient]]
=== Connecting to a Gremlin Server from Ruby

As far as we know, at the time of writing, there is currently no formal Gremlin
language binding support available for Ruby programmers. This is therefore a perfect
use case to show how, using a small amount of code, a Ruby programmer can connect to
a Gremlin Server and issue Gremlin Queries.

NOTE: The source code in this section comes from the 'gremlin-client-http.rb' sample
located at https://github.com/krlawrence/graph/tree/main/sample-code/ruby.

The code below represents a complete, standalone Ruby application. It uses the
standard Ruby libraries. No additional Ruby Gems or third party libraries should be
required. The example as shown connects to a Gremlin Server running on your local
machine. It packages up an HTTP POST request and sends it to Gremlin Server. The
body of the HTTP request is encoded as JSON.

.gremlin-client-http.rb
[source,ruby,linenums]
----
# Simple example of how you can connect to a Gremlin Server and
# issue queries from a Ruby application.

require 'net/http'
require 'uri'
require 'json'

uri = URI.parse("http://localhost:8182")

request = Net::HTTP::Post.new(uri)
req_options = { use_ssl: uri.scheme == "https", }

query = {"gremlin" => "g.V().has('code','AUS').out().count()"}
request.body = JSON.dump(query)

response = Net::HTTP.start(uri.hostname, uri.port, req_options) do |http|
  http.request(request)
end

puts "Response code from the server was #{response.code}"
puts response.body
----

Here is the output returned when we ran the program using Ruby version 2.3.1.

As you can see, the result body contains a JSON object just as when we issued
requests using the 'curl' command earlier.

[source,json]
----
{"requestId":"0129e905-6903-4658-9cfb-23404842ba12",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[62],"meta":{}}}
----

[[servertweaks]]
=== Tweaking queries to make the JSON returned easier to work with

Below is a query that we have seen used earlier in this book. It finds all routes
longer than 8,000 miles and returns the airport pairs and the distance between them.

[source,groovy]
----
g.V().as('a').outE().has('dist',gt(8000)).
      order().by('dist',desc).inV().as('b').
      filter(select('a','b').by('code').where('a', lt('b'))).
      path().by('code').by('dist')
----

When we run this query using the Gremlin Console with TinkerGraph, we get
back results that have been to a degree 'pretty printed' by the Console as
shown below.

[source,groovy]
----
[JFK,9526,SIN]
[EWR,9523,SIN]
[AKL,9025,DOH]
[LHR,9009,PER]
[PEK,8884,PTY]
[AKL,8818,DXB]
[LAX,8756,SIN]
[CAN,8754,MEX]
[IAH,8591,SYD]
[DFW,8574,SYD]
[JFK,8504,MNL]
[ATL,8434,JNB]
[SFO,8433,SIN]
[AUH,8372,LAX]
[DXB,8321,LAX]
[JED,8314,LAX]
[DOH,8287,LAX]
[LAX,8246,RUH]
[SCL,8208,TLV]
[MEL,8197,YVR]
[AKL,8186,ORD]
[DXB,8150,IAH]
[AUH,8139,SFO]
[HKG,8135,IAD]
[DFW,8105,HKG]
[DXB,8085,SFO]
[SEA,8059,SIN]
[HKG,8054,JFK]
[AUH,8053,DFW]
[EWR,8047,HKG]
[DOH,8030,IAH]
[DFW,8022,DXB]
----

However, if you were to use a system that returns the full JSON response, as is the
case when using a Gremlin Server over an HTTP connection, you will not get the
benefit of Gremlin Console '"pretty printing"'. Instead, you will get back something
that looks a lot like this from the exact same query as the one we used above.

[source,json]
----
{"requestId":"5acca62c-7351-4b3d-bb20-3660f6feb3cc",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":
    [{"labels":[["a"],[],["b"]],"objects":["AKL",9025,"DOH"]},
    {"labels":[["a"],[],["b"]],"objects":["AKL",8818,"DXB"]},
    {"labels":[["a"],[],["b"]],"objects":["LAX",8756,"SIN"]},
    {"labels":[["a"],[],["b"]],"objects":["CAN",8754,"MEX"]},
    {"labels":[["a"],[],["b"]],"objects":["IAH",8591,"SYD"]},
    {"labels":[["a"],[],["b"]],"objects":["DFW",8574,"SYD"]},
    {"labels":[["a"],[],["b"]],"objects":["ATL",8434,"JNB"]},
    {"labels":[["a"],[],["b"]],"objects":["SFO",8433,"SIN"]},
    {"labels":[["a"],[],["b"]],"objects":["AUH",8372,"LAX"]},
    {"labels":[["a"],[],["b"]],"objects":["DXB",8321,"LAX"]},
    {"labels":[["a"],[],["b"]],"objects":["JED",8314,"LAX"]},
    {"labels":[["a"],[],["b"]],"objects":["DOH",8287,"LAX"]},
    {"labels":[["a"],[],["b"]],"objects":["LAX",8246,"RUH"]},
    {"labels":[["a"],[],["b"]],"objects":["MEL",8197,"YVR"]},
    {"labels":[["a"],[],["b"]],"objects":["DXB",8150,"IAH"]},
    {"labels":[["a"],[],["b"]],"objects":["AUH",8139,"SFO"]},
    {"labels":[["a"],[],["b"]],"objects":["DFW",8105,"HKG"]},
    {"labels":[["a"],[],["b"]],"objects":["DXB",8085,"SFO"]},
    {"labels":[["a"],[],["b"]],"objects":["HKG",8054,"JFK"]},
    {"labels":[["a"],[],["b"]],"objects":["AUH",8053,"DFW"]},
    {"labels":[["a"],[],["b"]],"objects":["EWR",8047,"HKG"]},
    {"labels":[["a"],[],["b"]],"objects":["DOH",8030,"IAH"]},
    {"labels":[["a"],[],["b"]],"objects":["DFW",8022,"DXB"]}],
    "meta":{}}}
----

What is being returned is useful in some cases. For example, we can see the 'a' and
'b' labels that we used in our query, but in this case all we really wanted was the
last part with the airport codes and the distances. We could decide to write code to
process this JSON as-is, and that is a valid choice you could make. However, by
tweaking the query slightly, we can enable Gremlin to give us back what we really
wanted. Let's start by looking at what happens if we add '.toList().toString()' to
the end of the query. Take a look at the modified form of the query below.

[source,groovy]
----
g.V().as('a').outE().has('dist',gt(8000)).
      order().by('dist',desc).inV().as('b').
      filter(select('a','b').by('code').where('a', lt('b'))).
      path().by('code').by('dist').toList().toString()
----

If we were to send this modified form of the query to our Gremlin Server, we should
get back something that looks a lot more like the result we got back when working
with the Gremlin Console. As shown below, it is certainly a bit easier to process in
your application now. However, this is still not an ideal result as what we now have
is a list containing  a single string with all of our routes in it.

[source,json]
----
{"requestId":"63c660d0-28cf-41fc-86cf-5560a4e2fac0","status":{"message":"","code":200,"attributes":{}},"result":{"data":["[[AKL, 9025, DOH], [AKL, 8818, DXB], [LAX, 8756, SIN], [CAN, 8754, MEX], [IAH, 8591, SYD], [DFW, 8574, SYD], [ATL, 8434, JNB], [SFO, 8433, SIN], [AUH, 8372, LAX], [DXB, 8321, LAX], [JED, 8314, LAX], [DOH, 8287, LAX], [LAX, 8246, RUH], [MEL, 8197, YVR], [DXB, 8150, IAH], [AUH, 8139, SFO], [DFW, 8105, HKG], [DXB, 8085, SFO], [HKG, 8054, JFK], [AUH, 8053, DFW], [EWR, 8047, HKG], [DOH, 8030, IAH], [DFW, 8022, DXB]]"],"meta":{}}}
----

We can add a little more post-processing to split up our single string into an
array of strings where each string is a single route of the form
'[AKL,9025,DOH]'. One way to do this is to trim off the unwanted characters at
each end of the string and then use split to divide it up. As there are a lot
of commas in the string, we could not just do a simple 'split(",")' as that
would not have returned what we wanted. To make the split work, we replaced
every occurrence of '],' in the string with ']x' and then did the split using
'split("x")'. Here is the modified query.

[source,groovy]
----
g.V().as('a').outE().has('dist',gt(8000)).
      order().by('dist',desc).inV().as('b').
      filter(select('a','b').by('code').where('a', lt('b'))).
      path().by('code').by('dist').toList().toString()[1..-2].
      replaceAll('],',']x').split('x')
----

Here is what we now get back in the returned JSON. Each route is now a string
in an array of strings. From here it is a simple task to extract the airport
names and distances for each route.

[source,json]
----
{"requestId":"9d8324a8-89e4-4c1e-be59-ff433784a3da",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[ " [AKL, 9025, DOH]",
                    " [AKL, 8818, DXB]",
                    " [LAX, 8756, SIN]",
                    " [CAN, 8754, MEX]",
                    " [IAH, 8591, SYD]",
                    " [DFW, 8574, SYD]",
                    " [ATL, 8434, JNB]",
                    " [SFO, 8433, SIN]",
                    " [AUH, 8372, LAX]",
                    " [DXB, 8321, LAX]",
                    " [JED, 8314, LAX]",
                    " [DOH, 8287, LAX]",
                    " [LAX, 8246, RUH]",
                    " [MEL, 8197, YVR]",
                    " [DXB, 8150, IAH]",
                    " [AUH, 8139, SFO]",
                    " [DFW, 8105, HKG]",
                    " [DXB, 8085, SFO]",
                    " [HKG, 8054, JFK]",
                    " [AUH, 8053, DFW]",
                    " [EWR, 8047, HKG]",
                    " [DOH, 8030, IAH]",
                    " [DFW, 8022, DXB]"]
----

It's really a matter of personal preference whether you decide to have the query
return less data or just return the full set of data that we got back from the
initial query. One advantage to having the query limit what is returned is that less
data, potentially a lot less data, will need to be sent back to your application and
stored in memory or on disk. However, as most programming languages have built-in
support that makes it easy to deserialize JSON objects into native data structures,
you may prefer to just have all the JSON be returned and do the rest of the
processing yourself.

Here is a basic example. If we added the following lines to our Ruby application that
we created in the previous section and used the original query from before we
added any post-processing, we could easily get at the parts of the JSON that we are
interested in.

[source,ruby]
----
res = JSON.parse(response.body)['result']['data']

res.each do |x|
  p x['objects']
end
----

The code uses Ruby's 'JSON' class to convert the JSON response from the Gremlin
Server into a map data structure. We can then access each part of the map by the
names contained in the JSON. Note that the code as written expects a specific set of
keywords to be present in the JSON. Not all query results contain these keywords.
Therefore, it would take a little more work to turn this into a more general-purpose
piece of code that could handle any of the possible JSON return formats the server
could send to us. Here is the output from running the updated Ruby code. Notice that
what we have now is a nice collection of lists, each one containing two strings and
an integer. The data is now in a form that is really easy and convenient to process
further.

[source,groovy]
----
["AKL", 9025, "DOH"]     ["LAX", 8246, "RUH"]
["AKL", 8818, "DXB"]     ["MEL", 8197, "YVR"]
["LAX", 8756, "SIN"]     ["DXB", 8150, "IAH"]
["CAN", 8754, "MEX"]     ["AUH", 8139, "SFO"]
["IAH", 8591, "SYD"]     ["DFW", 8105, "HKG"]
["DFW", 8574, "SYD"]     ["DXB", 8085, "SFO"]
["ATL", 8434, "JNB"]     ["HKG", 8054, "JFK"]
["SFO", 8433, "SIN"]     ["AUH", 8053, "DFW"]
["AUH", 8372, "LAX"]     ["EWR", 8047, "HKG"]
["DXB", 8321, "LAX"]     ["DOH", 8030, "IAH"]
["JED", 8314, "LAX"]     ["DFW", 8022, "DXB"]
["DOH", 8287, "LAX"]
----

In the next section you will find more examples of the JSON that can be returned by
Gremlin Server and also some examples of how to reduce the amount of data that is
returned.

[[serverjson]]
=== More examples of the JSON returned from a Gremlin Server

The JSON returned by Gremlin Server depends on the query that is used and more
specifically, what that query returns. Everything returned in the 'data' part of the
'result'  will, at the outermost level, be an array. What is inside that array could
be a simple number or a string. It could also be a list of strings or other objects
including maps. If you plan to write some general-purpose code that can handle the
different possible formats, it is important to know what they look like. In the
examples that follow, we have attempted to show several of the possible response
formats that you may encounter. We are mainly going to focus on the parts of the JSON
that follow the 'data' key. Each example assumes that the query shown was sent to a
Gremlin Server using the HTTP protocol. As always, if you are unsure what JSON a
particular query may generate, you should always run some experiments to find out.

Please note that some of the queries that follow  may not represent the best way to
achieve the specific result. We have deliberately picked queries that show different
Gremlin steps to give you a feel for the type of JSON result each generates.

==== No result

The following query does not return any results. The JSON reflects this in the form
of the 'data' returned being an empty list '"[]"'.

[source,groovy]
----
g.V().has('code','AUS').out('route').has('code','SYD')

{"requestId":"e68ce6d6-29a0-4a70-af35-b4e8bb123458",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[],"meta":{}}}
----

==== Integer result

A simple query that just returns a single integer result will generate JSON as shown
below. The 'result' section of the JSON will contain a 'data' section with the single
integer value encoded as a list with one member.

[source,groovy]
----
g.V().count()

{"requestId":"25fc4d45-3e58-4f72-99b1-fe1c6575fdd0",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[3624],"meta":{}}}
----

==== String result

As with integer results, a query that just returns a single string  result will
generate JSON as shown below. The 'result' section of the JSON will contain a 'data'
section with the single string value encoded as a list with one member.

[source,groovy]
----
g.V().has('code','DFW').values('city')

{"requestId":"0ae1e2af-adea-487c-b365-7ef76bb56791",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":["Dallas"],"meta":{}}}
----

==== List of strings

The query below generates a 'data' array containing a list of strings representing
airport codes.

[source,groovy]
----
g.V().has('code','SAF').out().values('code')

{"requestId":"264cbaf8-6679-43b0-936c-f65b9f6fd0ed",
"status":{"message":"","code":200,"attributes":{}},
"result":{"data":["PHX","DFW","LAX","DEN"],"meta":{}}}
----

==== List of integers

The query below generates a 'data' array containing a list of integers representing
runway counts. Note that in reality you would not use a 'sack' for this, a simple
'values' step will generate the same results, but we wanted to show an example that
uses a 'sack' step.

[source,groovy]
----
g.withSack(0).V().has('code','SAF').out().sack(sum).by('runways').sack()

{"requestId":"23598951-ffa4-440d-910f-eebc6d5f620a",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[3,7,4,6],"meta":{}}}
----

==== List of mixed types

It is common for a query result to contain a variety of different data types. The
example below generates a list containing a string, and integer and a double. Note,
as we have seen before, TinkerPop does not guarantee the order in which results are
returned so do not create any dependencies on that.

[source,groovy]
----
g.V().has('code','LGW').values('city','lat','runways')

{"requestId":"6043ce66-221b-49b8-a3f9-6131eef3b9c2",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":["London",2,51.1481018066406],"meta":{}}}
----

==== Value map

As you might expect, when a 'valueMap' is used to generate the result from a query,
the JSON generated also contains a map. Note how each property value is encoded in a
list even if there is only one value.

[source,groovy]
----
g.V().has('code','CDG').valueMap()

{"requestId":"c989a182-aa97-4ed7-bddb-7f0e3ad237d6",
    "status":{"message":"","code":200,"attributes":{}},
    "result":{"data":[{
       "country":["FR"],
          "code":["CDG"],
       "longest":[13829],
          "city":["Paris"],
          "elev":[392],
          "icao":["LFPG"],
           "lon":[2.54999995232],
          "type":["airport"],
        "region":["FR-J"],
       "runways":[4],
           "lat":[49.0127983093],
          "desc":["Paris Charles de Gaulle"]}],"meta":{}}}
----

==== Single vertex

In Gremlin Console you get back something like "'v[51]'" when your query returns a
vertex. Wit Gremlin Server what you get back is a JSON object representing everything
that is known about the vertex including its ID, label, properties and the ID of each
property. If you do not need the entire vertex  returned, it might be worth writing
your query in a way such that you only get back the properties that you are
interested in. This is especially pertinent if your query could potentially return a
lot of vertices in the result.

[source,groovy]
----
g.V().has('code','CDG')

{"requestId":"a70cab32-73a5-492f-a00b-0c7d66485b18",
    "status":{"message":"","code":200,"attributes":{}},
    "result":{"data":
       [{"id":69736,
      "label":"airport",
      "type":"vertex",
"properties":
     {"country":[{"id":"2e4t-1ht4-8p1", "value":"FR"}],
         "code":[{"id":"2ej1-1ht4-5j9","value":"CDG"}],
      "longest":[{"id":"2ex9-1ht4-mx1","value":13829}],
         "city":[{"id":"2fbh-1ht4-7wl","value":"Paris"}],
         "elev":[{"id":"2fpp-1ht4-but","value":392}],
         "icao":[{"id":"2g3x-1ht4-6bp","value":"LFPG"}],
         " lon":[{"id":"2gi5-1ht4-dfp","value":2.54999995232}],
         "type":[{"id":"2gwd-1ht4-745","value":"airport"}],
       "region":[{"id":"2hal-1ht4-9hh","value":"FR-J"}],
      "runways":[{"id":"2hot-1ht4-b2d","value":4}],
          "lat":[{"id":"2i31-1ht4-cn9","value":49.0127983093}],
         "desc":[{"id":"2ih9-1ht4-a9x","value":"Paris Charles de Gaulle"}]}}],
    "meta":{}}}
----

==== Selected vertex information

One way to limit the amount of JSON we get back is shown below. Let's assume for a
selection of airport vertices, all we are interested in is the ID, airport code and
city name. We can construct a query, as shown below, that will return just those
values for each vertex.

[source,groovy]
----
g.V().hasLabel('airport').sample(3).
      union(id(),values('code','city'))

{"requestId":"4d308287-9725-4fa6-8c2b-b7e517ca5009",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[45096,"SCL","Santiago",
                  610336,"YWK","Wabush",
                  163880,"CAK","Akron"],"meta":{}}}
----

==== Single edge

Just as when we queried a single vertex, when we query a single edge, we get back a
lot of information including its label and ID and information about the vertices the
edge is connected to.

[source,groovy]
----
g.V().has('code','SAF').outE().limit(1)

{"requestId":"cac0a975-33a0-4714-a797-1be782201a27",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"
        id":"2xhcd-1560-pat-39s",
    "label":"route",
     "type":"edge","inVLabel":"airport",
                  "outVLabel":"airport","
                         inV":4240,
                       "outV":53352,
                 "properties":{"dist":369}}],"meta":{}}}
----

==== New vertex

When a new vertex and some properties are added the returned JSON will contain all of
the information about the vertex including its ID, label and type as well as its
properties.

[source,groovy]
----
g.addV('test').property('fruit','apple')

{"requestId":"accd4354-0db9-417d-927f-c0945e1721dc",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"id":4248,
          "label":"test",
           "type":"vertex",
     "properties":{"fruit":[{"id":"177-3a0-28lh",
                          "value":"apple"}]}}],"meta":{}}}
----

==== New vertex only returning the ID

When adding a new vertex, if you are not really interested in getting back the entire
new vertex and its properties, you can write the query to only return the ID of the
new vertex as shown below.

[source,groovy]
----
g.addV('test').as('a').property('fruit','apple').select('a').id()

{"requestId":"c50d0fa7-5caa-4294-8eca-310f032b1c42",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[8344],"meta":{}}}
----

==== Path by value (list of strings)

The query below returns a path between two airports as a list of airport codes.
Note the new 'objects' key that is used when the returned JSON represents a path.

[source,groovy]
----
g.V().has('code','SAF').out().path().by('code').limit(1)

{"requestId":"b9a1655f-1b14-4313-96d0-085858f47de7",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"labels":[[],[]],
                   "objects":["SAF","PHX"]}],"meta":{}}}
----

==== Path by values (list of strings and integers)

Similar to the previous query but this time the path also includes the distance
between the airports.

[source,groovy]
----
g.V().has('code','SAF').outE().inV().path().by('code').by('dist').limit(1)


{"requestId":"c4eb3141-be1e-4335-aa04-50843f73838b",
    "status":{"message":"","code":200,"attributes":{}},
    "result":{"data":[{"labels":[[],[],[]],
                      "objects":["SAF",369,"PHX"]}],"meta":{}}}
----

==== Two vertex path

The query below returns a path but does not include a 'by' modulator so what is
returned is the two vertices along with their IDs, labels and properties.

[source,groovy]
----
g.V().has('code','SAF').out().path().limit(1)

{"requestId":"bcdc3113-d1f6-41cf-b2ad-b1409646677e",
    "status":{"message":"","code":200,"attributes":{}},
    "result":{"data":[{"labels":[[],[]],
           "objects":[{
              "id":53352,
           "label":"airport",
            "type":"vertex",
      "properties":{
         "country":[{"id":"1s0d-1560-8p1","value":"US"}],
             "code":[{"id":"1sel-1560-5j9","value":"SAF"}],
          "longest":[{"id":"1sst-1560-mx1","value":8366}],
             "city":[{"id":"1t71-1560-7wl","value":"Santa Fe"}],
             "elev":[{"id":"1tl9-1560-but","value":6348}],
             "icao":[{"id":"1tzh-1560-6bp","value":"KSAF"}],
              "lon":[{"id":"1udp-1560-dfp","value":-106.088996887}],
             "type":[{"id":"1urx-1560-745","value":"airport"}],
           "region":[{"id":"1v65-1560-9hh","value":"US-NM"}],
          "runways":[{"id":"1vkd-1560-b2d","value":3}],
              "lat":[{"id":"1vyl-1560-cn9","value":35.617099762}],
             "desc":[{"id":"1wct-1560-a9x","value":"Santa Fe"}]}},

             {"id":4240,
           "label":"airport",
            "type":"vertex",
      "properties":{
          "country":[{"id":"176-39s-8p1","value":"US"}],
             "code":[{"id":"1le-39s-5j9","value":"PHX"}],
          "longest":[{"id":"1zm-39s-mx1","value":11489}],
             "city":[{"id":"2du-39s-7wl","value":"Phoenix"}],
             "elev":[{"id":"2s2-39s-but","value":1135}],
             "icao":[{"id":"36a-39s-6bp","value":"KPHX"}],
              "lon":[{"id":"3ki-39s-dfp","value":-112.012001037598}],
             "type":[{"id":"3yq-39s-745","value":"airport"}],
           "region":[{"id":"4cy-39s-9hh","value":"US-AZ"}],
          "runways":[{"id":"4r6-39s-b2d","value":3}],
              "lat":[{"id":"55e-39s-cn9","value":33.4342994689941}],
             "desc":[{"id":"5jm-39s-a9x",
              "value":"Phoenix Sky Harbor International Airport"}]}}]}],
      "meta":{}}}
----

==== Path with two vertices and an edge

The following query is similar to the previous one but also includes an edge. You can
hopefully see here how the JSON can rapidly get large if we are not more specific in
our queries about what results we really need back. Notice how, because this is a
path result, most of the data is contained inside an 'objects' key.

[source,groovy]
----
g.V().has('code','SAF').outE().inV().path().limit(1)

{"requestId":"171d0f30-2f93-4ae6-a421-4601a35388a2",
 "status":{"message":"","code":200,"attributes":{}},
  "result":{"data":[{"labels":[[],[],[]],
  "objects":[
       {"id":53352,"label":"airport","type":"vertex",
       "properties":
           {"country":[{"id":"1s0d-1560-8p1","value":"US"}],
           "code":[{"id":"1sel-1560-5j9","value":"SAF"}],
           "longest":[{"id":"1sst-1560-mx1","value":8366}],
           "city":[{"id":"1t71-1560-7wl","value":"Santa Fe"}],
           "elev":[{"id":"1tl9-1560-but","value":6348}],
           "icao":[{"id":"1tzh-1560-6bp","value":"KSAF"}],
           "lon":[{"id":"1udp-1560-dfp","value":-106.088996887}],
           "type":[{"id":"1urx-1560-745","value":"airport"}],
           "region":[{"id":"1v65-1560-9hh","value":"US-NM"}],
           "runways":[{"id":"1vkd-1560-b2d","value":3}],
           "lat":[{"id":"1vyl-1560-cn9","value":35.617099762}],
           "desc":[{"id":"1wct-1560-a9x","value":"Santa Fe"}]}},

       {"id":"2xhcd-1560-pat-39s",
        "label":"route",
        "type":"edge",
        "inVLabel":"airport",
        "outVLabel":"airport",
        "inV":4240,"outV":53352,
            "properties":{"dist":369}},

       {"id":4240,"label":"airport","type":"vertex",
       "properties":
           {"country":[{"id":"176-39s-8p1","value":"US"}],
            "code":[{"id":"1le-39s-5j9","value":"PHX"}],
            "longest":[{"id":"1zm-39s-mx1","value":11489}],
            "city":[{"id":"2du-39s-7wl","value":"Phoenix"}],
            "elev":[{"id":"2s2-39s-but","value":1135}],
            "icao":[{"id":"36a-39s-6bp","value":"KPHX"}],
            "lon":[{"id":"3ki-39s-dfp","value":-112.012001037598}],
            "type":[{"id":"3yq-39s-745","value":"airport"}],
            "region":[{"id":"4cy-39s-9hh","value":"US-AZ"}],
            "runways":[{"id":"4r6-39s-b2d","value":3}],
            "lat":[{"id":"55e-39s-cn9","value":33.4342994689941}],
            "desc":[{"id":"5jm-39s-a9x",
              "value":"Phoenix Sky Harbor International Airport"}]}}]}],
      "meta":{}}}
----

==== Selection map

If a query ends with a 'select' step that references labels defined earlier in the
query, what is returned is a map where the labels are the keys and the values are the
things that the labels were attached to in the query.

[source,groovy]
----
g.V().has('code','SAF').as('a').out().has('code','DFW').as('b').
      select('a','b').by('code')

{"requestId":"af8de8e6-4137-4378-bb31-921e134d0661",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"a":"SAF","b":"DFW"}],"meta":{}}}
----

==== Projected map

The 'project' step also generates a map just as the 'select' step did in the previous
example.

[source,groovy]
----
g.V().has('code','LGW').project('a','b').by('code').by(out().count())

{"requestId":"57819d0b-c27e-40d7-a89a-e69a6b4872a1",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"a":"LGW","b":204}],"meta":{}}}
----

==== Strings and a map

The following path query returns a list containing two strings representing airport
codes and the full JSON object representing an edge.

[source,groovy]
----
g.V().has('code','SAF').outE().inV().limit(1).path().by('code').by()

{"requestId":"5102bb14-e594-41ec-8643-89882377b1e7",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"labels":[[],[],[]],
           "objects":["SAF",
                      {"id":"2xhcd-1560-pat-39s",
                      "label":"route",
                      "type":"edge",
                      "inVLabel":"airport",
                      "outVLabel":"airport",
                      "inV":4240,
                      "outV":53352,
                      "properties":{"dist":369}},
                      "PHX"]}],"meta":{}}}
----

==== Nested lists

When using the console or issuing Gremlin commands via the TinkerPop API from an
application program, ending a query with a 'fold' step can be a nice way to put all
the results into a list. When working with a Gremlin Server, ending a query with a
'fold' step in many cases is redundant as the results will be placed in a list inside
the JSON anyway. In the example below, the 'fold' step simply caused an extra list to
be nested inside the one that was generated while the JSON was being assembled.

[source,groovy]
----
g.V().has('region','US-OK').values('code').fold()

{"requestId":"edcea305-086d-4f8d-b79a-ff72c5a26847",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[["OKC","TUL","LAW","SWO"]],"meta":{}}}

----

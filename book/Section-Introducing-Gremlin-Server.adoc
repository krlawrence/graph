// vim: set tw=85 cc=+1 wrap spell redrawtime=20000:

[[gremlinserver]]
INTRODUCING GREMLIN SERVER
--------------------------

We have now explored a few ways to setup a TinkerPop enabled graph
store. Initially we focussed on running TinkerGraph locally. Next we looked at
JanusGraph, both as an in memory store, and connected to Cassandra, running locally
or remotely. In each case, successfully making the connection to Cassandra, required
knowledge of specific configuration details; such as IP addresses, ports and the
protocols being used.

While this may be acceptable in scenarios where it is OK for the user of the graph to
have this level of insight and access into the back end, there are many scenarios
where it is desirable to keep most of the implementation detail hidden and access
secured. This is where Gremlin Server comes in.

Gremlin Server, as its name suggests, offers a way of setting up access to a graph
that goes via a front end web server. In this way the user of the graph only has to
know the name or IP address of the Gremlin Server in order to communicate with a
graph. You can set Gremlin Server up on your local machine, which is useful for
testing but you can also use it to setup a graph on a remote server and allow users
to access it. Gremlin Server supports a number of different connection protocols and
methods. You can connect to it from a Gremlin console, from a command line using
'curl' commands or from an application. Gremlin Server has a second advantage over
allowing us to hide the graph implementation details. It allows people using
programming languages that do not yet have Apache TinkerPop language bindings to work
with a graph using simple HTTP protocols.

NOTE: The official Apache TinkerPop documentation includes in depth coverage of
configuring and using Gremlin Server.
http://tinkerpop.apache.org/docs/current/reference/#gremlin-server

Gremlin Server offers a lot of valuable capabilities. In this section we are going to
explain how to take the JanusGraph backed by Cassandra that we built earlier and
expose it via Gremlin Server. There are many other useful ways that Gremlin Server
can be configured, deployed and used. If you plan to experiment further with Gremlin
Server we very much encourage you to read the official documentation.

NOTE: When this book was first released, the majority of "real world" use cases
focussed on directly attached or even in memory graphs. As Apache TinkerPop has
evolved, it has become a lot more common to connect to a graph remotely via a Gremlin
Server.

[[serverconfig]]
Configuring Gremlin Server
~~~~~~~~~~~~~~~~~~~~~~~~~~

The Gremlin Server runtime is a separate download available from the Apache TinkerPop
Web site. However, if you are going to be using Gremlin Server in conjunction with
JanusGraph you should use the version of Gremlin Server that comes bundled as part of
the JanusGraph download. The JanusGraph version comes preconfigured to work more
easily with the JanusGraph runtimes and connect more easily to JanusGraph managed
back end stores like Cassandra. The simplest way to configure Gremlin Server is to
use the YAML and properties files that are delivered as part of the Gremlin Server or
JanusGraph downloads. Depending on your configuration, you may need to edit these
files.

The Apache TinkerPop documentation has detailed instructions and examples showing
different ways of configuring a Gremlin Server. In this section we are going to focus
on setting up a Gremlin Server that can front end the JanusGraph and Dockerized
Cassandra instance that we configured earlier.

If you look at the files that were installed on your machine when you unzipped the
JanusGraph download, you will find a path of 'conf/gremlin-server'. Inside this
directory you will find a set of YAML and properties files that can be used to start
a Gremlin Server working with JanusGraph and a variety of different back end stores.

For the rest of this discussion we are going to use the 'gremlin-server.yaml' file as
our starting point and make minor modifications to it.

The Gremlin Server by default is configured for a WebSockets connection and that is
how the Gremlin Console connects to it. Using WebSockets is the recommended approach
when possible as it allows for a long running full duplex connection. However, there
are still many use cases where supporting an HTTP connection is desirable. There is
also a third option that allows both WebSockets and HTTP connections. In the YAML
file that is used when starting a Gremlin Server you need to specify one of the
following.

org.apache.tinkerpop.gremlin.server.channel.WebSocketChannelizer::
- The server will expect a WebSockets connection (this is the default).
org.apache.tinkerpop.gremlin.server.channel.HttpChannelizer::
- The server will expect an HTTP connection.
org.apache.tinkerpop.gremlin.server.channel.WsAndHttpChannelizer::
- The server will accept both WebSockets and HTTP connections.

The first part of the 'gremlin-server.yaml' file, modified to meet our needs is shown
below. We did not modify the parts of the file that are not shown but we encourage
you to look at the whole file and study the settings. For our current needs the
defaults are fine. However, in your environment the defaults may not meet your needs.
The TinkerPop documentation has detailed coverage of the settings and what they do.

OK so let's look at the parts of the YAML file that are relevant to this experiment.
Note that we have chosen to use the 'WsAndHttpChannelizer'. This is because we want
to allow both the Gremlin Console over WebSockets and other applications such as
'curl' and 'Ruby' over HTTP to connect to our new Gremlin Server.

Notice also that the 'janusgraph-cassandra-es.server.properties' file is specified in
the 'graphs' section. This is a file that is provided as part of the JanusGraph
download. This is the file that Gremlin Server will use to connect to our JanusGraph
backed by Cassandra. Note that the '"-es"' in the properties file name refers to
Elasticsearch. As we did not configure an external index when we setup our
JanusGraph the lines referring to Elasticsearch inside the properties file should be
commented out.

The 'evaluationTimeout' setting is important. It tells the Gremlin Server how long to
let a query run before terminating it. This essentially establishes the maximum 
amount of time any query will be allowed to run, regardless of whether it has
completed or not. For this experiment the default setting of 30000 should be more
than adequate. The value represents the number of milliseconds allowed. If you want
to allow queries sent to the server to run for longer you can increase this value.
Just keep in mind that if you have multiple users using the same Gremlin Server you
may not want to allow someone to run a really complex query that might take a long
time to complete. As a side note, we have seen people increase this value to allow
queries to complete when in fact what they should have been doing is creating an
index in the graph to allow the query to run faster and hence take less time! If you
want to disable the timeout feature you can do that by specifying a timeout value of
0 (zero).

.gremlin-server.yaml
[source,groovy]
----
host: 0.0.0.0
port: 8182
evaluationTimeout: 30000
channelizer: org.apache.tinkerpop.gremlin.server.channel.WsAndHttpChannelizer
graphs: {
  graph: conf/gremlin-server/janusgraph-cassandra-es-server.properties
}
plugins:
  - janusgraph.imports
scriptEngines: {
  gremlin-groovy: {
    imports: [java.lang.Math],
    staticImports: [java.lang.Math.PI],
    scripts: [scripts/empty-sample.groovy]}}

# The rest of the file is not shown
----

As well as the YAML file and the properties file, there is a third file that we need
to provide when starting a Gremlin Server. This file can contain Groovy code that
will be run when the server starts. For our purposes the default file is all we need.
These files should be placed in the 'scripts' directory that is part of the standard
Gremlin Server or JanusGraph install. We will take a look at the default script in a
moment.

By default both Gremlin Server and JanusGraph include a Groovy script called
`empty-sample.groovy`. That name is a bit misleading as the file actually does some
interesting things. For our purposes the most useful thing that the script does is to
configure and make available to us in the Gremlin Console, the graph traversal
source, 'g' object that hopefully by now you are very familiar with. This provides
you with a template for any other 'global' variables that you may want to make
available to the user of the console connected to your Gremlin Server. The file also
configures some default log messages  that will be generated when the server starts
and stops. Note that you can add your own code to this script or replace it with your
own script entirely. You will find additional example scripts included as part of the
Gremlin Server download. These scripts do things such as create a TinkerGraph
instance and load some graph data as part of the server startup process. Using this
technique, we could easily add a line to the script so that when the server starts an
empty TinkerGraph is created and the 'air-routes' data loaded.

.empty-sample.groovy
[source,groovy]
----
// an init script that returns a Map allows explicit setting of global bindings.
def globals = [:]

// defines a sample LifeCycleHook that prints some output to the Gremlin Server console.
// note that the name of the key in the "global" map is unimportant.
globals << [hook : [
        onStartUp: { ctx ->
            ctx.logger.info("Executed once at startup of Gremlin Server.")
        },
        onShutDown: { ctx ->
            ctx.logger.info("Executed once at shutdown of Gremlin Server.")
        }
] as LifeCycleHook]

// define the default TraversalSource to bind queries to - this one will be named "g".
globals << [g : traversal().with(graph)]
----

Now that we have all of our configuration files in place we can start the Gremlin
Server by typing the following command into a terminal window. The
'gremlin-server.sh' file is located in the 'bin' directory of your Gremlin Server or
JanusGraph installation.

[source,console]
----
sh> gremlin-server.sh conf/gremlin-server/gremlin-server.yaml
----

If all goes well you should see output from the Gremlin Server displayed. The server
will keep running until you kill it. In this case a simple CTRL-C is all you need to
do to kill the server. After you press CTRL-C the server will do a bit of cleaning
up.

TIP: You can use the 'start' keyword to start the Gremlin Server as a background
task.

You can also start the Gremlin Server in the background rather than have it take over
your current terminal window by adding the 'start' keyword as part of the invocation
command as shown below. The examples below assume that you are starting the server
from the place where you installed the Gremlin Server zip file.


[source,console]
----
sh> bin/gremlin-server.sh start

Server started 25897
----

By default the configuration information for the server being started will be looked
for in the file `conf/gremlin-server.yaml`. If you want to override this value you
need to provide an environment variable called 'GREMLIN_YAML' before starting the
server as shown below.

[source,console]
----
sh> export GREMLIN_YAML='conf/mysettings.yaml'
sh> bin/gremlin-server.sh start

Server started 25897
----

As an alternative to defining an environment variable, you can instead create a file
called `bin/gremlin-server.conf` and put the name of your YAML file in it. An example
is shown below.

[source,console]
----
GREMLIN_YAML='conf/mysettings.yaml'
----

If you want to check whether or not the Gremlin Server is currently running you can
use the 'status' keyword.

[source,console]
----
sh> bin/gremlin-server.sh status

Server running with PID 25897
----

To stop the server you can use the 'stop' keyword as follows.

[source,console]
----
sh> bin/gremlin-server.sh stop

Server stopped [25897]
----


[[serverconsole]]
Connecting to a Gremlin Server from the Gremlin Console
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is fairly straightforward to connect to a running Gremlin Server from a Gremlin
Console. In this case it should not matter whether you are using the Gremlin Console
that is part of the Apache TinkerPop download or the one that comes as part of the
JanusGraph download. This is because the Gremlin Server very nicely hides the back
end implementation details from us. As far as we are concerned it is just an HTTP or
WebSockets endpoint that can handle Gremlin queries.

There is one exception, that we are currently aware of, to our statement about not
needing to worry about server side implementation details. This exception is a result
of potential version mismatches. Typically, the TinkerPop download, assuming you have
the very latest, will be at least a few minor point releases ahead of any given graph
store release. This is purely because whenever TinkerPop has a release, it takes a
bit of time for the GraphDB maintainers to catch up. we will give a concrete example
of this in a moment.

As with Gremlin Server, YAML files can be used to configure a remote connection from
the Gremlin Console. The Gremlin Console as well as the version that comes bundled
with JanusGraph includes a set of YAML files that can be used as-is or edited as
needed. In order to connect the Gremlin Console to the Gremlin Server that we just
configured, the file 'remote.yaml' can be used. It is essential that the console
and the server be using the same version. If they are not, the Gremlin Console and
the Gremlin Server would not be able to correctly communicate. Note that in 'remote
.yaml' file we also specify the name and port of the Gremlin Server host that we will
be connecting to. As we are running everything locally the default host name of
'localhost' is fine. If you are connecting to a remote Gremlin Server the 'hosts'
value needs to be edited to correctly identify name or IP address of the server where
the Gremlin Server is running. Also we can use the default port of 8182. By default
a Gremlin Server listens on port 8182. The only reason you would need to change this
value is if you are connecting to a Gremlin Server using a different port.

[source,groovy]
.remote.yaml
----
hosts: [localhost]
port: 8182
serializer: { className: org.apache.tinkerpop.gremlin.util.ser.GraphBinaryMessageSerializerV1, config: { serializeResultToString: true }}
----

[[remoteconn]]
Making the remote connection
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Now that we have our YAML file ready, all that we have to do to establish a
connection between our Gremlin Console and the Gremlin Server is to issue the
following command once the console is running.

[source,console]
----
gremlin> :remote connect tinkerpop.server conf/remote.yaml
----

Now that we are connected to the Gremlin Server we can issue some Gremlin commands.
Given that the 'air-routes' graph is already loaded into our remote graph we can
immediately start to issue some queries. In order to make sure the query goes to the
remote graph, the query needs to be prefixed with '":>"'.

[source,groovy]
----
gremlin> :> g.V().count()

==>3624
----

[[resultvar]]
The Gremlin Console's 'result' variable
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
When working within the Gremlin console, one other useful thing to be aware of is
that the results of queries sent to a server, when the console is in '"local mode"',
as well as being displayed are stored in a variable called 'result'. Take a look at
the query below.

[source,groovy]
----
gremlin> :>  g.V().hasLabel('continent').group().by('desc').by(out().count())

==>{South America=305, Asia=941, Europe=596, Africa=298, Antarctica=0, North America=981, Oceania=287}
----

If we were to print the contents of the 'result' variable we would find it contains
the results from the query.

[source,groovy]
----
gremlin> println result

[result{object={South America=305, Asia=941, Europe=596, Africa=298, Antarctica=0, North America=981, Oceania=287} class=java.lang.String}]
----

As the console is still in local mode we can use some inline Groovy code to post
process, in this case  pretty print, the contents of 'result'. This capability is
worth keeping in mind. There are some interesting things it allows you to do such as
easily post processing results and saving them to a file locally when working with a
remote server.

[source,groovy]
----
gremlin> for (x in result['object'][0][1..-2].split(', ')) println x

South America=305
Asia=941
Europe=596
Africa=298
Antarctica=0
North America=981
Oceania=287
----

[[remotemode]]
Working in remote mode
^^^^^^^^^^^^^^^^^^^^^^

As useful as keeping the console in '"local mode"' can be, if you are going to be
issuing a lot of queries to the remote graph, We find it more convenient to put the
console into '"remote mode"'. This can be done as follows.

[source,console]
----
gremlin> :remote console

All scripts will now be sent to Gremlin Server - [localhost/127.0.0.1:8182] - type ':remote console' to return to local mode
----

The console is now in '"remote mode"'. All queries that you enter will be sent to the
Gremlin Server and there is no need to use the '":>"' prefix.

[source,groovy]
----
gremlin> g.V().count()

==>3624
----

One thing to notice is that the output that comes back from a Gremlin Server looks a
little different at times from when you use the commands using the Gremlin Console
attached to a local TinkerGraph. This is because Gremlin Console essentially does a
'toString()' on the output before it is shown to the user in these cases.

[source,groovy]
----
gremlin> g.V().has('code','AUS').valueMap()

==>{country=[US], code=[AUS], longest=[12250], city=[Austin], elev=[542], icao=[KAUS], lon=[-97.6698989868164], type=[airport], region=[US-TX], runways=[2], lat=[30.1944999694824], desc=[Austin Bergstrom International Airport]}
----

As an example of the slight differences in the output format, below you will find the
results from the same query when the graph was running as a local, in memory,
TinkerGraph.

[source,groovy]
----
[country:[US],code:[AUS],longest:[12250],city:[Austin],elev:[542],icao:[KAUS],lon:[-97.6698989868164],type:[airport],region:[US-TX],runways:[2],lat:[30.1944999694824],desc:[Austin Bergstrom International Airport]]
----

Once you are done sending all commands to the Gremlin Server you can switch out of
that mode as follows. Commands will now be sent to your local console. This means
that you can work with a local and remote graph at the same time. The ':remote
console' command is therefore a toggle. Each time you use the command the console
will switch between local mode and remote mode or vice versa.

[source,console]
----
gremlin> :remote console

==>All scripts will now be evaluated locally - type ':remote console' to return to
remote mode for Gremlin Server - [localhost/127.0.0.1:8182]
----

If you are completely done with the remote connection for this console session you can
truly close it as follows. Having done this you will need to reestablish the
connection before the ':remote console' will work again.

[source,console]
----
gremlin> :remote close

==>Removed - Gremlin Server - [localhost/127.0.0.1:8182]

----

[[servercli]]
Connecting to a Gremlin Server from the command line
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now that we have a Gremlin Server up and running that supports both HTTP and Web
Sockets connections, we can, if we wish, communicate with it using nothing more than
a 'curl' command. The 'curl' command below uses an HTTP GET to send a query to our
Gremlin Server.

[source,console]
----
sh> curl "http://localhost:8182?gremlin=g.V().has('code','AUS').valueMap()"
----

In response to the HTTP GET request the server sends back the result packaged as JSON
as follows. We have formatted the output in a way that makes it easier to read. What
was actually returned did not have any line breaks in it at all and was quite hard to
read..

[source,groovy]
----
{"requestId":"a8ad654a-a5a3-4bb9-8474-69aca3c3db1e",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"country":["US"],
                       "code":["AUS"],
                    "longest":[12250],
                       "city":["Austin"],
                       "elev":[542],
                       "icao":["KAUS"],
                        "lon":[-97.6698989868164],
                       "type":["airport"],
                     "region":["US-TX"],
                    "runways":[2],
                        "lat":[30.1944999694824],
                       "desc":["Austin Bergstrom International Airport"]}],
           "meta":{}}}

----

The following example shows how to send the same query, but with the 'valueMap' step
removed, using an HTTP POST. The Apache TinkerPop documentation states that using
POST is the recommended way to send queries over HTTP to a Gremlin Server. Note how
in this case we are sending the query packaged as JSON and that we have to escape the
quote characters.

[source,console]
----
sh> curl -X POST -d "{\"gremlin\":\"g.V().has('code','AUS')\"}" \
            "http://localhost:8182"
----

As with the prior query, the HTTP POST form of the query also returns the result
packaged as JSON. However, in this case, because we left off the 'valueMap' step, the
JSON includes additional information in the form of the ID values and labels for the
vertex and its properties. This is because the result represents a vertex this time
rather than a map. We have again formatted the output in a way that is easier
to read.


//[source,json]]
[source,groovy]
----
{"requestId":"64c757b8-27a6-4509-a54c-ea35ba517667",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{
   "data":[
     {"id":12352,
      "label":"airport",
      "type":"vertex",
      "properties":
        {"country":[{"id":"8p4-9j4-8p1", "value":"US"}],
            "code":[{"id":"93c-9j4-5j9", "value":"AUS"}],
         "longest":[{"id":"9hk-9j4-mx1", "value":12250}],
            "city":[{"id":"9vs-9j4-7wl", "value":"Austin"}],
            "elev":[{"id":"aa0-9j4-but", "value":542}],
            "icao":[{"id":"ao8-9j4-6bp", "value":"KAUS"}],
             "lon":[{"id":"b2g-9j4-dfp", "value":-97.6698989868164}],
            "type":[{"id":"bgo-9j4-745", "value":"airport"}],
          "region":[{"id":"buw-9j4-9hh", "value":"US-TX"}],
         "runways":[{"id":"c94-9j4-b2d", "value":2}],
             "lat":[{"id":"cnc-9j4-cn9", "value":30.1944999694824}],
            "desc":[{"id":"d1k-9j4-a9x",
                  "value":"Austin Bergstrom International Airport"}]}}],
            "meta":{}}}

----

We have included examples of the different types of JSON result that you are likely
to have to process in the "<<serverjson>>" section that is coming up soon.

[[javagsclient]]
Connecting to a Gremlin Server from Java using 'with'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

While it is perfectly possible to work directly with the JSON returned from a Gremlin
Server it is often more desirable to have the results placed directly into variables
of the appropriate type. If the appropriate Gremlin language driver exists for the
programming language that you are using, this is quite easy to setup. In this section
we will look at connecting to a Gremlin Server from a Java application and taking
advantage of the remote connection capability that TinkerPop provides.

NOTE: The source code in this section comes from the 'RemoteClient.java' sample
located at https://github.com/krlawrence/graph/tree/main/sample-code/java.

Let's look at the small application in sections. First of all it is necessary to
import the required classes that we will need to make the connection to the server
and retrieve the query results.

[source,groovy]
----
import org.apache.tinkerpop.gremlin.driver.Cluster;
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;
import org.apache.tinkerpop.gremlin.driver.remote.DriverRemoteConnection;
import org.apache.tinkerpop.gremlin.util.ser.GraphBinaryMessageSerializerV1;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;

import static org.apache.tinkerpop.gremlin.process.traversal.AnonymousTraversalSource.traversal;
----

We can now define a small Java class that we will call 'RemoteClient' and setup the
connection to the Gremlin Server. This is done by first of all creating a
'Cluster.Builder' instance that will be used to describe the server we are connecting
to and the protocol we want to use. It is important that these settings match what
the Gremlin Server is configured to use. For this simple example we are just using
'localhost' as the host name but the name of any Gremlin Server that you have access
to can be used instead. The default Gremlin Server port of '8182' is specified and 
the 'GraphBinaryMessageSerializerV1' serialization format is selected. Again, this 
needs to match both the protocol and the version of the protocol that your Gremlin 
Server is supporting.

[source,groovy]
----
public class RemoteClient
{
  public static void main( String[] args )
  {
    Cluster.Builder builder = Cluster.build();
    builder.addContactPoint("localhost");
    builder.port(8182);
    builder.serializer(new GraphBinaryMessageSerializerV1());
----

Once the 'Cluster.Builder' instance has been setup we can use it to create our
'Cluster' instance.

[source,groovy]
----
    Cluster cluster = builder.create();
----

Lastly, we need to setup a 'GraphTraversalSource' object for the Gremlin Server
hosted graph that we will be working with. This object is often named "g" by
convention and is typically created using the statically imported 'traversal()'
method which in turn allows the call to 'with' to bind the traversal source to a
graph. We've seen 'with' take a graph instance before, but this time we will use it
with a reference to a remote connection to a graph in Gremlin Server. Note that the
cluster instance that we just created is passed in as a parameter. While this looks a
little complicated it is really not a lot different than when we connect to a local
graph using the Gremlin Console. The only difference is that by setting up the remote
connection this way, when we start to issue queries against the graph, rather than
getting JSON objects back, the results will automatically be serialized into Java
variables for us. This makes our code a lot easier to write and essentially is the
same code from this point onwards that would also work with a local graph that we are
directly connected to.

[source,groovy]
----
    GraphTraversalSource g = traversal().
        with(DriverRemoteConnection.using(cluster));
----

We can now use our new 'GraphTraversalSource' object to issue a Gremlin query. The
results will be placed directly into the 'List' called 'vmaps'. The query finds the
first 10 airports with a region code of 'GB-ENG' which is short for Great Britain
- England.

[source,groovy]
----
    List <Map<String,Object>> vmaps =
      g.V().has("airport","region","GB-ENG").limit(10).valueMap().toList();

    System.out.println("\n\nThe following airports were found\n");
    for (Map <String,Object> m : vmaps)
    {
      ArrayList code = (ArrayList) m.get("code");
      ArrayList desc = (ArrayList) m.get("desc");
      System.out.println(code.get(0) + " , " + desc.get(0));
    }

    cluster.close();
  }
}
----

When the Java application is compiled and run the output should look similar to that
shown below.

[source,groovy]
----
LEQ , Land's End Airport
LGW , London Gatwick
MAN , Manchester Airport
LHR , London Heathrow
LCY , London City Airport
STN , London Stansted Airport
EMA , East Midlands Airport
LPL , Liverpool John Lennon Airport
LBA , Leeds Bradford Airport
NCL , Newcastle Airport
----

[[rubyclient]]
Connecting to a Gremlin Server from Ruby
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As far as we know, at time of writing, there is currently no formal Gremlin language
binding support available for Ruby programmers. This is therefore a perfect use case
to show how, using a small amount of code, a Ruby programmer can connect to a Gremlin
Server and issue Gremlin Queries.

NOTE: The source code in this section comes from the 'gremlin-client-http.rb' sample
located at https://github.com/krlawrence/graph/tree/main/sample-code/ruby.

The code below represents a complete, standalone Ruby application. It uses the
standard Ruby libraries. No additional Ruby Gems or third party libraries should be
required. The example as shown connects to a Gremlin Server running on your local
machine. It packages up an HTTP POST request and sends it to the Gremlin Server. The
body of the HTTP request is encoded as JSON.

.gremlin-client-http.rb
[source,ruby,linenums]
----
# Simple example of how you can connect to a Gremlin Server and
# issue queries from a Ruby application.

require 'net/http'
require 'uri'
require 'json'

uri = URI.parse("http://localhost:8182")

request = Net::HTTP::Post.new(uri)
req_options = { use_ssl: uri.scheme == "https", }

query = {"gremlin" => "g.V().has('code','AUS').out().count()"}
request.body = JSON.dump(query)

response = Net::HTTP.start(uri.hostname, uri.port, req_options) do |http|
  http.request(request)
end

puts "Response code from the server was #{response.code}"
puts response.body
----

Here is the output that was returned when we ran the program using Ruby version 2.3.1
.
As you can see the result body contains a JSON object just as when we issued requests
using the 'curl' command earlier.

[source,groovy]
----
Response code from the server was 200

{"requestId":"0129e905-6903-4658-9cfb-23404842ba12",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[62],"meta":{}}}
----

[[servertinkergraph]]
Configuring a Gremlin Server to use a TinkerGraph
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We have already seen how a Gremlin Server can be configured as a way to provide
remote access to a JanusGraph and Cassandra deployment. Sometimes it can be useful to
setup a Gremlin Server with just a basic TinkerGraph, in-memory graph, as the
backend. This is often a handy way to work if you are developing code that will
ultimately work with a remote TinkerPop enabled graph database but want to do some
testing and development locally. A Gremlin Server can of course be configured as a
genuinely remote endpoint, perhaps running on a cloud hosted machine, but it can also
be configured to run on your local computer. We often set it up this way on our
laptop while experimenting. In this section we are going to walk through the steps
required to configure a Gremlin Server running locally that hosts the air-routes
dataset in a TinkerGraph.

NOTE: You will find the configuration files discussed in this section in the
`sample-data` folder at this location
https://github.com/krlawrence/graph/tree/main/sample-data.

[[TGConfig]]
Creating the configuration files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To get our remote TinkerGraph up and running, all we have to do is to configure a few
settings files and start the Gremlin Server. The first file we need to create is the
YAML file that will be read by the Gremlin Server as it starts. We created a file
called `gremlin-server-air-routes.yaml` for this purpose. The file actually only
contains minor changes from the default `gremlin-server.yaml` file that comes
included as part of the Gremlin Server download. The key change is that the file
includes a reference to a script in the `/scripts` folder called `air-routes.groovy`.
The script will load the air-routes data set into a TinkerGraph instance once it has
been created.

NOTE: All folders referenced in this section, such as `/data` and `/script` are
relative to the location where the Gremlin Server is installed.

The `gremlin-server-air-routes.yaml` file should be placed in the `/conf` folder.

.gremlin-server-air-routes.yaml
[source,groovy]
----
host: localhost
port: 8182
evaluationTimeout: 30000
channelizer: org.apache.tinkerpop.gremlin.server.channel.WsAndHttpChannelizer
graphs: {
  graph: conf/tinkergraph-empty.properties}
scriptEngines: {
  gremlin-groovy: {
    plugins: { org.apache.tinkerpop.gremlin.server.jsr223.GremlinServerGremlinPlugin: {},
               org.apache.tinkerpop.gremlin.tinkergraph.jsr223.TinkerGraphGremlinPlugin: {},
               org.apache.tinkerpop.gremlin.jsr223.ImportGremlinPlugin: {classImports: [java.lang.Math], methodImports: [java.lang.Math#*]},
               org.apache.tinkerpop.gremlin.jsr223.ScriptFileGremlinPlugin: {files: [scripts/air-routes.groovy]}}}}
serializers:
  - { className: org.apache.tinkerpop.gremlin.util.ser.GraphSONUntypedMessageSerializerV3, config: { ioRegistries: [org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerIoRegistryV3] }}     # application/json
  - { className: org.apache.tinkerpop.gremlin.util.ser.GraphBinaryMessageSerializerV1 }                                                                                                           # application/vnd.graphbinary-v1.0
  - { className: org.apache.tinkerpop.gremlin.util.ser.GraphBinaryMessageSerializerV1, config: { serializeResultToString: true }}                                                                 # application/vnd.graphbinary-v1.0-stringd
metrics: {
  slf4jReporter: {enabled: true, interval: 180000}}
strictTransactionManagement: false
idleConnectionTimeout: 0
keepAliveInterval: 0
maxInitialLineLength: 4096
maxHeaderSize: 8192
maxChunkSize: 8192
maxContentLength: 65536
maxAccumulationBufferComponents: 1024
resultIterationBatchSize: 64
----

Note that we configured the YAML file so that when JSON is returned it is in the
original V3 GraphSON format. This is done by specifying that the
'GraphSONUntypedMessageSerializerV3' message serializer be used. Using an untyped
form of GraphSON removes embedded types in the response and relies on standard JSON
data types. We find that users find this format much easier to read while learning
Gremlin and might be more suitable for use case that do not use TinkerPop serializers
to process the embedded type information.

The properties file that is referenced in the YAML file is unchanged from the default
one that comes with Gremlin Server. It creates an empty in-memory TinkerGraph.

The `tinkergraph-empty.properties` file should also be placed in the `/conf` folder.

.tinkergraph-empty.properties
[source,groovy]
----
gremlin.graph=org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph
gremlin.tinkergraph.vertexIdManager=LONG
----

The file `air-routes.groovy` invokes the necessary method to load the
`air-routes.graphml` file from the `/data` folder. The file should be placed in the
`/scripts` folder.

.air-routes.groovy
[source,groovy]
----
def globals = [:]

globals << [hook : [
  onStartUp: { ctx ->
    ctx.logger.info("Loading 'air-routes' graph data.")
    g = traversal().with(graph)
    g.io('data/air-routes.graphml').read().iterate()
  }
] as LifeCycleHook]

globals << [g : traversal().with(graph)]
----

[[TGStart]]
Starting the Server
^^^^^^^^^^^^^^^^^^^

As discussed in the "<<serverconfig>>" section, you can start the Gremlin Server in 
the foreground or in the background. For our initial test let's just start the server
running in the foreground.

[source,console]
----
$ bin/gremlin-server.sh conf/gremlin-server-air-routes.yaml
----

[[TGTest]]
Testing the Server
^^^^^^^^^^^^^^^^^^

Now that the Gremlin Server is up and running you can access it using 'localhost' as
the host name and a port of 8182 just as we did earlier while setting up a Gremlin
Server and JanusGraph. It's always a good idea to try a simple 'curl' command to make
sure that things are working.

[source,console]
----
$ curl "localhost:8182/gremlin?gremlin=g.V().has('code','SFO').valueMap()"
----

Here is the output returned. Note that it is in the GraphSON V1 format that
we configured for earlier.

[source,groovy]
----
{"requestId":"fbcab664-7538-402f-85b4-1b14db88c968","status":{"message":"","code":200,"attributes":{}},"result":{"data":[{"country":["US"],"code":["SFO"],"longest":[11870],"city":["San Francisco"],"elev":[13],"icao":["KSFO"],"lon":[-122.375],"type":["airport"],"region":["US-CA"],"runways":[4],"lat":[37.6189994812012],"desc":["San Francisco International Airport"]}],"meta":{}}}
----

The same Gremlin Console remote connections configuration we looked at earlier can
also be reused. Likewise, you can connect to your Gremlin Server using the host name
'localhost' and port 8182. The example below assumes that you have already started
the Gremlin Console.

[source,groovy]
----
gremlin> :remote connect tinkerpop.server conf/remote.yaml
==>Configured localhost/127.0.0.1:8182

gremlin> :remote console
==>All scripts will now be sent to Gremlin Server - [localhost/127.0.0.1:8182] - type ':remote console' to return to local mode

gremlin> g.V().has('code','SFO').valueMap().unfold()
==>country=[US]
==>code=[SFO]
==>longest=[11870]
==>city=[San Francisco]
==>elev=[13]
==>icao=[KSFO]
==>lon=[-122.375]
==>type=[airport]
==>region=[US-CA]
==>runways=[4]
==>lat=[37.6189994812012]
==>desc=[San Francisco International Airport]
----

Hopefully having read this section you now have an understanding of how to setup a
Gremlin Server that hosts an in-memory TinkerGraph containing the 'air-routes' data
set. This can be a useful environment when you want to test queries and code locally
that will ultimately need to work with a remote TinkerPop enabled graph
database.

In the next section we will look at ways to make the JSON returned easier to work
with and also add to our Ruby program to work with the JSON.

[[servertweaks]]
Tweaking queries to make the JSON returned easier to work with
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Below is a query that we have seen used earlier in this book. It finds all
routes longer than 8,000 miles and returns the airport pairs and the distance
between them.

[source,groovy]
----
g.V().as('a').outE().has('dist',gt(8000)).
      order().by('dist',desc).inV().as('b').
      filter(select('a','b').by('code').where('a', lt('b'))).
      path().by('code').by('dist')
----

When we run this query using the Gremlin console with TinkerGraph we get
back results that have been to a degree 'pretty printed' by the Console as
shown below.

[source,groovy]
----
[AKL,9025,DOH]    [LAX,8246,RUH]
[AKL,8818,DXB]    [MEL,8197,YVR]
[LAX,8756,SIN]    [DXB,8150,IAH]
[CAN,8754,MEX]    [AUH,8139,SFO]
[IAH,8591,SYD]    [DFW,8105,HKG]
[DFW,8574,SYD]    [DXB,8085,SFO]
[ATL,8434,JNB]    [HKG,8054,JFK]
[SFO,8433,SIN]    [AUH,8053,DFW]
[AUH,8372,LAX]    [EWR,8047,HKG]
[DXB,8321,LAX]    [DOH,8030,IAH]
[JED,8314,LAX]    [DFW,8022,DXB]
[DOH,8287,LAX]
----

However, if you were to use a system that returns the full JSON response, as is the
case when using a Gremlin Server over an HTTP connection, you will not get the
benefit '"pretty printing"' that the Gremlin Console does
for you. Instead, you will get back something that looks a lot like this from the
exact same query as the one we used above.

//[source,json]
[source,groovy]
----
{"requestId":"5acca62c-7351-4b3d-bb20-3660f6feb3cc",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":
    [{"labels":[["a"],[],["b"]],"objects":["AKL",9025,"DOH"]},
    {"labels":[["a"],[],["b"]],"objects":["AKL",8818,"DXB"]},
    {"labels":[["a"],[],["b"]],"objects":["LAX",8756,"SIN"]},
    {"labels":[["a"],[],["b"]],"objects":["CAN",8754,"MEX"]},
    {"labels":[["a"],[],["b"]],"objects":["IAH",8591,"SYD"]},
    {"labels":[["a"],[],["b"]],"objects":["DFW",8574,"SYD"]},
    {"labels":[["a"],[],["b"]],"objects":["ATL",8434,"JNB"]},
    {"labels":[["a"],[],["b"]],"objects":["SFO",8433,"SIN"]},
    {"labels":[["a"],[],["b"]],"objects":["AUH",8372,"LAX"]},
    {"labels":[["a"],[],["b"]],"objects":["DXB",8321,"LAX"]},
    {"labels":[["a"],[],["b"]],"objects":["JED",8314,"LAX"]},
    {"labels":[["a"],[],["b"]],"objects":["DOH",8287,"LAX"]},
    {"labels":[["a"],[],["b"]],"objects":["LAX",8246,"RUH"]},
    {"labels":[["a"],[],["b"]],"objects":["MEL",8197,"YVR"]},
    {"labels":[["a"],[],["b"]],"objects":["DXB",8150,"IAH"]},
    {"labels":[["a"],[],["b"]],"objects":["AUH",8139,"SFO"]},
    {"labels":[["a"],[],["b"]],"objects":["DFW",8105,"HKG"]},
    {"labels":[["a"],[],["b"]],"objects":["DXB",8085,"SFO"]},
    {"labels":[["a"],[],["b"]],"objects":["HKG",8054,"JFK"]},
    {"labels":[["a"],[],["b"]],"objects":["AUH",8053,"DFW"]},
    {"labels":[["a"],[],["b"]],"objects":["EWR",8047,"HKG"]},
    {"labels":[["a"],[],["b"]],"objects":["DOH",8030,"IAH"]},
    {"labels":[["a"],[],["b"]],"objects":["DFW",8022,"DXB"]}],
    "meta":{}}}
----

What is being returned is useful in some cases, for example we can see the
'a' and 'b' labels that we used in our query but in this case all we really
wanted was the last part with the airport codes and the distances. We could
decide to write code to process this JSON as-is (probably using a JSON helper
class) and that is a valid choice you could make. However by tweaking the
query slightly, we can enable Gremlin to give us back what we really wanted.
Let's start by looking at what happens if we add '.toList().toString()' to the
end of the query. Take a look at the modified form of the query below.

[source,groovy]
----
g.V().as('a').outE().has('dist',gt(8000)).
      order().by('dist',desc).inV().as('b').
      filter(select('a','b').by('code').where('a', lt('b'))).
      path().by('code').by('dist').toList().toString()
----

If we were to send this modified form of the query to our Gremlin Server, we should
get back something that looks a lot more like the result we got back when working
with the Gremlin Console. As shown below, it is certainly a bit easier to process in
your application now. However, this is still not an ideal result as what we now have
is a list containing  a single string with all of our routes in it.

[source,groovy]
//[source,json]
----
{"requestId":"63c660d0-28cf-41fc-86cf-5560a4e2fac0","status":{"message":"","code":200,"attributes":{}},"result":{"data":["[[AKL, 9025, DOH], [AKL, 8818, DXB], [LAX, 8756, SIN], [CAN, 8754, MEX], [IAH, 8591, SYD], [DFW, 8574, SYD], [ATL, 8434, JNB], [SFO, 8433, SIN], [AUH, 8372, LAX], [DXB, 8321, LAX], [JED, 8314, LAX], [DOH, 8287, LAX], [LAX, 8246, RUH], [MEL, 8197, YVR], [DXB, 8150, IAH], [AUH, 8139, SFO], [DFW, 8105, HKG], [DXB, 8085, SFO], [HKG, 8054, JFK], [AUH, 8053, DFW], [EWR, 8047, HKG], [DOH, 8030, IAH], [DFW, 8022, DXB]]"],"meta":{}}}
----

We can add a little more post processing to split up our single string into an
array of strings where each string is a single route of the form
'[AKL,9025,DOH]'. One way to do this is to trim off the unwanted characters at
each end of the string and then use split to divide it up. As there are a lot
of commas in the string we could not just do a simple 'split(",")' as that
would not have returned what we wanted. To make the split work, we replaced
every occurrence of '],' in the string with ']x' and then did the split using
'split("x")'. Here is the modified query.

[source,groovy]
----
g.V().as('a').outE().has('dist',gt(8000)).
      order().by('dist',desc).inV().as('b').
      filter(select('a','b').by('code').where('a', lt('b'))).
      path().by('code').by('dist').toList().toString()[1..-2].
      replaceAll('],',']x').split('x')
----

Here is what we now get back in the returned JSON. Each route is now a string
in an array of strings. From here it is a simple task to extract the airport
names and distances for each route.

[source,groovy]
----
{"requestId":"9d8324a8-89e4-4c1e-be59-ff433784a3da",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[ " [AKL, 9025, DOH]",
                    " [AKL, 8818, DXB]",
                    " [LAX, 8756, SIN]",
                    " [CAN, 8754, MEX]",
                    " [IAH, 8591, SYD]",
                    " [DFW, 8574, SYD]",
                    " [ATL, 8434, JNB]",
                    " [SFO, 8433, SIN]",
                    " [AUH, 8372, LAX]",
                    " [DXB, 8321, LAX]",
                    " [JED, 8314, LAX]",
                    " [DOH, 8287, LAX]",
                    " [LAX, 8246, RUH]",
                    " [MEL, 8197, YVR]",
                    " [DXB, 8150, IAH]",
                    " [AUH, 8139, SFO]",
                    " [DFW, 8105, HKG]",
                    " [DXB, 8085, SFO]",
                    " [HKG, 8054, JFK]",
                    " [AUH, 8053, DFW]",
                    " [EWR, 8047, HKG]",
                    " [DOH, 8030, IAH]",
                    " [DFW, 8022, DXB]"]
----

It's really a matter of personal preference whether you decide to have the query
return less data or just return the full set of data that we got back from the
initial query. One advantage to having the query limit what is returned is that less
data, potentially a lot less data, will need to be sent back to your application and
stored in memory or on disk. However, as, most programming languages have built in
support that makes it easy de serialize JSON objects into native data structures such
as maps, you may prefer to just have all the JSON be returned and do the rest of the
processing yourself.

By way of a simple example, if we added the following lines to our Ruby application
that we created in the previous section, and used the original query from before we
added any post processing, we could easily get at the parts of the JSON that we are
interested in.

[source,ruby]
----
res = JSON.parse(response.body)['result']['data']

res.each do |x|
  p x['objects']
end
----

The code uses Ruby's 'JSON' class to convert the JSON response from the Gremlin
Server into a map data structure. We can then access each part of the map by the
names contained in the JSON. Note that the code as written expects a specific set of
keywords to be present in the JSON. Not all query results contain these keywords.
Therefore, it would take a little more work to turn this into a more general purpose
piece of code that could handle any of the possible JSON return formats the server
could send to us. Here is the output from running the updated Ruby code. Notice that
what we have now is a nice collection of lists, each one containing two strings and
an integer. The data is now in a form that is really easy and convenient to process
further.

[source,groovy]
----
["AKL", 9025, "DOH"]     ["LAX", 8246, "RUH"]
["AKL", 8818, "DXB"]     ["MEL", 8197, "YVR"]
["LAX", 8756, "SIN"]     ["DXB", 8150, "IAH"]
["CAN", 8754, "MEX"]     ["AUH", 8139, "SFO"]
["IAH", 8591, "SYD"]     ["DFW", 8105, "HKG"]
["DFW", 8574, "SYD"]     ["DXB", 8085, "SFO"]
["ATL", 8434, "JNB"]     ["HKG", 8054, "JFK"]
["SFO", 8433, "SIN"]     ["AUH", 8053, "DFW"]
["AUH", 8372, "LAX"]     ["EWR", 8047, "HKG"]
["DXB", 8321, "LAX"]     ["DOH", 8030, "IAH"]
["JED", 8314, "LAX"]     ["DFW", 8022, "DXB"]
["DOH", 8287, "LAX"]
----

In the next section you will find more examples of the JSON that can be returned by
Gremlin Server and also some examples of how to reduce the amount of data that is
returned.



[[serverjson]]
More examples of the JSON returned from a Gremlin Server
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The JSON returned by the Gremlin Server depends on query that is used and more
specifically, what that query returns. Everything that is returned in the 'data' part
of the 'result'  will, at the outermost level be an array. What is inside that array
could be a simple number or a string. It could also be a list of strings or other
objects including maps. If you plan to write some general purpose code that can
handle the different possible formats it is important to know what they look like. In
the examples that follow we have attempted to show several of the possible response
formats that you may encounter. We are mainly going to focus of the parts of the JSON
that follow the 'data' key. Each example assumes that the query shown was sent to a
Gremlin Server using the HTTP protocol. As always, if you are unsure what JSON a
particular query may generate, you should always run some experiments to find out.

Please note that some of the queries that follow  may not represent the best way to
achieve the specific result. We have deliberately picked queries that show different
Gremlin steps to give you a feel for the type of JSON result each generates.

No result
^^^^^^^^^

The following query does not return any results. The JSON reflects this in the form
of the 'data' returned being an empty list '"[]"'.

[source,groovy]
----
g.V().has('code','AUS').out('route').has('code','SYD')

{"requestId":"e68ce6d6-29a0-4a70-af35-b4e8bb123458",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[],"meta":{}}}
----

Integer result
^^^^^^^^^^^^^^

A simple query that just returns a single integer result will generate JSON as shown
below. The 'result' section of the JSON will contain a 'data' section with the single
integer value encoded as a list with one member.

[source,groovy]
----
g.V().count()

{"requestId":"25fc4d45-3e58-4f72-99b1-fe1c6575fdd0",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[3624],"meta":{}}}
----

String result
^^^^^^^^^^^^^

As with integer results, a query that just returns a single string  result will
generate JSON as shown below. The 'result' section of the JSON will contain a 'data'
section with the single string value encoded as a list with one member.

[source,groovy]
----
g.V().has('code','DFW').values('city')

{"requestId":"0ae1e2af-adea-487c-b365-7ef76bb56791",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":["Dallas"],"meta":{}}}
----

List of strings
^^^^^^^^^^^^^^^

The query below generates a 'data' array containing a list of strings representing
airport codes.

[source,groovy]
----
g.V().has('code','SAF').out().values('code')

{"requestId":"264cbaf8-6679-43b0-936c-f65b9f6fd0ed",
"status":{"message":"","code":200,"attributes":{}},
"result":{"data":["PHX","DFW","LAX","DEN"],"meta":{}}}
----

List of integers
^^^^^^^^^^^^^^^^

The query below generates a 'data' array containing a list of integers representing
runway counts. Note that in reality you would not use a 'sack' for this, a simple
'values' step will generate the same results, but we wanted to show an example that
uses a 'sack' step.

[source,groovy]
----
g.withSack(0).V().has('code','SAF').out().sack(sum).by('runways').sack()

{"requestId":"23598951-ffa4-440d-910f-eebc6d5f620a",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[3,7,4,6],"meta":{}}}
----

List of mixed types
^^^^^^^^^^^^^^^^^^^

It is common for a query result to contain a variety of different data types. The
example below generates a list containing a string, and integer and a double. Note,
as we have seen before, TinkerPop does not guarantee the order in which results are
returned so do not create any dependencies on that.

[source,groovy]
----
g.V().has('code','LGW').values('city','lat','runways')

{"requestId":"6043ce66-221b-49b8-a3f9-6131eef3b9c2",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":["London",2,51.1481018066406],"meta":{}}}
----

Value map
^^^^^^^^^

As you might expect, when a 'valueMap' is used to generate the result from a query,
the JSON generated also contains a map. Note how each property value is encoded in a
list even if there is only one value.

[source,groovy]
----
g.V().has('code','CDG').valueMap()

{"requestId":"c989a182-aa97-4ed7-bddb-7f0e3ad237d6",
    "status":{"message":"","code":200,"attributes":{}},
    "result":{"data":[{
       "country":["FR"],
          "code":["CDG"],
       "longest":[13829],
          "city":["Paris"],
          "elev":[392],
          "icao":["LFPG"],
           "lon":[2.54999995232],
          "type":["airport"],
        "region":["FR-J"],
       "runways":[4],
           "lat":[49.0127983093],
          "desc":["Paris Charles de Gaulle"]}],"meta":{}}}
----


Single vertex
^^^^^^^^^^^^^

When your query returns a vertex, unlike in the Gremlin Console where you would get
back something like "'v[51]'" when talking to the Gremlin Server what you get back is
a JSON object representing everything that is known about the vertex including its ID
, label, properties and the ID of each property. If you do not need the entire vertex
returned it might be worth writing your query in a way such that you only get back
the properties that you are interested in. This is especially pertinent if your
query could potentially return a lot of vertices in the result.

[source,groovy]
----
g.V().has('code','CDG')

{"requestId":"a70cab32-73a5-492f-a00b-0c7d66485b18",
    "status":{"message":"","code":200,"attributes":{}},
    "result":{"data":
       [{"id":69736,
      "label":"airport",
      "type":"vertex",
"properties":
     {"country":[{"id":"2e4t-1ht4-8p1", "value":"FR"}],
         "code":[{"id":"2ej1-1ht4-5j9","value":"CDG"}],
      "longest":[{"id":"2ex9-1ht4-mx1","value":13829}],
         "city":[{"id":"2fbh-1ht4-7wl","value":"Paris"}],
         "elev":[{"id":"2fpp-1ht4-but","value":392}],
         "icao":[{"id":"2g3x-1ht4-6bp","value":"LFPG"}],
         " lon":[{"id":"2gi5-1ht4-dfp","value":2.54999995232}],
         "type":[{"id":"2gwd-1ht4-745","value":"airport"}],
       "region":[{"id":"2hal-1ht4-9hh","value":"FR-J"}],
      "runways":[{"id":"2hot-1ht4-b2d","value":4}],
          "lat":[{"id":"2i31-1ht4-cn9","value":49.0127983093}],
         "desc":[{"id":"2ih9-1ht4-a9x","value":"Paris Charles de Gaulle"}]}}],
    "meta":{}}}
----

Selected vertex information
^^^^^^^^^^^^^^^^^^^^^^^^^^^

One way to limit the amount of JSON we get back is shown below. Let's assume for a
selection of airport vertices, all we are interested in is the ID, airport code and
city name. We can construct a query, as shown below, that will return just those
values for each vertex.

[source,groovy]
----
g.V().hasLabel('airport').sample(3).
      union(id(),values('code','city'))

{"requestId":"4d308287-9725-4fa6-8c2b-b7e517ca5009",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[45096,"SCL","Santiago",
                  610336,"YWK","Wabush",
                  163880,"CAK","Akron"],"meta":{}}}
----

Single edge
^^^^^^^^^^^

Just as when we queried a single vertex, when we query a single edge, we get back a
lot of information including its label and ID and information about the vertices the
edge is connected to.

[source,groovy]
----
g.V().has('code','SAF').outE().limit(1)

{"requestId":"cac0a975-33a0-4714-a797-1be782201a27",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"
        id":"2xhcd-1560-pat-39s",
    "label":"route",
     "type":"edge","inVLabel":"airport",
                  "outVLabel":"airport","
                         inV":4240,
                       "outV":53352,
                 "properties":{"dist":369}}],"meta":{}}}
----

New vertex
^^^^^^^^^^

When a new vertex and some properties are added the returned JSON will contain all of
the information about the vertex including its ID, label and type as well as its
properties.

[source,groovy]
----
g.addV('test').property('fruit','apple')

{"requestId":"accd4354-0db9-417d-927f-c0945e1721dc",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"id":4248,
          "label":"test",
           "type":"vertex",
     "properties":{"fruit":[{"id":"177-3a0-28lh",
                          "value":"apple"}]}}],"meta":{}}}
----

New vertex only returning the ID
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When adding a new vertex, if you are not really interested in getting back the entire
new vertex and its properties, you can write the query to only return the ID of the
new vertex as shown below.

[source,groovy]
----
g.addV('test').as('a').property('fruit','apple').select('a').id()

{"requestId":"c50d0fa7-5caa-4294-8eca-310f032b1c42",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[8344],"meta":{}}}
----

Path by value (list of strings)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The query below returns a path between two airports as a list of airport codes.
Note the new 'objects' key that is used when the returned JSON represents a path.

[source,groovy]
----
g.V().has('code','SAF').out().path().by('code').limit(1)

{"requestId":"b9a1655f-1b14-4313-96d0-085858f47de7",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"labels":[[],[]],
                   "objects":["SAF","PHX"]}],"meta":{}}}
----

Path by values (list of strings and integers)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Similar to the previous query but this time the path also includes the distance
between the airports.

[source,groovy]
----
g.V().has('code','SAF').outE().inV().path().by('code').by('dist').limit(1)


{"requestId":"c4eb3141-be1e-4335-aa04-50843f73838b",
    "status":{"message":"","code":200,"attributes":{}},
    "result":{"data":[{"labels":[[],[],[]],
                      "objects":["SAF",369,"PHX"]}],"meta":{}}}
----

Two vertex path
^^^^^^^^^^^^^^^

The query below returns a path but does not include a 'by' modulator so what is
returned is the two vertices along with their IDs, labels and properties.

[source,groovy]
----
g.V().has('code','SAF').out().path().limit(1)

{"requestId":"bcdc3113-d1f6-41cf-b2ad-b1409646677e",
    "status":{"message":"","code":200,"attributes":{}},
    "result":{"data":[{"labels":[[],[]],
           "objects":[{
              "id":53352,
           "label":"airport",
            "type":"vertex",
      "properties":{
         "country":[{"id":"1s0d-1560-8p1","value":"US"}],
             "code":[{"id":"1sel-1560-5j9","value":"SAF"}],
          "longest":[{"id":"1sst-1560-mx1","value":8366}],
             "city":[{"id":"1t71-1560-7wl","value":"Santa Fe"}],
             "elev":[{"id":"1tl9-1560-but","value":6348}],
             "icao":[{"id":"1tzh-1560-6bp","value":"KSAF"}],
              "lon":[{"id":"1udp-1560-dfp","value":-106.088996887}],
             "type":[{"id":"1urx-1560-745","value":"airport"}],
           "region":[{"id":"1v65-1560-9hh","value":"US-NM"}],
          "runways":[{"id":"1vkd-1560-b2d","value":3}],
              "lat":[{"id":"1vyl-1560-cn9","value":35.617099762}],
             "desc":[{"id":"1wct-1560-a9x","value":"Santa Fe"}]}},

             {"id":4240,
           "label":"airport",
            "type":"vertex",
      "properties":{
          "country":[{"id":"176-39s-8p1","value":"US"}],
             "code":[{"id":"1le-39s-5j9","value":"PHX"}],
          "longest":[{"id":"1zm-39s-mx1","value":11489}],
             "city":[{"id":"2du-39s-7wl","value":"Phoenix"}],
             "elev":[{"id":"2s2-39s-but","value":1135}],
             "icao":[{"id":"36a-39s-6bp","value":"KPHX"}],
              "lon":[{"id":"3ki-39s-dfp","value":-112.012001037598}],
             "type":[{"id":"3yq-39s-745","value":"airport"}],
           "region":[{"id":"4cy-39s-9hh","value":"US-AZ"}],
          "runways":[{"id":"4r6-39s-b2d","value":3}],
              "lat":[{"id":"55e-39s-cn9","value":33.4342994689941}],
             "desc":[{"id":"5jm-39s-a9x",
              "value":"Phoenix Sky Harbor International Airport"}]}}]}],
      "meta":{}}}
----


Path with two vertices and an edge
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following query is similar to the previous one but also includes an edge. You can
hopefully see here how the JSON can rapidly get large if we are not more specific in
our queries about what results we really need back. Notice how, because this is a
path result, most of the data is contained inside an 'objects' key.

[source,groovy]
----
g.V().has('code','SAF').outE().inV().path().limit(1)

{"requestId":"171d0f30-2f93-4ae6-a421-4601a35388a2",
 "status":{"message":"","code":200,"attributes":{}},
  "result":{"data":[{"labels":[[],[],[]],
  "objects":[
       {"id":53352,"label":"airport","type":"vertex",
       "properties":
           {"country":[{"id":"1s0d-1560-8p1","value":"US"}],
           "code":[{"id":"1sel-1560-5j9","value":"SAF"}],
           "longest":[{"id":"1sst-1560-mx1","value":8366}],
           "city":[{"id":"1t71-1560-7wl","value":"Santa Fe"}],
           "elev":[{"id":"1tl9-1560-but","value":6348}],
           "icao":[{"id":"1tzh-1560-6bp","value":"KSAF"}],
           "lon":[{"id":"1udp-1560-dfp","value":-106.088996887}],
           "type":[{"id":"1urx-1560-745","value":"airport"}],
           "region":[{"id":"1v65-1560-9hh","value":"US-NM"}],
           "runways":[{"id":"1vkd-1560-b2d","value":3}],
           "lat":[{"id":"1vyl-1560-cn9","value":35.617099762}],
           "desc":[{"id":"1wct-1560-a9x","value":"Santa Fe"}]}},

       {"id":"2xhcd-1560-pat-39s",
        "label":"route",
        "type":"edge",
        "inVLabel":"airport",
        "outVLabel":"airport",
        "inV":4240,"outV":53352,
            "properties":{"dist":369}},

       {"id":4240,"label":"airport","type":"vertex",
       "properties":
           {"country":[{"id":"176-39s-8p1","value":"US"}],
            "code":[{"id":"1le-39s-5j9","value":"PHX"}],
            "longest":[{"id":"1zm-39s-mx1","value":11489}],
            "city":[{"id":"2du-39s-7wl","value":"Phoenix"}],
            "elev":[{"id":"2s2-39s-but","value":1135}],
            "icao":[{"id":"36a-39s-6bp","value":"KPHX"}],
            "lon":[{"id":"3ki-39s-dfp","value":-112.012001037598}],
            "type":[{"id":"3yq-39s-745","value":"airport"}],
            "region":[{"id":"4cy-39s-9hh","value":"US-AZ"}],
            "runways":[{"id":"4r6-39s-b2d","value":3}],
            "lat":[{"id":"55e-39s-cn9","value":33.4342994689941}],
            "desc":[{"id":"5jm-39s-a9x",
              "value":"Phoenix Sky Harbor International Airport"}]}}]}],
      "meta":{}}}
----

Selection map
^^^^^^^^^^^^^

If a query ends with a 'select' step that references labels defined earlier in the
query, what is returned is a map where the labels are the keys and the values are the
things that the labels were attached to in the query.

[source,groovy]
----
g.V().has('code','SAF').as('a').out().has('code','DFW').as('b').
      select('a','b').by('code')

{"requestId":"af8de8e6-4137-4378-bb31-921e134d0661",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"a":"SAF","b":"DFW"}],"meta":{}}}
----

Projected map
^^^^^^^^^^^^^

The 'project' step also generates a map just as the 'select' step did in the previous
example.

[source,groovy]
----
g.V().has('code','LGW').project('a','b').by('code').by(out().count())


{"requestId":"57819d0b-c27e-40d7-a89a-e69a6b4872a1",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"a":"LGW","b":204}],"meta":{}}}
----

Strings and a map
^^^^^^^^^^^^^^^^^

The following path query returns a list containing two strings representing airport
codes and the full JSON object representing an edge.

[source,groovy]
----
g.V().has('code','SAF').outE().inV().limit(1).path().by('code').by()

{"requestId":"5102bb14-e594-41ec-8643-89882377b1e7",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"labels":[[],[],[]],
           "objects":["SAF",
                      {"id":"2xhcd-1560-pat-39s",
                      "label":"route",
                      "type":"edge",
                      "inVLabel":"airport",
                      "outVLabel":"airport",
                      "inV":4240,
                      "outV":53352,
                      "properties":{"dist":369}},
                      "PHX"]}],"meta":{}}}
----

Nested lists
^^^^^^^^^^^^

When using the console or issuing Gremlin commands via the TinkerPop API from an
application program, ending a query with a 'fold' step can be a nice way to put all
the results into a list. When working with a Gremlin Server, ending a query with a
'fold' step in many cases is redundant as the results will be placed in a list inside
the JSON anyway. In the example below, the 'fold' step simply caused an extra list to
be nested inside the one that was generated while the JSON was being assembled.

[source,groovy]
----
g.V().has('region','US-OK').values('code').fold()


{"requestId":"edcea305-086d-4f8d-b79a-ff72c5a26847",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[["OKC","TUL","LAW","SWO"]],"meta":{}}}

----

= 実践 GREMLIN: An Apache TinkerPop チュートリアル
Kelvin R. Lawrence <gfxman@yahoo.com>; 訳：Tadashi Kaneda <tkaneda@gmail.com>
//v281 (TP 3.3.5), January 28th 2019
v283-preview, May 4th 2022
// vim: set tw=85 cc=+1 wrap spell redrawtime=20000:
// Wed May 04, 2022 08:20:08 CDT
//:Author:    Kelvin R. Lawrence
//:Email:     gfxman@yahoo.com
:Numbered:
:source-highlighter: pygments
:pygments-style: paraiso-dark
:title-logo-image: ../../CoverArt.png
//:pygments-style: lovelace
//:source-highlighter: rouge
//:source-highlighter: coderay
//:pygments-style: native
//:pygments-style: monokai
//:pygments-style: manni
//:pygments-style: vim
:toc:
:toclevels: 4
:revision: 283-preview
//:revision: 281 (TP 3.3.5)
:doctype: book
:icons: font
//:pdf-page-size: Letter
:draftdate: May 4th 2022
:tpvercheck: 3.5.2
:scripts: cjk
:pdf-theme: default-with-fallback-font


// NOTE1: I updated the paraiso-dark style so that source code with a style of text
//        has a white foreground color. The default was unreadable,
// NOTE2: These notes are encoded using a minimal level of Asciidoc markup. You can read
// them as-is or generate HTML or other output formats from this file using the
// 'asciidoc' processor available on most Linux systems or via Cygwin on
// Windows. On Mac OS X the easiest way to install asciidoc is probably via
// Homebrew. You can also install Asciidoctor, a Ruby Gem, as an alternative to
// Asciidoc which is written in Python.
// 
// NOTE3: In my tests, Asciidoctor seems a lot faster than Asciidoc and it has now become my
//       preferred way of processing this file.
// 
// As well as 'asciidoc' or Asciidoctor, the 'source-highlight' utility will also need to
// be installed if you want to process this file using Asciidoc and get source code
// highlighting. To get the table of contents to render correctly, the 'toclevels'
// setting needs to be set to 3 in asciidoc.conf. There are alternatives to
// 'source-highlight' such as Pygments that can also be used. Pygments, like
// source-highlight, will need to be installed before it can be used.
// 
// Currently I find that Asciidoctor + pygments produces the most pleasing output.
// 
// To use the Asciidoctor/Pygments combo you will need to install:
//   1. Asciidoctor (via gem)
//   2. pygments.rb (via gem)
// 
// You probably should not need to manually install the pip piece as it is bundled
// in the Gem but if it does not work you may,
// 
//   3. pygments (via pip)
// 
// <img src="GremlinEaselNoText.png">
// <h1>PRACTICAL GREMLIN:<br>An Apache TinkerPop Tutorial</h1>
//<img src="PRACTICAL-GREMLIN-Revised-v2.png">
//<h1>PRACTICAL GREMLIN:<br>An Apache TinkerPop Tutorial</h1>



== はじめに

.本書は現在執筆中です。フィードバックは大いに推奨され、歓迎される。

本書のタイトルも同様に、'"ヒント、ティップス、サンプルクエリを主とした、グラフデータベースユーザと Gremlin クエリ言語のユーザのための入門ガイド"'となる可能性がある。見出しの１行に収めるには少し長すぎることがわかったが、１行で、本書の焦点をかなりうまく表している。

私は リファレンスマニュアルの形で、TinkerPop のすべての機能をカバーしようとする衝動に抵抗してきた。その代わり、私がやろうとしたことは、私自身が入門からより高度なトピックへの経てきた学習プロセスを、道理にかなった流れであると考えるものを使って取り込むことだ。本書を最大限に活用するには、Gremlin コンソールを開いて、サンプルデータをロードして追いかけることをお勧めする。私は、本書の読者が Apache TinkerPopやGremlin クエリ言語、または関連ツールに関しての予備知識を持っていることを前提とはしていない。始めるのに必要なことはすべて第２章で紹介する。

本書の内容がお役に立てることを望んでいる。これは、間違いなく進行中の作業であり、時間の許す限り、今後数週間から数か月の間にさらに追記される予定だ。これまでに執筆した内容が私のような、Gremlin クエリとトラバーサル言語および、関連するテクノロジの使い方を学んでいる人の役に立つことを願っている。

PDF、HTML、ePub や MOBI などのようなさまざまなフォーマットの書籍やサンプルコード、データなど多くの追加資料が https://github.com/krlawrence/graph[GitHubのプロジェクトホーム] に置いてある。"<<samplesintro>>"の節に、参照可能なすべてのサマリがある。

=== 本書がどのようにして出来たか

正確な日時は忘れたが、2016年の初めにメモ、ヒント、ティップスのリストを、最初は自分自身のために、作り始めた。私のメモは、グラフデータベースを使っているときに、特に Apache TinkerPop、Gremlin、JanusGraph を使っているときに他書では説明が不十分であることがわかったものであふれていた。時間が経つにつれて、そのドキュメントは成長を続け、名前を除いては事実上、１冊の本となった。同僚からの励ましもあり、興味のある人なら誰でも読めるように、オープンソースな場所で '生きた本' として公開することにした。これは間違いなく、プログラマやデータサイエンティストを対象としているが、Gremlin グラフクエリやトラバーサル言語を使ってグラフデータベースを扱う人なら誰にでも利用できることを望んでいる。

多数のコード例やサンプルクエリをベストプラクティスの説明や、私が苦労して学んだいくつかのレッスンと合わせて盛り込んだので、参考になることを願っている。私のゴールは、Apache TinkerPop 自体が進化するにつれて、コンテンツを可能な限り最新の状態に保ちつつ、追加が必要なものをみつけたときは定期的に更新することなので、'生きた本' と呼んでいる。

この冒険を続けるように励ましてくれたすべての人に心からの*お礼を言いたい*と思う。かなり多くの作業が必要だったが、多くの楽しみもあった。

ケルビン R. ローレンス +
最初のドラフト：2017/10/5 +
現在のドラフト：2022/05/04 +

=== フィードバックの提供

本書で見つけた間違いについて知らせていただきたい。また、どんな種類のフィードバックでもお気軽にお送りいただきたい。改善の提案は特に歓迎したい。フィードバックいただくよい方法は、 https://github.com/krlawrence/graph にあるGitHubリポジトリでissueを開くことだ。あなたは現在、本書の改訂283プレビュー版を読んでいる。

これまですでに原稿のレビューや問題提起、プルリクエストの送付に時間を割いていただいた方々に感謝したい。

[[thanks]]
=== 謝辞

本書に盛り込んだいくつかのクエリの詳細化と改善に協力いただいたかつての同僚である、Graham Wallis, Jason Plurad そして Adam Holley に感謝する。Gremlin は間違いなくちょっとしたチームスポーツだ。我々はさまざまなタイプのクエリやトラバーサルを扱うための最良の方法を議論するために多くの楽しい時間を過ごした。
https://groups.google.com/forum/#!forum/gremlin-users[Gremlin Users Google Group] で質問や提案に返信するのに多くの時間を費やしているすべての方々に大声で叫ばなかったら、私も失望してしまう。Apache TinkerPop を生み出しメンテしているチームの主要メンバーである、Daniel Kuppitz, Marko Rodriguez,Stephen Mallette に特に感謝する。

最後に、GitHub issues やプルリクエストと同様に、電子メールでフィードバックやアイデアをお送りいただいたすべての人に感謝する。これが '生きた本' であることの最善の部分は、テクノロジーが進化を続けるのと同じように、改善と進化を続けることができるということだ。あなたの助力とサポートは非常にありがたい。


/[[about]]
=== 本書は何についてなのか？

本書では、Apache TinkerPop 3 'Gremlin' グラフクエリとトラバーサル言語を、実際のグラフデータを主とする実例を介して紹介する。サンプルコードやサンプルアプリケーションとともに、データはGitHub プロジェクトや他の多くのアイテムからダウンロード可能だ。グラフ 'air-routes' は、43,400の航路を含む 3,373 の空港間の国際航空ルートネットワークのモデルだ。提示された例は、TinkerGraph で実行されている Gremlin コンソールにロードされた `air-routes.graphml` ファイルを変更せずに動く。その環境をセットアップする方法は下記の<<gremlininstall>>の節で説明されている。

NOTE: 本書の例は、Apache TinkerPop リリース 3.5.1 を使ってテストされている。しかしながら、そのリリースの新機能についての追記はまだ行われていない。

TinkerGraph は 'インメモリ' グラフであり、これはつまり、自動的にディスクに保存されるものは何もない、ということだ。これは、Apache TinkerPop 3 ダウンロードの一部として出荷される。本チュートリアルのゴールは、事前の知識がほとんどもしくは全くない人が、Gremlin コンソールを立ち上げて、'air-routes'グラフを実行できるようにすることだ。本書の後半では、JanusGraph, Apache Cassandra, Gremlin Server や Elasticsearch のような追加のテクノロジを使い、Gremlin クエリを使ってトラバースできるスケールする永続化されたグラフストアを構築する方法について説明する。また、Gremlin コンソールを使うのと同様に、スタンドアロンのJava やGroovy アプリケーションの作成についても説明する。Rubyの例もいくつか盛り込んである。

NOTE: 本書の冒頭の数節では、Gremlin を使って発行できるいろんなタイプのクエリをお見せすることに主にフォーカスした。これらのクエリを入力すると得られる出力についてすべてをお見せしようとはしていないが、出力の例を選んでお見せしている。第4章、第５章、第６章でさらに深く掘り下げる。

.本書の構成
第１章 - はじめに::
- まず、なぜグラフデータベースが我々にとって興味深いものなのかを簡単に要約し、グラフについての優れたユースケースをいくつか説明する。また、本書で参照されているサンプルプログラムや他の追加資料へのポインタも提供する。
第２章 - スタートガイド::
- 第2章では、Apache TinkerPop のコンポーネントをいくつか紹介し、本書で示されているサンプルの大部分がベースとしているグラフとして使われている`air-routes.graphml` ファイルも紹介する。
第３章 - Gremlin クエリを書く::
- 第3章では、物事がさらに興味深いものとなり始める。Gremlin グラフトラバーサルとクエリ言語を使って、従来のリレーショナルデータベースを使って'air-routes' グラフをどのように構築できるかと、次にどのようにSQLとGremlinがいくつかの点で類似していて、他の点では異なっていることを比較するところから始める。本章の残りの部分で、いくつかの主要な Gremlin のメソッド、あるいはしばしば'"ステップ"'と呼ばれるものを紹介する。本章では、主にグラフを読むことにフォーカスする（追加や削除は行わない）。
第４章 - 基本的なクエリのその先::
- 第4章では、フォーカスを移し、グラフを読むだけでなく、頂点（ノード）、エッジ、プロパティを追加、ならびにそれらを削除、更新する方法について説明する。また、さまざまなベストプラクティスについても説明する。また本章では、より高度なトピックスについても触れる。
第５章 - 様々なクエリとそれらが生成する結果::
- 第5章では、前章で説明したことを使って、より現実感のあるクエリを作成することにフォーカスする。本章では、より多くのクエリの実行からの出力例をお見せする。また距離の分析、経路分布や地理的なクエリの作成などのトピックスについても触れる。
第６章 - コンソールとTinkerGraph を超える::
- 第6章では、Gremlin コンソールや TinkerGraph の使用に留まらない概念へフォーカスを広げ始める。グラフを操作できるスタンドアロンのJava や Groovy アプリケーションを作成する方法を見ていく。次に、JanusGraph を紹介し、トランザクション、スキーマ、インデックスのサポートなどのような機能について、かなり詳しく見ていく。その過程で、バックエンドの永続ストアやインデックスに関するさまざまなテクノロジの選択肢について調査する。
第7章 - GREMLINサーバーの紹介::
- 第7章では、Gremlin サーバを紹介する。Gremlin コンソールとコマンドラインの両方、ならびにコードからリモートグラフに接続して操作する方法を調査開始する。本書が最初にリリースされたとき、"現実世界"のユースケースの大部分は直接添付された、あるいはメモリ上のグラフにフォーカスしていた。Apache TinkerPop が進化するにつれて、Gremlin サーバを介して、リモートにグラフに接続することがはるかに一般的になった。
第8章 - 一般的なグラフのシリアライズ形式::
- 第8章では、一般的なグラフのシリアル化ファイル形式をいくつかと、TinkerPop 3 でサポートされるグラフのコンテキストでそれらを使う方法について説明する。
第9章 - 参考文献::
- 最後に、本書で扱っているトピックスやテクノロジーの多くに関するツールやドキュメントを見つけることができる便利なウェブサイトへのリンクをいくつか提供する。

[[samplesintro]]
=== 本書のソース、サンプル、プログラムとデータを紹介する

本プロジェクトに関連するすべての作業はGitHub で公開されている。主要なコンポーネントが置いてある場所のリストを下記に示す。本書の例では、air-routes と呼ばれる、世界の3,370を超える空港間の航空経路ネットワークを盛り込んだサンプルグラフを使う。サンプルグラフデータ、かなりの量のサンプルコード、いくつかの大きいデモアプリケーションが本書の原稿をホストしているGitHubの同じところにある。 また、GitHub の同じところに、様々なフォーマット(HTML, PDF, DocBook/XML, MOBI, EPUB) の本書のリリースが置いてある。サンプルプログラムには、Gremlin コンソールから実行できる多数の例と一緒に、スタンドアロンのJava、Groovy、Python そしてRuby のサンプルが置いてある。スタンドアロンプログラムからGremlinを使うのと、Gremlin コンソールから使うのとでは、違いが幾分ある。サンプルアプリケーションのエリアには、air-routes グラフをビジュアル的に調査できるように完全なサンプルHTMLとJavaScript アプリケーションが含まれている。GitHub のプロジェクトのホームページにはREADME.md ファイルが同梱されていて、サイトを見て回るガイドとして役に立つ。下記に本書に含まれている様々なリソースのリンクを列挙する。

.本書、サンプル、データが見つかるところ
プロジェクトホーム::
- https://github.com/krlawrence/graph
Asciidoc 形式の本書の原稿::
- このファイルは、GitHub ウェブインタフェースを使ってみることができる。これは常に最新版を表示する。
- https://github.com/krlawrence/graph/tree/main/book
最新のPDFとHTMLのスナップショット::
- これらのファイルは重要な変更を反映するために定期的に更新される。これらは、完全なリリースサイクルの外で更新される唯一の生成されたフォーマットである。PDFバージョンには、ページ番号付きでページネーションが含まれおり、A4ページサイズを使って生成されている。HTMLバージョンにはこれらの機能は含まれていない。それ以外はほとんど同じだ。
- http://kelvinlawrence.net/book/PracticalGremlin.pdf
- http://kelvinlawrence.net/book/PracticalGremlin.html
- (訳注): http://andore.com/money/trans/Gremlin-Graph-Guide-ja.pdf[日本語版PDF]
- (訳注): http://andore.com/money/trans/Gremlin-Graph-Guide-ja.html[日本語版HTML]
複数フォーマットでの公式な書籍リリース::
- 公式リリースには、ASciidoc, HTML, PDF, ePub, MOBI, DocBook の各バージョンの他、すべてのサンプルとその他の資料のスナップショットが1つのパッケージに含まれている。私のゴールは、それを行うことを正当化できるだけの新しい資料が提供される前提で、月に一度ぐらい公式リリースを行うことである。eBook と MOBIのバージョンは実際には e-reader デバイスを使って読むことを意図しており、そのため、モノクロデバイスで読みやすいようにすべてのソースコードを白背景にしてハイライトしている。
- (訳注): http://andore.com/money/trans/Gremlin-Graph-Guide-ja.epub[日本語版epub]
- (訳注): http://andore.com/money/trans/Gremlin-Graph-Guide-ja.mobi[日本語版mobi]
- ページ番号がついているので、できればPDFバージョンを使うことをお勧めする。本書をウェブページのように読みたい場合は、HTMLバージョンを使ってほしい。ページネーション、あるいはページ番号は表示されない。DocBook フォーマットは LinuxシステムのYelp のようなツールを使って読むことができるが、主要のものとして含まれているため、私がまだ用意できていない別のフォーマットを生成するのに使うことができる。現在、MOBIとePub のバージョンには問題があり、リンクのテキストが間違っている。それ以外はちゃんと機能するはずだが、読みやすくするためにデバイスで使用するフォントサイズを変更する必要があるかもしれない。
- https://github.com/krlawrence/graph/releases
サンプルデータ（`air-routes.graphml`)::
- https://github.com/krlawrence/graph/tree/main/sample-data
サンプルコード::
- https://github.com/krlawrence/graph/tree/main/sample-code
サンプルアプリケーション::
- https://github.com/krlawrence/graph/tree/main/demos
更新履歴::
- これまでの変更を追いかけるのであれば、これが注視すべきファイルだ。
- https://github.com/krlawrence/graph/blob/main/ChangeHistory.md

[[tp34intro]]
=== TinkerPop 3.4 に関する用語

Apache TinkerPop バージョン 3.4.0 のメジャーアップデートが 2019年1月にリリースされ、その後いくつかのポイントリリースが行われた。本書の例は、3.4.x のプロダクトラインのすべてのリリースでテストされている。これらの更新に必要な新しい例も追加されている。

NOTE: 変更履歴には時間の経過とともに追加されたものすべての詳細が含まれていて、ここに置いてある:
https://github.com/krlawrence/graph/blob/main/ChangeHistory.md

Apache TinkerPop をサポートするグラフデータベースエンジンは、多くの場合、新しいリリースに移行するのに時間がかかるので、使用しているデータベースがサポートする正確なレベルを確認することはよい考えだ。

NOTE: TinkerPop 3.4.x リリースで追加されたすべての新機能の詳細については、下記のリンクで見つけることができる:
https://github.com/apache/tinkerpop/blob/master/CHANGELOG.asciidoc

本書を更新するだけでなく、これらの機能のカバレッジを `sample-code` フォルダに順次継続的に追加していく。現在追加されているサンプルには、新しいネストされた繰り返しステップ機能を見せるための、nested-repeat.groovy が含まれている。これは、Gremlin コンソールからロードして実行することができる。

[[tp35intro]]
=== TinkerPop 3.5 を導入する

Apache TinkerPop 3.5.0 は2021年5月にリリースされた。このアップデートでは、Gremlin クライアントドライバ、Gremlin サーバ、全体的なバグ修正などの分野で多くの改善が導入された。このリリースでは、いくつかの主要な領域でGremlin クエリ言語の改善も行われた。以前のリリースで非推奨と宣言されていた機能のいくつかは3.5.0 のアップデートの一部として最終的に削除された。これらの非推奨機能を引き続き使用するクエリやコードがある場合は、3.5.x レベルへのアップグレードの一貫として、適切な変更を行う必要がある。

注意すべき主要な、重大な変更は、'Order.incr' と 'Order.decr' はGremlin 言語から削除されたということだ。代わりに、新しいOrder.asc と Order.desc を使用する必要がある。本書の例や `sample-code` フォルダにあるものは、これらの変更を反映して更新されている。

2022年１月、TInkerPop 3.5.2 リリースではプログラミング言語固有の構造を必要とせずに日付が追加できるように、ネイティブの `datetime` 演算子が Gremlin 言語に追加された。これは Gremlin クエリをテキスト文字列として送信する際に役に立つ。

NOTE: TinkerPop 3.5.x リリースで追加されたすべての新機能の詳細については、下記のリンクで見つけることができる:
https://github.com/apache/tinkerpop/blob/master/CHANGELOG.asciidoc

[[tp36intro]]
=== TinkerPop 3.6 を導入する

Apache TinkerPop 3.6.0 は 2022年４月にリリースされた。最初の3.5.0 リリースからほぼ正確に１年後に来て、これはTinkerPop 3.4.0 が 2019年1月に登場して以来、最も重要な TinkerPopのリリースの１つである。このリリースには、一般的に実行されるタスクをはるかに簡単にするように設計されたいくつかの新しい Gremlin ステップを含む、多くの改善点が含まれている。注目すべき改善点は次の通り：

- "存在しなければ作成" のタイプのクエリ、” アップサート" と呼ばれることもある、新しい 'mergeV'_ と 'mergeE' ステップははるかに簡単に記述できる。時間の経過とともに、これらのステップは 'fold ... coalesce' パターンの使用を置き換え、１つのクエリの中で複数の頂点やエッジを生成するのに使われるさまざまな "マップインジェクション" パターンも置き換える。
- 文字列を比較する際に正規表現を使えるようにする新しい 'TextP.regex' 述部。
- 'property' ステップにキー／値のペアのマップを指定して複数のプロパティを一度に作成できるようになった。
- プロパティの親の要素(頂点もしくはエッジ）を見つけるのに使うことができる新しい 'element' ステップ。
- Gremlin クエリが他のエンドポイントを呼びだせるようにする基盤を構築する新しい 'call' ステップ。これにより、クエリフェデレーションや、他のサービスからの値の参照のような多くのタイプの興味深いユースケースが広がる。
- エラーで失敗する代わりに、トラバーサルの一部を除外することにより、不必要な例外を取り除こうと多くの労力が割かれてきた。これは特に 値が存在しない場合に例外をスローするのではなくフィルタリングを行う__by__ モジュレータの場合に当てはまる。この作業はTinkerPop 3.5.2 のアップデートの一部として開始され、TinkerPop 3.6.0 で完了した。
- 制御された方法でクエリをアボートするのに使われる新しい 'fail' ステップ。

時間の経過とともに、これらの各機能を詳細に触れる新しいセクションが本書に追加される予定だ。

いつものように、これらの新機能を使い始める前に、使っているグラフデータベースがサポートするApache TinkerPop のレベルをチェックしてほしい。

NOTE: TinkerPop 3.6.x リリースで追加された新機能すべての完全な詳細は、次のリンクを参照してほしい:
https://github.com/apache/tinkerpop/blob/master/CHANGELOG.asciidoc

[[whygraph]]
=== それでは、グラフデータベースとは何か、なぜ気にする必要があるのだろうか？

本書は、主に、Gremlin クエリ言語を用いて、グラフデータベースや関連するテクノロジを扱うためのチュートリアルとして意図されている。しかしながら、グラフデータベースとは何か、グラフにとってどんなユースケースが優れているか、すでにあらゆる種類のSQLやNoSQLのデータベースであふれている世界で注意を払うべきなのはなぜかを理解することがなぜ重要なのかをサマリすることは少し時間を費やすだけの価値がある。本書では、有向プロパティグラフについて説明している。概念レベルでは、これらのタイプのグラフは非常に簡単に理解できる。3つの基本的な構成要素がある。頂点（ノードと呼ばれることが多い）、エッジそしてプロパティだ。頂点は人々や場所のような「モノ」を表す。エッジはこれら頂点間の接続を表し、プロパティは必要に応じて頂点やエッジに追加された情報である。名前の '有向' の部分は、どのエッジにも方向があることを意味している。エッジは、ある頂点から '出て' 別の頂点に '入る'。今後、'directed graph' の省略形として'digraph' という単語を使うのを聞くことがあるだろう。 ”Kelvin は Jack を知っている” という関連を考えてみよう。これはそれぞれの人を頂点としてエッジを関連として下記のようにモデル化することができる。

[.text-center]
Kelvin -- knows -> Jack

関連の方向を示す矢印に注意してほしい。Jack もまたKelvin を知っていることを認めているという事実を記録したいのであれば、Jack から Kelvin への2つ目のエッジを追加する必要がある。プロパティを各人に追加してそれらに関する詳細情報を提供することができる。例えば、私の年齢は私の頂点のプロパティになるだろう。

Jack が本当に猫が好きであることがわかった。関連を作成できるように、それもグラフに保存したいとしよう。

[.text-center]
Jack -- likes -> Cats

グラフが少し増えたので「ケルビンは猫が好きだと誰が知っているのか？」という質問に答えることができる。

[.text-center]
Kelvin -- knows -> Jack -- likes -> Cats

これは単純な例だけど、現実の世界で我々が考えている方法でデータをモデル化していることはすでにお分かりだと思う。この知識を身に付けると、慣れ親しんだものをグラフとしてモデル化する方法について考え始めるために必要な基本的な構成要素をすべて手に入る。

では、”なぜ気にするべきか？”という質問に戻ると、もし、何かがグラフのように見えるのであれば、そのようにモデル化できてもそれは素晴らしいとは思えない。我々の日常生活の多くのものは、グラフで非常にうまく表現できるものを中心にしている。ソーシャルネットワークやビジネスネットワーク、通勤経路、電話ネットワーク、必要な旅行のため航空経路の選択などはすべて優れた候補だ。グラフデータベースやアルゴリズムのための多くの優れたビジネスアプリケーションもある。これらにはレコメンドシステム、防犯、不正検出などが含まれるが3つある。

逆もまた真だ。グラフのように感じられないものは、無理にグラフにしようとするべきではない。動画はオブジェクトストアの中で、うまく生きているはずだ。リレーショナルデータベース使って構築された販売台帳システムは、そのままで十分だろうし、ドキュメントストアはドキュメントを保存する場所として最適だ。このように、”適材適所”という言葉は、他の分野と同様、ここでも有効なフレーズだ。グラフデータベースがほんりょうを発揮するのは、保存するデータが本質的にリンクされている場合であり、本書のすべての例のベースとなっている航空路線網は、そのような状況の完全な例だ。

コンピュータサイエンスのコースの一部としてグラフを見た人は、”確かに、グラフは何年も前からあるが、なぜこれが新しいと考えるのか？”というリアクションがあれば、それは正しい。実際、Leonard Euler は、最初のグラフ問題を実証し、1763年に現在有名な「ケーニヒスベルクの七つの橋」問題を調査した時に”グラフ理論”の概念全体を発明した人とされている。

もし、グラフ理論と現在のアプリケーションについてさらに詳しく知りたい場合は、オンラインで多くのすぐれた情報を見つけることができる。開始するためのウィキペディアのリンクは次の通り:
https://en.wikipedia.org/wiki/Graph_theory

では、グラフ理論が既知のもので、新しいものではないとすると、なぜ最近になって、グラフデータベースシステムとアプリケーションの構築とデプロイが大幅に増えているのだろうか？答えの少なくとも一部は、コンピュータのハードウェアとソフトウェアがリーズナブルな価格で適切に拡張できる大規模なビッグデータシステムを構築できるようになったからだ。実際、クラウドを使ってシステムを動かせば、ハードウェアを購入するする必要がないので、大規模なシステムを構築するのがこれまでになく簡単になっている。

ラップトップでグラフデータベースを実行するのは確かに可能ではあるが、（私は毎日そうしている。）実際には、大規模な本番環境では、それはビッグデータシステムだ。大規模なグラフには通常、数十億の頂点とエッジがあり、ディスク上のペタバイトのデータを使う。グラフアルゴリズムは、計算とメモリの両方を大量に消費する可能性がある。そして、このような政府や学術目的だけでなく、ビジネスで日常的な利用に経済的な意味をもつビッグデータシステムに必要なリソースをデプロイするビッグデータシステムにごく最近のことだ。グラフデータベースはハイエンドの科学研究から金融ネットワークまで、さらにそれを超えてスペクトラム全体で広く採用されるようになっている。

このグラフデータベース革命を開始するのに実際に役に立った別の要因は、高品質のオープンソーステクノロジの可用性だ。グラフデータを格納するのに必要なデータベースから、それをトラバースするためのクエリ言語、すべての方法、ユーザインタフェースレイヤの一部として視覚的なグラフの表示まですべてに対応する数多くのすぐれたオープンソースプロジェクトがある。特に、プロパティグラフと呼ばれるものは最も広範に開発され取り込まれている。プロパティグラフでは、頂点とエッジ双方にはそれらに紐づけられたプロパティ（事実上、キーバリューのペア）がある。最終的に作成される可能性のあるグラフには多くのスタイルがある。これらの様々なデザインパターンについて書かれた本はあるが、本書でフォーカスするプロパティグラフテクノロジには、最も一般的な利用パターンがある。有向グラフや無向グラフ、あるいは、巡回グラフや非巡回グラフなどのようなフレーズを聞いたことがあれば、またグラフデータベースを触っているときに素早くオンライン検索すると、その用語に慣れることができる。これらのパターンについての詳しい説明は、本書の範囲外であり、迅速に生産性をあげるためにグラフ理論の完全な背景をもつことは本質的ではない。

グラフデータベースを採用することで見られる成長に関する3つ目の、そして同様に重要な要因は、プログラマにとっての参入障壁が低いことだ。本書の例からわかるように、グラフテクノロジに振れてみたい人は、Apache TinkerPop パッケージをダウンロードして、Java8さえインストールされていれば、わずか5分で、（ファイルを解凍する以外に）特段の設定等は行わずに起動して実行することができる。グラフデータベースはグラフを構築し始める前に、スキーマの定義やテーブルやカラムのレイアウトの指定を強制しない。プログラマも、プログラミングのグラフスタイルが世界の考え方を厳密にモデル化しているので、非常に直感的であると感じているようだ。

グラフデータベーステクノロジは、「総取り換えの」テクノロジとしてみなすべきではなく、すでにデプロイ済みかもしれない他のデータベースに対してとても補足的なものとしてみなすべきだ。グラフにとって1つの一般的なユースケースは、他のデータストアへのスマートインデックスの形式として使われることだ。これはポリグロットデータアーキテクチャを持っていると言われることもある。

[[nodevert]]
=== 用語について一言

グラフについて議論する場合、 'ノード' と '頂点' という単語は同義語である。本書を通して、どちらの単語も使われているのを見つけるかもしれない。しかしながら、Apache TinkerPop のドキュメントでは、ほぼ排他的に '頂点' という単語を使っているので、 Gremlin クエリや他の概念について説明するときは可能な限り、 '頂点' という単語または、複数形の 'vertices'に固執するように努めている。本書が進化するにつれて、これらの用語の使用に一貫性がなくなったことに気づいた。更新を続けるにつれて、バイナリツリーについて説明する場合など、いくつかの例外を除いて、node ではなく vertex で標準化するつもりだ。このようにして、本書は公式の TinkerPop ドキュメントと一致する。同様に、頂点間の接続について説明する際は、edgeという単語、あるいは複数形の edges を使う。他の書籍や記事では、 'relationship' や 'arc' などの用語が使われている場合もある。繰り返しになるが、グラフのコンテキストではこれらの用語は同義だ。

[[gs]]
== スタートガイド

本チュートリアルに含まれている例を最大限に活用するために、インストールする必要があるものと、使えるようにする必要があるツールを見てみよう。必要となる重要なことは、Apache TinkerPop プロジェクトの Gremlin コンソールのダウンロードである。下記の節では、ダウンロードする必要があるものとその設定方法について説明する。

[[tpintro]]
=== Apache TinkerPop とは何か？

Apache TinkerPop は、Apache Software Foundation でホストされている グラフコンピューティングフレームワーク及び、トップレベルプロジェクトである。本プロジェクトのホームページは次のURLにある：
http://tinkerpop.apache.org/

.プロジェクトには下記のコンポーネントが含まれている：
Gremlin::
- グラフトラバーサル（クエリ）言語

Gremlinコンソール::
- ローカル、もしくはリモートのグラフを操作するためのインタラクティブシェル
- http://tinkerpop.apache.org/docs/current/reference/#gremlin-console
Gremlinサーバ::
- HTTP/Web Sockets 接続を介してリモートでグラフをホストできるようにする
- http://tinkerpop.apache.org/docs/current/reference/#gremlin-server
TinkerGraph::
- 学習に適した小さなインメモリグラフの実装
- http://tinkerpop.apache.org/docs/current/reference/#tinkergraph-gremlin
プログラミングインタフェース::
- Javaで書かれたプログラミングインタフェースの集合
- http://tinkerpop.apache.org/javadocs/current/full/
ドキュメント::
- ユーザガイド、チュートリアル、プログラミングAPIドキュメント
- http://tinkerpop.apache.org/docs/current/
- http://tinkerpop.apache.org/docs/current/reference/
有用なレシピ::
- Gremlin クエリを使って一般的なグラフ指向のタスクを実行する方法を示す一連の例、あるいは、「レシピ」
- http://tinkerpop.apache.org/docs/current/recipes/

プログラミングインタフェースにより、グラフデータベースのプロバイダは、TinkerPop 対応のシステムを構築し、アプリケーションプログラマがそれらのシステムと通信するプログラムを作成できるようになる。

このような TinkerPop 対応のグラフデータベースには、 Gremlin クエリ言語と対応するAPIを使ってアクセスできる。またTinkerPop API を使って、TinkerPop 対応のグラフと通信できる Java などの言語でクライアントコードを記述することもできる。本書のほとんどで、 ローカルのグラフを使ってGremlin コンソールを使って作業を行う。しかしながら、第6章では、Gremlin サーバとその他のTinkerPop 3 対応の環境について説明する。ほとんどのApache TinkerPop Java8を使って開発されているが、Groovy やPython のような他の多くのプログラミング言語で使用できるバインディングもある。TinkerPopの一部には、それ自体がGroovy で開発されており、特に Gremlin コンソールが使われている。これの良いところは、コンソールにクエリを入力したり、REST API を介してGremlin サーバにクエリを送信する際に、Groovy の文法を Gremlin と一緒に利用できることだ。これらのトピックはすべて本書で詳しく説明されている。

本書で例として使われているクエリは、TinkerGraph グラフと Gremlin コンソール、およびその他の TinkerPop 3 対応のグラフストアを使って Apache TinkerPop バージョン 3.3 でテストされている。

[[gconsole]]
=== Gremlin コンソール

Gremlin コンソールはかなり標準的なREPL (Read Eval Print Loop) シェルである。これはGroovy コンソールに基づいていて、Scala、Python、Rubyで見られるような他のコンソール環境のいづれかを使ったことがあれば、心地よく感じるだろう。コンソールはオーバーヘッドが低く（数秒でセットアップできる）、ローカルコンピュータ上でグラフを動かし始めるための参入障壁が低い。コンソールは実際にはローカルもしくはリモートで実行されているグラフを操作できるが、本書の大部分では、物事をシンプルに保つために、ローカルグラフにフォーカスする。

本チュートリアルに沿うためには、Gremlin コンソールをインストールするか、TinkerGraph や JanusGraph などの TinkerPop3/Gremlin 対応のグラフストアにアクセスできる必要がある。

使う環境に関わらず、Apache TinkerPop 対応のグラフを使う場合、Gremlin コンソールを常にマシン上にインストールしておく必要がある。

[[gremlininstall]]
==== コンソールをダウンロード、インストール、起動する

Gremlin コンソールは Apache TinkerPop の公式ウェブサイトからダウンロードできる：

http://tinkerpop.apache.org/

Gremlin コンソールをインストールして実行するのに数分しかかからない。ZIPファイルをダウンロードして、それを 'unzip'するだけで、設定は完了する。TinkerPop 3 は最新のJava8 もインストールされている必要がある。Java8 バージョン 1.8.0_131 を使ってすべてのテストを実行した。Gremlin コンソールは1.8.0_45以前のバージョンでは動かない。Java8 がインストールされていないのであれば、Webから簡単に見つけてダウンロードできる。ダウンロードには、スタンドアロンの Java あるいは Groovy TinkerPop アプリケーションを作成するために必要なすべてのJARファイルも含まれているが、それは、後で扱うトピックだ。

Gremlin コンソールを起動すると、バナー/ロゴと次のようなプロンプトが表示される。プラグインメッセージについては後で説明するので心配しなくてよい。

----
$ ./gremlin.sh 

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
plugin activated: tinkerpop.server
plugin activated: tinkerpop.utilities
plugin activated: tinkerpop.tinkergraph
gremlin> 
----

':help' と入力すると使用可能なコマンドのリストが表示される。子ソール自体へ入力するコマンドはすべてコロン":"のプレフィクスがついている。これにより、コンソールはそれらを特別で実際の Gremlin 及び Groovy コマンドとは異なるものとして区別できる。

----
gremlin> :help

For information about Groovy, visit:
    http://groovy-lang.org

Available commands:
  :help       (:h  ) Display this help message
  ?           (:?  ) Alias to: :help
  :exit       (:x  ) Exit the shell
  :quit       (:q  ) Alias to: :exit
  import      (:i  ) Import a class into the namespace
  :display    (:d  ) Display the current buffer
  :clear      (:c  ) Clear the buffer and reset the prompt counter
  :show       (:S  ) Show variables, classes or imports
  :inspect    (:n  ) Inspect a variable or the last result with the GUI object browser
  :purge      (:p  ) Purge variables, classes, imports or preferences
  :edit       (:e  ) Edit the current buffer
  :load       (:l  ) Load a file or URL into the buffer
  .           (:.  ) Alias to: :load
  :save       (:s  ) Save the current buffer to a file
  :record     (:r  ) Record the current session to a file
  :history    (:H  ) Display, manage and recall edit-line history
  :alias      (:a  ) Create an alias
  :grab       (:g  ) Add a dependency to the shell environment
  :register   (:rc ) Register a new command with the shell
  :doc        (:D  ) Open a browser window displaying the doc for the argument
  :set        (:=  ) Set (or list) preferences
  :uninstall  (:-  ) Uninstall a Maven library and its dependencies from the Gremlin Console
  :install    (:+  ) Install a Maven library and its dependencies into the Gremlin Console
  :plugin     (:pin) Manage plugins for the Console
  :remote     (:rem) Define a remote connection
  :submit     (:>  ) Send a Gremlin script to Gremlin Server
  :bytecode   (:bc ) Gremlin bytecode helper commands
  :cls        (:C  ) Clear the screen.

For help on a specific command type:
    :help command

----

TIP: 上記にリストされているすべてのコマンドの中で、:clear(略して :c) は、覚えておくべき重要なコマンドだ。コンソールの動作がおかしくなったり、".....1>" のようなプロンプトが表示されなくなったときは、:clear と入力すると問題なくリセットされる。

上述したように、Gremlin コンソールは Groovy コンソールをベースにしているので、有効な Groovy コードを直接コンソールに入力することができることに注意してほしい。なので、グラフや Gremlin を試すために使うだけではなく、たとえば、必要に応じてデスクトップ計算機として使うこともできる。

[source,groovy]
----
gremlin> 2+3
==>5

gremlin> a = 5
==>5

gremlin> println "The number is ${a}"
The number is 5

gremlin> for (a in 1..5) {print "${a} "};println()
1 2 3 4 5 
----

NOTE: Gremlin コンソールは、クエリ結果の適切で整然としたセットを表示するだけという非常に優れた機能を果たす。TinkerPop 3 をサポートしているが、Gremlin コンソールを介していない（この例では、Gremlin サーバとHTTP REST API を使って通信する）グラフシステムを使っているのであれば、返されるものはパースするコードを書く必要のあるJSONドキュメントになる。このトピックについては、本書の後半で詳しく説明する。

様々なクエリを実行したときの出力例を数多く見たい場合は、本書の、さまざまなトピックについてさらに深く掘り下げようとした"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#msc[様々なクエリとその結果]" の節ににたくさんある。

ほとんどの場合、Gremlin コンソールをインタラクティブモードで実行すると思う。しかしながら、ファイルの名前をコマンドラインパラメータとして渡すこともできる。その前に '-e' フラグを付けると、Gremlin がそのファイルを実行して終了する。例えば、"mycode.groovy" という名前のファイルがある場合、次のように、コマンドラインウィンドウもしくは、ターミナルウィンドウからこれを直接実行することができる。

----
$ ./gremlin.sh -e mycode.groovy
----

コンソールでスクリプトを実行し、そのあと終了させたくない場合、 '-e' の代わりに '-i' オプションを使うことができる。

'gremlin --help' と入力すると、Gremlin コンソールのすべてのコマンドラインオプションに関するヘルプが表示される。次のようなヘルプテキストが返ってくるはずだ。

----
$ ./gremlin.sh --help

Usage: gremlin.sh [-CDhlQvV] [-e=<SCRIPT ARG1 ARG2 ...>]... [-i=<SCRIPT ARG1
                  ARG2 ...>...]...
  -C, --color     Disable use of ANSI colors
  -D, --debug     Enabled debug Console output
  -e, --execute=<SCRIPT ARG1 ARG2 ...>
                  Execute the specified script (SCRIPT ARG1 ARG2 ...) and close
                    the console on completion
  -h, --help      Display this help message
  -i, --interactive=<SCRIPT ARG1 ARG2 ...>...
                  Execute the specified script and leave the console open on
                    completion
  -l              Set the logging level of components that use standard logging
                    output independent of the Console
  -Q, --quiet     Suppress superfluous Console output
  -v, --version   Display the version
  -V, --verbose   Enable verbose Console output

----

インストールしたTinkerPop のバージョンを確認したい場合は、Gremlin コンソールで次のコマンドを入力できる。

[source,groovy]
----
// What version of Gremlin console am I running?
gremlin>  Gremlin.version()
==>3.4.10
----

全く明らかでなく明白でもないこと１つは、Gremlin コンソールは起動時にユーザに代わって多数の Java クラスと列挙型を静かにインポートする。これによりコンソールでクエリを書くのが簡単になる。しかしながら、後で、"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#javastatics[注意すべき重要なクラスと列挙型]" の節で説明するように、一度スタンドアロンのプログラムをJava やほかの言語で書き始めると、コンソールがユーザの代わりに何をやったか実際に知る必要がある。後で何が起こるかについての難題として、Gremlin コンソールを使う際に、 ':show imports' と入力して、何が返ってくるかを確認していただきたい。

[[gremlinsave]]
==== コンソールからの出力をファイルに保存する

コンソールセッションの一部、あるいは全部をファイルに保存すると便利な場合がある。 ':record' コマンドを使ってファイルへの記録のオンとオフを切り替えることができる。

次の例では、':record start mylog.txt' を使って記録をオンにする。これにより ':record stop' コマンドが入力されるまで、入力されたすべてのコマンドとその出力がファイル 'mylog.txt' に書き込まれる。コマンド 'g.V().count().next()' は、いくつの頂点(ノード）がグラフにあるかを数えるだけだ。次節から、Gremlin グラフトラバーサルとクエリ言語について、詳しく説明する。

[source,groovy]
----
gremlin> :record start mylog.txt
Recording session to: "mylog.txt"

gremlin> g.V().count().next()
==>3618
gremlin> :record stop
Recording stopped; session saved as: "mylog.txt" (157 bytes)
----

'mylog.txt' を見ると、これがすべてだ。

----
// OPENED: Tue Sep 12 10:43:40 CDT 2017
// RESULT: mylog.txt
g.V().count().next()
// RESULT: 3618
:record stop
// CLOSED: Tue Sep 12 10:43:50 CDT 2017

----

本書の残りでは、混乱を少し減らすために、各例の中で、 'gremlin>' プロンプト、あるいは '=>' 出力識別子を表示しないようにするつもりだ。

TIP: コンソール自体について詳しく学びたい場合、公式 TinkerPop ドキュメントを参照するとよい。さらにコンソールと組み込みのヘルプを試してみるとよいだろう。

[[tgintro]]
=== TinkerGraph を導入する

Gremlinコンソールと同様、TinkerPop 3 のダウンロードにはTinkerGraph と呼ばれるインメモリグラフストアの実装が含まれている。本書は主に TinkerGraph を使って開発されたが、すべて JanusGraph を使ってのテストも行っている。JanusGraph は後の "https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#janusintro[JanusGraph を導入する]"の節で導入する。TinkerGraphのいいところは、何かを学習してテストするために、ラップトップあるいはデスクトップコンピュータで必要なものをすべて実行し、非常に迅速に実行できることだ。また、本節の後半では、 Gremlin コンソールと、TinkerGraphの始め方についても説明する。

TinkerPop 3 はグラフストアがサポートすべき多数の機能を定義する。オプショナルのものもあれば、そうでないものもある。サポートされていれば、TinkerPop 3 対応のグラフストアにクエリを実行して、 'グラフ' オブジェクトを確立したら、 'graph.features()' のようなコマンドを使って、どの機能がサポートされているかを確認できる。その方法をすぐに見ていく。下記のリストはTinkerGraph によってサポートされている機能を示している。これはTinkerGraph が提供する 'features' メソッドを呼び出したときに返されるものである。読みやすくするために、リストを２列に変更した。これらの用語のすべてがわからなくても心配する必要はない。すぐにわかるようになる。

.graph.features() の出力
----
> GraphFeatures                          > VertexPropertyFeatures        
>-- ConcurrentAccess: false              >-- UserSuppliedIds: true       
>-- ThreadedTransactions: false          >-- StringIds: true             
>-- Persistence: true                    >-- RemoveProperty: true        
>-- Computer: true                       >-- AddProperty: true           
>-- Transactions: false                  >-- NumericIds: true            
> VariableFeatures                       >-- CustomIds: false            
>-- Variables: true                      >-- AnyIds: true                
>-- LongValues: true                     >-- UuidIds: true               
>-- SerializableValues: true             >-- Properties: true            
>-- FloatArrayValues: true               >-- LongValues: true            
>-- UniformListValues: true              >-- SerializableValues: true    
>-- ByteArrayValues: true                >-- FloatArrayValues: true      
>-- MapValues: true                      >-- UniformListValues: true     
>-- BooleanArrayValues: true             >-- ByteArrayValues: true       
>-- MixedListValues: true                >-- MapValues: true             
>-- BooleanValues: true                  >-- BooleanArrayValues: true    
>-- DoubleValues: true                   >-- MixedListValues: true       
>-- IntegerArrayValues: true             >-- BooleanValues: true         
>-- LongArrayValues: true                >-- DoubleValues: true          
>-- StringArrayValues: true              >-- IntegerArrayValues: true    
>-- StringValues: true                   >-- LongArrayValues: true       
>-- DoubleArrayValues: true              >-- StringArrayValues: true     
>-- FloatValues: true                    >-- StringValues: true          
>-- IntegerValues: true                  >-- DoubleArrayValues: true     
>-- ByteValues: true                     >-- FloatValues: true           
> VertexFeatures                         >-- IntegerValues: true         
>-- AddVertices: true                    >-- ByteValues: true            
>-- DuplicateMultiProperties: true       > EdgePropertyFeatures    
>-- MultiProperties: true                >-- Properties: true               
>-- RemoveVertices: true                 >-- LongValues: true               
>-- MetaProperties: true                 >-- SerializableValues: true       
>-- UserSuppliedIds: true                >-- FloatArrayValues: true         
>-- StringIds: true                      >-- UniformListValues: true        
>-- RemoveProperty: true                 >-- ByteArrayValues: true          
>-- AddProperty: true                    >-- MapValues: true                
>-- NumericIds: true                     >-- BooleanArrayValues: true       
>-- CustomIds: false                     >-- MixedListValues: true          
>-- AnyIds: true                         >-- BooleanValues: true            
>-- UuidIds: true                        >-- DoubleValues: true                  
> EdgeFeatures                           >-- IntegerArrayValues: true                               
>-- RemoveEdges: true                    >-- LongArrayValues: true                                  
>-- AddEdges: true                       >-- StringArrayValues: true                                
>-- UserSuppliedIds: true                >-- StringValues: true                                     
>-- StringIds: true                      >-- DoubleArrayValues: true                                
>-- RemoveProperty: true                 >-- FloatValues: true                                      
>-- AddProperty: true                    >-- IntegerValues: true                                    
>-- NumericIds: true                     >-- ByteValues: true                                       
>-- CustomIds: false                                                
>-- AnyIds: true                                                    
>-- UuidIds: true                                                   
----

TinkerGraph はGremlin の操作方法を学習する際に非常に役に立ち、それらのテストに最適だ。TinkerGraph がとても役に立つ一般的なユースケースの１つは大きなグラフのサブグラフを作成し、ローカルで操作することだ。インメモリグラフのすべてが適切な場合は、TinkerGrapgh は本番環境で使うこともできる。通常、TinkerGraph は静的な(変更のない）グラフを調査するのに使われるが、Java などのプログラミング言語から使って、必要に応じてその内容を変更するのにも使うことができる。しかしながら、TinkerGraph は、トランザクションや外部インデックスのようなJanusGraph のような実装に見られるより高度な機能をサポートしない。これらのトピックはJanusGraph に関する議論の一部として後ほど、<<janusintro>> 節で扱う。上記のリストで注目に値するもう一つは、頂点やエッジのIDの値に対し、 'UserSuppliedIds' がtrue に設定されていることだ。これはつまり、GraphML フォーマットファイルのような、頂点やエッジのIDの値を指定するグラフファイルをロードしたら、TinkerGraph はそれらのIDを尊重し、それを使う。あとで見るように、これは他のいくつかのデータベースシステムでは当てはまらない。

Gremlin コンソールで実行している場合、TinkerGraph のサポートはデフォルトでオンになっているはずだ。何らかの理由によりオフになっている場合、次のコマンドを発行してオンにすることができる。

[source,groovy]
----
:plugin use tinkerpop.tinkergraph
----

一度TinkerGraph プラグインを有効にしたら、Gremlin コンソールを閉じて、リロードする必要がある。その後、コンソールから次のように、新しいTinkerGraph インスタンスを生成することができる。

[source,groovy]
----
graph = TinkerGraph.open()
----

多くの場合、グラフの構成方法に関する詳細情報を提供するパラメータを 'open' メソッドに渡す。これらのオプションについては後で説明する。グラフに対して、Gremlin クエリの発行を始める前に、次のように新しいグラフの 'traversal' メソッドを呼び出して、グラフトラバーサルソースオブジェクトを確立する必要もある。

[source,groovy]
----
g = graph.traversal()
----

NOTE: 本書の残りの部分を通して、下記の規則が使われる。変数名 graph はグラフインスタンスを表す任意のオブジェクトに使われ、変数名 g はグラフトラバーサルソースオブジェクトのインスタンスを表す任意のオブジェクトに使われる。

[[air]]
=== air-routes グラフを導入する

本書と合わせて、私はビッグデータの観点から、とても小さいがそれでもなお、グラフをアプリケーション間で移動するために利用できるグラフを記述するための標準のXMLフォーマットであるGraphMLに格納される実世界のグラフを提供した。このグラフ、 'air-routes' は私が作成した世界の航空会社の航路ネットワークのモデルであり、かなり正確だ。 

NOTE: air-routes.graphml ファイルは、GitHub リポジトリの下記のURLにあるsample-data フォルダからダウンロードできる：
https://github.com/krlawrence/graph/tree/main/sample-data

もちろん、現実の世界では、航空会社によっていつでも航路は追加、削除されるので、このグラフをあなたの次の休暇や出張の計画に使うのはやめていただきたい。しかしながら、学習ツールとして、私はあなたが、それを有用であり関連しやすいものであるとわかることを期待している。もしあなたが、気になるのであれば、ファイルをテキストエディタにロードして、どのようにレイアウトされているかを調べることができる。グラフを操作する際は、著名なグラフシリアライズフォーマットに慣れてくるだろう。一般的なものの２つはGraphML と GraphSONだ。後者はＪＳＯＮフォーマットで Apache TinkerPop で定義されていて、その環境で頻繁に使われている。GraphML はTinkerPop や、グラフデータを視覚化するための著名なオープンソースツールであるGephi のような、多くの他のツールで広く認識されている。多くのグラフ取り込みツールでもコンマ区切り値形式(CSV) ファイルを利用している。

セクション２と４で、グラフデータのロードと保存について、簡単に説明するつもりだ。本書の終わりのほうの、"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#serialize[一般的なグラフシリアライズフォーマット]のセクションにて、グラフデータのインポート、エクスポートを含む、様々な方法でテキストフォーマットファイルに格納されたグラフデータを扱う。

'air-routes' グラフにはラベルを使って指定された様々な頂点タイプが含まれている。最も一般的なものは、 'airport' と 'country' だ。また７つの大陸(continent) のそれぞれの頂点や、使用しているグラフのバージョンをテストする方法として用意した単一の 'version' 頂点がある。

空港間の経路は、エッジとしてモデル化されている。これらのエッジには 'route' ラベルがついていて、その２つの接続された空港の頂点間の距離が 'dist' と呼ばれるプロパティ として含まれている。国と空港の間の接続は 'contains' ラベルがついたエッジを使ってモデル化される。

各空港の頂点には、IATAコードや ICAO コード、説明、空港のある都市、地理的な場所など、空港に関する様々な詳細を提供する多くのプロパティが関連づけられている。

具体的には、各空港の頂点には一意のID、 'airport' のラベルがあり、下記のプロパティが含まれている。カッコ内の単語はプロパティのタイプを示している。

----
 type    (string) : Vertex type. Will be 'airport' for airport vertices   
 code    (string) : The three letter IATA code like AUS or LHR
 icao    (string) : The four letter ICAO code or none. Example KAUS or EGLL
 desc    (string) : A text description of the airport
 region  (string) : The geographical region like US-TX or GB-ENG
 runways (int)    : The number of available runways
 longest (int)    : Length of the longest runway in feet
 elev    (int)    : Elevation in feet above sea level
 country (string) : Two letter ISO country code such as US, FR or DE.
 city    (string) : The name of the city the airport is in
 lat     (double) : Latitude of the airport
 lon     (double) : Longitude of the airport
----

一度航空経路グラフがロードされると、Gremlinを使って、空港の頂点にあるプロパティが表示される。ここで例として、オースティン空港の頂点がどのように見えるかを示す。Gremlin クエリを構成する手順を簡単に説明するつもりだ。まずは、データをロードしていくつかのプレファレンスを設定ｓるう方法を少し掘り下げる必要がある。

[source,groovy]
----
// Query the properties of vertex 3
g.V().has('code','AUS').valueMap(true).unfold()

id=3
label=airport
type=[airport]
code=[AUS]
icao=[KAUS]
desc=[Austin Bergstrom International Airport]
region=[US-TX]
runways=[2]
longest=[12250]
elev=[542]
country=[US]
city=[Austin]
lat=[30.1944999694824]
lon=[-97.6698989868164]
----

空港の頂点ラベルは 'airport' であるが、文字列 'airport' を含むtype というプロパティも選んだ。これは他のグラフデータベースシステムでインデックス付与を支援するために行われたものであり、本書の後ろのほうで、より詳細をせつめいする。

各リストには要素が１つしか含まれていないとしても、各プロパティの値がリスト（あるいは好みに応じて配列）として表現されていることに気づいているかもしれない。この理由については、本書の後半で説明するが、簡単に説明すると、これは、TinkerPop にを使うと値のリストを任意の頂点プロパティに関連づけることができるからだ。我々はこの機能の利便性を得る方法を、"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#listprop[複数の値（リストやセット）を単一のプロパティにアタッチする]"のセクションで調査する。

'air-routes' グラフに含まれている全機能の完全な詳細は、 `air-routes.graphml` ファイルの先頭にあるコメントか、README.txt ファイルを読むと知ることができる。

グラフには現在、全部で3,619個の頂点と、50,148本のエッジが含まれている。このうち、3374個の頂点は空港を、43,400本のエッジは航空路を表す。ビッグデータの用語では、これは実際には小さいグラフだが、非常に興味深いGremlinクエリを作成して、実験するのには十分な大きさだ。

最後に、ここに 'air-routes' グラフに関する統計と事実がいくつかある。さらに多くの統計情報を見たい場合は、 air-routes' グラフに同梱されている README.txt ファイルをチェックしてほしい。

----
Air Routes Graph (v0.77, 2017-Oct-06) contains:
  3,374 airports
  43,400 routes
  237 countries (and dependent areas)
  7 continents
  3,619 total nodes
  50,148 total edges

Additional observations:
  Longest route is between DOH and AKL (9,025 miles)
  Shortest route is between WRY and PPW (2 miles)
  Average route distance is 1,164.747 miles.
  Longest runway is 18,045ft (BPX)
  Shortest runway is 1,300ft (SAB)
  Furthest North is LYR (latitude: 78.2461013793945)
  Furthest South is USH (latitude: -54.8433)
  Furthest East is SVU (longitude: 179.341003418)
  Furthest West is TVU (longitude: -179.876998901)
  Closest to the Equator is MDK (latitude: 0.0226000007242)
  Closest to the Greenwich meridian is LDE (longitude: -0.006438999902457)
  Highest elevation is DCY (14,472 feet)
  Lowest elevation is GUW (-72 feet)
  Maximum airport node degree (routes in and out) is 544 (FRA)
  Country with the most airports: United States (579)
  Continent with the most airports: North America (978)
  Average degree (airport nodes) is 25.726
  Average degree (all nodes) is 25.856
----

航路（入りと出）の総数でソートされた上位15の空港はこの通り。グラフの用語では、これはしばしば頂点がもつ次数、あるいは単に '頂点の次数' と呼ばれることがある。

----
    POS   ID  CODE  TOTAL     DETAILS

     1    52   FRA  (544)  out:272 in:272
     2    70   AMS  (541)  out:269 in:272
     3   161   IST  (540)  out:270 in:270
     4    51   CDG  (524)  out:262 in:262
     5    80   MUC  (474)  out:237 in:237
     6    64   PEK  (469)  out:234 in:235
     7    18   ORD  (464)  out:232 in:232
     8     1   ATL  (464)  out:232 in:232
     9    58   DXB  (458)  out:229 in:229
    10     8   DFW  (442)  out:221 in:221
    11   102   DME  (428)  out:214 in:214
    12    67   PVG  (402)  out:201 in:201
    13    50   LGW  (400)  out:200 in:200
    14    13   LAX  (390)  out:195 in:195
    15    74   MAD  (384)  out:192 in:192
----

本書を通して、多くのこれらの統計を生成するのに使えるGremlin クエリがある。

NOTE: sample-code フォルダにある GitHub リポジトリに、グラフに関するいくつかの統計情報を生成する方法を示す graph-stats.groovy というサンプルスクリプトがある。このスクリプトは下記のURLにある:
https：//github.com/krlawrence/graph/tree/master/sample-code

[[airrouteupdates]]
==== air-route データのバージョンを更新する

一貫性を維持するために、本書で紹介しているすべての例は、同じバージョンの、air-routes データセットを使って作成されている。このデータセットは 2017年10月に作成された。例の一貫性を維持することが重要であると考えたが、それは同時に、本書で示されている例の中には、現在飛行中の航空路の中で最長のルートのような、すでに古くなっているものがあるということも意味する。

TIP: 最新のair-routes データセットは下記からダウンロードできる:
https://github.com/krlawrence/graph/blob/main/sample-data/air-routes-latest.graphml

最新の結果が欲しい場合は、新しいバージョンのデータセットが利用可能である。そのファイルは、 'sample-data' フォルダにある。 `air-routes-latest.graphml` というファイルを探してみてほしい。同じフォルダに、 `README-air-routes-latest.txt` という名前のREADMEファイルが、更新されたデータセットと一緒にある。

[[mn]]
=== TinkerPop 3 マイグレーションに関する注意事項

インターネット上には、TinkerPop 2のやり方を示す例がいまだにたくさんある。TinkerPop2 と TinkerPop3 の間で、非常に多くの変更点があった。もしあなたがアーリーアダプターで、TinkerPop2 環境から TinkerPop3 環境へ移行しようとしているのであれば、本節のヒントは役に立つものがいくつかあるだろう。下記で説明するように、 'sugar' プラグインを使えば、TinkerPop2 から簡単にマイグレーションできるようになるが、TinkerPop 3 Gremlin の完全な構文を学んで、できるだけ早く慣れることをお勧めする。完全な構文を使えば、クエリを他のTinkerPop 3 対応グラフシステムへ移植しやすくなる。

TinkerPop 3 では最低限 Java 8 v45 を必要とする。私がテストしたところ、Java8 ベースの以前のバージョンでは動かなかった。

[[cr]]
==== TinkerGraph を作る TP2 vs TP3

TinkerPop 2 と３とでは、TinkerGraph の作り方が変更された。
[source,groovy]
----
graph = new TinkerGraph()  // TinkerPop 2        
graph = TinkerGraph.open() // TinkerPop 3
----

[[ld2]]
==== graphML ファイルのロード TP2 vs TP3

TinkerPop 2 の使用経験があるのであれば、TinkerPop3 でグラフの読み込み方法が変更されたことに気づいているかもしれない。

[source,groovy]
----
graph.loadGraphML('air-routes.graphml') // TinkerPop 2 
graph.io(graphml()).readGraph('air-routes.graphml') // TinkerPop 3
----

Gremlin言語自体、TinkerPop2 と TinkerPop3 とでかなりの変更が行われた。本章の残りではTinkerPop3 の例のみを示す。

[[sugarplugin]]
==== TinkerPop.sugar プラグインについて一言

Gremlinコンソールには、個別に有効化／無効化できるプラグインモジュールのセットがある。ユースケースに応じて、プラグインを管理する必要がある場合とない場合がある。

TinkerPop 2 はデフォルトで、いくつかのシンタックスシュガーをサポートしていて、Gremlin コンソールを使う際に、クエリの簡略形式を使うことができる。TinkerPop 3 ではそのサポートはプラグインに移され、デフォルトでOFFとなっている。引き続きTInkerPop2 でデフォルトで使えたのと同じショートカットを使いたい場合は、これを有効化する必要がある。

次のようにGremlin コンソールから 'sugar' サポートを有効化できる：

[source,groovy]
----
:plugin use tinkerpop.sugar
----

TIP: Gremlinコンソールは再起動しても有効化されたプラグインを記憶している。

本書の現行の改訂版では、提示されている例から、TinkerPop.sugar プラグインへの依存性を削除しようとした。Sugar を使わないことで、本書で示されているクエリは簡単に他のTinkerPop3 対応グラフプラットフォームに移植できるはずだ。TinkerPop は継続的に進化し続けていて、新しい機能がかなり定期的に追加されているので、クエリのいくつかは、 TinkerPop 3.2よりも以前のバージョンではうまく動かない可能性がある。

'TinkerPop.sugar' プラグインを使うと、一部のクエリをより省略形であるいは雑な形式で表現で、多くの場合 'values()' への参照を省略し、カッコを省略できる。例えばこのように：

[source,groovy]
----
// With Sugar enabled
g.V.hasLabel('airport').code

// Without Sugar enabled
g.V().hasLabel('airport').values('code')
----

TinkerPop 2 から移行する人は、Sugar プラグインが既存のクエリをより簡単に実行するのに役に立つことに気づくだろうが、原則として、TinkerPop 3 をサポートするグラフストアでできるだけ効率的に実行できるようにクエリを省略しない書き方に慣れることをお勧めする。また、TinkerPop 3 で導入された変更により、sugar を使うと、通常のGremlin構文を使うほどのパフォーマンスが出ない。

NOTE: 本書の以前のバージョンでは、多くの例がsugar 形式で示されていた。現行の改訂版では、その形式を使うのをすべて削除しようとしている。いくつか漏れているものもあるかもしれないので、それは引き続きチェックして修正を行う。もし修正漏れを見つけたら、教えていただきたい。

[[ld]]
=== Gremlin コンソールを使って、air-routes グラフをロードする

Gremlin コンソールを使って航空経路グラフをロードするここにいくつかのコードがある。ファイルに格納し、 ':load' を使ってロードしそれを実行するかあるいは、各行をコンソールに手で入れて実行する。これらのコマンドはコンソール環境をセットアップし、TinkerGraph グラフを作成し、air-routes.graphml ファイルを読み込む。いくつかの追加のコンソール機能も有効になっている。

NOTE: load-air-routes-graph.groovy というファイルがあり、下記のコマンドが含まれている。/sample-data ディレクトリにある。
https://github.com/krlawrence/graph/tree/main/sample-data

これらのコマンドは、頂点、エッジ、頂点プロパティIDにLONG 値を使うインメモリ TinkerGraph を作成する。TinkerPop 3 は 'traversal' の概念を導入したので、 'graph' をロードする部分で、g というグラフトラバーサルソースオブジェクトをセットアップする。これは後続のグラフのクエリで参照される。 'max_iteration' オプションは、Gremlin コンソールに、クエリから返される出力の最大行数を知らせる。この指定がない場合、デフォルトでは100になる。

TIP: max-iteration の設定を使って、Gremlin コンソールが表示する出力の量を制御できる。

別のグラフ環境を使っていて、GraphML インポートがサポートされている場合でも、そのシステムに固有の手順にしたがってair-routes.graphml ファイルをロードできる。ロードされると、下記のクエリは変更しなくても、あるいはわずかな変更を加えるだけで動くはずだ。

.load-air-routes-graph.groovy
[source,groovy]
----
conf = new BaseConfiguration()
conf.setProperty("gremlin.tinkergraph.vertexIdManager","LONG")
conf.setProperty("gremlin.tinkergraph.edgeIdManager","LONG")
conf.setProperty("gremlin.tinkergraph.vertexPropertyIdManager","LONG");[]
graph = TinkerGraph.open(conf)
graph.io(graphml()).readGraph('air-routes.graphml')
g=graph.traversal()
:set max-iteration 1000
----

NOTE: 上記のようにIDマネージャを設定することが重要だ。これを行わないと、デフォルトでは、TinkerGraph を使う際に、ID の値は、数字の3 だけでなく、文字列で"3" のように指定される必要がある。

load-air-routes-graph.groovy ファイルをダウンロードしたら、コンソールを起動して起動すると下記のコマンドを入力してそのファイルがロードできる。これを行うと、コンソールを再起動するたびに構成ファイルをリロードするだけで環境が構成され、グラフがロードされて、直接クエリを書くことができるようになるので、かなりの時間を節約できる。

[source,groovy]
----
:load load-air-routes-graph.groovy
----

TIP: ベストプラクティスとして、GraphML 読み取りコードが確実にファイルを見つけることができるように、可能な限りGraphML ファイルが置かれている場所へのフルパスを使うべきだ。

Gremlin コンソールを起動して実行し、グラフをロードできたら、本書からクエリをコピペしてコンソールに直接貼り付けて実行を確認することができる。

'air-routes' グラフがロードされたら、下記のコマンドを入力すると、グラフに関する情報が返される。TinkerGraph の場合、グラフに含まれる頂点やエッジの数を示す便利なメッセージが返される。このメッセージの内容は、グラフシステムごとに異なるので、頂点やエッジの数を追跡する方法としては頼るべきではないことに注意してほしい。後ほど、数を数える別の方法を見ていく予定だ。

[source,groovy]
----
// Tell me something about my graph 
graph.toString() 
----

TinkerGraphを使う場合、返されるメッセージは、このようになる。

[source,groovy]
----
tinkergraph[vertices:3610 edges:49490]
----

[[off]]
=== Gremlin コンソールの出力の一部をオフにする

時々、特に結果を変数に割り当てたが、Gremlinがそこに到達するまでに実行した全てのステップを見ることに興味がない場合、Gremlin コンソールは求めているものよりも多くの出力を表示する。これを避ける簡単な方法は、下記のように、クエリの最後に空リスト「;[]」を追加することだ。

[source,groovy]
----
a=g.V().has('code','AUS').out().toList();[]
----

[[indexschema]]
=== インデックスとスキーマに関して一言

一部のグラフの実装には、 'index' を使う上での厳密な要件がある。これはつまり、グラフを操作する前に、スキーマとインデックスを配置する必要があり、インデックスに含まれるグラフ内のプロパティを参照して初めてトラバーサルを開始できる、ということだ。そのため、ほとんどの場合、本書の範囲外ではあるが、本書に含まれているクエリの中にはすべてのクエリがインデックスに基づく必要のあるグラフシステムでは動作しないものがある点を指摘すべきである。そのようなグラフストアは、グラフ中の特定の項目がインデックスに裏付けられていない場合に、完全グラフ検索と呼ばれるものを許さない傾向にある。この一例は、頂点とエッジの 'label' であり、これは典型的にインデックスされないが、クエリの開始点を指定するのにとても便利なアイテムであることがある。本書にある例のほとんどが基本的なTnkerGraph だけでうまく動作することを目的としているため、インデックスの主題については第6章 "<<beyond>>" まで詳細に触れない。しかしながら、TinkerGraph にはいくつかのインデックス機能があるので、"<<tinkerindex>>" のセクションにその説明を含めた。JanusGraph のような追加テクノロジの検討を始める第6章では、そのカバレッジの一部としてインデックス作成のより詳細な説明を含めた。グラフのインデックスやスキーマを作成するのに何が必要なのか判断するために使っているグラフシステムの特定のドキュメントを常に参照すべきである。次節では、TinkerGraph とは何かについて説明する。明示的なスキーマの作成について第6章までは再度説明しない。TinkerGraph を使う場合、事前にスキーマを定義する必要はない。各プロパティのタイプは、生成時に導出される。これは本当に便利な機能であり、生産性を高め、実験を素早く行うことができる。
    
NOTE: 本番システム、特にグラフが大きいシステムでは、インデックスの一部を作成し管理するタスクは、Apache Solr や Elasticsearch などの追加ソフトウェアコンポネントに任せることがよくある。

一般にグラフデータベースでは、オプションであるかどうかにかかわらず、インデックスを使うことはベストプラクティスとみなす必要がある。すでに述べたように、TinkerGraph でさえ、必要に応じてインデックスを作成する方法がある。

[[gq]]
== Gremlin クエリを書く

これで、 'air-routes'グラフがロードできたら、クエリの作成を始める。

NOTE: 第3章では、既存のグラフから単純に読み取るクエリにフォーカスしている。新しい頂点、エッジ、プロパティを追加したり、既存のプロパティを変更することに興味があるのであれば、第4章、特に、"<<addnodes>>"のセクションまで読み飛ばすとよい。

本章では、Gremlin クエリ言語について見ていくことから始める。私はGremlin とSQL がどのように違うのか、どの点で似ているのかを簡単に見るところから始め、かなり基本的なクエリのいくつかを説明し、最後により高度な概念について説明する。あわよくば、前に説明したことに基づいてお見せした例の各セットが理解しやすくなるだろう。

[[gremlinintro]]
=== Gremlinを導入する

Gremlinは、TinkerPop がプロパティグラフを操作するために提供するグラフトラバーサルとクエリ言語の名前である。Gremlin は、Apache TinkerPop に対応した任意のグラフストアで使うことができる。Gremlin はかなり命令型の言語であるが、さらにいくつかの宣言的な構造もある。Gremlin を使えば、グラフをトラバースして、頂点やエッジを追加または削除できる値、パターン、関連を探したり、サブグラフを作成したり、他にも多くのことができる。

[[gremlinandsql]]
==== Gremlin と SQL の概要

Gremlinで生産性を上げるためにSQLを知る必要はないが、SQLで何らかの経験があれば、Gremlin で使われているのと同じキーワードやフレーズが多いことに気づくだろう。簡単な例として、下記のSQLとGremlin の例はどちらも、最初にリレーショナルデータベース使い、次にプロパティグラフを使って、各国にある空港の数を数える方法を示している。

リレーショナルデータベースを使う場合、全ての空港データを 'airports' という1つのテーブルに格納することを決定する場合がある。非常に簡単な場合（航空経路のグラフには実際には各空港に関するこれよりも多くのデータが格納されている）では、下記のように、各空港のエントリが含まれるように空港テーブルを設定することができる。

----
ID   CODE  ICAO  CITY             COUNTRY
---  ----  ----  ---------------  ----------
1    ATL   KATL  Atlanta          US
3    AUS   KAUS  Austin           US
8    DFW   KDFW  Dallas           US
47   YYZ   CYYZ  Toronto          CA
49   LHR   EGLL  London           UK
51   CDG   LFPG  Paris            FR
52   FRA   EDDF  Frankfurt        DE
55   SYD   YSSY  Sydney           AU
----

次に、SQLクエリを使って、次のように各国の空港の分布をカウントできる。

[source,sql]
----
select country,count(country) from airports group by country;
----

'air-routes' グラフと下記のようなクエリを使えば、Gremlin でこれを行うことができる（これが何を意味するのかについては、本書の後半で説明する予定だ)。

[source,groovy]
----
g.V().hasLabel('airport').groupCount().by('country')
----

Gremlin がこれまでSQLを使ったことがあれば、慣れ親しんだいくつかの構造に独自のフレーバーを提供するのを見つけるだろうが、繰り返しになるが、Gremlin を学ぶのに、SQLの予備知識は不要だ。

Gremlin を使っていて、グラフを操作するときに見つけることができないことの１つは、SQLの 'join' の概念だ。グラフデータベースは、その性質上、(接続する必要があるものはすでに接続されているので）結合する必要がない。これが、多くのユースケースでグラフデータベースが非常に優れた選択肢であり、リレーショナルデータベースよりもパフォーマンスが向上する主な理由である。

グラフデータベースは通常ネットワークの保存とモデリングにはよい選択だ。 'air-routes' グラフはネットワークグラフの一例である。ソーシャルネットワークももちろんよい例だ。ネットワークはリレーショナルデータベースを使ってモデル化することもできるが、ネットワークを調査して、ソーシャルネットワークで、”誰が私の友達の友達ですか？”質問をしたり、”ここから最大２駅でどこまで飛べますか？”といったことは、急激に複雑になり、結果として複数の 'joins' が必要になる。

例として、routes という名前のリレーショナルデータベースに、２番目のテーブルを追加することを想像してみてほしい。それには出発地の空港、目的地の空港、それらの間の距離をマイル単位で表す３つのカラム(SRC, DEST, およびDIST) が含まれている。これにはこのようなエントリ含まれる（実際のテーブルには、もちろん数千の行が含まれるが、これでどのようなテーブルになるかがわかる）。

----
SRC  DEST  DIST
---  ----  ----
ATL  DFW   729
ATL  FRA   4600
AUS  DFW   190
AUS  LHR   4901
BOM  AGR   644
BOM  LHR   4479
CDG  DFW   4933
CDG  FRA   278
CDG  LHR   216
DFW  FRA   5127
DFW  LHR   4736
LHR  BOM   4479
LHR  FRA   406
YYZ  FRA   3938
YYZ  LHR   3544
----

オースティン(AUS) から２か所を経由してアグラ(AGR) に移動する方法を計算するためのSQLクエリを書きたい場合、次のようなクエリを書くことになる：

[source,sql]
----
select a1.code,r1.dest,r2.dest,r3.dest from airports a1 
  join routes r1 on a1.code=r1.src 
  join routes r2 on r1.dest=r2.src 
  join routes r3 on r2.dest=r3.src 
  where a1.code='AUS' and r3.dest='AGR';   
----

'air-routes' グラフデータベースを使うと、このクエリは次のように非常に簡単に表現できる：

[source,groovy]
----
g.V().has('code','AUS').out().out().out().has('code','AGR').path().by('code')
----

ホップの追加あるいは削除は、１つ以上の out() ステップを追加あるいは削除するのと同じぐらい簡単だ。これは、SQL クエリに 'join' 句を追加するよりもはるかに簡単だ。これは単純な例だが、ネットワークなどの密接に接続されたデータセットでクエリが複雑になるにつれ、SQLクエリを書くのがますます難しくなるが、Gremlin はこのタイプのデータを扱うように設計されているので、トラバーサルを表現することはかなり簡単だ。

Gremlin でさらに一歩進んで、 'repeat' を使って下記のように、３回という概念を表現することができる。

[source,groovy]
----
g.V().has('code','AUS').repeat(out()).times(3).has('code','AGR').path().by('code')
----

Gremlin には、本書の後半で用いられる 'repeat .. until' 構造もある。 'emit' ステップと組み合わせると、 'repeat' は、そこへ到達するためのホップ数にかかわらず、発と着の間の経路を取得するための優れた方法を提供する。

繰り返すが、ここで示されているGremlin ステップのいくつかで混乱していても心配しなくてよい。これらはすべて、本書の後ですべて詳しく説明する。このSQLとGremlin の議論から離れるための主要なポイントは、とても接続されたデータであれば、グラフデータベースはそのデータを格納するための非常に優れた方法を提供し、Gremlin はそのデータを効率的にトラバースするためのすぐれたかなり直感的な方法を提供する、ということだ。

注目すべきもう１つのポイントは、グラフのすべての頂点とすべてのエッジが一意のIDを持っていることだ。テーブルにIDのカラムを用意するかいなかを判断する可能性があるリレーショナルの世界とは異なり、グラフデータベースではオプションではない。IDがユーザ提供のIDであることもあるが、より一般的には、頂点やエッジが最初に生成されたときに、グラフシステムによって生成される。SQLに精通しているのであれば、IDは必要に応じて、プライマリキーとして考えることができる。すべての頂点とエッジはこのIDを使ってアクセスできる。リレーショナルデータベースの場合と同様、グラフデータベースではインデックスをつけたり、頂点やエッジに含まれる任意のプロパティをインデックスに追加したり、効率的に見つけることができるようになる。大規模なグラフのデプロイでは、これは期待通りにデータを見つけるプロセスが大幅にスピードアップする。<<wid>> のセクションで、IDについて詳しく見ていく。

[[bq]]
=== かなり基本的な Gremlin クエリ

グラフ 'クエリ' は、実際に行っていることなので、しばしば 'トラバーサル' と呼ばれる。グラフを開始点から終了点までトラバースする。トラバーサルは、１つ以上のステップ（本質的にはメソッド）から成り、それらは一緒につなげられる。

ここで、単純なトラバーサルをいくつか調べ始めると、よく見るステップがいくつかある。まず、ほとんどすべてのトラバーサルがg.V() か g.E() のどちらかで始まっていることに気づくだろう。これらの手順と合わせて指定されるパラメータがあることもあるが、それについては、少し後で説明する。第2節で、 'air-routes' グラフをロードする方法を確認したことを覚えているかもしれないが、ロードしたグラフでグラフトラバーサルソースオブジェクトを生成するのに下記の命令を使った。

[source,groovy]
----
g = graph.traversal()
----

グラフトラバーサルソースオブジェクトを取得したら、それを使って、グラフの探索を始めることができる。 'V' ステップは頂点を返し、 'E' ステップはエッジを返す。他に トラバーサルの開始時だけでなく途中ででも 'V' ステップを使うことができるが、それらの使い方については、少し後で検討する。 'V' ステップや 'E' ステップは関心のある頂点あるいはエッジのセットを示すパラメータを取ることもできる。その使用方法は、"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#wid[IDを操作する]" のセクションで説明されている。

TIP: g.V() を「グラフのすべての頂点を見る」という意味として、g.E()を「グラフのすべてのエッジを見る」という意味として考えると、思い出しやすくなるだろう。次に検索条件を絞り込むための手順を追加する。

導入する必要のある他のステップは、 'has' と 'hasLabel' ステップだ。これらはあるラベルやプロパティが特定の値であるかどうかをテストするのに使うことができる。 'has' ステップの多くの他の形式を含め本書を通して様々なGremlin クエリを調べる際に多くの異なる Gremlin ステップと遭遇すると思うが、始める際にはこのうちのいくつかだけで十分だ。

本チュートリアルで用いられているグラフトラバーサルステップすべての完全な詳細については、公式のApache TinkerPop ドキュメントを参照いただきたい。本チュートリアルでは、全てのGremlin ステップとメソッドのすべての利用可能な使い方を教えようとはしておらず、むしろ、興味深い現実世界のグラフを使って、多くの様々なタイプの Gremlin クエリを書く際の優れた適切な基礎を提供しようとしている。

NOTE: 最新の TinkerPop 3 ドキュメントはこのURL でいつでもアクセスできる：
http://tinkerpop.apache.org/docs/current/reference/

以下は、 'air-routes' グラフを使い始めるための簡単なクエリである。上述の手順に従って、 'air_routes' グラフがすでにロードされていることを前提としている。下記のクエリは 'airport' ラベルをもつ頂点（ノード）を返す。

[source,groovy]
----
// Find vertices that are airports
g.V().hasLabel('airport')
----

このクエリは、Dallas Fort Worth(DFW) 空港を表す頂点を返す。

[source,groovy]
----
// Find the DFW vertex
g.V().has('code','DFW')
----

次の2つのクエリは前の2つを組み合わせて1つのクエリにまとめる。最初のクエリは、クエリを1つにつなげるだけだ。2つ目は、これまでに見たことのない 'has' ステップの形式を示していて、最初のパラメータとして追加のラベルの値を取る。

[source,groovy]
----
// Combining those two previous queries (two ways that are equivalent)
g.V().hasLabel('airport').has('code','DFW')  

g.V().has('airport','code','DFW') 
----

これがこのクエリから返されるものだ。これは、Gremlin コンソールが、IDが8 である頂点を返すことを通知する方法であることに注意してほしい。

[source,groovy]
----
v[8]
----

したがって、これらのクエリから実際に返されたものは、TinkerPopの 'Vertex' データ構造だった。本書の後半では、追加の処理を行うためにこの値を変数に格納する方法を見ていく。覚えておいていただきたいのは、Gremlin コンソール内でGroovy 環境を使っている場合でも、ここで使っているのは、Javaのコードだけだ、ということだ。したがって、Java からオブジェクトを確認するのに 'getClass' メソッドを使うことができる。トラバーサル結果をそのあとに処理を行うオブジェクトへ変換する 'next' の呼び出しに注意してほしい。

[source,groovy]
----
g.V().has('airport','code','DFW').next().getClass()

class org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerVertex
----

上記で使用した 'next' ステップは、TinkerPop ドキュメントで 'ターミナルステップ' として記述されている一連のステップのうちの1つだ。これらの 'ターミナルステップ' がもっと使われていることを本書を通してわかると思う。上述したように、ターミナルステップは本質的に、グラフトラバーサルを終端し、アプリケーションで次の処理を行う具体的なオブジェクトを返す。後で、スタンドアロンプログラムから Gremlinを使うのを検討し始めるとこの方法で使われる 'next' と他の関連するステップを見るだろう。上記のクエリの最後に 'getMethods()' の呼び出しを追加して 'TinkerVertex' クラスでサポートされているメソッドとタイプのリストを返すようにすることもできる。

[[values]]
==== 頂点からプロパティの値を取得する

頂点のプロパティを操作するにはいくつかの方法がある。グラフ内の任意の頂点やエッジのプロパティを追加、削除、およびクエリできる。本書の中でこれらのトピックそれぞれについて詳しくみていく。最初に、特定の頂点のプロパティの値を検索する簡単な方法をいくつか見てみよう。

[source,groovy]
----
// What property values are stored in the DFW vertex?
g.V().has('airport','code','DFW').values()   
----

このクエリが返す出力はこの通り。 'values' ステップを使うとプロパティの値が返されるだけで、関連するキーは返されないことに注意してほしい。本書の後半でこれを行う方法について説明する。

[source,groovy]
----
US
DFW
13401
Dallas
607
KDFW
-97.0380020141602
airport
US-TX
7
32.896800994873
Dallas/Fort Worth International Airport
----

'values' ステップは指定されたキー名の値だけを返すことを指定するパラメータを取ることができる。下記のクエリは指定されたプロパティの値を返す。

[source,groovy]
----
// Return just the city name property
g.V().has('airport','code','DFW').values('city')   

Dallas

// Return the 'runways' and 'icao' property values.
g.V().has('airport','code','DFW').values('runways','icao')   

KDFW
7
----

[[exist]]
==== 特定のプロパティは指定された頂点、あるいはエッジに存在するか？

プロパティが存在するかだけでなく、特定の値が含まれているかを簡単にテストできる。これを行うために、関心のあるプロパティ名を 'has' に指定するだけだ。これは頂点プロパティとエッジプロパティの両方で同じように動作する。

[source,groovy]
----
// Find all edges that have a 'dist' property
g.E().has('dist')

// Find all vertices that have a 'region' property
g.V().has('region')

// Find all the vertices that do not have a 'region' property
g.V().hasNot('region')

// The above is shorthand for 
 g.V().not(has('region'))
----

[[count]]
==== 数える

グラフを扱う際の一般的なニーズは、「たくさんある何か」を数えることができるようになることだ。次のセクションでモノのグループを数える別の方法を見ていくつもりだが、まずは、 'count' ステップを使っていろんなものの数を数える例をいくつか見てみよう。まずは、グラフ内に空港を表す頂点の数を調べてみよう。

[source,groovy]
----
// How many airports are there in the graph?
g.V().hasLabel('airport').count()

3374
----

次に、 'route' ラベルのついたエッジを見て、いくつの飛行ルートがグラフに格納されているかを数えよう。 'outE' ステップは出力エッジを調べることに注意してほしい。この場合、代わりに 'out' ステップを使うこともできる。発エッジと着エッジを確認する様々な方法については、次の"<<walk>>"のセクションで説明されている。

[source,groovy]
----
// How many routes are there?
g.V().hasLabel('airport').outE('route').count()

43400
----

上記を下記のように少し短くすることもできるが、空港以外のすべての頂点を最初に除外するのではないので、これはより多くのエッジが表示されるようになる。

[source,groovy]
----
// How many routes are there?
g.V().outE('route').count()

43400
----

この方法でもできるが、プロパティグラフは頂点よりもはるかに多くのエッジをもつ傾向があるので、通常、グラフ内のすべてのエッジを確認することから始めることは、不適切な形式と考えられる。

[source,groovy]
----
// How many routes are there?
g.E().hasLabel('route').count()

43400
----

上記で使った 'outE' ステップはまだ確認できていない。但し、すぐに"<<walk>>"のセクションで確認する。

[[countgroup]]
==== 物事のグループを数える

グラフ内にある、各タイプ(あるいはグループ）の数を数えると便利な場合がある。これは 'group' ステップと 'groupCount' ステップを使って実行できる。非常に大きなグラフの場合、グラフ内のすべての頂点、あるいはすべてのエッジを調べるクエリを実行するのはおすすめしないが、小さなグラフであれば、これは非常に便利だ。航空経路グラフの場合、次のように、グラフ内の様々な頂点とエッジのタイプを簡単にカウントすることができる。

[source,groovy]
----
// How many of each type of vertex are there?
g.V().groupCount().by(label)
----

このクエリを実行すると、キーがラベル名で、値がグラフ内の各ラベルの出現回数であるマップが返される。

[source,groovy]
----
[continent:7,country:237,version:1,airport:3374]
----

同じ結果が得られる上記クエリを作成する方法は他にもある。そのような例の１つを下記に示す。

[source,groovy]
----
// How many of each type of vertex are there?
g.V().label().groupCount()

[continent:7,country:237,version:1,airport:3374]
----

グラフ内のエッジラベルの分布を見つけるために同様のクエリを実行することもできる。返される結果のタイプの例も示す。

[source,groovy]
----
// How many of each type of edge are there?
g.E().groupCount().by(label)

[contains:6748,route:43400]
----

前のように、このクエリは下記のように書き換えることができる。

[source,groovy]
----
// How many of each type of edge are there?
g.E().label().groupCount()

[contains:6748,route:43400]
----

ちなみに、上記の例はこの例のように、ラベルごとに頂点を数える短い書き方だ。

[source,groovy]
----
// As above but using group()
g.V().group().by(label).by(count())

[continent:7,country:237,version:1,airport:3374]
----

カウントしたいもののグループを指定する方法をもっと選択的にすることができる。下記の例では、まず各国に空港がいくつあるかをカウントする。これは キーが国コードで値がその国の空港の数であるkey:value ペアのマップを返す。４つ目と５つ目の例が示すように、 'select' を使って、カウントされたグループ全体からいくつかの値を選ぶことができる。もちろん、単一の値しか必要ない場合は、その国に直接接続されている空港を数えることができるが、最後の２つの例は、グループをカウントできることを示すことを目的としている。

[source,groovy]
----
// How many airports are there in each country?
g.V().hasLabel('airport').groupCount().by('country')

// How many airports are there in each country? (look at country first)
g.V().hasLabel('country').group().by('code').by(out().count())
----

'group' を使って大陸コードと空港の数のマップを作成すると、各大陸にいくつ空港があるかを簡単に見つけることができる。このクエリを実行して得られた出力も下記に示す。

[source,groovy]
----
// How many airports are there in each continent?
g.V().hasLabel('continent').group().by('code').by(out().count())

[EU:583,AS:932,NA:978,OC:284,AF:294,AN:0,SA:303]
----

これらのクエリは 'select' を使って、特定の値を作成したマップから抽出する方法示している。ここでも、このクエリの実行して得られる結果を確認することができる。

[source,groovy]
----
// How many airports are there in France (having first counted all countries)
g.V().hasLabel('airport').groupCount().by('country').select('FR')

58

// How many airports are there in France, Greece and Belgium respectively?
g.V().hasLabel('airport').groupCount().by('country').select('FR','GR','BE')

[FR:58,GR:39,BE:5]
----

'group' と 'groupCount' ステップは、何かのグループや、選択条件を使って１つのグループに集めたものを数えるのにとても役に立つ。「https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#countmore[もっと数える]」というセクションで、 より多くのグルーピングして数える例を見つけることができるだろう。

[[walk]]
=== グラフのウォーキングを始める

これまでで頂点のプロパティを参照したり、あるタイプのものの数を数えたりするクエリをほとんど調べた。グラフの持つ力が本当に有効なのは、頂点間の接続（エッジ）を参照することでグラフを 'walk' あるいは 'traverse' し始めるときだ。 'グラフをウォークする' という用語はある頂点から別の頂点へエッジを介して移動することを説明するために使われる。通常 'グラフをウォークする' というフレーズが使われる場合、目的は、１つまたは複数の頂点とエッジを横断する頂点から始まり、異なる頂点で終わるか、場合によっては、巡回の場合は、開始した頂点に戻ることを説明する。Gremlin を使えばこの方法でグラフをトラバースすることはとても簡単だ。 'walk' での旅はしばしば 'path' と呼ばれる。クエリの結果として、エッジを返すか、頂点とエッジの組み合わせだけを実行したい場合があり、Gremlin でもこれは可能だ。次のセクションでは、グラフをトラバーサルする方法を変更するための多くのやり方を詳しく見ていくことにする。

次の表は、Gremlin を使ってグラフを 'walk' あるいは 'traverse' するために利用可能な手順のすべての簡単なサマリである。これらの手順はすべて、本書全体で様々な方法で使われている。グラフトラバーサルを、グラフ内をある場所から別の場所へ移動することと考えていただきたい。これらの手順はGremlin にグラフをトラバースする際に、次に移動する場所を伝える。

これらの手順をよりよく理解するために、いくつかの用語を定義するのは価値がある。ある頂点と別の頂点の間を接続するエッジがある場合、一方の頂点はもう一方の頂点に隣接しているとみなされる。ある頂点とエッジがお互いに接続されている場合、それらは 'indcident' とみなされる。

.グラフを移動する際に次に移る場所
[cols="^1,4"]
|==============================================================================
|out   * | Outgoing adjacent vertices.
|in    * | Incoming adjacent vertices.
|both  * | Both incoming and outgoing adjacent vertices.
|outE  * | Outgoing incident edges.
|inE   * | Incoming incident edges.
|bothE * | Both outgoing and incoming incident edges.
|outV    | Outgoing vertex.
|inV     | Incoming vertex.
|otherV  | The vertex that was not the vertex we came from.
|==============================================================================

'*' でラベルづけされたステップは、オプションで1つ以上のエッジラベルの名前をパラメータとして受け取ることができることに注意してほしい。省略した場合、関連するすべてのエッジがトラバースされる。

==== 単純なグラフのトラバーサルの例

はじめに、このセクションでは、紹介したばかりのステップをいくつか使った単純なグラフトラバーサルの例を見ていく。 'out' ステップは、射出エッジによってその頂点へ接続された頂点を見つけるために使われ、 'outE' ステップは、指定された頂点からの射出エッジを調べたい場合に使われる。 'outE' と 'inE' ステップは、"<<exedge>>"セクションで説明するように、エッジのプロパティを見たい場合に本質的に便利だ。グラフをトラバースして、頂点とエッジの間を移動する際に使うことができるステップは他にもいくつかある。これらには、 'bothE' 、 'bothV' や 'otherV' が含まれている。これらには、"<<otherv>>"のセクションで遭遇する。

それでは、これらのグラフトラバーサルステップの理解を深めるためにいくつかの例を使ってみよう。下記の最初のクエリはいくつかの興味深いことを実行する。最初に、Austin 空港(コードのプロパティに AUS の値が含まれている空港）を表す頂点を見つける。その頂点が見つかったら、そこから 'out' へ進む。これにより射出エッジによってAustin に接続されている頂点が見つかるだろう。それらの空港が見つかったら、それらの 'code' プロパティの値を 'values' ステップを使って問い合わせる。最後に、 'fold' ステップはすべての結果がリストに追加される。これでコンソールで結果が簡単に確認できるようになる。

[source,groovy]
----
// Where can I fly to from Austin?
g.V().has('airport','code','AUS').out().values('code').fold()
----

このクエリをコンソールで実行したらこれが返される。

[source,groovy]
----
[YYZ, LHR, FRA, MEX, PIT, PDX, CLT, CUN, MEM, CVG, IND, MCI, DAL, STL, ABQ, MDW, LBB, HRL, GDL, PNS, VPS, SFB, BKG, PIE, ATL, BNA, BOS, BWI, DCA, DFW, FLL, IAD, IAH, JFK, LAX, MCO, MIA, MSP, ORD, PHX, RDU, SEA, SFO, SJC, TPA, SAN, LGB, SNA, SLC, LAS, DEN, MSY, EWR, HOU, ELP, CLE, OAK, PHL, DTW]
----

グラフ中のすべてのエッジにはラベルがついている。しかしながら、前のクエリで実行しなかったことの１つは 'out' ステップのラベルを指定することだった。ラベルを指定しないと、エッジラベルに関係なく、任意の接続された頂点が返される。この場合、空港には 'route' というラベルのついた１種類の射出エッジしかないので、問題にはならない。しかしながら、多くの場合、作成、あるいは操作しているグラフでは、頂点は、異なるラベルのエッジによってほかの頂点と接続されている可能性があるので、Gremlin クエリの一部としてエッジラベルを指定する習慣を身に着けることはベストプラクティスである。したがって、次のように、 'out' ステップにラベル参照を追加することでクエリを少し変更できる。

[source,groovy]
----
// Where can I fly to from Austin?
g.V().has('airport','code','AUS').out('route').values('code').fold()
----

クエリでエッジラベルを一貫して使うことはよい考えであると述べたばかりであるにもかかわらず、本当にすべてのエッジあるいはすべての接続された頂点を返したいのでない限り、本書では私自身のルールを破る。それは、純粋にスペースを節約し、提示するクエリを短くするためだ。

前のクエリと同様の簡単なクエリをいくつか示す。最初の例は「Austin から途中１駅でどこに飛ぶことができるか？」という質問に答えるのに使うことができる。書かれているように、このクエリは除外しないので、Austin に戻るというのは結果に含まれることに注意してほしい。

[source,groovy]
----
// Where can I fly to from Austin, with one stop on the way?
g.V().has('airport','code','AUS').out('route').out('route').values('code')
----

このクエリは、 'in' ステップを使って、ロンドンシティ空港(LCY)に到着するすべての経路を検索し、それらのIATAコードを返す。

[source,groovy]
----
// What routes come in to LCY?
g.V().has('airport','code','LCY').in('route').values('code')
----

このクエリは、おそらくもう少し興味深いものだ。これは、イギリスのロンドンヒースロー空港から米国ないの空港に向かうすべての経路を検索し、そのIATAコードを返す。

[source,groovy]
----
// Flights from London Heathrow (LHR) to airports in the USA
g.V().has('code','LHR').out('route').has('country','US').values('code')
----

[[pathintro]]
==== どの頂点とエッジにアクセスしたか？ - path を導入する

本書でよく使われる Gremlin メソッド（ステップと呼ばれることもある）は 'path' だ。クエリを使ってグラフウォーキングを実行した後、path を使って、どこをたどったかのサマリを返すことができる。 'path' ステップが使われている簡単な例を下記に示す。本書を通して、パスの結果を整形する方法を指定するために、１つあるいは複数の 'by' ステップと組み合わせて使われる 'path' が使われているさまざまな例を見るだろう。

この特定のクエリはロンドンシティ(LCY) 空港頂点から始まる頂点と射出エッジを返す。このクエリはこのように読むことができる：「LCY 頂点から開始し、すべての射出エッジを見つけ、そのエッジに対向するすべての頂点を見つける。」 'inV' ステップは射出エッジの反対側の頂点を返す。

[source,groovy]
----
// This time, for each route, return both vertices and the edge that connects them.
g.V().has('airport','code','LCY').outE().inV().path()
----

そのクエリをそのまま実行すると、次のような一連の結果が返される。これは、頂点88 から 頂点 77 へ ID が13698のエッジを経由する経路があることを示している。

[source,groovy]
----
[v[88],e[13698][88-route->77],v[77]]
----

この結果は有用であるが、各空港のIATAコードや、その空港がどれぐらい離れているかを示すエッジからの距離プロパティなど、もっと読みやすいものを返してほしいことがある。これを行うために、クエリに 'by' モジュレータを追加することができる。Apache TinkerPop ドキュメントでは、 'modulator' というフレーズを使って、実際には独立したステップではなく、関連づけられているステップのふるまいを変更するステップを説明している

TIP: モジュレータは関連づけられているステップのふるまいに影響を与えるステップである。そのようなモジュレータステップの例は byや as だ。

下記に示されたクエリの変更された形式と、それが返す結果の例を見てほしい。これは完全に明確ではない場合でも慌てる必要はない。本書を通して、 'path' と 'by' の両方がよく使われる

[source,groovy]
----
g.V().has('airport','code','LCY').outE().inV().
      path().by('code').by('dist')
----

この変更されたバージョンのクエリを実行すると、次のような一連の結果を受け取る

[source,groovy]
----
[LCY,456,GVA]
----

'by' モジュレータステップはラウンドロビン方式で処理される。パス内の要素の総数に対して十分なモジュレータが指定されていなければ、Gremlin は最初の 'by' ステップなどにループバックだけを行う。したがって、たとえパスに整形したい要素が3つあったとしても、2つの 'by' モジュレータを指定するだけでよい。これは、パス内の最初と3つ目の要素が同じタイプ、つまり空港の頂点なので、同じプロパティ名 'code' を使いたかったからだ。パス結果の各要素ごとに代わりに異なるプロパティ名を参照したい場合は、3つの明示的な 'by' モジュレータステップを指定する必要がある。これは、例えば、パスにある3つの要素の 'code' ではなく 'city' プロパティを参照したい場合に必要になる。

TIP: by モジュレータステップは、適用する結果が指定されたbyモジュレータよりも多い場合は、ラウンドロビン方式で処理さるれ

上記の例は、同じクエリの長い形式と同等である。

[source,groovy]
----
g.V().has('airport','code','LCY').outE().inV().
      path().by('code').by('dist').by('code')
----

下記の例は、3つの異なる 'by' モジュレータが使われる場合を示す。今回は、3つ目の 'by' モジュレータステップが空港の 'code' ではなく、 'city' プロパティを参照する。サンプル出力からわかるように、今回は、空港コード GVA ではなく、都市名 'Geneva' が表示される。

[source,groovy]
----
g.V().has('airport','code','LCY').outE().inV().
      path().by('code').by('dist').by('city')


[LCY,456,Geneva]
----

下記に示すように、パラメータのない 'by' モジュレータを使う必要がある場合がある。これは、パスにある要素が複数のプロパティを持つ頂点やエッジではなく単一の値（この場合は、整数）だからだ。

[source,groovy]
----
g.V().has('airport','code','LCY').out().limit(5).
      values('runways').
      path().by('code').by('code').by()
----

結果には、訪問した空港のコードと、2つ目の空港にある滑走路の数を表す数値が表示されている。
      
[source,groovy]
----
[LCY,AGP,2]
[LCY,ABZ,4]
[LCY,JER,1]
[LCY,BSL,2]
[LCY,BHD,1]
----

'by' モジュレータの内部でトラバーサルを使うことも可能だ。そのようなトラバーサルは、開始 'V' や、 'E' ステップが含まれていないので、 「'匿名トラバーサル'」として知られる。

NOTE: V ステップや、E ステップで開始しないトラバーサルは、「匿名トラバーサル」と呼ばれる。

この機能により、パス結果の一部として、複数の値を組み合わせたりが可能になる。下記の例は、Austin で開始する5つの経路を検索し、出発地と到着地の両方の空港コードと都市名を含むパス結果を生成する。この場合、 'by' モジュレータに含まれている匿名トラバーサルは、パス内の各要素に適用される。

[source,groovy]
----
g.V(3).out().limit(5).path().by(values('code','city').fold())

[[AUS,Austin],[YYZ,Toronto]]
[[AUS,Austin],[LHR,London]]
[[AUS,Austin],[FRA,Frankfurt]]
[[AUS,Austin],[MEX,Mexico City]]
[[AUS,Austin],[PIT,Pittsburgh]]
----

任意のトラバーサルを 'by' モジュレータ内に配置できることを示すために、パス結果の生成の一部として、出発地と到着地の空港の射出経路の数をカウントするもう1つの例を示す。

[source,groovy]
----
g.V(3).out().limit(5).path().by(out().count())

[59,181]
[59,191]
[59,272]
[59,105]
[59,54]
----

[[pathfromto]]
==== from モジュレータと to モジュレータを使ってパスを変更する
Apache TinkerPop のバージョン 3.2.5 では、 'from' や 'to' モジュレータを使って、 'path' ステップによって返されるものを制限する機能が追加された。これにより、トラバーサルのパス全体を返すのではなく、より選択的にすることができる。

まず、下記の例を見ていただきたい。ここでは、前の例で使ったのと同じ 'path' 構造を使った。このクエリはAustin(AUS) で始まり途中に1駅あるもので見つかった最初の10ルートを返す。

[source,groovy]
----
g.V().has('airport','code','AUS').out().out().path().by('code').limit(10)
----

期待した通り、結果は訪問した各空港を示している。

[source,groovy]
----
[AUS,EWR,YYZ]
[AUS,EWR,YVR]
[AUS,EWR,LHR]
[AUS,EWR,CDG]
[AUS,EWR,FRA]
[AUS,EWR,NRT]
[AUS,EWR,DEL]
[AUS,EWR,DUB]
[AUS,EWR,HKG]
[AUS,EWR,PEK]
----

すべての旅がオースティンで始まることから、実際にはAUS 空港のコードが返された結果の一部として含まれていることを望んでいないかもしれない。オースティンを離れたあとに訪れた場所をキャプチャしたいだけかもしれない。これは 'as' ステップを使って関心のあるトラバーサルの一部をラベリングし、 'from' と 'to' モジュレータを使って 'path' ステップに関心あるものを伝えることで実現できる。下記のクエリの変更されたバージョンを見てほしい。

[source,groovy]
----
g.V().has('airport','code','AUS').out().as('a').out().as('b').
      path().by('code').from('a').to('b').limit(10)
----

今回、AUS は 'path' の結果に含まれていない。

[source,groovy]
----
[EWR,YYZ]
[EWR,YVR]
[EWR,LHR]
[EWR,CDG]
[EWR,FRA]
[EWR,NRT]
[EWR,DEL]
[EWR,DUB]
[EWR,HKG]
[EWR,PEK]
----
パスのAUS部分をスキップした後、実際には残りの結果が必要だったので、 'to' モジュレータを省略して、下記のようにクエリを書いた。

[source,groovy]
----
g.V().has('airport','code','AUS').out().as('a').out().
      path().by('code').from('a').limit(10)
----

見ての通り、結果は前のとおなじだ。

[source,groovy]
----
[EWR,YYZ]
[EWR,YVR]
[EWR,LHR]
[EWR,CDG]
[EWR,FRA]
[EWR,NRT]
[EWR,DEL]
[EWR,DUB]
[EWR,HKG]
[EWR,PEK]
----

明らかに、 'from' と 'to' が使える方法は数多くある。最後の例として、3つの 'out' ステップを使ったクエリのバージョンを作成してみよう。少しあとで、このように同じステップを繰り返し使う必要がある場合に、 'repeat' が使える方法をお見せするが、この特定の例ではそれは重要ではない点に注意してほしい。

[source,groovy]
----
g.V().has('airport','code','AUS').out().out().out().
      path().by('code').limit(10)
----

予想どおり、経路のそれぞれに、経由地が追加された。

[source,groovy]
----
[AUS,EWR,YYZ,ATL]
[AUS,EWR,YYZ,AUS]
[AUS,EWR,YYZ,BNA]
[AUS,EWR,YYZ,BOS]
[AUS,EWR,YYZ,BWI]
[AUS,EWR,YYZ,DCA]
[AUS,EWR,YYZ,DFW]
[AUS,EWR,YYZ,FLL]
[AUS,EWR,YYZ,IAD]
[AUS,EWR,YYZ,IAH]
----

次は、クエリを修正して、パスのどの部分が返されるかを制限をかけよう。

[source,groovy]
----
g.V().has('airport','code','AUS').out().as('a').out().as('b').out().
      path().by('code').from('a').to('b').limit(10)
----

このように、選択した経路の一部のみが返された。

[source,groovy]
----
[EWR,YYZ]
[EWR,YYZ]
[EWR,YYZ]
[EWR,YYZ]
[EWR,YYZ]
[EWR,YYZ]
[EWR,YYZ]
[EWR,YYZ]
[EWR,YYZ]
[EWR,YYZ]
----

下記に示すように、特定のポイントまでの各パスの結果のみを表示するように、クエリを書くこともできる。

[source,groovy]
----
g.V().has('airport','code','AUS').out().out().as('b').out().
      path().by('code').to('b').limit(10)
----

今回は、最初に訪問した3つの空港のみ各結果に含まれている。

[source,groovy]
----
[AUS,EWR,YYZ]
[AUS,EWR,YYZ]
[AUS,EWR,YYZ]
[AUS,EWR,YYZ]
[AUS,EWR,YYZ]
[AUS,EWR,YYZ]
[AUS,EWR,YYZ]
[AUS,EWR,YYZ]
[AUS,EWR,YYZ]
[AUS,EWR,YYZ]
----

ちなみに、このような1つ以上の結果が同じ場合、重複を除去したくなると思う。ここで、 'dedup' ステップが役に立つ。 'dedup' のないようについては、"<<dedup>>"のセクションにある。しかしながら、ちょっとしたテストをして、前のクエリの最後に 'dedup' ステップを追加して、どうなるか見てみよう。

[source,groovy]
----
g.V().has('airport','code','AUS').out().out().as('b').out().
      path().by('code').to('b').limit(10).dedup()

[AUS,EWR,YYZ]
----

御覧の通り、重複すした結果はすべて除去された。うまくいけば、これで、 'path' ステップの基本的な理解が得られる。本書の残りの部分では、これは頻繁に使われていることに気づくだろう。しかしながら、 'path' を使う際に注意すべきことがいくつかある。これらの懸念については、少し後の、<<pathwarn>>のセクションで説明している。

[[edgeexist]]
==== 2つの頂点の間にエッジが存在するか？

'hasNext' ステップを使って2つの頂点間にエッジが存在するかどうかをチェックして、ブール値(true または false) の値を返すことができる。下記の1つめのクエリはAUSと DFW の間にエッジ（航路）があるので、 **true** を返す。2つ目のクエリは、AUSとSYDの間に航路がないので、**false** を返す。

[source,groovy]
----
g.V().has('code','AUS').out('route').has('code','DFW').hasNext()

true

g.V().has('code','AUS').out('route').has('code','SYD').hasNext()

false
----


[[aselproj]]
==== as を使って、選択、射影してトラバーサルステップを参照する

名前（ラベル）をつけて同じクエリ内の後で参照できるようにしてトラバーサルのポイントを覚えておくと便利なことがある。この機能は、TInkerPop 2 においてのほうが、TinkerPop 3 においてよりも重要だったが、それでも多くの用途がある。下記のクエリは、 'as' ステップを使って、検出された異なる頂点を表すトラバーサルの異なる2つの部分にラベルを添付する。 'select' ステップは後でそれらを参照するのに用いられる。

[source,groovy]
----
g.V().has('code','DFW').as('from').out().
      has('region','US-CA').as('to').
      select('from','to')
----

このクエリは少し工夫されているが、この場合はおそらく 'path' を使う代わりにはならないが、下記の結果を返す。

[source,groovy]
----
[from:v[8],to:v[13]]
[from:v[8],to:v[23]]
[from:v[8],to:v[24]]
[from:v[8],to:v[26]]
[from:v[8],to:v[28]]
[from:v[8],to:v[42]]
[from:v[8],to:v[151]]
[from:v[8],to:v[181]]
[from:v[8],to:v[244]]
[from:v[8],to:v[384]]
[from:v[8],to:v[877]]
----

上記の例では、頂点自体のみが選択されている。 'by' モジュレータを使って選択した頂点から取得するプロパティを指定することもできる。

[source,groovy]
----
g.V().has('code','DFW').as('from').out().
      has('region','US-CA').as('to').
      select('from','to').by('code')
----

今回は結果に、空港コードが含まれている。

[source,groovy]
----
[from:DFW,to:LAX]
[from:DFW,to:SFO]
[from:DFW,to:SJC]
[from:DFW,to:SAN]
[from:DFW,to:SNA]
[from:DFW,to:OAK]
[from:DFW,to:ONT]
[from:DFW,to:PSP]
[from:DFW,to:SMF]
[from:DFW,to:FAT]
[from:DFW,to:SBA]
----

前の例はおそらく理想的ではなかったが、 'as' と 'select' がどのように機能するかを示している。完全を期するために、これは同じクエリだが、 'path' を使っている。本書を通してよく用いられる 'select' ステップと 'path' ステップの両方のステップに気づくだろう。

[source,groovy]
----
g.V().has('code','DFW').out().
      has('region','US-CA').
      path().by('code')
----

これにより、下記の結果が得られる。今回の結果には、ラベルが関連づけられていないが、それ以外は同じであることに注意してほしい。

[source,groovy]
----
[DFW,LAX]
[DFW,ONT]
[DFW,PSP]
[DFW,SFO]
[DFW,SJC]
[DFW,SAN]
[DFW,SNA]
[DFW,OAK]
[DFW,SMF]
[DFW,FAT]
[DFW,SBA]
----

'path' ステップのほうがはるかに便利ではあるが、メモリとCPUの使用率の観点で非常にコストがかかることがあるので、 'as' や 'select' を用いたこれらの代替手段を覚えておく価値がある。このトピックについては"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#pathwarn[パスファインディングはメモリとCPUを集中的に使用する可能性があるという警告]" のセクションにてより詳しく説明されている。

下記に示すように、トラバーサルのポイントに複数の名前をつけて、トラバーサル／クエリ中の後でそれぞれを参照することもできる。

[source,groovy]
----
g.V().has('type','airport').limit(10).as('a','b','c').
      select('a','b','c').
        by('code').by('region').by(out().count())
----

TInkerPop の最新のリリースでは、新しい 'project' ステップを使って、 'as' と 'select' ステップを組み合わせるのと同じ結果を得ることもできる。下記の例は、前のクエリを、 'as' と 'select' の代わりに 'project' を使うように書き直したもの示したものである。

[source,groovy]
----
g.V().has('type','airport').limit(10).
      project('a','b','c').
        by('code').by('region').by(out().count())
----

このクエリと前のクエリは下記の結果を返す。

[source,groovy]
----
[a:ATL,b:US-GA,c:232]
[a:ANC,b:US-AK,c:39]                                                              
[a:AUS,b:US-TX,c:59]
[a:BNA,b:US-TN,c:55]
[a:BOS,b:US-MA,c:129]
[a:BWI,b:US-MD,c:89]
[a:DCA,b:US-DC,c:93]
[a:DFW,b:US-TX,c:221]
[a:FLL,b:US-FL,c:141]
[a:IAD,b:US-VA,c:136]
----

前の例では、変数に 'a' や 'b' のような単純な名前を付けた。しかしながら、トラバーサル変数や名前付きステップにもっと意味のある名前を付けると便利なことがあり、それを実行しても全く問題はない。クエリを書き換えてわかりやすい変数名をつけてみよう。

[source,groovy]
----
 g.V().has('type','airport').limit(10).
       project('IATA','Region','Routes').
         by('code').by('region').by(out().count())
----

修正したクエリを実行すると、このような出力が得られる。

[source,groovy]
----
[IATA:ATL,Region:US-GA,Routes:232]
[IATA:ANC,Region:US-AK,Routes:39]
[IATA:AUS,Region:US-TX,Routes:59]
[IATA:BNA,Region:US-TN,Routes:55]
[IATA:BOS,Region:US-MA,Routes:129]
[IATA:BWI,Region:US-MD,Routes:89]
[IATA:DCA,Region:US-DC,Routes:93]
[IATA:DFW,Region:US-TX,Routes:221]
[IATA:FLL,Region:US-FL,Routes:141]
[IATA:IAD,Region:US-VA,Routes:136]
----

[[multias]]
==== 同じラベルをもつ複数の as ステップを使う

1つの 'as' ステップを使って、トラバーサルの複数の部分に同じラベル（名前）を付けることが実際には可能だ。下記の例では、ラベル '+++'+++a+++'+++' は2回使われているが、ラベルが選択すると、最後に追加された要素のみが返されることがわかるだろう。

[source,groovy]
----
g.V(1).as('a').V(2).as('a').select('a')

v[2]
----

このような場合に、 'select' ステップと組み合わせて使うことができる特別なキーワードがある。これらのキーワードは、 'first' 、 'last' および 'all' で、使い方を下記に示す。

[source,groovy]
----
g.V(1).as('a').V(2).as('a').select(first,'a')

v[1]

g.V(1).as('a').V(2).as('a').select(last,'a')

v[2]

g.V(1).as('a').V(2).as('a').select(all,'a')

[v[1],v[2]]
----

これらは、トラバーサルの2つの異なる部分に同じ '+++'+++a+++'+++' のラベルを付けるクエリの別の例である。結果からお分かりのように、 'select' ステップで提供される最後にキーワードのために、2つめのみが使われる。

[source,groovy]
----
g.V().has('code','AUS').as('a').
      out().as('a').limit(10).
      select(last,'a').by('code').fold()

[YYZ,LHR,FRA,MEX,PIT,PDX,CLT,CUN,MEM,CVG]
----

これは同じクエリだが、今回は 'select' ステップの一部として、 'first' キーワードを使っている。

[source,groovy]
----
g.V().has('code','AUS').as('a').
      out().as('a').limit(10).
      select(first,'a').by('code').fold()

[AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS]
----

ステップにラベルを付けるのに同じ名前が使われる場合、Gremlin によって生成されるデータ構造は本質的にリストであることに注意してほしい。そのため、 'select' ステップに 'all' キーワードが使われる場合、 'by' モジュレータは使えない。リスト中の各要素の値を取得するためには、下記に示したように、 'unfold' ステップを使うことができる。

[source,groovy]
----
g.V().has('code','AUS').as('a').
      out().as('a').limit(10).
      select(all,'a').unfold().values('code').fold()

[AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS,
 YYZ,LHR,FRA,MEX,PIT,PDX,CLT,CUN,MEM,CVG]
----

'all' 、 'first' 、 'last' などのようなキーワードについては、本書の中で、のちの"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#javastatics[注意すべき重要なクラスと列挙型]"のセクションで詳しく説明する。

[[pathselect]]
==== パスの選択された部分を返す

'from' と 'to' モジュレータステップを 'path' ステップと一緒に使っても、求めてた結果が得られない場合がある。前のセクションの例と同様の方法で、 'select' ステップといくつかの 'as' ステップを使うと、トラバーサルの"path" の特定の部分がセレクトできる。ロスアンゼルス(LAX)からの経路を見つけてそのパスを返す下記のクエリ検討してみよう。

[source,groovy]
----
g.V().has('code','LAX').
      out().
      out().
      out().
      out().
      out().
      limit(1).
      path().by('code')

[LAX,YYC,BNA,BWI,YYZ,ZRH]
----

ここで、クエリからの結果として１つおきの経由地を返したいと想像してみてほしい。下記の例はまさにそれを行う方法を示している。

[source,groovy]
----
g.V().has('code','LAX').
      out().as('stop').
      out().
      out().as('stop').
      out().
      out().as('stop').
      limit(1).
      select(all,'stop').
      unfold().
      values('code').fold()

[YYC,BWI,ZRH]
----

[[exedge]]
==== 2つの頂点間のエッジを調べる

調べたいものが、2つの頂点間のエッジであり、頂点そのものではないことがある。通常、これはそのエッジに関連づけられている1つ以上のプロパティを確認したいからだ。例として、マイアミ（MIA)とダラスフォートワース(DFW) の間のフライトの距離を知りたい場合を想像してみてほしい。航空路グラフでは、頂点間の距離は 'route' ラベルの付いたエッジの 'dist' というプロパティを使って格納されている。 'outE' と 'inV' ステップを使えばマイアミとダラスを接続するエッジを見つけることができる。また、先ほど学んだばかりの 'select' と 'as' ステップを使えば、このタスクを行う上で役に立たせることもできる。下記のクエリを見てほしい。これは、MIAからDFWへの、射出 'route' エッジを見つける。トラバーサル変数 'e' に格納され、クエリの終わりに 'select' を使って、クエリの結果としてこれを返す。

[source,groovy]
----
g.V().has('code','MIA').outE().as('e').inV().has('code','DFW').select('e')
----

このクエリを実行すると、次のようなものが返される。

[source,groovy]
----
e[4127][16-route->8]
----

なので、IDが16(MIA)の頂点と、IDが8(DFW) の空港を接続する 'route' エッジが見つかる。興味深いことではあるが、これは正確には、我々がやりたかったことではない。我々が実際に関心のあったことは、そのエッジの距離プロパティで、マイアミからダラスフォートワースまでどれだけ離れているかを知りたいのだ。エッジの 'dist' プロパティを参照するステップをクエリに１つ追加する必要がある。それを行うためにクエリを修正してみよう。

[source,groovy]
----
g.V().has('code','MIA').outE().as('e').
      inV().has('code','DFW').select('e').values('dist')
----

クエリを再度実行すると、探していたものが返される。マイアミからダラスフォートワースまで1120マイルであることがわかる。

[source,groovy]
----
1120
----

ちなみに、 'inE' と 'outV' を使ってクエリを書いて、ダラスからマイアミまでのエッジを調べると同じ結果が得られる。

[source,groovy]
----
g.V().has('code','MIA').inE().as('e').
      outV().has('code','DFW').select('e').values('dist')

1120
----

本書の残りの部分に、 'outE' 、 'inE' 、 'outV' そして 'inV' などのステップを使った例が数多くある。

[[limit]]
=== 返されるデータの数を制限する

特に大きなグラフを扱う場合、クエリから返されるデータの数を制限すると便利なことがある。下記の例で示されているように、これは 'limit' や 'tail' ステップを使って実行することができる。本書の少し後で、データの疑似ランダムのサンプルを返すことができる 'coin' ステップも導入する。

[source,groovy]
----
// Only return the FIRST 20 results
g.V().hasLabel('airport').values('code').limit(20)  

// Only return the LAST 20 results
g.V().hasLabel('airport').values('code').tail(20)
----

実装によって、このようなクエリを書く方がおそらく効率がよい。 'values' の前に 'limit' が来て、最初に返される空港が少なくなるが、実装により両方を同じ方法で最適化する可能性がある。

[source,groovy]
----
// Only return the FIRST 20 results
g.V().hasLabel('airport').limit(20).values('code')
----

'limit' は 'range' の省略形を代替できることに注意してほしい。上記の2つの例の最初のものは、下記のように書くことができる。

[source,groovy]
----
// Only return the FIRST 20 results
g.V().hasLabel('airport').range(0,20).values('code')
----

実行が許される時間に制限を指定することで、トラバーサルを制限することもできる。下記のクエリは最大10ミリ秒に制限されているこのクエリはオースティン(AUS)からロンドンヒースロー(LHR)への経路を探す。このクエリの全体については、本書の後半で詳しく説明しているが、何をしているかはかなり明確だと思う。 'repeat' ステップは"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#sp[(空港間の) 最短経路：repeat を導入する]" のセクションで詳しく説明されている。

[source,groovy]
----
// Limit the query to however much can be processed within 10 milliseconds
g.V().has('airport','code','AUS').
      repeat(timeLimit(10).out()).until(has('code','LHR')).path().by('code')
----

これが、私のラップトップ上で実行したときに上記のクエリが返したものだ。

[source,groovy]
----
[AUS,LHR]
[AUS,YYZ,LHR]
[AUS,FRA,LHR]
[AUS,MEX,LHR]
----

クエリをさらに10ミリ秒実行すると、合計20ミリ秒になるので、見つかる経路がさらにいくつか増えることがわかる。

[source,groovy]
----
// Limit the query to 20 milliseconds
g.V().has('airport','code','AUS').
      repeat(timeLimit(20).out()).until(has('code','LHR')).path().by('code')

[AUS,LHR]
[AUS,YYZ,LHR]
[AUS,FRA,LHR]
[AUS,MEX,LHR]
[AUS,PDX,LHR]
[AUS,CLT,LHR]
----

[[retrrange]]
==== ある範囲にある頂点を取得する

Gremlinでは様々な方法で頂点のシーケンスを返すことができる。クエリ結果の最初の20要素を返すために前のセクションで使われた 'limit' ステップや 'range' ステップをすでにみてきた。 'range' ステップを使って、非ゼロの開始オフセットと終了オフセットを指定して、様々な範囲の頂点を選択することもできる。 'range' のオフセットはゼロスタートで、公式ドキュメントには,範囲は以上／以下と記載されているが、実際には私がテストしたところ、以上／未満であるように見える。

[source,groovy]
----
// Return the first two airport vertices found 
g.V().hasLabel('airport').range(0,2)

v[1]
v[2]
----

'range' ステップに渡される開始値は '0' は入らないはずだ。下記の例では、'"(3,6)"' という範囲を指定して、3番め、4番目、5番目の結果を求めている。

[source,groovy]
----
// Return the fourth, fifth and sixth airport vertices found (zero based)
g.V().hasLabel('airport').range(3,6)

v[4]
v[5]
v[6]
----

これは、インデックス '-1' を使って「リストの最後まで」を表す方法の例だ。これは、多くのプログラミング言語で、配列やリストを操作するときの規則と同様のものだ。

[source,groovy]
----
// Return all the remaining vertices starting at the 3500th one
g.V().range(3500,-1)
----

これは、別の 'range' ステップを使う例で、今回は 'country' のラベルがついた頂点のみを調べる。今回どれだけ高いIDの値をもつ頂点がヒットしたかに注目してほしい。

[source,groovy]
----
g.V().hasLabel('country').range(0,2)

v[3376]
v[3377]
----

NOTE: どの空港頂点が選択されるかについてはなんの保証もない。というのも、バックエンドグラフにどのように格納されているかに依存するからである。TinkerGraph を使うと、空港はグラフに格納された順番で返されると思われる。これは、JanusGraph などの他のグラフストアには当てはまらないかもしれない。なので、範囲を使って頂点の集合を処理する場合は、順序にいかなる期待にも依存しないでいただきたい。

TinkerPop 3.3 では、新しい 'skip' ステップが導入された。これは、場合により、 'range' の代わりに使われる。 'skip' ステップは2番目のパラメータが '-1' で「残りすべて」を意味するような 'range' を使う場合はいつでも使うことができる。

下記の2つの例は、同じ結果が得られる。

[source,groovy]
----
g.V().has('region','US-TX').skip(5).fold()

g.V().has('region','US-TX').range(5,-1).fold()
----

このいづれかのクエリを実行すると、下記のような出力が得られる。

[source,groovy]
----
[v[39],v[186],v[273],v[278],v[289],v[314],v[356],v[357],v[358],v[361],v[368],v[370],v[390],v[394],v[404],v[405],v[423],v[426],v[428],v[1118],v[3313]]
----

上記で使った 'skip' ステップと 'range' ステップが機能することを再度証明するために、 'skip' を削除してクエリを再度実行し、その結果をみてみよう。お気づきのように、リストされている最初の5つの頂点は、前のクエリ結果には含まれていなかった。

[source,groovy]
----
g.V().has('region','US-TX').fold()

[v[3],v[8],v[11],v[33],v[38],v[39],v[186],v[273],v[278],v[289],v[314],v[356],v[357],v[358],v[361],v[368],v[370],v[390],v[394],v[404],v[405],v[423],v[426],v[428],v[1118],v[3313]]
----

'local' キーワードを使ってトラバーサル内の入りのコレクションで 'skip' を機能させることも可能だ。下記の例は、わざとらしいが、 'fold' ステップにより生成されたリストに skip を適用する。

[source,groovy]
----
g.V().has('region','US-TX').fold().skip(local,3)

[v[33],v[38],v[39],v[186],v[273],v[278],v[289],v[314],v[356],v[357],v[358],v[361],v[368],v[370],v[390],v[394],v[404],v[405],v[423],v[426],v[428],v[1118],v[3313]]
----

Gremlin を使って値の範囲を指定する方法は、他にも数多くある。いくつかの例が"<<tranges>>"のセクションでさらに見つかるだろう。

[[dedup]]
==== 重複を除去する - dedup を導入する

多くの場合、クエリ結果から重複した値を除去するのが望ましい。'dedup' ステップを使うとこれができるようになる。すでにGroovy のコレクションに慣れ親しんでいるのであれば、 'dedup' ステップは、Groovy の 'unique' メソッドと同様のものだ。下記の例では、イングランドにあるすべての空港の滑走路の数を問い合わせている。返された値に多数の重複した値があることに注意してほしい。

[source,groovy]
----
g.V().has('region','GB-ENG').values('runways').fold()

[2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,2,1,3,1,3,3,4,1,1]
----

結果に一意の値のセットのみが欲しい場合、 'dudep' ステップを含めるようにクエリを書き換える。今回のクエリ結果には各値が1つしか含まれていない。

[source,groovy]
----
g.V().has('region','GB-ENG').values('runways').dedup().fold()

[2,1,3,4]
----

'by' モジュレータ使って、 'dedup' の適用方法を指定することもできる。下記の例では、各一意の滑走路の本数ごとに1つの空港のみを返す。

[source,groovy]
----
g.V().has('region','GB-ENG').dedup().by('runways').
      values('code','runways').fold()

[LHR,2,LCY,1,BLK,3,LEQ,4]
----

'dedup' ステップにはもう1つの形式がある。この形式では、ラベル付けされたステップを表す1つ以上の文字列がパラメータとして渡される。まずは、下記のクエリを見ていただきたい。頂点 'V(3)' があり、 '+++'+++a+++'+++' のラベルを付ける。次に、頂点 'V(4)' があり、'+++'+++c+++'+++ のラベルを付ける。次に、V(4)と接続されているすべての頂点を見つけ、それらに '+++'+++b+++'+++ をラベル付けをする。最初の10件だけが取得される。最後に、 'select' ステップを使って結果を返す。期待した通り、全ての結果に頂点3と4 がある。

[source,groovy]
----
g.V(3).as('a').V(4).as('c').both().as('b').limit(10).
  select('a','b','c')

[a:v[3],b:v[1],c:v[4]]
[a:v[3],b:v[3],c:v[4]]
[a:v[3],b:v[5],c:v[4]]
[a:v[3],b:v[6],c:v[4]]
[a:v[3],b:v[7],c:v[4]]
[a:v[3],b:v[8],c:v[4]]
[a:v[3],b:v[9],c:v[4]]
[a:v[3],b:v[10],c:v[4]]
[a:v[3],b:v[11],c:v[4]]
[a:v[3],b:v[12],c:v[4]]
----

同じクエリを実行するが、'+++'+++a+++'+++' と '+++'+++c+++'+++' のラベルを参照する 'dedup' ステップを追加すると、それらの頂点を含むすべての重複参照が結果から除去されるので、今回は 'limit' 10 を使っても実際には1つしか結果を返さない。

[source,groovy]
----
g.V(3).as('a').V(4).as('c').both().as('b').limit(10).
  dedup('a','c').select('a','b','c')

[a:v[3],b:v[1],c:v[4]]
----

少し後で、トラバーサルを操作するときの 'local' スコープの概念を見ていく。 'dedup' と組み合わせて 'local' スコープが使われている例が"<<localcollect>>"のセクションにいくつかある。

'sets'を使っても以降の、すぐに出てくる"<<setsandlists>>" のセクションなどで説明をするのと同じ結果を得ることもできる。

[[vm]]
=== valueMap を使って頂点またはエッジのプロパティを調べる

valueMap を呼び出すと頂点やエッジのすべてのプロパティを、key:value ペアの配列で返される。基本的に、Javaの用語で、HashMap  と呼ばれるものだ。すべてを返したくない場合は、どのプロパティをvalueMap で返したいかを選択することもできる。マップ中の各要素はキーの名前を使ってアドレス指定できる。デフォルトでは、 'true' のプロパティが指定されない限り、IDとラベルはマップには含まれない。

下記のクエリはオースティン空港頂点に関連づけられているすべてのプロパティのキーと値を返す。

[source,groovy]
----
// Return all the properties and values the AUS vertex has
g.V().has('code','AUS').valueMap().unfold()
----

Gremlin コンソールを使っていると、前のコマンドを実行したときの出力はこのようになる。クエリの最後にあるunfold ステップは、結果を読みやすくするために使われる。

[source,groovy]
----
country=[US]
code=[AUS]
longest=[12250]
city=[Austin]
elev=[542]
icao=[KAUS]
lon=[-97.6698989868164]
type=[airport]
region=[US-TX]
runways=[2]
lat=[30.1944999694824]
desc=[Austin Bergstrom International Airport]  
----

NOTE: 国のような各キーの後に、リストの要素として返される値が続くことに注意してほしい。これは（頂点用であり、エッジ用ではないが）指定されたキーに対してリストやセットにエンコードすることにより、複数のプロパティ値を返すことができるからだ。Apache TinkerPop リリース 3.4 では、これらの結果がどのように返されるかを制御しやすくするためにいくつかの変更が導入された。これらの変更については、次のセクションで説明する。

'valueMap' の使い方についての例をいくつか示す。 'true' のパラメータが指定されている場合、返される結果には、要素のIDやラベルが含まれる。

[source,groovy]
----
// If you also want the ID and label, add a parameter of true
g.V().has('code','AUS').valueMap(true).unfold()

id=3
label=airport
country=[US]
code=[AUS]
longest=[12250]
city=[Austin]
elev=[542]
icao=[KAUS]
lon=[-97.6698989868164]
type=[airport]
region=[US-TX]
runways=[2]
lat=[30.1944999694824]
desc=[Austin Bergstrom International Airport]
----

'true' を特定のプロパティのマップのリクエストと混在させて使うこともできる。次の例はID、ラベルおよび 'region' プロパティのみを返す。

[source,groovy]
----
// If you want the ID, label and a specific field like the region, you can do this
g.V().has('code','AUS').valueMap(true,'region')

[id:3,region:[US-TX],label:airport]
----

TIP: 特定のプロパティのキーと値だけを返したい場合、それらのプロパティの名前をパラメータとして 'valueMap' ステップにに渡して、必要以上のデータが返されないようにすることをお勧めする。これはSQLの世界での、SELECT * を実行するのではなく、テーブルから目的のカラムだけを選択することの違いであると考えてほしい。

上記のように、'valueMap' ステップにパラメータとして、プロパティの名前を指定することで、どのプロパティを返すかを指定することができる。完全を期するために、 'select' ステップを使って 'valueMap' の結果を絞り込むこともできることに注意してほしい。

[source,groovy]
----
// You can 'select' specific fields from a value map
g.V().has('code','AUS').valueMap().select('code','icao','desc')

[code:[AUS],icao:[KAUS],desc:[Austin Bergstrom International Airport]]
----

Gremlin コンソールで、valueMap を使ったクエリの出力を読んでいるのであれば、下記のようにクエリの最後に 'unfold' ステップを追加すると出力が読みやすくなることがある。 'unfold' ステップはコレクションを案バンドルする。本書のいろんなところで使われているのを見るだろう。

[source,groovy]
----
g.V().has('code','AUS').valueMap(true,'code','icao','desc','city').unfold()

code=[AUS]
city=[Austin]
icao=[KAUS]
id=3
label=airport
desc=[Austin Bergstrom International Airport]
----

'valueMap' を使って、エッジに関連づけられているプロパティを検査することもできる。この簡単な例では、IDが 5161 のエッジを調べている。御覧の通り、エッジは経路を表し、1357マイルの値をもつ距離( 'dist' )のプロパティがある。

[source,groovy]
----
g.E(5161).valueMap(true)

[id:5161,dist:1357,label:route]
----

[[tp34vm]]
==== TInkerPop 3.4 で導入された valueMap に変更する

Apache TinkerPop 3.4 リリース以降、 'valueMap' ステップが返す結果をより簡単に制御できるようにする変更がいくつか導入された。さらに、 'true' を使って頂点、あるいはエッジのIDとラベルプロパティを返すのは非推奨となり、 'with' モジュレータを使う方法に置き換えられた。

NOTE: 新しい valueMap 構成オプションについては、下記のリンクにある公式ドキュメントで説明されている。
http://tinkerpop.apache.org/docs/current/reference/#valuemap-step.

'valueMap' を使うこれまでの方法は引き続き機能するが、Graph DB プロバイダが TinkerPop 3.4 を採用するにつれて、下記に示す例が 'valueMap' によって返される結果を制御するための好ましい方法になる。

'valueMap(true)' を使って、要素(頂点あるいはエッジ）のIDとラベルを結果に含める代わりに、新しい 'with ( WithOptions.tokens)' コンストラクトを下記に示すように使えるようになった。

[source,groovy]
----
g.V().has('code','SFO').valueMap().with(WithOptions.tokens).unfold()

id=23
label=airport
country=[US]
code=[SFO]
longest=[11870]
city=[San Francisco]
elev=[13]
icao=[KSFO]
lon=[-122.375]
type=[airport]
region=[US-CA]
runways=[4]
lat=[37.6189994812012]
desc=[San Francisco International Airport]
----

TIP: WithOptions を使って指定できるすべての可能な値は、http://tinkerpop.apache.org/javadocs/current/full/org/apache/tinkerpop/gremlin/process/traversal/step/util/WithOptions.html[この場所にある]、公式のApache TinkerPop JavaDoc ドキュメントにある。

まだ、関心のあるプロパティキーに明示的に名前をつけることで、プロパティのサブセットと合わせてIDとラベルを結果に含めることができる。下記の例では、 'code' プロパティのみリクエストされている。

[source,groovy]
----
g.V().has('code','SFO').valueMap('code').with(WithOptions.tokens).unfold()

id=23
label=airport
code=[SFO]
----

追加の 'WithOptions' 修飾子を使って、ラベルのみを選択することができる。

[source,groovy]
----
g.V().has('code','SFO').
      valueMap('code').with(WithOptions.tokens,WithOptions.labels).
      unfold()

label=airport
code=[SFO]
----

同様に、ラベルなしでID値だけを返すように選択することもできる。

[source,groovy]
----
g.V().has('code','SFO').
      valueMap('code').with(WithOptions.tokens,WithOptions.ids).
      unfold()

id=23
code=[SFO]
----

前のセクションで説明したように、 'valueMap' で返されるプロパティの値は、たとえ、プロパティ値が1つしかなくても、デフォルトでリストとして表現される。

NOTE: 3.4より前のバージョンのTinkerPop を使っても、 by(unfold()) を使った場合と同じ展開した結果を生成することができる。これを行う方法は本書の少しあとで説明されているが、最初にmap などの他のいくつかのステップを確認する必要がある。先に進みたいのであれば、"<<vmunroll>>"のセクションに、これらの例がある。

TinkerPop 3.4 以降では、非常に簡単にこれらの値がリストにラップされていない単一の値として返されるようにリクエストすることができる。これは、下記に示すように、 'by' ステップモジュレータを使えば実行できる。

[source,groovy]
----
g.V().has('code','SFO').valueMap().by(unfold()).unfold()
----

都市名 "San Francisco" のようなすべての値は単純な文字列、あるいは数値になり、長さが1のリストにラップされた単一の値ではないことに注意してほしい。

[source,groovy]
----
country=US
code=SFO
longest=11870
city=San Francisco
elev=13
icao=KSFO
lon=-122.375
type=airport
region=US-CA
runways=4
lat=37.6189994812012
desc=San Francisco International Airport
----

NOTE: WithOptions には、メタプロパティがあるプロパティがvalueMap によって返される方法を変更するために使えるさらなる設定がある。これは"<<tp34vmmetaprop>>"のセクションの一部として、後ほど扱う。

[[element-map]]
=== valueMap の代替ーelementMap の導入

新しいステップ、 'elementMap' は、2019年10月のApache TinkerPop 3.4.4 リリースの一部として Gremlin 言語に追加された。この新しいステップは、多くの点で valueMap ステップに似ているが、いくつかの点で少し簡単になる。

TIP: クエリで elementMap を使う前に、使用しているグラフデータベースが Apache TinkerPop の 3.4.4 以上をサポートしていること確認してほしい。

valueMap を使う際には、IDと頂点やエッジのラベルがクエリ結果に含まれるように、明示的にリクエストする必要がある。これはelementMap を使う際には必要ない。

[source,groovy]
----
g.V().has('code','AUS').elementMap().unfold()

id=3
label=airport
country=US
code=AUS
longest=12250
city=Austin
elev=542
icao=KAUS
lon=-97.6698989868164
type=airport
region=US-TX
runways=2
lat=30.1944999694824
desc=Austin Bergstrom International Airport
----

'valueMap' と同様、特定のプロパティ値のみが結果のマップに含まれるようにリクエストすることができる。しかしながら、注意してほしいのは、プロパティ値はリストメンバとして返されないということだ。これは valueMap との主要な違いだ。実際、指定されたプロパティの値が複数の値を内包したリスト、もしくはセットであれば、elementMap は、そのリストもしくはセットの最初のメンバのみを返す。もしセットあるいはリストのカーディナリティ値を返す櫃よがあるのであれば、代わりに valueMap を使うべきだ。

[source,groovy]
----
g.V().has('code','AUS').elementMap('city')

[id:3,label:airport,city:Austin]  
----

'elementMap' と 'valueMap' の最大の違いは、エッジを見ると明らかになる。特定のエッジ、並びに ID、ラベル、プロパティに対し、入りと出の頂点についての情報も返される。

[source,groovy]
----
g.V(3).outE().limit(1).elementMap()

[id:5161,label:route,IN:[id:47,label:airport],OUT:[id:3,label:airport],dist:1357]
----

下記に示すように、 'valueMap' を使うと同様の結果が生成されるが、それは間違いなくもう少し手順が必要になる。

[source,groovy]
----
g.E(5161).project('v','IN','OUT').
            by(valueMap(true)).
            by(inV().union(id(),label()).fold()).
            by(outV().union(id(),label()).fold())

[v:[id:5161,label:route,dist:1357],IN:[47,airport],OUT:[3,airport]]
----

出力を、 'elementMap' によって返される結果にさらに近づけるために、いくつかの 'project' ステップを追加することを決めることになる。

[source,groovy]
----
g.E(5161).project('v','IN','OUT').
            by(valueMap(true)).
            by(project('id','label').
              by(inV().id()).
              by(inV().label())).
            by(project('id','label').
              by(outV().id()).
              by(outV().label())).
            unfold()
----

クエリを実行した結果をいかに示す。結果を少し読みやすくするために、クエリに unfold ステップを追加した。

[source,groovy]
----
v={id=5161, label=route, dist=1357}
IN={id=47, label=airport}  
OUT={id=3, label=airport}
----

[[var]]
=== クエリ結果を変数に割り当てる

クエリの結果を変数に割り当てることができれば、非常に便利だ。下記の例では、上述の 'valueMap' 呼び出しの結果をausという変数に格納している。

[source,groovy]
----
// Store the properties for the AUS airport in the variable aus.
aus=g.V().has('code','AUS').valueMap().next()
----

TIP: これを機能させるには、クエリの最後にnext の呼び出しを追加することが必要である。next への呼び出しを追加するのを忘れるのはGremlin クエリ言語に慣れている人々にとってはよくある間違いだ。next への呼び出しはクエリのトラバーサル部分を終端し、変数に格納できる具体的な結果を生成する。このトラバーサルを終端するアクションを実行するものは、toList や toSet などのステップがほかにもある。これらのステップについては後ほど説明する。

変数に結果を格納できたら、他のプログラミング言語と同じようにそれを参照することができる。本書の後半で、JavaコードとGroovy コードをGremlin クエリと混成する方法調べる予定だ。今は、Groovy の 'println' を使って 'aus' に格納したクエリの結果を表示させてみよう。Gremlin での変数の使い方については本書の後ほど "https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#grv[Gremlin をさらに Groovier にする]" のセクションでGremlin と Groovy を混成する方法について見る際に深く掘り下げる。

[source,groovy]
----
// We can now refer to aus using key:value syntax
println "The AUS airport is located in " + aus['city'][0]

The AUS airport is located in Austin
----

NOTE: プロパティは値の配列として格納されている。指定されたキーに紐づくプロパティ値がたとえ1つしかない場合であってもそれを参照する際には、[0] をつける必要がある。さもないと、aus['city'] を指定しただけだと配列全体が返される。なぜプロパティの値がこのような方法で格納されているかについては、"<<listprop>>"のセクションで詳しく説明する予定だ。

ちなみに、 'next' ステップは返すデータの数を指定するパラメータ値を取ることができる。例えば、下記のように、クエリから次の3つの頂点が欲しい場合、 'next(3)' の呼び出しをクエリの最後に追加することができる。これを行うと、結果がArrayList に替わることに注意してほしい。このリストの各要素には、頂点が含まれる。

[source,groovy]
----
verts=g.V().hasLabel('airport').next(3)

v[1]
v[2]
v[3]
----

Java の getClass メソッドを呼び出して、返される値のタイプを確認することができる。

[source,groovy]
----
verts.getClass()

class java.util.ArrayList

verts.get(1).getClass()

class org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerVertex
----

TIP: Gremlin コンソールを使う場合、コマンド :show variables を使って定義した変数をチェックすることができる。

[[setsandlists]]
==== toList, toSet, bulkSet 及び fill を導入する

クエリの結果をリストやセットとして返すと便利なことが多い。これを行うための1つの方法は、 'toList' や 'toSet' メソッドを使うことだ。下記に、それぞれの例を示す。 'join' の呼び出しは結果を1行で読みやすくするためだけに使っている。

[source,groovy]
----
// Create a list of runway counts in Texas
listr = g.V().has('airport','region','US-TX').
              values('runways').toList().join(',')

2,7,5,3,4,3,3,3,3,4,2,3,2,3,2,2,3,2,1,3,2,3,4,3,4,2
----

次にセットを作成して、返されるいろんな結果を観察してみよう。

[source,groovy]
----
// Create a set of runway counts in Texas (no duplicates)
setr = g.V().has('airport','region','US-TX').
             values('runways').toSet().join(',')

1,2,3,4,5,7
----

ちなみに、多くの場合、結果から重複を除去するために 'dedup' ステップを使うことができる。しかしながら、場合によっては、非常に便利な結果タイプとしてセットを作ることができることは知っておくとよい。下記の例は、 'dedup' ステップを使って同じ滑走路のクエリを実行している。前のクエリと結果を比較しやすくするために、 'order' ステップを追加した。

[source,groovy]
----
// Create a list of runway counts in Texas (no duplicates)
g.V().has('airport','region','US-TX').
      values('runways').dedup().order().fold()

[1,2,3,4,5,7]
----

最後に、再度リストを作ってみよう。ただし、 'join' の呼び出しをしないでいただきたい。これにより、単一の文字列の結果が作られるので、この場合は必要ない。

[source,groovy]
----
listr = g.V().has('airport','region','US-TX').
        values('runways').toList()
----

これで期待通りに変数を使うことができる。

[source,groovy]
----
listr[1]
7

listr.size()
26

listr[1,3]
7
3
----

TinkerPop は、トラバーサルの最後でコレクションを作る 'bulkSet' という3番目のメソッドも使用できる。 'bulkSet' と 'set' の違いは、 'bulkSet' はいわゆる重み付きセットと呼ばれるものであることだ。 'bulkSet' はすべての値を格納するが、各タイプがいくつ存在するかのカウントを含んでいる。いくつかの例を見てみよう。まず、 'bulkSet' に実際にすべての値が含まれていることが確認できる。

[source,groovy]
----
setb= g.V().has('airport','region','US-TX').values('runways').toBulkSet().join(',')
2,2,2,2,2,2,2,2,7,5,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,1
----

'bulkSet' は呼び出すことができるいくつかの追加のメソッドを提供する。そのうちの1つは、 'uniqueSize' で、これは存在する一意の値の数を示す。

[source,groovy]
----
setb= g.V().has('airport','region','US-TX').values('runways').toBulkSet()

// How many unique values are in the set?
setb.uniqueSize()
6

// How many total values are present?
setb.size()
26
----

'asBulk' メソッドはキー/値のペアのマップを返す。ここで、キーは数値で、値はその数がセットに含まれている回数である。

[source,groovy]
----
setb.asBulk()

2=8
7=1
5=1
3=11
4=4
1=1
----

クエリの結果をコレクションへ格納するのには他にも方法がある。これは、 'fill' メソッドを使えば実現できる。 'toList' やこれまで見てきた他のメソッドとは異なり、 'fill' は結果を既存の変数へ格納する。下記のクエリは 'a' というリストを定義し、クエリ結果をこれに格納する。これは 'toList' を使った場合と同じ結果が得られる。

[source,groovy]
----
a = []
g.V().has('airport','region','US-TX').values('runways').fill(a)

a.size()
26

a[1,3]
7
3
----

セットの変数を定義して、 'fill' を使うと、 'toSet' を使うのと同じ結果を得ることができる。

[source,groovy]
----
s = [] as Set
g.V().has('airport','region','US-TX').values('runways').fill(s)

println s

[2, 7, 5, 3, 4, 1]
----

[[wid]]
=== IDを操作する

グラフにある全ての頂点、すべてのエッジ、そしてすべてのプロパティにも、個々に、あるいはグループの一部として参照するために使われる一意のIDがある。GraphMLやGraphSON ファイルからグラフをロードする際に指定するIDは多くの場合、バックエンドのグラフストアがグラフを構築する際に実際に使うIDにならない場合があることに注意してほしい。例えば、TinkerGraph はユーザ指定のIDを保存するが、JanusGraph のような多くのグラフデータベースは独自のIDを生成する。おなじことが、グラフトラバーサルを使って、あるいはTinkerPop API を使って頂点やエッジを追加する際にもいえる。これは、データを一旦グラフストアにロードしたら、それを変更していなくても、GraphMLやGraphSON ファイル中のIDに依存すべきでない、というまどろっこしい言い方だ。新しい頂点やエッジをトラバーサルを使ってグラフに追加すると、グラフシステムは自動的に新しい一意のIDをそれのために生成する。その頂点やエッジのIDを指定する必要がある場合は、グラフからいつでもそれ自身をクエリで取得できる。

TIP: 登録したIDの値を保持するグラフに依存しないでいただきた。グラフ自体がID値を照会できるコードを書くこと。IDがどのように管理されているかはグラフデータベースの実装に依存する。

特に大きなグラフを扱う場合は、IDを使うと通常とても効率的なので、クエリの多くは1つ以上のIDを収集し、それらを他のクエリ、あるいは同じクエリの別の部分に渡すことが多々あることがわかるだろう。全部ではないが、ほとんどの場合、基盤となるグラフシステムは、ディスク上であろうとメモリ上であろうと、ID値によって非常迅速にアクセスされるようにデータ構造をセットアップする。

いくつかの簡単な例を使って、ID値を使う例をお見せしよう。下記のクエリは、DFW空港を表す頂点のIDが8であることを見つける。

[source,groovy]
----
 // What is the ID of the "DFW" vertex?
 g.V().has('code','DFW').id()

 8
----

クエリを逆にして、IDが8の頂点のコードを見つけよう。

[source,groovy]
----
// Simple lookup by ID
g.V().hasId(8).values('code')

DFW
----

上記のクエリを下記のように書くこともできる。

[source,groovy]
----
// which is the same as this
g.V().has(id,8).values('code')
----

これは、ID値を使う別の例だ。

[source,groovy]
----
// vertices with an ID between 1 and 5 (note this is inclusive/exclusive)
g.V().hasId(between(1,6))

// Which is an alternate form of this
g.V().has(id,between(1,6))

// Find routes from the vertex with an ID of 6 to any vertex with an ID less than 46
g.V().hasId(6).out().has(id,lt(46)).path().by('code')

// Which is the same as
g.V().hasId(6).out().hasId(lt(46)).path().by('code')
----

単一のID、もしくは複数のID値を直接 'V()' ステップに渡すこともできる。下記の2つの例を見てみよう。

[source,groovy]
----
// What is the code property for the vertex with an ID of 3?
g.V(3).values('code')

AUS

// As above but for all of the specified vertex IDs
g.V(3,6,8,15).values('code')

AUS
BWI
DFW
MCO
----

ID値のリストを 'V' ステップに渡すこともできる。この方法で変数を使う方法については、"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#varaus[変数を使ってトラバーサルをフィードする]"のセクションで詳しく見ていく。

[source,groovy]
----
a=[3,6,8,15]

g.V(a).values('code')
----

使っているグラフデータベースがサポートしている場合、頂点の作成時にIDを設定することができる。これを行う方法は、"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#injectid[inject を使って新しい頂点のID値を指定する]"のセクションで説明されている。

グラフ内の全てのプロパティにもIDがある。これについて"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#propid[プロパティにもIDがある]"のセクションで説明する。

[[lab]]
=== ラベルを操作する

グラフを設計する際は、頂点やエッジに意味のあるラベルを付けることはよい考えだ。これらを使うと検索を詳細化することができる。例えば、 'air-routes' グラフでは、全ての空港頂点は 'airport' のラベルがついていて、全ての国頂点には、当然のことながら、 'country' のラベルがついている。同様に、飛行経路を表すエッジには 'route' のラベルがついている。ラベルは様々な使い方が可能だ。すでに特定のラベルをテストするために 'hasLabel' ステップが使われているのを基本的なクエリのセクションで見てきた。さらにいくつかの例を示す。

[source,groovy]
----
// What label does the LBB vertex have?
g.V().has('code','LBB').label()

// What airports are located in Australia? Note that 'contains' is an
// edge label and 'country' is a vertex label.
g.V().hasLabel('country').has('code','AU').out('contains').values('code')

// We could also write this query as follows
g.V().has('country','code','AU').out().values('code') 
----

このようにラベルを使うことにより、効率的に頂点やエッジをクラスやタイプにグループ化できる。様々なタイプの車両を含むグラフを構築したい場合を想像してみてほしい。全ての頂点に 'vehicle' とだけラベルを付けることを決定するかもしれないが、 'car' 、 'truck' 、 'bus' のようなラベルを使うことにすることもできる。最終的には、グラフのデータモデルの全体的な設計によりラベルの使い方が左右されることになるが、ラベルの値について注意を払うことはよいことだ。

NOTE: ラベルは便利ではあるが、全てのグラフデータベースエンジンがラベルのインデックス化をサポートしているわけではない。使っているグラフデータベーステクノロジでラベルのインデックス化が可能かどうか確認すべきだろう。サポートされていない場合、ラベルの代用として、インデックス化が可能な頂点やエッジプロパティを使うことをお勧めする。これは、頂点ラベルに依存するのではなく、グラフクエリで使うことができる。これは、探しているアイテムがインデックス化されていない場合に、パフォーマンスが問題となる可能性がある大規模なグラフを扱う場合、特に重要だ。

これは、ラベルを操作する方法の例だ。

[source,groovy]
----
// You can explicitly reference a vertex label using the label() method
g.V().where(label().is(eq('airport'))).count()

// Or using the label key word
g.V().has(label,'airport').count()

// But you would perhaps use the hasLabel() method in this case instead
g.V().hasLabel('airport').count()

// How many non airport vertices are there?
g.V().has(label,neq('airport')).count()
g.V().where(label().is(neq('airport'))).count()

// Again, it might be more natural to actually write this query like this:
g.V().not(hasLabel('airport')).count()
----

下記にあるように、エッジラベルを見る場合も、同じ概念が同様に当てはまる。

[source,groovy]
----
// The same basic concepts apply equally to edges
g.E().has(label,'route').count()

g.E().where(label().is(eq('route'))).count()  

g.E().hasLabel('route').count()
----

もちろん、ラベルが使われる可能性がある他の一般的なところはすでにみてきた。つまり、下記の例のような、 'has' の3つのパラメータ形式だ。最初のパラメータはラベルの値である。次の2つのパラメータは、コードが"'SYD'"の 'airport' ラベルをもつすべての頂点のプロパティをテストする。

[source,groovy]
----
g.V().has('airport','code','SYD')
----

下記に示すように、同じステップで1つ以上のラベルを指定することも可能だ。通常、ステップにラベルを付けることができる場合はいつでも、複数のラベルをつけることもできる。

[source,groovy]
----
g.E().hasLabel('route','contains')
----

[[local]]
=== ローカルステップを使って意図した結果が得られることを確認する

トラバーサルの終了間際まで待つよりも、トラバーサルの現在の状態に基づいて計算できることが重要な場合がある。一般的にこれが必要になるのは、コレクションの平均値を計算する場合だ。次のセクションでは、Gremlinで実行できる数値や統計処理の選択について見ていく。しかしながら、ここでは、 'mean' ステップを使って平均値を計算して、 'local' ステップが計算に及ぼす効果を見てみよう。 'mean' ステップは、期待通りに動作し、一連の数値の平均を返す。

空港からの経路数の平均を計算したいのであれば、最初に作るクエリはこのようになる。

[source,groovy]
----
g.V().hasLabel('airport').out('route').count().mean()

43400.0
----

返された答えを見ての通り、43400.0 は間違っているように見えるが、実際にはそうだ。この数は、実際には、グラフ全体の発ルートの総数だ。これは、書かれているように、クエリがすべての経路をカウントし、それらをすべて合計しているが、アクセスした空港の数を追跡していないからだ。これは、 'mean'_ステップを呼び出すことが本質的に、カウントを1で割ることと同じであることを意味している。

では、どのように修正すればよいだろうか？答えは、 'local' ステップを使うことだ。本当にやりたいことは、本質的に、空港ごとの経路の数のコレクションを作成することだ。それができたら、これらすべての数値の合計をメンバの数、ここの場合は空港の数で割って、コレクションに格納することだ。

下記の修正したクエリをみていただきたい。

[source,groovy]
----
// Average number of outgoing routes from an airport.  
g.V().hasLabel('airport').local(out('route').count()).mean()  

12.863070539419088
----

今回の結果は、はるかに信頼できる答えだ。今回は、 'out('route').count()' ステップを 'local' ステップの内側に配置した点に注意してほしい。下記のクエリは、 'mean' ステップを除去してあり、このクエリの実行中に、トラバーサル中に何が起こっているかを示す。出力を切り捨てて、数行だけをお見せしている。

[source,groovy]
----
g.V().hasLabel('airport').local(out('route').count()).limit(10)

232
38
59
55
129
87
93
220
141
135
----

これが示すのは、最初の10の空港について、構築したコレクションには空港にある発ルートの数を表す、空港ごとに１つのエントリが含まれていることだ。次に、最終的に 'mean' ステップが適用されると、コレクション全体の平均値が計算され、探していた結果が返される。

'local' ステップを使って、クエリの結果を便利な方法で変更する別の例をみてみよう。まず、下記のクエリと、それが生成する結果を見てほしい。このクエリはまずGB-SCT のリージョンコードを使って、スコットランドにあるすべての空港を見つける。次に空港コードと都市名の順序つきリストを生成する。

[source,groovy]
----
g.V().has('region','GB-SCT').order().by('code').
      values('code','city').fold()
----

このクエリを実行した結果はこうだ。

[source,groovy]
----
[ABZ,Aberdeen,BEB,Balivanich,BRR,Eoligarry,CAL,Campbeltown,DND,Dundee,EDI,Edinburgh,EOI,Eday,FIE,Fair Isle,FOA,Foula,GLA,Glasgow,ILY,Port Ellen,INV,Inverness,KOI,Orkney Islands,LSI,Lerwick,LWK,Lerwick,NDY,Sanday,NRL,North Ronaldsay,PIK,Glasgow,PPW,Papa Westray,PSV,Papa Stour Island,SOY,Stronsay,SYY,Stornoway,TRE,Balemartine,WIC,Wick,WRY,Westray]
----

しかしながら、結果を、各小さいリストには空港コードと都市名を入れて、全部の小さいリストを大きなリストにラップした、リストのリストとして返すほうがおそらくより便利だ。これは、下記に示すように、クエリの後半を 'local' ステップの内側にラップすることで実現できる。

[source,groovy]
----
g.V().has('region','GB-SCT').order().by('code').
      local(values('code','city').fold())

----

これが、修正したクエリを実行した結果だ。読みやすくするために、結果を2列にまとめた。

[source,groovy]
----
[ABZ,Aberdeen]          [LSI,Lerwick]                 
[BEB,Balivanich]        [LWK,Lerwick]                 
[BRR,Eoligarry]         [NDY,Sanday]                  
[CAL,Campbeltown]       [NRL,North Ronaldsay]         
[DND,Dundee]            [PIK,Glasgow]                 
[EDI,Edinburgh]         [PPW,Papa Westray]            
[EOI,Eday]              [PSV,Papa Stour Island]       
[FIE,Fair Isle]         [SOY,Stronsay]                
[FOA,Foula]             [SYY,Stornoway]               
[GLA,Glasgow]           [TRE,Balemartine]             
[ILY,Port Ellen]        [WIC,Wick]                    
[INV,Inverness]         [WRY,Westray]                 
[KOI,Orkney Islands]
----

'local' の使い方は、他にもたくさんある。本書を通して、これらの例を見つけるだろう。"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#meanmode[グラフ内の経路の分布(モードと平均)]"のセクションでルート分析をさらに深く掘り下げる際に、 'order' ステップのパラメータとしてlocalをどのように使うかを示すものを見つかるだろう。
    
[[st]]
=== 基本的な統計と数値演算

下記のクエリはグラフに存在する特定のアイテムの量を計算したり、値のセットの平均(mean)を計算したり、最大値や最小値を計算したりといった概念を示すものだ。下記の表は、利用可能なステップをまとめたものだ。

.基本的な統計ステップ
[cols="^1,4"]
|==============================================================================
|count   | Count how many of something exists.
|sum     | Sum (add up) a collection of values.
|max     | Find the maximum value in a collection of values.
|min     | Find the minimum value in a collection of values.
|mean    | Find the mean (average) value in a collection.
|==============================================================================

本書の https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#meanmode[グラフ内の経路の分布(モードと平均)] のセクションにて、これらの機能をもう少し深く掘り下げて詳細を説明する。これらの例のいくつかは、前のセクションで紹介した 'local' ステップも利用している。データセット内の標準偏差を計算する方法については、後ほどの https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#mathstep[Gremlinの関数電卓-mathを導入する] のセクションで説明する。各クエリを実行した結果も下記の例に示されている。

[source,groovy]
----
// How many routes are there from Austin?
g.V().has("airport","code","AUS").out().count()

59

// Sum of values - total runways of all airports
g.V().hasLabel('airport').values('runways').sum()

4828
----

'mean' ステップを使うと、データセット内の平均値を見つけることができる。

[source,groovy]
----
// Statistical mean (average) value - average number of runways per airport
g.V().hasLabel('airport').values('runways').mean()

1.4309425014819206

// Average length of the longest runway across all airports
g.V().hasLabel('airport').values('longest').mean()

7570.862477771191

// Average number of routes to and from an airport
g.V().hasLabel('airport').local(both('route').count()).mean()

25.726141078838175
----

下記のクエリは、 'max' ステップと 'min' ステップを使って最大値と最小値を見つける。

[source,groovy]
----
//maximum value - longest runway
g.V().hasLabel('airport').values('longest').max()

18045

// What is the biggest number of outgoing routes any airport has?
g.V().hasLabel('airport').local(out('route').count()).max()

272

//minimum value - shortest runway
g.V().hasLabel('airport').values('longest').min()

1300
----

最近のバージョンのApache TinkerPop では、数値だけでなく、 'min' や 'max' ステップを使うこともできる。

NOTE: TinkerPop 3.4 がリリースされる前は、minとmax は数値に対してのみ使うことができた。今では、「比較可能」とみなされる値をテストすることもできるようになった。

TinkerPop 3.4 より前は、 'min' と 'max' を使う場合は、純粋に数値でしか使うことができなかった。今は、これらのステップを「比較可能である」とみなすことができる任意の値に適用することができる。なので、例えば、数値と同様に文字列も比較することができる。下記の例は、大陸の説明的な名前の最小値と最大値を探すものだ。

[source,groovy]
----
g.V().hasLabel('continent').values('desc').min()

Africa

g.V().hasLabel('continent').values('desc').max()

South America
----

TinkerPop 3.4 以前では、結果を並べ替えて、最初の結果を単に返すだけで同様の結果が得られた。

[source,groovy]
----
g.V().hasLabel('continent').values('desc').order().limit(1)

Africa

g.V().hasLabel('continent').values('desc').order().by(desc).limit(1)

South America
----

[[tranges]]
=== 値と、値の範囲をテストする

ある値が特定の範囲にあるかどうかをテストするいくつかの方法をすでに見てきた。Gremlin では範囲のテストに使うことのできる様々な述部が用意されている。下記のリストは利用可能な述部をサマリしたものだ。これらのそれぞれについては、本書を通して使われているのを見ていく。

.値や値の範囲をテストする述部
[cols="^1,4"]
|==============================================================================
|eq      | Equal to
|neq     | Not equal to
|gt      | Greater than 
|gte     | Greater than or equal to
|lt      | Less than
|lte     | Less than or equal to
|inside  | Inside a lower and upper bound, neither bound is included.
|outside | Outside a lower and upper bound, neither bound is included.
|between | Between two values inclusive/exclusive (upper bound is excluded)
|within  | Must match at least one of the values provided. Can be a range or a list
|without | Must not match any of the values provided. Can be a range or a list
|==============================================================================


下記のクエリはこれらの機能が様々な方法で使われているのを示している。まず最初は、 'gt' や 'gte' のような直接比較するステップの例である。 'fold' ステップは結果のすべてをリストにまとめるのに便利だ。

[source,groovy]
----
// Airports with at least 5 runways
g.V().has('runways',gte(5)).values('code','runways').fold()
----

これは、このクエリを実行して得られる出力である。

[source,groovy]
----
[ATL,5,BOS,6,DFW,7,IAH,5,ORD,8,DEN,6,DTW,6,YYZ,5,AMS,6,SNN,5,MKE,5,MDW,5,GIS,5,HLZ,5,NPE,5,NSN,5,PPQ,5,TRG,5,UFA,5,KRP,5]
----

次の3つのクエリは、 'lt' 、 'eq' そして 'neq'_が使われている例を示している。

[source,groovy]
----
// Airports with fewer than 3 runways
g.V().has('runways',lt(3)).values('code','runways').fold()

// How many airports have 3 runways?
g.V().has('runways',eq(3)).count()

// How many airports have anything but just 1 runway?
g.V().has('runways',neq(1)).count()
----

場合によっては、単純な 'has' ステップを使う場合など、 'eq' は実際には必要ないことがあることに注意してほしい。例えば、上記で使用したクエリは代わりに下記のように書ける。

[source,groovy]
----
g.V().has('runways',3).count()  
----

このクエリを 'is' ステップを使って書くこともできる。本書にも 'is' ステップが使われているものがたくさんあるが、ほとんどは、 'where' ステップと組み合わされている。私にとって、下記の使い方は、上記で使われた 'has' ステップの代替案ほどにはあまりエレガントには思えない。

[source,groovy]
----
// How many airports have 3 runways?
g.V().values('runways').is(3).count()
----

これが、 'inside' と 'outside' が使われる例だ。

[source,groovy]
----
// Airports with greater than 3 but fewer than 6 runways.
g.V().has('runways',inside(3,6)).values('code','runways')

// Airports with fewer than 3 or more than 6 runways.
g.V().has('runways',outside(3,6)).values('code','runways')
----

下記は、 'within' と 'without' が使われる例だ。

[source,groovy]
----
// Airports with at least 3 but not more than 6 runways 
g.V().has('runways',within(3..6)).values('code','runways').limit(15)

// Airports with 1,2 or 3 runways.
g.V().has('runways',within(1,2,3)).values('code','runways').limit(15)

// Airports with fewer than 3 or more than 6 runways.
g.V().has('runways',without(3..6)).values('code','runways').limit(15)
----

'between' ステップは、指定された値が、下限以上で上限未満であるかどうかをテストすることができる。下記のクエリは、滑走路が5,6,7本ある空港、言い換えると、滑走路が5本以上8本未満の空港を見つける。

[source,groovy]
----
// Airports with at least 5 runways but fewer than 8
g.V().has('runways',between(5,8)).values('code','runways').fold()
----

これがそのクエリを実行した結果である。

[source,groovy]
----
[ATL,5,BOS,6,DFW,7,IAH,5,DEN,6,DTW,6,YYZ,5,AMS,6,SNN,5,MKE,5,MDW,5,GIS,5,HLZ,5,NPE,5,NSN,5,PPQ,5,TRG,5,UFA,5,KRP,5]
----

構築している数多くのクエリと同様、同じ答えを得るにはいくつかの方法がある。下記のクエリはそれぞれ同じ結果を返す。どれを使うかは個人的な好みによるところがあるが、パフォーマンス上の理由により、クエリのある形式が、別の形式よりも優れている場合がある。

[source,groovy]
----
g.V().hasId(gt(0)).hasId(lte(46)).out().hasId(lte(46)).count()

g.V().hasId(within(1..46)).out().hasId(lte(46)).count()

g.V().hasId(within(1..46)).out().hasId(within(1L..46L)).count()

g.V().hasId(between(1,47)).out().hasId(lte(46)).count()

g.V().hasId(within(1..46)).out().hasId(between(1,47)).count()

g.V().hasId(inside(0,47)).out().hasId(lte(46)).count()
----

NOTE: 値は、数値である必要はない。例えば、文字列を比較することもできる。

さて、数値ではなく文字列を比較するクエリを見てみよう。下記のクエリは、米国のテキサス州にある全ての空港を見つけるが、空港のある都市の名前が 'Houston' でない場合に限り、そのコードを返す。

[source,groovy]
----
g.V().has('airport','region','US-TX').
      has('city',neq('Houston')).
      values('code')
----

この次のクエリはオースティンからラスベガスへの経路を見つけるのに使うことができる。 'within' ステップを使って、ダラス、サンアントニオあるいはヒューストンの空港で飛行機を乗り換える経路だけに返される結果を絞っている。

[source,groovy]
----
 g.V().has('airport','code','AUS').
       out().has('code',within('DFW','DAL','IAH','HOU','SAT')).
       out().has('code','LAS').path().by('code')
----

これがクエリが返したものだ。ダラスあるいはヒューストンで飛行機を乗り換えることができるようだが、サンアントニオを経由するものはない。

[source,groovy]
----
[AUS,DFW,LAS]
[AUS,IAH,LAS]
[AUS,DAL,LAS]
[AUS,HOU,LAS]
----

逆に、特定の空港を避けたい場合は、 'without' を代わりに使うことができる。このクエリは、再度オースティンからラスベガスへの経路を検索するが、フェニックス(PHX)あるいはロサンゼルス(LAX) を経由する経路は避ける。

[source,groovy]
----
 g.V().has('airport','code','AUS').
       out().has('code',without('PHX','LAX')).
       out().has('code','LAS').path().by('code')
----

最後に、オースティンでは今イングランドのロンドンへの直行便があるので、このクエリはwithin と without の両方を使って、以前のクエリを米国あるいはカナダ内の空港のみに修正している。ベガスに向かっているのであれば、そのような経路では行きたくないだろう。

[source,groovy]
----
g.V().has('airport','code','AUS').out().
      has('country',within('US','CA')).
      has('code',without('PHX','LAX')).out().
      has('code','LAS').path().by('code')
----

'within' と 'without' ステップは様々な入力タイプを取ることができる。例えば、これらのクエリはそれぞれ同じ結果になる。

[source,groovy]
----
// Range of values (inclusive, inclusive)
g.V().hasId(within(1..3))

// Explicit set of values
g.V().hasId(within(1,2,3))

// List of values
g.V().hasId(within([1,2,3]))
----

これらのタイプのクエリのさらなる例は次の2つのセクションにある。

[[startswith]]
==== between を使って、startsWith をシミュレートする

明らかでないかもしれないことの1つは、 'between' 述部で文字列の値を使う際、その値には、完全一致を指定する必要がないことだ。下記のクエリを見てみよう。これは、 '"Dal"' で始まる名前をもつ都市にある空港を検索し、 '"Dal"' と '"Dam"' の間の文字列を包括的/排他的な方法で探す。テスト対象となる文字列中の '"Dal"' に続く残りの文字は無視される。これは、大文字と小文字を区別する比較であることに注意してほしい。言い換えると、 '"Dal"' と '"dal"' はこのコンテキストでは異なる文字列である。

TIP: between 述部を使うと、文字列 startsWith メソッドをシミュレートできる

"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#fuzzyregs[正規表現を使ってあいまい検索を行う]"のセクションでさらに詳しく説明されているように、Gremlin は現在、正規表現を適用する方法、あるいは文字列に対する基本的なテキスト分析演算子さえもサポートしない。この 'between' 述部を使うことは、少なくとも、 'startsWith' タイプの演算子をシミュレートするために使うことができる。おそらく、将来のApache TinkerPop リリースでテキスト検索述部がサポートされると思われる。

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',between('Dal','Dam')).
      values('city')
----

これが、このクエリを実行した結果だ。ご覧の通り、すべての都市名が、 '"Dal"' の文字で始まっている。

[source,groovy]
----
Dallas
Dallas
Dalaman
Dalian
Dalcahue
Dalat
Dalanzadgad  
----

上記の結果から、 '"Dallas"' が2回出ていることがわかる。これは、都市名の空港が2つあるからである。クエリに 'dedup' ステップを追加して、一意に一致したものだけを返すことができる。

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',between('Dal','Dam')).
      values('city').dedup()
----

これが、修正した結果だ。

[source,groovy]
----
Dallas
Dalaman
Dalian
Dalcahue
Dalat
Dalanzadgad
----

これは、比較される値の範囲が少し広げられたさらに別の例だ。このクエリは、 '"Dal"' から '"Dar"' で始まる都市を検索する。

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',between('Dal','Dat')).
      values('city').order().dedup()
----

今回御覧の通り、より多くの都市が検索条件を満たした。

[source,groovy]
----
Dalaman
Dalanzadgad
Dalat
Dalcahue
Dalian
Dallas
Damascus
Dandong
Dangriga
Daocheng
Daqing Shi
Dar es Salaam
Daru
Darwin
----

一文字で始まる文字列を検索したい場合、下記のように実行できる。

[source,groovy]
----
g.V().has('airport','code',between('X','Xa')).
      values('code').fold()
----

クエリを実行すると、文字 '"X"' で始まるコードを持つすべての空港が返される。

[source,groovy]
----
[XNA,XMN,XRY,XIY,XUZ,XSB,XCH,XIL,XFN,XNN,XGR,XFW,XCR,XSC,XQP,XMH,XBJ,XAP,XMS,XKH,XIC,XTG,XKS,XBE,XTO]
----

Gremlinは現在、高度なテキスト検索機能はないが、JanusGraph のようなグラフシステムではそのような機能を持っている。これらの機能については、"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#janpred[追加のJanusGraph テキスト検索述部]" のセクションで説明されている。

[[winout]]
==== not, neq, within および without を使って飛行経路分析を改良する

前のセクションで見たように、クエリに値を具体的に含めたり外したりできると便利なことがある。上記のセクションで、 'within' や 'without' が使われたいくつかの例をすでに見てきた。下記の例は 'within' や 'without' を使った追加のクエリと、 'neq' (not equal) ステップと 'not' ステップを使って、特定の空港をクエリ結果から除外する例を示している。

次のクエリはAUSからSYDへの経由地が1か所のみの経路を検索するが、DFWを経由するルートはすべて無視する。

[source,groovy]
----
g.V().has('airport','code','AUS').
      out().has('code',neq('DFW')).
      out().has('code','SYD').path().by('code')
----

'not' を使ってクエリを書くこともできる。

[source,groovy]
----
g.V().has('airport','code','AUS').
      out().not(values('code').is('DFW')).
      out().has('code','SYD').path().by('code')
----

上記と同様ではあるが、LAXを外すために、 'and' 句を追加している。

[source,groovy]
----
g.V().has('airport','code','AUS').
      out().and(has('code',neq('DFW')),has('code',neq('LAX'))).
      out().has('code','SYD').path().by('code')
----

'and' を 'without' で置き換えるこの方法で以前のクエリを作成することもできる。このアプローチは非常に明白で、必要に応じて、 'without' テストに空港を追加するのは簡単だ。まもなく登場する"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#bool[ブール演算]" のセクションで、 'and' のようなステップについてさらに詳しく見ていく。

[source,groovy]
----
// Flights to Sydney avoiding DFW and LAX
g.V().has('airport','code','AUS').
      out().has('code',without('DFW','LAX')).
      out().has('code','SYD').path().by('code')
----

'without' を使うと、クエリから項目のリストを除外したい場合に特に便利だ。この次のクエリはサンアントニオから乗り換え1回でソルトレイクシティへの経路を検索するが、指定された空港のリストを通過する経路は除外する。

[source,groovy]
----
// How can I get from SAT to SLC but avoiding DFW,LAX,PHX and JFK ? 
g.V().has('airport','code','SAT').
      out().has('code',without('DFW','LAX','PHX','JFK')).
      out().has('code','SLC').path().by('code')

----

同様に、 'within' を使うと、*関心があるもの* のリストを具体的に指定できるようになる。下記のクエリでは再びSATからSLCへの乗り継ぎ1回の経路を確認するが、今回は指定された空港のうちの1つを経由する経路のみを返す。

[source,groovy]
----
// From AUS to SLC with a stop in any one of DFW,LAX,PHX or TUS
g.V().has('airport','code','SAT').
       out().has('code',within('DFW','LAX','PHX','TUS')).
       out().has('code','SLC').path().by('code')
----

これがクエリが返すものだ。

[source,groovy]
----
[SAT,LAX,SLC]
[SAT,DFW,SLC]
----

これは 'without' と 'within' を使って国に基づいた経路を検索するさらに2つの例だ。

[source,groovy]
----
// Flights from Austin to countries outside (without) the US and Canada
g.V().has('code','AUS').out().has('country',without('US','CA')).values('city')
----

これは、このクエリを実行した出力だ。

[source,groovy]
----
London
Frankfurt
Mexico City
Cancun
Guadalajara
----

これは、おーすてぃからの直行便で飛ぶことができるメキシコ、あるいはカナダの目的地を探す以前にクエリにひねったものだ。

[source,groovy]
----
// Flights from Austin to airports in (within) Mexico or Canada 
g.V().has('code','AUS').out().has('country',within('MX','CA')).values('city')
----

これは、新しいクエリから返されたものだ。

[source,groovy]
----
Toronto
Mexico City
Cancun
Guadalajara
----

==== coin とsample を使ってデータセットをサンプリングする

あらゆる種類の分析作業では、グラフに含まれるデータセットのサンプル、おそらく疑似ランダムサンプリングが得られると便利なことがしばしばある。 'coin' ステップはまさにこれができるものだ。これは、バイアスがかったコイントスをシミュレートする。 'coin' にトスのどの程度バイアスをかけるかを示す値を渡す。その値は、0から1の間を指定する。0は何かが選択されることはなく（役に立たない）、1はすべてが選択され（これも役に立たない）、0.5 はその要素が選ばれる可能性が50/50 であることを意味する。

下記のクエリは単純に50/50 コイントスで空港を選択し、最初に見つかった20の空港コードを返す。

[source,groovy]
----
// Pick 20 airports at random with an evenly biased coin (50% chance).
g.V().hasLabel('airport').coin(0.5).limit(20).values('code')
----

この次のクエリは、最初の似ているが、わずかに異なるアプローチをとる。グラフから頂点の疑似ランダムサンプリングを選択し、選択した頂点ごとにコードと標高を返す。今回は 'coin' のバイアスパラメータに0.05(あるいは成功確率5%) というとても小さい値が使われていることに注意してほしい。これには、グラフのすべての部分からまんべんなく少ない数の頂点のみが選択され、 'limit' ステップが不要になる、という効果がある。もちろん、このクエリで選択される空港の数は保証されない。

[source,groovy]
----
// Select some vertices at random and return them with their elevation.
g.V().hasLabel('airport').coin(0.05).values('code','elev').fold()
----

返された頂点の数を数えれば、 'coin' ステップがどれだけ公平に機能しているかがわかる。下記のクエリは常にグラフ中の空港の約半分を表すカウントを返すはずだ。

[source,groovy]
----
g.V().hasLabel('airport').coin(0.5).count()
----

coin の値の設定などを気にせず、ランダムに選択された20個の頂点が欲しい場合は、代わりに 'sample' ステップを使うとよい。

[source,groovy]
----
g.V().hasLabel('airport').sample(20).values('code')
----

==== Math.random を使って、よりランダムに、単一頂点を選ぶ

'sample' ステップで、1つ以上の頂点をランダムに選択することができるが、私がテストした限りでは、少なくとも TinkerGraph を使った場合、インデックスの値が低い頂点を優先する傾向がある。例えば、テストではこのクエリを1000回実行した。

[source,groovy]
----
g.V().hasLabel('airport').sample(1).id()
----

わかったことは、常に200未満のIDが返される、ということだ。これにより、 'sample(1)' の呼び出しはこれと同様のことが行われていると考えている。

[source,groovy]
----
g.V().hasLabel('airport').coin(0.01).limit(1)
----

下記のコードを見ていただきたい。この単純な実験を何度実行しても、常にこれと同じ結果が返される。

[source,groovy]
----
(1..10).each { println g.V().hasLabel('airport').sample(1).id().next()}

69
143
94
115
36
47
23
22
129
67
----

空港経路のグラフには3300以上の空港頂点があるので、グラフ内にあるすべての空港全体から任意の1つの空港をピックアップした結果が得られるクエリを考えたかった。Java Math クラスを使えば、考えられるすべての空港から1つの空港をランダムに選択するようなことを実行できる。下記のGroovy/Gremlin コードのスニペットを見てほしい。

NOTE: 変数を使って値を格納するさらなる例や、Gremlin で追加のGroovy クラスとメソッドを使うその他の方法については、"<<grv>>" や "<<varaus>>" のセクションを参照いただきたい。

[source,groovy]
----
// How many airports are there?
numAirports = g.V().hasLabel('airport').count().next()

3374

// Pick a random airport ID
x=Math.round(numAirports*Math.random()) as Integer

2359

// Get the code for our randomly selected airport
g.V(x).values('code')

PHO 
----

この簡単な実験は、 'Math.random' アプローチを使って生成された数値はすべての空港にまたがって広く分散しているように見えることを示している。

[source,groovy]
----
(1..10).each { println Math.round(numAirports*Math.random()) as Integer}

1514
18
3087
1292
3062
2772
2401
400
2084
3028
----

このアプローチはTinkerGraph にロードされた 'air-routes' グラフでのみ変更せずに機能することに注意してほしい。これは、TinkerGraph の実装がユーザが指定したIDを尊重し、 'air-routes' グラフでは、空港のIDが1から始まり、隙間なく連続していることがわかっているからだ。しかしながら、インデックスの値がシーケンシャルであることを知らなくても、このアプローチを簡単に修正して、ほかのグラフが機能させることができる。例えば、すべてのIDをリストに抽出し、そのリストから1つをランダムに選択することができる。

このランダム性の明らかな欠如は、TinkerGraph に特有であり、ユーザ指定のID値を尊重する事実に対し、他のグラフシステムはおそらくよりランダムな順序で、最初から頂点を保存している。実際、これらのクエリをJanusGraph で実行したら、 'sample' ステップにより、グラフ全体から空港を適切に選択することができた。

空港のIDがすべて順番に並んでいることがわかっていない場合、すべての空港IDのリストを作成し、 'Math.random' 手法を使えば、このようにして、ランダムに1つを選択することができる。

[source,groovy]
----
airports = g.V().hasLabel('airport').id().toList()

numAirports = airports.size

3374

x=Math.round(numAirports*Math.random()) as Integer 

859

g.V(airports[x-1])

v[859]

g.V(airports[x-1]).values('code')

OSR
----

[[textpredicates]]
=== TinkerPop 3.4 で追加された新しいテキスト検索述部

Apache TinkerPop バージョン 3.4 で、おそらく、あるいは最も期待されていた機能の1つは、よりフォーカスされたテキスト検索の実行を支援する新しい '”述部”' の追加だった。

TIP: テキスト述部の詳細については、Apache TinkerPop の公式ドキュメントにある: http://tinkerpop.apache.org/docs/current/reference/#a-note-on-predicates

全部で、6つの新しい述部がGremlin クエリ言語に追加された。テキストの文字列に1つ以上の文字が存在することを検索する3つの述部と、１つ以上の文字が存在しないことを検索する3つの述部がある。

.テキスト検索述部
[cols="^1,4"]
|==============================================================================
|startingWith     | Match text that starts with the given character(s)
|endingWith       | Match text that ends with the given charcter(s)
|containing       | Match text that contains the given character(s)
|notStartingWith  | Match text that does not start with the given character(s)  
|notEndingWith    | Match text that does not end with the given charcter(s)     
|notContaining    | Match text that does notcontain the given character(s)      
|==============================================================================

下記のセクションでは、各述部が使われている例を示す。各述部は大文字と小文字を区別するので、使うときはその点に注意いただきたい。大文字と小文字を区別しない検索を行うには、 'or' ステップを使って複数のステップを組み合わせて連鎖させることができる。

NOTE: これらの述部はすべて*_大文字と小文字を区別する_*。

これらの述部は、<<tranges>>セクションで取り上げた既存のGremlin 述部に追加される。

[[startingwith]]
==== startingWith

検索するテキストは1文字以上にすることができる。これは、大文字の"X"で始まる一意の都市名を探す簡単な例だ。

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',startingWith('X')).
      values('city')
----

期待した通り、実行すると、"X"で始まる名前のセットが返される。

[source,groovy]
----
Xiamen
Xianyang
Xuzhou
Xilinhot
Xiangfan
Xining
Xalapa
Xieng Khouang
Xiahe
Xiaguan
Xichang
Xingyi
Xinyuan
Xigaze
----

下記の例は、"Dal" で始まる名前の都市を探す。 'dedup' ステップは結果の中の重複する名前を除去するのに使われる。

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',startingWith('Dal')).
      values('city').
      dedup().
      fold()
----

実行すると、このクエリは期待通り、グラフにある"Dal"で始まるすべての都市名を見つける。

[source,groovy]
----
[Dalat, Dallas, Dalcahue, Dalaman, Dalian, Dalanzadgad]
----

前述したように、すべてのテキスト述部は大文字と小文字が区別される。"dal" という文字で始まる都市名を検索すると、マッチするものがなかった。下記のクエリはそれを示している。

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',startingWith('dal')).
      count()

0
----

述部では、大文字と小文字が区別されるので、例えば、Dal または dal の両方に一致するものを見つける必要がある場合は、下記にあるように、 'or' ステップと、2つの 'has' ステップを使う。

[source,groovy]
----
g.V().hasLabel('airport').
      or(has('city',startingWith('dal')),
         has('city',startingWith('Dal'))).
      dedup().by('city').
      count()

6
----

[[endingwith]]
==== endingWith

下記の例は、"zhi" の文字で終わる都市名を探す。

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',endingWith('zhi')).
      values('city')

Changzhi
----

[[containing]]
==== containing

名前に、1文字以上の特定の文字列が含まれている都市を探すこともできる。下記の例では、名前に"gzh"という文字列が含まれている都市を探す。

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',containing('gzh')).
      values('city')
----

このクエリを実行すると、下記の結果が得られる。

[source,groovy]
----
Guangzhou
Hangzhou
Zhengzhou
Changzhi
Changzhou
Yongzhou
Yangzho
----

[[notStartingWith]]
==== notStartingWith

テキスト述部それぞれに、逆のステップがある。 'notStartingWith' 述部を使うと、"Dal"で始まらない都市名を探すことができる。

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',notStartingWith('Dal')).
      count()

3367
----

上記の例は下記に示すように、 'startingWith' 述部を否定した場合に得られるのと同じ結果を返す。

[source,groovy]
----
g.V().hasLabel('airport').
      not(has('city',startingWith('Dal'))).
      count()

3367
----


[[notEndingWith]]
==== notEndingWith

'notEndingWith' を使うと、名前が、"zhi"で終わらない都市を簡単に見つけることができる。

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',notEndingWith('zhi')).
      count()

3373
----


[[notContaining]]
==== notContaining

下記のクエリは、名前に文字列 "berg" を含まない都市の数をカウントする。

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',notContaining('berg')).
      count()

3370
----

ここで、もう少し面白いことをやってみよう。下記のクエリは 'notContaining' と 'containing' 述部を使って、英語で一般的に使われる基本的な小文字の母音を含まないが、二次母音を含む名前の都市を見つけるためにいくつかの has ステップを繋げたものだ。

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',notContaining('e')).
      has('city',notContaining('a')).
      has('city',notContaining('i')).
      has('city',notContaining('u')).
      has('city',notContaining('o')).
      or(has('city',containing('y')),
         has('city',containing('h'))).
      values('city').
      dedup()
----

結果が2件だけ見つかった。結果の1つには、母音が含まれているが、大文字の”O"なので、指定された制約により許されていることに注意してほしい。

[source,groovy]
----
Osh
Kyzyl
----

[[sort]]
=== 並べ替え - order を導入する

'order' を使うと、昇順（デフォルト）あるいは降順に並べ借ることができる。ソートはクエリの最後のステップである必要がないことに注意してほしい。さらに次のステップに進む前にクエリの途中でソートしても全く問題じゃない。これの例が下記の最初の2つのクエリだ。最初のクエリは 'limit' ステップの配置により、２つめのクエリとは異なる結果を返すことに注意してほしい。 'fold' をクエリの最後に使って、結果をすべてリストに集めている。 'fold' ステップはこれ以上のこともできる。これは、map-reduce 操作のreduce 部分を実行することができる。"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#mapreduce[foldを使って単純なMap-Reduce処理を行う] のセクションなど、本書の他のところで、さらにいくつかの例が挙げられている。

[source,groovy]
----
// Sort the first 20 airports returned in ascending order
g.V().hasLabel('airport').limit(20).values('code').order().fold()

[ANC,ATL,AUS,BNA,BOS,BWI,DCA,DFW,FLL,IAD,IAH,JFK,LAX,LGA,MCO,MIA,MSP,ORD,PBI,PHX]
----

上記と同様だが、今回は 'limit' ステップを 'order' ステップの後で実行している。

[source,groovy]
----
// Sort all of the airports in the graph by their code and then return the first 20
g.V().hasLabel('airport').order().by('code').limit(20).values('code').fold()

[AAE,AAL,AAN,AAQ,AAR,AAT,AAX,AAY,ABA,ABB,ABD,ABE,ABI,ABJ,ABL,ABM,ABQ,ABR,ABS,ABT]
----

これは前の2つと同様の例である。オースティン(AUS)から飛行機で行くことができるすべての場所を見つけて、空港の IATAコードを使って以前と同じようにソートを行うが、今回は各空港のICAO コードも結果セットに含めている。

[source,groovy]
----
g.V().has('code','AUS').out().order().by('code').
                        values('code','icao').fold()
----

このクエリを実行した結果はこの通り。

[source,groovy]
----
[ABQ,KABQ,ATL,KATL,BKG,KBBG,BNA,KBNA,BOS,KBOS,BWI,KBWI,CLE,KCLE,CLT,KCLT,CUN,MMUN,CVG,KCVG,DAL,KDAL,DCA,KDCA,DEN,KDEN,DFW,KDFW,DTW,KDTW,ELP,KELP,EWR,KEWR,FLL,KFLL,FRA,EDDF,GDL,MMGL,HOU,KHOU,HRL,KHRL,IAD,KIAD,IAH,KIAH,IND,KIND,JFK,KJFK,LAS,KLAS,LAX,KLAX,LBB,KLBB,LGB,KLGB,LHR,EGLL,MCI,KMCI,MCO,KMCO,MDW,KMDW,MEM,KMEM,MEX,MMMX,MIA,KMIA,MSP,KMSP,MSY,KMSY,OAK,KOAK,ORD,KORD,PDX,KPDX,PHL,KPHL,PHX,KPHX,PIE,KPIE,PIT,KPIT,PNS,KPNS,RDU,KRDU,SAN,KSAN,SEA,KSEA,SFB,KSFB,SFO,KSFO,SJC,KSJC,SLC,KSLC,SNA,KSNA,STL,KSTL,TPA,KTPA,VPS,KVPS,YYZ,CYYZ]
----

デフォルトでは、 'order' を使って実行されたソートは結果を昇順で返す。代わりに結果を降順で得るには、byモジュレータを使って 'desc' を指定する。同様に、 'asc' を使えば、昇順のソートが必要であることを明示的に指定することができる。

[source,groovy]
----
// Sort the first 20 airports returned in descending order
g.V().hasLabel('airport').limit(20).values('code').order().by(desc).fold()

[PHX,PBI,ORD,MSP,MIA,MCO,LGA,LAX,JFK,IAH,IAD,FLL,DFW,DCA,BWI,BOS,BNA,AUS,ATL,ANC]
----

'shuffle' を使ってランダムな順序で並べ替えることもできる。下記の例とそれが生成する出力を見てみよう。

[source,groovy]
----
g.V().hasLabel('airport').limit(20).values('code').order().by(shuffle).fold()

[MCO,LGA,BWI,IAD,ATL,BOS,DCA,BNA,IAH,DFW,MIA,MSP,ANC,AUS,JFK,ORD,PBI,FLL,LAX,PHX]
----

下記は、 'longest' でソートしたいフィールドを並べ替えの方向 'desc' を1つの 'by' 命令に組み合わせた例だ。

[source,groovy]
----
// List the 10 airports with the longest runways in decreasing order.
g.V().hasLabel('airport').order().by('longest',desc).valueMap().
      select('code','longest').limit(10)
----

これは、このクエリを実行した出力だ。スペースを節約するために結果を2カラムに分割してある。

[source,groovy]
----
[code:[BPX],longest:[18045]]    [code:[DOH],longest:[15912]]
[code:[RKZ],longest:[16404]]    [code:[GOQ],longest:[15748]]
[code:[ULY],longest:[16404]]    [code:[HRE],longest:[15502]]
[code:[UTN],longest:[16076]]    [code:[FIH],longest:[15420]]
[code:[DEN],longest:[16000]]    [code:[ZIA],longest:[15092]]
----

グラフで最長の滑走路を見つけるために以前に使ったクエリをコード化した別の方法を見てみよう。すでにご存じだと思うが、我々は下記のクエリを使った。このクエリは実際に最長の滑走路をグラフから見つけるが、どの空港にその長さの滑走路があるかを知りたいのであれば、2つ目のクエリを実行してそれらを見つける必要がある。

[source,groovy]
----
g.V().hasLabel('airport').values('longest').max()
----

これで、ソートする方法がわかったので、少し複雑なクエリを書いてすべての空港を最長の滑走路を降順にソートして、最初の空港の 'valueMap' を返す。このクエリはおそらくもっと効率的に書くことができ、複数の空港に最長の滑走路がある場合を処理するように改善されるかもしれないが、 'order' を使って関心のある空港を見つけるよい例を提供する

[source,groovy]
----
g.V().hasLabel('airport').order().by(values('longest'),desc).limit(1).valueMap()
----

'air-routes' グラフの場合、最長の滑走路がある空港は1つだけだ。中国の都市バンダにあるその滑走路の長さは18,045フィートだ。その滑走路がそれほど長い理由は海抜14,219フィートにあるその空港の標高によるものだ。航空機はその高度で安全に運行するにはさらに長い滑走路が必要になるのである。

[source,groovy]
----
[country:[CN], code:[BPX], longest:[18045], city:[Bangda], elev:[14219], icao:[ZUBD], lon:[97.1082992553711], type:[airport], region:[CN-54], runways:[1], lat:[30.5536003112793], desc:[Qamdo Bangda Airport]]
----


[[sortkeyvalue]]
==== キー、あるいは値でソートする

クエリの結果が1つ以上のキーと値のペアのセットである場合、キーもしくは値のいづれかで昇順あるいは降順でソートする必要がある場合がある。Gremlin にはこれらの場合にソートを制御する方法が用意されている。これがどのように機能するかの例を下記に示す。

NOTE: TinkerPop 3.3 で構文が変更された。以前のキーワード、valueDecr, valueIncr, keyDecrそしてkeyIncr は現在は、by(keys,asc) あるいは by( values, desc) などの形式で指定するようになった。

下記の例は、 'order' を使ってクエリを実行する場合と使わずに実行する場合の違いを示していて、 'group' ステップで作成されたマップのキーを使ってソートされる。

[source,groovy]
----
// Query but do not order
g.V().hasLabel('airport').limit(5).group().by('code').by('runways')

[BNA:[4],ANC:[3],BOS:[6],ATL:[5],AUS:[2]]
----

どのように 'local' が 'order' のパラメータとして使われるかについてにも注目してほしい。これは最終的なリストが作成される間にソートが行われるようにするために必要とされる。 'local' が指定されないと、その時点で単一のエンティティとして扱われる結果全体に適用されるので、 'order' は効果がない。

[source,groovy]
----
// Query and order by airport code (the key)
g.V().hasLabel('airport').limit(5).
      group().by('code').by('runways').
      order(local).by(keys,asc)

[ANC:[3],ATL:[5],AUS:[2],BNA:[4],BOS:[6]]
----

この例では、滑走路の数をキーフィールドとして降順にソートする。

[source,groovy]
----
g.V().hasLabel('airport').limit(10).
      group().by('runways').by('code').
      order(local).by(keys,desc)

[7:[DFW],6:[BOS],5:[ATL],4:[BNA,IAD],3:[ANC,BWI,DCA],2:[AUS,FLL]]
----

[[orderchanges]]
==== TinkerPop リリース 3.3.4 で導入された並べ替えの変更

2018年10月15日に、Apache TinkerPop 3.3.4 リリースの一部として変更が導入された。この変更は 'order' ステップで認識される、 'incr' や 'decr' のキーワードが非推奨となり、当時としては新しい、 'asc' と 'desc' のキーワードが推奨された。本書とそれに付随するサンプルコードは 'asc' や 'desc' のみを使うように更新済みである。使っているデータベースが、Apache TinkerPop 3.3.4 レベル以上のバージョンがサポートされているのであれば、新しいキーワードを使うべきだ。

NOTE: Order.incr や Order.decr の列挙子は、TinkerPop 3.3.4 リリースで非推奨になり、Order.ascや Order.desc が推奨となった。これはキーワードをほかの一般的に使われるクエリ言語と合わせるために行われた。

これらの変更により、クエリがどのような影響を受けるか見てみよう。下記のクエリは、イングランドにある最も発経路がある10個の空港を検索し、その結果を降順にソートする。TinkerPop 3.3.4 以前では、このクエリは下記のように記述された。

[source,groovy]
----
g.V().has('airport','region','GB-ENG').
      order().by(out().count(),decr).limit(10).
      project('a','b').by('code').by(out().count())
----

このクエリを実行すると下記の結果が生成される。

[source,groovy]
----
[a:LGW,b:200]
[a:LHR,b:191]
[a:STN,b:186]
[a:MAN,b:182]
[a:BHX,b:109]
[a:LTN,b:104]
[a:BRS,b:84]
[a:EMA,b:64]
[a:LBA,b:62]
[a:LPL,b:60]
----

3.3.4 リリースで導入された新しいキーワードを使うと、クエリは下記に示したように書くことができる。

[source,groovy]
----
g.V().has('airport','region','GB-ENG').
      order().by(out().count(),desc).limit(10).
      project('a','b').by('code').by(out().count())
----

生成された結果は、想定の通り、前と同じだ。

[source,groovy]
----
[a:LGW,b:200]
[a:LHR,b:191]
[a:STN,b:186]
[a:MAN,b:182]
[a:BHX,b:109]
[a:LTN,b:104]
[a:BRS,b:84]
[a:EMA,b:64]
[a:LBA,b:62]
[a:LPL,b:60]
----

完全を期すために、同じクエリだが、元の 'incr' キーワードと、新しく導入された 'asc' キーワードの両方を使って昇順でソートされたものを見てみよう。 'incr' を使ったのと同じく、 'asc' を指定しても 'desc' を指定してもこれはデフォルトの動作のままだ。

[source,groovy]
----
g.V().has('airport','region','GB-ENG').
      order().by(out().count(),incr).limit(10).
      project('a','b').by('code').by(out().count())
----

今回のクエリでは、商用航空のルートが最も少ない空港が見つかった。

[source,groovy]
----
[a:CVT,b:0]
[a:GLO,b:1]
[a:LEQ,b:1]
[a:BZZ,b:1]
[a:MME,b:2]
[a:ISC,b:3]
[a:HUY,b:6]
[a:BLK,b:9]
[a:NQY,b:11]
[a:DSA,b:15]
----

下記のクエリでは、新しい 'asc' キーワードを使うように修正されている。

[source,groovy]
----
g.V().has('airport','region','GB-ENG').
      order().by(out().count(),asc).limit(10).
      project('a','b').by('code').by(out().count())
----

生成される結果は前のと同じだ。

[source,groovy]
----
[a:CVT,b:0]
[a:GLO,b:1]
[a:LEQ,b:1]
[a:BZZ,b:1]
[a:MME,b:2]
[a:ISC,b:3]
[a:HUY,b:6]
[a:BLK,b:9]
[a:NQY,b:11]
[a:DSA,b:15]
----

TinkerPop 3.3.4 がリリースされたとき、これらは重大な変更ではなかった。より多くのグラフデータベースエンジンがTinkerPop 3.5.0 レベルに移行すると、これらは重大な変更になり、 'asc' と 'desc' を使う必要がある。あなたのコードやほかのクエリが将来にわたって利用可能であるために、データベースがまだTinkerPop3.5.0 レベルになっていない場合でも、できるだけ早くコードにこれらの変更を行うことをお勧めする。


[[bool]]
=== ブール演算

Gremlin ではブール(true/false) 型クエリを作るために利用可能な 'and' 、 'or' や 'not' などの論理演算子のセットが利用できる。多くの場合、例えば 'within' を使って 'or' を避けることができ、 'without' を使うことで 'not' を回避できることがあるが、これらの演算子が存在することは知っておくとよい。 'and' 演算子は 'has' ステップをつなげることで回避できる場合がある。とはいっても、これらのブール演算のステップを使えることが非常に役に立つ場合が常にある。

[source,groovy]
----
// Simple example of doing a Boolean AND operation
g.V().and(has('code','AUS'),has('icao','KAUS'))

// Simple example of doing a Boolean OR operation
g.V().or(has('code','AUS'),has('icao','KDFW'))
----

2つのトラバーサルの 'and' を取りたい場合に限り、次のように 'and' を挿入する形で使うこともできる。

[source,groovy]
----
g.V().has('code','AUS').and().has('icao','KAUS')
----

ご想像のとおり、 'or' ステップは3つ以上の選択肢をもつことができる。この例が下記に4つある。また、実際には、このクエリでは、 'within' を使ってよりよいアプローチをとることができるが、これは より大きな 'or' 式の例として十分であることに注意してほしい。

[source,groovy]
----
g.V().hasLabel('airport').or(has('region','US-TX'),
                             has('region','US-LA'),
                             has('region','US-AZ'),
                             has('region','US-OK')).
                           order().by('region',asc).
                           valueMap().select('code','region')
----

'within' を使うと、上記の例は下記のように書くことができるので、 'or' を使うことが指定されたクエリに使うのに常にベストのアプローチであるとは限らないことに注意してほしい。次のセクションでは、 'within' と 'without' ステップを詳しく見ていく。

[source,groovy]
----
g.V().hasLabel('airport').has('region',within('US-TX','US-LA','US-AZ','US-OK')).
                          order().by('region',asc).
                          valueMap().select('code','region')
----

この次の例では、 'and' ステップを1つ使って、少なくとも12,000フィートの長さの滑走路をもつテキサス州の空港を検索する。

[source,groovy]
----
g.V().hasLabel('airport').and(has('region','US-TX'),has('longest',gte(12000))).values('code')
----

'or' ステップと同様、 'and' を使う必要は必ずしもない。前のクエリはこのように書き換えることができる。

[source,groovy]
----
g.V().has('region','US-TX').has('longest',gte(12000))
----

Gremlin では 期待通りに機能する 'not' ステップも用意されている。このクエリは空港ではない頂点を見つける。

[source,groovy]
----
g.V().not(hasLabel('airport')).count()
----

この前のクエリはこのように書くこともできる。

[source,groovy]
----
g.V().has(label,neq('airport')).count()
----

TIP: グラフのモデルとクエリ自体に従って、ブールステップを使うことが理にかなっている場合とそうでない場合がある。上述のように、連鎖したhasステップのほうが効率的な場合や、 'within' や 'without' のようなステップを使ったほうが理にかなっている場合がある。

下記の例に示すように、 'and' のようなブールステップはドッドで組み合わせることもできる。このクエリは、94以上100未満の発経路をもつすべての空港を検索し、空港コードと経路数でグループ化して返す。この場合、 'and' がテスト全体の包含ステップではなくドットを使って 'and' ステップが 'lt' ステップに追加されることに注目してほしい。このクエリを実行した結果も下記に示す。

[source,groovy]
----
g.V().hasLabel('airport').
      where(out().count().is(lt(100).and(gt(94)))).
      group().by('code').by(out().count())

[BUD:98,STR:95,NCE:97,AUH:97,WAW:98,CRL:95]  
----

これまで見てきたクエリもまた下記のように書くこともできるが、この場合、（上記のように）ドットを組み合わせて 'and' ステップをインラインで使うと、よりきれいになると思う。ご覧のとおり、前のと同じ結果が得られる。

[source,groovy]
----
g.V().hasLabel('airport').where(and(out().count().is(lt(100)),
                out().count().is(gt(94)))).
                group().by('code').by(out().count())

[BUD:98,STR:95,NCE:97,AUH:97,WAW:98,CRL:95]
----

すでに何度か指摘してきたように、同じ結果を生成するクエリを作成する方法はたくさんある。これは、前の2つのクエリを 'and' ステップの代わりに 'between' ステップを使うように書き換えた例だ。注意しておいてほしいのは、 'between' は～以上～未満を表すので、上限として101を、下限として95を指定する必要がある。

[source,groovy]
----
g.V().hasLabel('airport').where(out().count().is(between(95,101))).
                          group().by('code').by(out().count())

[BUD:98,STR:95,NCE:97,AUH:97,WAW:98,CRL:95]
----

楽しみのために、これは、同じクエリだが、 'inside' ステップを使うように書き直されている。

[source,groovy]
----
g.V().hasLabel('airport').where(out().count().is(inside(94,100))).
                          group().by('code').by(out().count())

[BUD:98,STR:95,NCE:97,AUH:97,WAW:98,CRL:95]]
----

ちなみに、空港がコードではなく、カウントでグループ化されるようにグループ化を逆にしたい場合は、下記のようにすることができる。

[source,groovy]
----
g.V().hasLabel('airport').
      where(out().count().is(lt(100).and(gt(94)))).
      group().by(out().count()).by('code')

[97:[NCE,AUH],98:[BUD,WAW],95:[STR,CRL]]
----

下記に示すように、クエリにインラインな 'and' ステップをさらに追加することもできる。今回のAUH や NCE は新しい 'and' テストで除外された97件の経路があるので、結果セットの一部ではないことに注意してほしい。

[source,groovy]
----
g.V().hasLabel('airport').
      where(out().count().is(lt(100).and(gt(94)).and(neq(97)))).
      group().by(out().count()).by('code')

[98:[BUD,WAW],95:[STR,CRL]]
----

上記の例では、 'where' ステップがよく使われている。願わくは、これを使った効果は明らかだ。それでも、次のセクションで、 'where' ステップがどのように機能するかをより詳しく説明する。

[[where]]
=== where を使って結果から除外する

これまでの例の中で使われた 'where' ステップはすでに見てきた。本セクションでは、 'where' ステップにもう少しフォーカスを当ててみていく。 'where' ステップは 'filter' の一例だ。トラバーサルの今の状態を取得し、指定された制約にマッチするものだけが後続ステップに渡されるようにする。 'where' は、単独で使われたり、後で説明するように、 'by' モジュレータと組み合わせて使うことも、後続の 'match' や 'choose' ステップと組み合わせて使うこともできる。

TIP: whereを使ったクエリの中には、代わりに hasを使って書くことができるものもある。

'has' や 'where' を使って同じ結果が得られる簡単な例を見ていくことにしよう。

[source,groovy]
----
// Find airports with more than five runways
g.V().has('runways',gt(5))

// Find airports with more than five runways
g.V().where(values('runways').is(gt(5)))
----

上記のような例では、両方のクエリで全く同じ結果が得られるが、そのような場合、 'has' ステップより単純ですっきりしているように感じられる。 'where' ステップのバージョンでは、 'gt' 述部を 'is' ステップの内側に置く必要があることに注意してほしい。次の例は 'where' ステップの本当の力を見せ始めている。 'where' ステップの内側に、フィルタリングを行うトラバーサルを含めることができる。この場合、まずすべての空港の頂点を検索し、次に 'where' ステップを使って60を超える発経路がある空港のみを保持する。最後に、そのような空港がいくつ見つかったかを数える。

[source,groovy]
----
// Airports with more than 60 unique routes from them
g.V().hasLabel('airport').where(out('route').count().is(gt(60))).count()

179
----

次の例では、IDが47未満で、4000マイルを超える空港間の経路を検索する。繰り返すが、 'where' 式の先頭に、 'inV' への参照を置くことにより着頂点のIDをどのように参照できるかに注意してほしい。 'where' ステップは 'and' ステップの内側に配置されているので、エッジの 'dist' プロパティも調べることができる。最後に、クエリの結果としてパスを返す。

[source,groovy]
----
// Routes longer than 4,000 miles between airports with and ID less than 47
g.V().hasId(lt(47)).outE().
      and(where(inV().id().is(lt(47))),values('dist').is(gt(4000))).
      inV().path().by('code').by('dist')
----

下記は、クエリを実行した結果として返されたものだ。

[source,groovy]
----
[ATL,4502,HNL]
[JFK,4970,HNL]
[ORD,4230,HNL]
[EWR,4950,HNL]
[HNL,4502,ATL]
[HNL,4970,JFK]
[HNL,4230,ORD]
[HNL,4950,EWR]
----

'where'ステップの逆条件にマッチする結果を探したいことがある。これを実現する方法の1つは、下記に示すように、 'where' ステップを 'not' ステップの内側にラップすることだ。

NOTE: 'in'ステップの前の二重アンダースコアプレフィクス '"+++__.+++"'が必要になるのは、'in'がGroovy の予約語だからだ。Gremlin コンソールを使っていてプレフィクスを含めないとエラーになる。これについては、少し後の、"<<rword>>"のセクションでより詳しく説明されている。'"+++__.+++"' の表記は実際には '"+++__+++"'（二重アンダースコア）  という名前の特別な TinkerPop の Java クラスへの参照だが、  当面は気にしないでいただきたい。実際、今のところ、'"+++__+++."'について、"前のステップの結果"を意味するものとして考えてみてほしい。これはGremlin クエリを発行する Javaプログラムを書き始めると重要になるので、これについては、少し後ほどの"<<tpinterfaces>>"のセクションで説明する。

クエリはオースティン空港(AUS)を見つけることから始まり、すべての発ルートを見つける。次にすべての着'contains'エッジを調べて、各空港に飛ぶことができる国を調べる。'not'ステップにより、米国の国コード 、'US'を持たない空港のみが選択される。

[source,groovy]
----
g.V().has('airport','code','AUS').
      out().not(where(__.in('contains').has('code','US'))).
      valueMap('code','city')
----

ご覧の通り、このクエリを実行すると、米国外の宛先のみが返される。

[source,groovy]
----
[code:[YYZ],city:[Toronto]]
[code:[LHR],city:[London]]
[code:[FRA],city:[Frankfurt]]
[code:[MEX],city:[Mexico City]]
[code:[CUN],city:[Cancun]]
[code:[GDL],city:[Guadalajara]]
----

このパターンは、'where'ステップの内側でトラバーサルを使って、結果を無効にしたい場合に役に立つ。もちろん、この特定のクエリのほかの書き方もあるが、この手法が使われている例をお見せしたい。完全を期すために、このクエリを'where'を全く使わないで書く2つの単純な方法を下記に示すが、'not'と'where'を組み合わせるのが最良の選択肢である場合もある。

[source,groovy]
----
g.V().has('airport','code','AUS').
      out().has('country', neq('US')).valueMap('code','city')

g.V().has('airport','code','AUS').
      out().not(has('country', 'US')).valueMap('code','city')
----

'where'ステップで使う場合に'and'と'or'ステップの特別な形式を使うことも可能だ。下記のクエリを見ていただきたい。これは、4本以上の滑走路があり、但し6本ではない、オースティン(AUS)から飛ぶことができる空港とマッチする。

[source,groovy]
----
g.V().has('airport','code','AUS').out().
      where(values('runways').is(gt(4).and(neq(6)))).
      valueMap('code','runways')
----

これが、クエリが返すものだ。ご覧のとおり、AUSから飛ぶことができる、5本、7本、8本の滑走路がある空港だけが見つかった。

[source,groovy]
----
[code:[YYZ],runways:[5]]
[code:[MDW],runways:[5]]
[code:[ATL],runways:[5]]
[code:[DFW],runways:[7]]
[code:[IAH],runways:[5]]
[code:[ORD],runways:[8]]
----

同じことが 'or'ステップにも当てはまる。クエリを書きなおして、オースティンから飛ぶことができる、6本以上、あるいは正確に4本の滑走路がある空港を見つけることができる。

[source,groovy]
----
g.V().has('airport','code','AUS').out().
      where(values('runways').is(gt(6).or(eq(4)))).
      valueMap('code','runways')
----

上記は、下記のクエリの短いバージョンであり、'where'ステップ内で、ブール演算子を使う別の方法を示している。この場合、ブール演算子（この場合は、'or'ステップ）を使って比較できるトラバーサルは、2つだけだ。

[source,groovy]
----
g.V().has('airport','code','AUS').out().
      where(values('runways').is(gt(6)).or().values('runways').is(4)).
      valueMap('code','runways')
----

本セクションの最後の例では、'where'ステップを使って経由地1か所の航空経路を見る際にスタート地点に戻らないようにしている。オースティンで始まり、途中経路地が1か所でその後別の空港に向かう経路を見つけるが、オースティンには戻らない。'limit'ステップはこの条件にマッチする最初の10件のみを返すために使われる。'as'ステップを使ってAUS空港をラベルを付けて、後の'where'ステップで参照できるようにしている点に注意してほしい。このクエリの効果は、AUS->DFW->AUS のような経路は返されないが、AUS->DFW->LHR はオースティンに戻っていないので返される。

[source,groovy]
----
// List 10 places you can fly to with one stop, starting at Austin but 
// never ending up back in Austin

g.V().has('airport','code','AUS').as('a').
      out().out().where(neq('a')).
      path().by('code').limit(10)
----

Gremlin を使っていると、'where'ステップを頻繁に使っていることに気づくだろう。本書の残りを通して、'where'が使われているさらに多くの例を見ることになる。次のセクションでは、'where'を使用できるさらに追加の方法について見ていく。

[[whereby]]
==== where と by を使って結果をフィルタリングする

TinkerPop 3.2.4 リリースに新しい機能が追加され、'where'ステップの後に'by'モジュレータを使えるようになった。これにより、特定の種類のクエリを以前よりもはるかに簡単に書けるようになった。あわよくば、この機能は多くのTinkerPop をサポートするグラフストアでサポートされるが、クエリの設計を開始する前に、サポートされているTinkerPop のバージョンを確認することをお勧めする。

下記のクエリは、オースティン空港から始まり、そこから飛ぶことができるすべての空港を検索する。'where by'ステップを使って結果をフィルタリングして、オースティンと同じ数の滑走路をもつ空港のみに結果をフィルタリングしている。これの本当にいいところは、クエリによって処理されるので、オースティン自体にいくつの滑走路があるかを事前に知る必要がないことだ。

[source,groovy]
----
 g.V().has('code','AUS').as('a').out().
       where(eq('a')).by('runways').valueMap('code','runways')
----

TIP: where と by ステップを組み合わせると、強力なクエリを素晴らしくシンプルな方法で書くことができる。

Gremlin コンソールでクエリを実行した場合、これらは表示されるはずの結果だ。返されたすべての空港には2本の滑走路がある点に注意してほしい。これはオースティン空港の滑走路と同じ数だ。

[source,groovy]
----
[code:[LHR],runways:[2]]
[code:[MEX],runways:[2]]
[code:[CUN],runways:[2]]
[code:[GDL],runways:[2]]
[code:[PNS],runways:[2]]
[code:[VPS],runways:[2]]
[code:[FLL],runways:[2]]
[code:[SNA],runways:[2]]
[code:[MSY],runways:[2]]
----

'where'と'by'ステップを組み合わせることができるので、下記に示すようなより複雑な方法で前のクエリを書く必要がなくなる。

[source,groovy]
----
g.V().has('code','AUS').as('a').out().as('b').
      filter(select('a','b').by('runways').where('a',eq('b'))).
      valueMap('code','runways')
----

上記で使われていることに気づいたかもしれないが、'where'ステップには2つのパラメータの形式もある。この場合、最初のパラメータは、クエリ中の先で定義されたラベルを参照する。下記の例を見ていただきたい。オースティン(AUS)空港の頂点を検索して、'+++'+++a+++'+++'にラベル付けしている。次に、そこから飛ぶことができるすべての空港を参照し、それらに'+++'+++b+++'+++'というラベルを付けている。そして、__where__ステップを使って、'+++'+++a+++'+++'と'+++'+++b+++'+++'を比較する。オースティンより滑走路が少ない空港のみが返されるはずだ。

[source,groovy]
----
g.V().has('airport','code','AUS').as('a').out().as('b').
      where('a',gt('b')).by('runways').valueMap('code','runways')
----

オースティンには2本の滑走路があるので、実行時にこのクエリによって返されるのは、滑走路が1本しかない空港のみだ。

[source,groovy]
----
[code:[BKG],runways:[1]]
[code:[SAN],runways:[1]]
----

2番目の'by'モジュレータを追加することで、2つの異なるプロパティを比較することもできる。これは、頂点プロパティに異なるキー名があるが、同じ値が含まれるかもしれないようなときに便利だ。下記のクエリは、わざわざ考案されたもので、同じことをもっと簡単な方法で実現できるが、2つの'by'モジュレータが使われているのを示している。空港頂点の'country'プロパティは'country'頂点の'code'プロパティと比較される。クエリはまず、文字列'London'を含む'city'プロパティをもつ空港頂点を見つける。次に、接続している'country'頂点（接続されているものにはエッジも含まれる）が見つかる。'where'テストでは、2つの頂点の国コードの値が比較される。最後に、'select'が使われ、返したい結果を選ぶ。

[source,groovy]
----
g.V().has('airport','city','London').as('a','r').
      in('contains').as('b').
      where('a',eq('b')).by('country').by('code').
      select('a','r','b').by('code').by('region')
----

クエリを実行すると、都市名が'London'で、地域コードと国コードがついたすべての空港が返される。

[source,groovy]
----
[a:LHR,r:GB-ENG,b:UK]
[a:LGW,r:GB-ENG,b:UK]
[a:LCY,r:GB-ENG,b:UK]
[a:STN,r:GB-ENG,b:UK]
[a:LTN,r:GB-ENG,b:UK]
[a:YXU,r:CA-ON,b:CA]
----

前述したように、上記のクエリは単なる例として使った。実際には、この場合、 'where' ステップを使わない下記のクエリで十分だ。

[source,groovy]
----
g.V().has('airport','city','London').
      valueMap('code','region','country')

[country:[UK],code:[LHR],region:[GB-ENG]]
[country:[UK],code:[LGW],region:[GB-ENG]]
[country:[UK],code:[LCY],region:[GB-ENG]]
[country:[UK],code:[STN],region:[GB-ENG]]
[country:[UK],code:[LTN],region:[GB-ENG]]
[country:[CA],code:[YXU],region:[CA-ON]]
----

フランスのニース空港と同じ地域コードをもつすべての空港を検索するクエリが書きたいと想像してみてほしい。ここでは、リージョンコードがわからないので、その地域にあるすべての空港を検索する単純なクエリを書くことはできないと仮定しよう。したがって、代わりに、最初にニースの地域コードを検索して、次にその地域コードを使ってその地域にある他の空港を検索するクエリを書く必要がある。最後に、空港コードを都市名や地域コードと一緒に返したい。このクエリを書く方法の1つは、'where...by'構文を使うことだ。

下記のクエリとそれが生成する出力を見てほしい。

[source,groovy]
----
g.V().has('code','NCE').values('region').as('r').
  V().hasLabel('airport').as('a').values('region').
      where(eq('r')).by().
      local(select('a').values('city','code','region').fold())

[NCE,Nice,FR-U]
[MRS,Marseille,FR-U]
[TLN,Toulon/Le Palyvestre,FR-U]
[AVN,Avignon/Caumont,FR-U]
----

TIP: サンプルプログラムのフォルダには、Java プログラムで上記のクエリを実行する方法を示す GraphRegion.java というプログラムがある。

このクエリには興味深い点がいくつかある。まず、2つの 'values'ステップの結果を比較しているので、プロパティキーを渡す必要がないので、'by'ステップにパラメータを渡していない。次に、クエリで2つ目の'V()' ステップを使って、ニースと同じ空港コードをもつすべての空港を検索している。これはニースも結果に含まれていることを意味している点に注意してほしい。最後に'local'ステップで必要な形式でクエリの出力を準備する部分をラップして、空港ごとに個別のリストが作成されるようにしている。

このクエリを、おそらく'match'ステップを使って、ほかの方法で書くことができるが、一度上記で使われているパターンを理解すると、かなり単純で非常に強力だ。

[[choose]]
=== choose を使って if...then...else 型のクエリを書く

'choose'ステップを使うと、ほとんどのプログラミング言語でみられる "if then else" 構造によく似たクエリを作成することができる。Java でプログラミングしているのであれば、下記のようなものを書いていることに気づくかもしれない。

[source,groovy]
----
if (longest > 12000)
{
  return(code);
}
else
{
  return(desc);
}
----

Gremlin では同じことをする方法が用意されている。下記のクエリはテキサスにあるすべての空港を検索して、空港に12,000フィートより長い滑走路があれば、'code'プロパティの値を返す、さもなければ、'desc'の値を返す。

[source,groovy]
----
// If an airport has a runway > 12,000 feet return its code else return its description
g.V().has('region','US-TX').
      choose(values('longest').is(gt(12000)),
             values('code'),
             values('desc')).
      limit(5)
----

実行すると、返される結果は下記のようになる。

[source,groovy]
----
AUS
DFW
IAH
San Antonio
Houston Hobby
----

'choose'ステップの "else" 部分が指定されていなければ、単純な "if"文としてふるまう。

[source,groovy]
----
g.V().has('region','US-TX').
      choose(values('longest').is(gt(12000)),
             values('code')).
             limit(5)

----

この場合、"else" は暗黙的に示され、'choose'ステップが受け取る入力要素は、下記のように渡される。

[source,groovy]
----
AUS
DFW
IAH
v[33]
v[38]
----

これは、同じ構造を使った別の例だ。

[source,groovy]
----
// If an airport has a code of AUS or DFW report its region else report its country
g.V().hasLabel('airport').
      choose(values('code').is(within('AUS','DFW')),
             values('city'),
             values('region')).
     limit(5)
----


[[chooseconstant]]
==== 定数値を含める - constant の導入

下記の例が示すように、クエリの一部として、導出された値ではなく、定数値を返すととても便利なことがある。このクエリは、空港が4本未満の滑走路しかない場合に文字列"some" を、4本以上の滑走路がある場合に"lots" を返す。

[source,groovy]
----
// You can also return constants using the constant() step
g.V().hasLabel('airport').limit(10).
      choose(values('runways').is(lt(4)),
             constant('some'),
             constant('lots'))
----

TIP: constant ステップはクエリの一部として定数値を返すために使うことができる。

これは、'sample'ステップを1つ使って、10件の空港を選択し、その空港に、50件以上の経路があるかどうかに従って"lots"か"not so many" かを返すもう一つの例だ。

[source,groovy]
----
g.V().hasLabel('airport').sample(10).as('a').
      choose(out('route').count().is(gt(50)),
             constant('lots'),
             constant('not so many')).as('b').
      select('a','b').by('code').by()
----

これが、このクエリの実行からの出力がどのようになるかの例だ。

[source,groovy]
----
[a:YYT,b:not so many]
[a:YEG,b:not so many]
[a:LGA,b:lots]
[a:DXB,b:lots]
[a:BLR,b:not so many]
[a:CGN,b:lots]
[a:BOM,b:lots]
[a:SIN,b:lots]
[a:TSF,b:not so many]
[a:HKG,b:lots]
----

下記のように、'select(values)'をクエリの最後に追加することで結果の一部としてキー、a:と b: が返されないように したいのであれば、さらに1ステップ実行する。

[source,groovy]
----
g.V().hasLabel('airport').sample(10).as('a').
      choose(out('route').count().is(gt(50)),
             constant('lots'),
             constant('not so many')).as('b').
      select('a','b').by('code').by().select(values) 
----

これが、修正した形式のクエリから出力されたものだ。

[source,groovy]
----
[YYT,not so many]
[YEG,not so many]
[LGA,lots]
[DXB,lots]
[BLR,not so many]
[CGN,lots]
[BOM,lots]
[SIN,lots]
[TSF,not so many]
[HKG,lots]
----

'constant'ステップは、'choose'ステップ内での使用に制限されない。必要に応じてどこででも使うことができる。これを使った多くの例が、"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#union[ユニオンを使ってクエリ結果を組み合わせる]" のセクションを含め本書を通して見つかるだろう。

[[option]]
=== option を使って case/switch 型のクエリを書く

'option'を'choose'と組み合わせると結果はほとんどのプログラミング言語に見られる'case'や'switch'型の構造に似たものになる。例えば Java では　switch 文はこのようにコーディングすると思う。

[source,java]
----
  switch(airport)
  {
    case "DFW": System.out.println(desc); break;
    case "AUS": System.out.println(region); break;
    case "LAX": System.out.println(runways);
  }
----

Java の switch 文と同じパターンに従う Gremlin クエリを書くことができる。Java の例のように、読みやすさと明確さを補うために、クエリを複数行にまたがってレイアウトすることにした。

[source,groovy]
----
// You can combine choose and option to generate a more "case statement" like query
g.V().hasLabel('airport').
      choose(values('code')).
        option('DFW',values('desc')).
        option('AUS',values('region')).
        option('LAX',values('runways'))

----

下記の例は、'choose'の後に4つのオプションが続いていることを示している。'none'のデフォルトケースはcatchall として使われていること、この場合、返される値は定数であることに注意してほしい。

[source,groovy]
----
// You can return constant values if you need to
g.V().hasLabel('airport').limit(10).
      choose(values('runways')).
        option(1,constant('just one')).
        option(2,constant('a couple')).
        option(7,constant('lots')).
        option(none,constant('quite a few'))

----

Apache TinkerPop 3.4.3 リリース以降、'option'ステップには述部を含めることができるようになった。素晴らしい改善により、'option'ステップ内でさらに比較ができるようになった。これにより、'option'ステップの一部としてより複雑なクエリを書くことなく、たとえば、ある値が別の値より大きいか小さいかをテストできるようになった。

NOTE: TinkerPop 3.4.3 リリースでは、option ステップに述部を含めることができる機能が追加された。

この新しい機能を使うと、よりシンプルな構文を使ってクエリを書くことができる。下記のクエリは'choose'と'option'ステップによって生成されたカテゴリのうちの１つに分類される空港の数を含んだグループを生成する。標高5000フィートを超える空港は”high"、3000フィートを超える空港には "medium" を、その他の空港にはすべて"low"に分類される。

[source,groovy]
----
g.V().hasLabel('airport').
      groupCount().
        by(choose(values('elev')).
             option(gt(5000),constant('high')).
             option(gt(3000),constant('medium')).
             option(none,constant('low')))

[high:157,low:3013,medium:204]   
----

3.4.3 より前の TinkerPop のリリースでは、このクエリは書かれていたかもしれないが、ネストされた'choose'ステップを使う必要があった。

[source,groovy]
----
g.V().hasLabel('airport').
      groupCount().
        by(choose(values('elev').is(gt(5000)),
             constant('high'),
             choose(values('elev').is(gt(3000)),
               constant('medium'),
               constant('low'))))

[high:157,low:3013,medium:204]   
----

[[patmatch]]
=== match を使ってパターンマッチを行う

'match'ステップは TinkerPop 3 で追加され、Gremlinを使って、より宣言的なスタイルのパターンベースのクエリを表現できるようになった。'match'をマスターするのは少し難しいかもしれないが、一度理解できると、特定のパターンを探してグラフをトラバースするのに非常に強力な手法になる。しかしながら、これからお見せするように、'match'でサポートされるのと同様のパターンを表現するのに使うにはwhere ステップで十分な場合がある。

下記は、'match'を使って、ある空港から別の空港へのフライトはあるが、元の空港への戻りのフライトがないという航空経路のパターンを検索する例だ。最初のクエリで、出発点としてJFK空港を含むそのようなパターンを探す。その下に、このクエリを実行して得られた出力がある。これは、現時点では、正解であり、ブリティッシュエアウェイズのエアバス A318 のロンドンシティ(LCY) 空港からのフライトはダブリン(DUB)を経由し、JFKに向かう途中で燃料の補給を行うが、帰りは、追い風のため、経由する必要はない。
   
[source,groovy]
----
// Find any cases of where you can fly from JFK non stop 
// to a place you cannot get back from non stop. This query
// should return LCY, as the return flight stops in Dublin
// to refuel.

g.V().has('code','JFK').
      match(__.as('s').out().as('d'),
            __.not(__.as('d').out().as('s'))).
      select('s','d').by('code')

[s:JFK,d:LCY]
----

出発点がJFKに特定してたのを解除することで、このクエリを拡張し、グラフ内の任意の場所でのこのパターンを探してみよう。これは本当に、'match' Gremlin ステップがどれだけ重要で便利かを示し始めている。何が見つかるかはわからないが、'match'を使うことで探しているふるまいのパターンを記述することができ、あとはGremlin がやってくれる。

[source,groovy]
----
// Same as above but from any airport in the graph.
g.V().hasLabel('airport').
      match(__.as('s').out().as('d'),
            __.not(__.as('d').out().as('s'))).
      select('s','d').by('code')
----

このクエリを実行すると、実態にはグラフ内に、この状況が当てはまる場所が200以上あることがわかる。クエリの最後に'count'を追加して、いくつあるかを確認してみよう。

[source,groovy]
----
// How many occurrences of the pattern in the graph are there?
g.V().hasLabel('airport').
      match(__.as('s').out().as('d'),
            __.not(__.as('d').out().as('s'))).
      count()

238
----

次のクエリは、パターン A->B->C に従うが、A->C の形の直行便がない経路を探す。つまり、直行便の代替手段がない、１つの経由地がある２つの空港間のすべての経路を検索する。このクエリは、元の空港に戻る経路も除外することに注意してほしい。開始したところに戻らないという要件を実現するために、A→B→Aの形の経路とマッチしないようにするための'where'ステップが含まれている。

[source,groovy]
----
g.V().hasLabel('airport').
      match(__.as('a').out().as('b')
           ,__.as('b').out().where(neq('a')).as('c')
           ,__.not(__.as('a').out().as('c'))).
      select('a','b','c').by('code').limit(10)

----

もちろん、'air-routes'グラフにはこのパターンが見つかる場所がたくさんある。クエリを実行して得られる結果のいくつかの例がこれだ。

[source,groovy]
----
[a:ATL,b:MLB,c:ISP]
[a:ATL,b:MLB,c:BIM]
[a:ATL,b:MLB,c:YTZ]
[a:ATL,b:PHF,c:SFB]
[a:ATL,b:SBN,c:SFB]
[a:ATL,b:SBN,c:AZA]
[a:ATL,b:SBN,c:PIE]
[a:ATL,b:SBN,c:PGD]
[a:ATL,b:TRI,c:SFB]
[a:ATL,b:TRI,c:PIE]
----

これは、'match'を'where'と一緒に使う別の例だ。これは実際には前に出てきたクエリを書く別の方法だ。このクエリはオースティンにある滑走路の数を調べることから始め、次にそれらの空港にある滑走路の数を調べる。オースティンと同じ数の空港のみが返される。このタスクに'match'ステップを使うのはやりすぎだ。しかしながら、これは'match'ステップで使われる基本的な構造を示していて、同じクエリでクエリの一部で計算された値を使う方法も示している。

[source,groovy]
----
g.V().has('code','AUS').
      match(__.as('aus').values('runways').as('ausr'),
            __.as('aus').out('route').as('outa').values('runways').as('outr')
              .where('ausr',eq('outr'))).
      select('outa').valueMap().select('code','runways')                           
----

前述したように、上記の例はこのクエリを書く最善の方法ではなく、下記の3つの例にあるように、'match'ステップを全く使わずに、'where'ステップだけで書くことができる。それぞれは前述のものより単純だ。

このクエリを書くために選択できる１つの方法は、複数のselect ステップを使うことだ。これもあまり効率的な解決策ではないが、機能する。

[source,groovy]
----
g.V().has('code','AUS').as('aus').values('runways').as('ausr').
      select('aus').out().as('outa').values('runways').as('outr').
      where('ausr',eq('outr')).
      select('outa').valueMap().select('code','runways')
----

前の2つのいづれよりもよい方法は、'filter'ステップと'where'ステップ、'select'ステップを組み合わせたものだ。

[source,groovy]
----
g.V().has('code','AUS').as('a').out().as('b').
      filter(select('a','b').by('runways').where('a',eq('b'))).
      valueMap('code','runways')
----

”https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#whereby[where と by を使って結果をフィルタリングする]" のセクションで述べたように、このクエリは'where'ステップと、'by'モジュレータを使えばさらに単純にできる。この機能はTinkerPop 3.2.4 リリースで導入された。

[source,groovy]
----
g.V().has('code','AUS').as('a').out().
       where(eq('a')).by('runways').
       valueMap('code','runways')
----

したがって、'match'ステップを使うのを避けるクエリを書く簡単な方法がしばしばあるが、一部のクエリ、特により複雑な場合、満たす必要のある一連の条件をより宣言的な方法で表現するための便利で強力な方法がある。しかしながら、'match'ステップを使う前に、私は常に、より単純なクエリを作れないか別の方法について慎重に検討する。これは、'match'ステップの構文は私の経験上、かなりの試行錯誤なしに正しく理解するのが難しい場合があるからだ。

[[patternwhere]]
==== where ステップを使ったパターンマッチング

Gremlin 言語が進化するにつれて、'match'ステップの完全な候補と思われる多くのクエリは、実際には'where'ステップを使って書かれるが、それでもより宣言的なスタイルで記述することができる。下記に示すように、前のセクションの帰りのフライトがないJFKからの経路を検索する'where'ステップを使ったクエリを書き換えることができる。

'match'ステップの場合と同様に、これを読み取る方法は、下記の通り。JFK から始めて、飛ぶことができるすべての場所を見つけよう。但しJFKに戻る経路がない空港だけを残すこと。このクエリでは、'as'ステップが2つの役割を果たすことに注意してほしい。'where'ステップの外では後で参照するクエリのステップにラベルを付けるために使われる。'where'ステップの内側では、出発した空港に戻るための便利な方法を提供する。

[source,groovy]
----
g.V().has('code','JFK').as('s').
      out().as('d').
      where(__.not(out().as('s'))).
      select('s','d').by('code')

[s:JFK,d:LCY]
----

前の例でいくつか見たように、結果には空港コードだけあればよく、"s"と"d"のキーが不要なのであれば、'select'ステップを追加するだけでよい。

[source,groovy]
----
g.V().has('code','JFK').as('s').
      out().as('d').
      where(__.not(out().as('s'))).
      select('s','d').by('code').
      select(values)

[JFK,LCY]   
----

クエリを拡張すると、グラフ全体でこの同じパターンを検索できるようになる。下記の例は、復路便がない場所にある最初の10件の経路を返す。この結果は、発空港コードを使って昇順でソートされる。

[source,groovy]
----
g.V().hasLabel('airport').as('s').
      out().as('d').
      where(__.not(out().as('s'))).
      limit(10).
      select('s','d').by('code').
      order().by(select('s'))
----

このクエリを実行すると下記の結果が返る。

[source,groovy]
----
[s:AMS,d:HRE]
[s:AMS,d:FNA]
[s:AMS,d:UIO]
[s:BNE,d:BCI]
[s:BNE,d:BKQ]
[s:BOM,d:DIU]
[s:HEL,d:IVL]
[s:HPN,d:HYA]
[s:JFK,d:LCY]
[s:MAN,d:ANU]
----

[[union]]
=== union を使ってクエリ結果を組み合わせる

'union'ステップは、その名前から期待される通りに機能する。これを使うと、クエリの一部を1つの結果にまとめることができる。ブール演算の'and'や'or'ステップと同様、'union'を使わずに同じことを行う違ったやり方を見つけることが可能な場合もあるが、非常に便利な機能がいくつかある。

これは、'union'ステップを使って、頂点とその頂点からの射出経路の数を含むリストを生成する簡単な例である。次のセクションでは、'union'ステップを使いつつもこのクエリを書くためのより簡単な方法があることに注意してほしい。この例から取り除く主なポイントは、'union'ステップを使って複数のトラバーサル結果を組み合わせることができる、ということだ。この例は2つのトラバーサルの結果を組み合わせたものだが、必要に応じてさらに組み合わせることができる。'out'ステップは、'union'ステップの直前に見つかった（この場合はDFWの頂点）から開始することに注意してほしい。つまり、前のステップの出力は、すでに見てきた他の Gremlin ステップと同様、'union'ステップの内側のステップに利用可能である。

[source,groovy]
----
g.V().has('airport','code','DFW').as('a').
      union(select('a'),out().count()).fold()

[v[8],221]
----

これが、おすすめというわけではないが、前のクエリは下記のように1つの'union'ステップの内側で2つの 'has'ステップを使って書くこともできる。しかしながら、これは、'union'ステップを使って、かなり任意のグラフトラバーサルの結果を組み合わせることができることを示している。

[source,groovy]
----
g.V().union(has('airport','code','DFW'),
            has('airport','code','DFW').
               out().count()).fold()

[v[8],221]
----

ちなみに、'union'ステップを使ってリストを生成する代わりに、'group'ステップを使ってマップを生成すると決める場合もある。マップは個々のキーと値に直接アクセスしたいのであれば、適している場合もある。それはすべて、常に、解決しようとしている問題に最も適した結果に依存する。

[source,groovy]
----
g.V().has('airport','code','DFW').
      group().by().by(out().count())

[v[8]:221]]
----

[[unionidentity]]
==== identity ステップを導入する

Gremlin にはこれまで本書では使われていない'identity'ステップが用意されている。'identity'ステップは、単にトラバーサルの今のステップに前のステップから渡されたエンティティ（この場合は、'union') を返すだけだ。上記で使ったクエリを'identity'ステップを使うように書き換えることができる。これにより、'as'や'select'ステップを使う必要がなくなるので、クエリが単純化される。下記に示すように、'identity'を使うと、前の'has'ステップから渡されたDFW空港を表す頂点'V[8]'が結果に含められる。

[source,groovy]
----
g.V().has('airport','code','DFW').
      union(identity(),out().count()).fold()

[v[8],221]
----

クエリを少し変更して、結果の最初の部分が単なる頂点ではなく、空港のIATAコードが返るようにすることができる。

[source,groovy]
----
g.V().has('airport','code','DFW').
      union(identity().values('code'),out().count()).fold()

[DFW,221]
----


[[unionconstant]]
==== union の一部として定数値を使う

"<<chooseconstant>>"で使われている'constant'ステップはすでに見てきた。想像の通り、下記の2つの例にあるように、'constant'ステップは、'union'ステップ内で使うこともできる。

[source,groovy]
----
g.V(3).union(constant("Hello"),
             constant("There")).fold()

[Hello,There]
----

上記で導入したばかりの'identity'ステップを使うと、'V[3]'頂点を結果に追加できる。現在、3つのトラバーサルステップを'union'ステップ内で組み合わせている。

[source,groovy]
----
g.V(3).union(constant("Hello"),
             constant("There"),
             identity()).fold()

[Hello,There,v[3]]
----

最後に、再度クエリを変更して、都市名を結果に含めてみよう。'values'ステップが'union'ステップの直前に参照された頂点のプロパティを参照しているので、頂点 'V[3]'の'city'プロパティを返していることに注意いただきたい。

[source,groovy]
----
g.V(3).union(constant("Hello"),
             constant("There"),
             values('city')).fold()

[Hello,There,Austin]
----

[[unionmore]]
==== union ステップのさらなる例

下記のクエリは、'sample'ステップを使って、グラフから10件の空港をランダムに選んでいる。選択された空港はそれぞれに対し、'union' ステップを使って、頂点の'id'といくつかのプロパティを組み合わせている。'local'スコープが使われているので、各'union'ステップの結果は、リストに格納されることに注意してほしい。

[source,groovy]
----
g.V().hasLabel("airport").sample(10).
      local(union(id(),values("code","city")).fold())
----

これが、クエリを実行して得られた出力である。

[source,groovy]
----
[83,RSW,Fort Myers]
[97,GLA,Glasgow]
[26,SAN,San Diego]
[57,MEL,Melbourne]
[136,MEX,Mexico City]
[163,YHZ,Halifax]
[44,SAF,Santa Fe]
[42,OAK,Oakland]
[92,OSL,Oslo]
[161,IST,Istanbul] 
----

'local'スコープが使われなかったら、結果は下記に示すように、全ての結果を含んだ単一のリストになる。

[source,groovy]
----
g.V().hasLabel("airport").sample(10).
      union(id(),values("code","city")).fold()

[84,MAN,Manchester,87,CGN,Cologne,35,EWR,Newark,37,HNL,Honolulu,54,NRT,Tokyo,86,YEG,Edmonton,45,PHL,Philadelphia,52,FRA,Frankfurt,85,YUL,Montreal,142,SOF,Sofia]
----

別の簡単な例として、下記のクエリは、UKからAUSに到着するフライト、あるいはAUを出発してMexico に到着するフライトを返す。

[source,groovy]
----
// Flights to AUS from the UK or from AUS to Mexico
g.V().has('code','AUS').
      union(__.in().has('country','UK'),
            out().has('country','MX')).
            path().by('code')
----

このクエリを実行すると、下記の結果が得られる。これは、UKにあるLHR からメキシコにある3つの空港、MEX, CUN, GDLへの経路があることを示している。

[source,groovy]
----
[AUS,LHR]
[AUS,MEX]
[AUS,CUN]
[AUS,GDL]
----

このクエリは、「イングランドのロンドンを出発し、経由地なく、パリ、あるいはベルリンに到着するすべての経路を検索する」という問題を解決する。空港コードではなく、都市名が使われているので、各都市の全ての空港が考えられる。

[source,groovy]
----
g.V().has('city','London').has('region','GB-ENG').
         union(out('route').has('city','Paris'),
               out('route').has('city','Berlin')).
               path().by('code')
----

これは、クエリを実行した結果である。5つの異なるロンドンの空港が見つかったことに注意してほしい。

[source,groovy]
----
[LHR,CDG]
[LHR,ORY]
[LHR,TXL]
[LGW,CDG]
[LGW,SXF]
[LCY,CDG]
[LCY,ORY]
[STN,TXL]
[STN,SXF]
[LTN,CDG]
[LTN,SXF]
----

前述したように、特に非常に簡単なクエリの場合、'union'を使わない別の代替手段がある場合がある。実際、前の結果を得るために'union'ステップを使う必要はない。下記のクエリのリライトバージョンは'union'ステップを使ったバージョンと同じ結果を返す。今回は、代わりに'within'述部を内在した単純な'has'ステップを使う。

[source,groovy]
----
g.V().has('city','London').has('region','GB-ENG').
      out('route').has('city',within('Berlin','Paris')).
      path().by('code')
----

前の2つのクエリは'path'ステップを使って、基本的に個々の経路を表示した。'union'ステップを使ったクエリのバージョンを少し調整して、代わりに結果を、最初の項目が出発地の空港でリストの残りの項目がそこから飛ぶことができる条件にマッチした場所であるような一連のリストに変換するすることができる。二重のアンダースコア '"__"' は、'identity'を使って入力頂点を参照するために使われている。'union'ステップは、'local'ステップ内にラップされているので、各'union'は、個々にfoldされる。'local'ステップがなければ、全ての結果が1つのリストに格納される。この場合、'union'ステップによりクエリを書くのが比較的簡単になり、これはおそらくは'union'ステップが使われるべき良い例である。つまり、複数のトラバーサル結果を組み合わせたい場合だ。

[source,groovy]
----
g.V().has('city','London').has('region','GB-ENG').
      local(union(__.values('code'),
                  out('route').has('city','Paris').values('code'),
                  out('route').has('city','Berlin').values('code')).
      fold())
----

修正されたクエリを実行ｓるうと、おそらくより便利な形式で表示される。

[source,groovy]
----
[LHR,ORY,CDG,TXL]
[LGW,CDG,SXF]
[LCY,ORY,CDG]
[STN,TXL,SXF]
[LTN,CDG,SXF]
----


[[unionthree]]
==== union を使ってより複雑なトラバーサル結果を組み合わせる

これまで見てきた例は、ほとんどの場合、'union'ステップ内で使われる、かなり単純なトラバーサルを示している。この次のクエリは、少し興味深いものだ。再度ロンドンのどこかの空港を出発するが、下記のいづれかの条件を満たす経路を探したい。

* ベルリンに行き、次にリスボンに行く
* パリに行き、次にバルセロナに行く
* エジンバラに行き、次にローマに行く

また、それぞれの場合に距離も返したい。必要な数の項目で'union'を使うことができる点に注意してほしい。この例では、3セットのトラバーサル結果を組み合わせて、目的の結果を取得している。

[source,groovy]
----
// Returns any paths found along with the distances between airport pairs.

g.V().has('city','London').has('region','GB-ENG').
      union(outE().inV().has('city','Berlin').
                   outE('route').inV().has('city','Lisbon').  
                   path().by('code').by('dist').by('code').by('dist'),
            outE().inV().has('city','Paris').
                   outE('route').inV().has('city','Barcelona').
                   path().by('code').by('dist').by('code').by('dist'),
            outE().inV().has('city','Edinburgh').
                   outE('route').inV().has('city','Rome').
                   path().by('code').by('dist').by('code').by('dist'))                                
----

クエリを実行すると、下記のようになる。

[source,groovy]
----
[LHR,227,ORY,513,BCN]
[LHR,216,CDG,533,BCN]
[LGW,591,SXF,1432,LIS]
[LGW,191,CDG,533,BCN]
[LCY,227,ORY,513,BCN]
[STN,563,SXF,1432,LIS]
[LTN,589,SXF,1432,LIS]
[LTN,236,CDG,533,BCN]  
----

次のクエリは、マドリッドにある任意の空港から任意の場所にある任意の空港までの全ての経路の合計の距離を検索し、同じ計算を実行するが、パリの空港に到着するルートを差し引いたものだ。下記で使われている'filter'ステップについては、まだ説明していない。これは、'where'など他の多くのステップの基礎となるGremlin ステップだ。'filter'ステップはクエリ内の'filter'内で指定された条件を満たす受信要素だけを次のステップへ渡す。

[source,groovy]
----
g.V().has('city','Madrid').outE('route').
      union(values('dist').sum(),
            filter(inV().has('city',neq('Paris'))).values('dist').sum())
----

これは、クエリを実行した出力である。ごらんのとおり、最初の数字は2つ目よりも若干大きい。というのも、パリを含む全てのルートが計算から除外されているからである。

[source,groovy]
----
397708
396410
----

unionステップ内のすべてのトラバーサルが結果を返す必要はない点に注意いただきたい。返される結果には、なにかしらを返すトラバーサルが含まれる。下記の例は、これを示したものである。もちろん、実際には、この特別なクエリをこのように書くことはないだろう。しかしながら、この例は理解すべき'union'ステップの機能を示していると思う。

[source,groovy]
----
g.V().has('airport','code','AUS').
      union(out().has('code','LHR'),
            out().has('code','SYD'),
            out().has('code','DFW')).
      values('code')
----

クエリを実行すると、オースティンとシドニー間に経路がないので、SYD は結果には含まれないことがわかる。

[source,groovy]
----
LHR
DFW
----

完全を期すために、このクエリは'union'を使うのではなく、下記のように書かれるだろう。

[source,groovy]
----
g.V().has('airport','code','AUS').
      out().has('code',within('LHR','DFW','SYD')).
      values('code')

LHR
DFW
----

[[sideeffect]]
=== sideEffect を使って副作用を起こす

'sideEffect'ステップを使うと、クエリの次のステージに渡される内容に変更を加えずに、クエリの一部として処理を追加することができる。下記の例では、空港の頂点 V(3) を見つけ、次に、'sideEffect'を使ってそこから飛べる場所の数をカウントし、それを名前が'a'というトラバーサル変数に格納してから、経由1回で到達できる場所の数をカウントする。その値を'b'に格納する。このクエリを作成する方法は他にもあるが、'sideEffect'がどのように機能するかを非常によく示していることに注意していただきたい。

[source,groovy]
----
g.V(3).sideEffect(out().count().store('a')).
       out().out().count().as('b').select('a','b')

[a:[59],b:5911]
----

本書の後半で、クロージャと呼ばれることもあるlambda関数とその使い方について説明する。下記の例は、クロージャを'sideEffect'と組み合わせて、見つかった頂点に関する情報を表示する前にメッセージを出力する。'sideEffect'ステップが後続のステップにどのように影響を及ぼさないかに再度注意してほしい。クエリの下に生成された出力を確認できる。

[source,groovy]
----
g.V().has('code','SFO').sideEffect{println "I'm working on it"}.values('desc')

I'm working on it
San Francisco International Airport
----

本書の後半で、副作用を使ってより興味深い問題を解決する別の方法について説明する。

[[aggregate]]
=== aggregate を使って、一時的なコレクションを生成する

本書を執筆している時点では、おーすてぃから直接（ノンストップで）飛ぶことができる場所は59か所あった。この事実は、次のクエリを使って確認できる。

[source,groovy]
----
g.V().has('code','AUS').out().count()

59
----

オースティンから1回の経由で行くことができる場所の数をカウントしたい場合、下記のクエリを使うことができる。'dedup'ステップが使われるのは、そこにあるすべての場所にたどり着くための様々な方法ではなく、移動できる一意な場所の数だけを知りたいためだ。

[source,groovy]
----
g.V().has('code','AUS').out().out().dedup().count()

871
----

しかしながら、このクエリには問題がある。871 箇所の場所には、オースティンから直行できる場所（の一部あるいはすべて）が含まれている。我々が本当に見つけたいのは、オースティンから経由1回でのみ行くことができるすべての場所だ。なので、必要なのは、それらの場所をすべて覚えて、871 から何らかの方法で削除することだ。ここで、'aggregate'が役に立つ。下記の変更されたクエリを見てみよう。

[source,groovy]
----
g.V().has('code','AUS').out().aggregate('nonstop').
     out().where(without('nonstop')).dedup().count()

812
----

最初の'out'ステップの後、見つかったすべての頂点は'nonstop'と呼ぶことにしたコレクションに格納される。次に、2つ目の'out'の後、基本的に「nonstopコレクションに入っていない頂点のみを保持する」という'where'ステップを追加できる。まだ'dedup'ステップを実行する。さもないと、残りの空港の多くを複数回カウントすることになる。

812は、ノンストップで行くことができる場所が全て2番目のクエリから削除されたことを示している前のクエリで返される871 の数値よりも正確に59少ない点に注意してほしい。これはまた、オースティンから他のどこからもいけない場所へのフライトがないことを示している。
少し後の、"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#collrev[増補版コレクション]"のセクションで、Gremlin クエリの一部として使うことができる様々なタイプのコレクションについて詳しく見ていく。


[[inject]]
=== inject を使って、クエリに値を挿入する

クエリの結果と一緒に返されるものを何か追加したい場合があるだろう。これは、'inject'ステップを使えば可能になる。まず、'inject'が基本的にどのように機能するかを示す簡単な例がある。いくつかの数値を挿入し、Gremlin に平均値を出すように求めている。

[source,groovy]
----
g.inject(1,2,3,4,5).mean()

3.0
----

もちろん、単純な算術演算を行うために'inject'を使うだけは用途が限られる。次の例はクエリの一部としてどのように'inject'が使えるのかを示している。オースティンバーグストローム国際空港を指す際に一般的に使われる別の省略形である文字列 ABIA がクエリに挿入される。

[source,groovy]
----
g.V().has('code','AUS').values().inject('ABIA')
----

クエリを実行すると、このようなものが返される。

[source,groovy]
----
ABIA
US
AUS
12250
Austin
542
KAUS
-97.6698989868164
airport
US-TX
2
30.1944999694824
Austin Bergstrom International Airport
----

[[injecttrick]]
==== inject を使った便利なトリック

'inject'を使ってできる便利なトリックが他にもある。下記のクエリを見てほしい。

[source,groovy]
----

g.V().choose(V().hasLabel('XYZ').count().is(0),constant("None found"))
----

これを実行すると、下記のような複数行が返ってくる。実際には、グラフ中の頂点ごとに1つずつ。

[source,groovy]
----
None found
None found
None found
None found
None found
...
----

結果を1つだけ取得するために、下記に示すようにクエリを書きたくなるだろう。

[source,groovy]
----
g.choose(V().hasLabel('XYZ').count().is(0),constant("None found"))
----

しかしながら、トラバーサルソースオブジェクト (g) の直後に、chooseステップがすぐに実行できないので、これはエラーが返される。これを回避するために、'g'の後に'inject'ステップを使って書き換えることができる。クエリでは'inject'の値を使わないが存在することにより'choose'ステップの後に続くことができる。

[source,groovy]
----
g.inject(1).choose(V().hasLabel('XYZ').count().is(0),constant("None found"))

None found
----

これは時々役に立つことがあるトリックだ。この点を示すために使われたクエリは、実査に'choose'を使わずに書き換えることができるが、'V'を使わなくて済む場合に回避する方法としての、'inject'の有用性は明らかだ。

[[coalesce]]
=== coalesce を使ってどのトラバーサルが結果を返すかを調べる

場合によっては、関心のある一連のどのトラバーサルが結果を返すか確かじゃない場合は、'coalesce'ステップで順番に評価することができる。結果を返すように指定した最初のトラバーサルにより、その結果がクエリに返される結果となる。

下記の例を見ていただきたい。ID が3の頂点から始めて、'coalesce'を使って、ラベルが'fly'の出力エッジがあるかどうかを最初に確認する。存在する場合、それらのエッジに接続されている頂点が返される。存在しない場合、'contains'というラベルの付いた入力エッジの頂点が返される。

[source,groovy]
----
// Return the first step inside coalesce that returns a vertex
g.V(3).coalesce(out('fly'),__.in('contains')).valueMap()
----

'air-routes'グラフには、'fly'というラベルの付いたエッジがないので、2つめのトラバーサルは、結果が返されたものになる。

'air-routes'グラフを使って上記のクエリを実行すると、これが返される。

[source,groovy]
----
[code:[NA],type:[continent],desc:[North America]]
[code:[US],type:[country],desc:[United States]]
----

'coalesce'ステップの内側には、3つ以上のトラバーサルを配置することができる。下記の例では、3つある。この頂点には、'contains'エッジがいくつか存在するので、トラバーサルは左から右の順番で評価されるので、'route'エッジは表示されない。

[source,groovy]
----
g.V(3).coalesce(out('fly'),
              __.in('contains'),
                out('route')).valueMap()
----

御覧の通り、返される結果は同じだ。

[source,groovy]
----
[code:[NA],type:[continent],desc:[North America]]
[code:[US],type:[country],desc:[United States]]
----

[[coalconst]]
==== coalesce を定数値と組み合わせる

'coalesce'ステップは'定数値'と組み合わせると、非常に便利だ。下記の例では、空港がテキサスにある場合、その説明が返される。テキサスにない場合、文字列 "Not in Texas" が代わりに返される。

[source,groovy]
----
g.V(1).coalesce(has('region','US-TX').values('desc'),constant("Not in Texas"))

Not in Texas

g.V(3).coalesce(has('region','US-TX').values('desc'),constant("Not in Texas"))

Austin Bergstrom International Airport
----

少し後にある、"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#coaladdv[coalesce を使って頂点が存在しない場合にのみ頂点を追加する]" のセクションで、再度'coalesce'を使って、追加する前に、頂点がすでに存在するかどうかのチェックを行う。

[[optional]]
=== 2つの有効な結果のうちの1つを返す - optional を導入する

トラバーサルの試行の結果に応じて、2つの結果のうちのいづれかを返すと便利なことがある。'optional'ステップは、結果がある場合はトラバーサル結果を返し、結果がなければ、前のステップの結果を返す。

下記の例では、オースティン(AUS)とシドニー(SYD)間に直行便がないので、'optional'ステップにより、オースティンの頂点が返される。

[source,groovy]
----
g.V().has('code','AUS').optional(out().has('code','SYD')).values('city')

Austin
----

しかしながら、オースティンとダラスフォートワース(DFW)間には、経路があるので、下記の例に示すように、今回は'optional'ステップはDFW頂点を返す。

[source,groovy]
----
g.V().has('code','AUS').optional(out().has('code','DFW')).values('city')

Dallas
----

前のクエリは、下記に示すように使った場合、'coalesce'ステップが動作するのと同じように振る舞うので注意してほしい。この場合、もし指定されたトラバーサルが結果を返さない場合は、'identity'ステップを使って前の頂点を返す。

[source,groovy]
----
g.V().has('code','AUS').
      coalesce(out().has('code','SYD'),identity()).values('city')

Austin

g.V().has('code','AUS').
      coalesce(out().has('code','DFW'),identity()).values('city')

Dallas
----


[[otherv]]
=== both, bothE, bothV, otherV を使って頂点とエッジを調査する他の方法

グラフをウォークして、'out','in','outE','inE'などのステップを使って頂点やエッジを調べる方法については、すでに例を見てきた。本セクションでは、頂点やエッジを調べるためのさらに別の方法を導入する。

簡単にまとめると、下記のような単にIDが3 の頂点からの発エッジの数をカウントするクエリの例をすでに見てきた。

[source,groovy]
----
g.V(3).outE().count()

59
----

同様に、このクエリは同じ頂点への入エッジの数をカウントする

[source,groovy]
----
g.V(3).inE().count()

61
----

下記のクエリは'bothE'ステップを導入する。このステップでは、入りであろうと出であろうと、この頂点に接続されている全てのエッジを返す。ごらんのように、120のカウントが出力されていて、発エッジと着エッジの数を数えた値と一致している。簡単な例として、エッジを取得して、各エッジのプロパティを調べることができる。

[source,groovy]
----
g.V(3).bothE().count()

120
----

エッジの代わりに頂点を返したいのであれば、'both'ステップを使うとよい。これは、出エッジと入エッジのどちらで接続されているかに関係なく、IDが3 の頂点に接続されているすべての頂点を返す。

[source,groovy]
----
g.V(3).both().count()

120
----

この次のクエリを使って前のクエリで数えた120個の頂点を表示することができる。結果をソートして、'fold'を使ってリストに入れて結果を読みやすくしてある。結果の中に、頂点3 が返されていない点に注意してほしい。これは重要で、いくつかの例で説明するように、常にこうなるとは限らない。

[source,groovy]
----
g.V(3).both().order().by(id).fold()

[v[1],v[1],v[4],v[4],v[5],v[5],v[6],v[6],v[7],v[7],v[8],v[8],v[9],v[9],v[10],v[10],v[11],v[11],v[12],v[12],v[13],v[13],v[15],v[15],v[16],v[16],v[17],v[17],v[18],v[18],v[20],v[20],v[21],v[21],v[22],v[22],v[23],v[23],v[24],v[24],v[25],v[25],v[26],v[26],v[27],v[27],v[28],v[28],v[29],v[29],v[30],v[30],v[31],v[31],v[34],v[34],v[35],v[35],v[38],v[38],v[39],v[39],v[41],v[41],v[42],v[42],v[45],v[45],v[46],v[46],v[47],v[47],v[49],v[49],v[52],v[52],v[136],v[136],v[147],v[147],v[149],v[149],v[178],v[178],v[180],v[180],v[182],v[182],v[183],v[183],v[184],v[184],v[185],v[185],v[186],v[186],v[187],v[187],v[188],v[188],v[190],v[190],v[273],v[273],v[278],v[278],v[389],v[389],v[416],v[416],v[430],v[430],v[549],v[549],v[929],v[929],v[1274],v[1274],v[3591],v[3605]]
----

おそらく、ほとんどの頂点が2回現れていることにも気づいたのではないだろうか。これはほとんどの航空路に出エッジと、入エッジの両方があるからだ。結果が重複するのを除外したいのであれば、クエリに'dedup'ステップを追加することでそれが可能になる。

[source,groovy]
----
g.V(3).both().dedup().order().by(id).fold()

[v[1],v[4],v[5],v[6],v[7],v[8],v[9],v[10],v[11],v[12],v[13],v[15],v[16],v[17],v[18],v[20],v[21],v[22],v[23],v[24],v[25],v[26],v[27],v[28],v[29],v[30],v[31],v[34],v[35],v[38],v[39],v[41],v[42],v[45],v[46],v[47],v[49],v[52],v[136],v[147],v[149],v[178],v[180],v[182],v[183],v[184],v[185],v[186],v[187],v[188],v[190],v[273],v[278],v[389],v[416],v[430],v[549],v[929],v[1274],v[3591],v[3605]]
----

修正したクエリを使ってカウントをやり直し、期待した結果の数が返されることを確認できるだろう。

[source,groovy]
----
g.V(3).both().dedup().count()

61
----

'bothV'と'otherV'ステップを使ってエッジを操作する際に利用可能な同様の一連のものがある。'bothV'ステップはエッジの両端の頂点を返し、'otherV'ステップはエッジのもう一方の端の頂点を返す。これは我々がエッジをどのように見ているか相対的なものだ。

下記のクエリは、IDが3の同じ頂点から開始し、次に出入に関係なくすべてのエッジを参照し、'bothV'ステップを使ってそれらのエッジの両端にある頂点を取得する。今回はカウントが240になったことに注目してほしい。これは、120本のエッジのすべてについて、両端の頂点を求めたので、最終的に240個になったからだ。

[source,groovy]
----
g.V(3).bothE().bothV().count()

240
----

再度、'dedup'ステップを追加して、以前にやったように重複する頂点を取り除き、再度カウントし直すことができるが、今回は、以前返った61ではなく、62が返ることに注意してほしい。では、ここで何が起こっているのだろうか？

[source,groovy]
----
g.V(3).bothE().bothV().dedup().count()

62
----

別のクエリを実行して、今回返ったすべての頂点を見てみよう。

[source,groovy]
----
g.V(3).bothE().bothV().dedup().order().by(id()).fold()

[v[1],v[3],v[4],v[5],v[6],v[7],v[8],v[9],v[10],v[11],v[12],v[13],v[15],v[16],v[17],v[18],v[20],v[21],v[22],v[23],v[24],v[25],v[26],v[27],v[28],v[29],v[30],v[31],v[34],v[35],v[38],v[39],v[41],v[42],v[45],v[46],v[47],v[49],v[52],v[136],v[147],v[149],v[178],v[180],v[182],v[183],v[184],v[185],v[186],v[187],v[188],v[190],v[273],v[278],v[389],v[416],v[430],v[549],v[929],v[1274],v[3591],v[3605]]
----

違いがわかるだろうか？今回は、頂点3 (v[3]) が**結果に含まれている**。これは、すべてのエッジを見て、次に、それらのエッジすべてに接続されている全ての頂点を求めたからだ。頂点 3 はその計算の一部として含まれている。したがって、'both'を使うパターンと'bothE().bothV()'を使うパターンの微妙な違いに注意してほしい。

再度今使ったばかりのクエリを書き換えてみよう。但し、'bothV'を'otherV'に置き換える。結果の数を数えると、再度61 に戻っていることに注意してほしい。

[source,groovy]
----
g.V(3).bothE().otherV().dedup().count()
61
----

それでは、返された頂点を見返して、違いが何か見てみよう。

[source,groovy]
----
g.V(3).bothE().otherV().dedup().order().by(id()).fold()

[v[1],v[4],v[5],v[6],v[7],v[8],v[9],v[10],v[11],v[12],v[13],v[15],v[16],v[17],v[18],v[20],v[21],v[22],v[23],v[24],v[25],v[26],v[27],v[28],v[29],v[30],v[31],v[34],v[35],v[38],v[39],v[41],v[42],v[45],v[46],v[47],v[49],v[52],v[136],v[147],v[149],v[178],v[180],v[182],v[183],v[184],v[185],v[186],v[187],v[188],v[190],v[273],v[278],v[389],v[416],v[430],v[549],v[929],v[1274],v[3591],v[3605]]
----

御覧の通り、'otherV'を使うと、開始位置('v[3]') に関連する他の頂点のみを表示しているので、'v[3]'は返されない。


[[sp]]
=== 最短経路(空港間の）- repeat を導入する

Gremlinでは多くのプログラミング言語で見られるものと同様の、 'repeat...until'ループ構造が用意されている。これにより単純な最短経路型のクエリを実行するための優れた方法が利用できる。'repeat...until'ループを使うと、明示的に試行する'out'ステップの数を指定しなくても、2つの空港間のパスの検索ができる

このような計算をしている際に、すでにトラバース済みのパスを再度トラバースしたくないことがある。'simplePath'ステップを使えば、この振る舞いを求めることができる。そうすることで、グラフを複数回トラバースするしなくてよくなり、クエリが高速化される。'simplePath'ステップを使わないと、これから調べるクエリにさらに時間がかかることがある。'limit'ステップを追加することも重要で、これがないと、このクエリは長時間実行され、すべての可能なパスを検索してしまう。

下記のクエリは、オースティン(AUS)とアグラ(AGR)間の経路を検索する。タージマハルを訪れたいオースティン人にとって重要なクエリだ。

[source,groovy]
----
// What are some of the ways to travel from AUS to AGR?
g.V().has('code','AUS').
      repeat(out().simplePath()).
        until(has('code','AGR')).
        path().by('code').limit(10) 
----

クエリを実行した結果はこのとおり。'repeat...until'構造を使って、試行するステップ数を指定する必要がなかった点に注目してほしい。

[source,groovy]
----
[AUS,YYZ,BOM,AGR]
[AUS,LHR,BOM,AGR]
[AUS,FRA,BOM,AGR]
[AUS,EWR,BOM,AGR]
[AUS,YYZ,ZRH,BOM,AGR]
[AUS,YYZ,BRU,BOM,AGR]
[AUS,YYZ,MUC,BOM,AGR]
[AUS,YYZ,ICN,BOM,AGR]
[AUS,YYZ,CAI,BOM,AGR]
[AUS,YYZ,ADD,BOM,AGR]
----

下記に示すように、'repeat'の前に、'until'を置くこともできる。

[source,groovy]
----
// Another shortest path example using until...repeat instead  
g.V().has('code','AUS').
      until(has('code','SYD')).
        repeat(out().simplePath()).limit(10).
      path().by('code')    
----

これが、クエリを実行した結果だ。

[source,groovy]
----
[AUS,DFW,SYD]
[AUS,LAX,SYD]
[AUS,SFO,SYD]
[AUS,YYZ,HND,SYD]
[AUS,YYZ,ICN,SYD]
[AUS,YYZ,SCL,SYD]
[AUS,YYZ,AUH,SYD]
[AUS,YYZ,TPE,SYD]
[AUS,YYZ,CAN,SYD]
[AUS,YYZ,DFW,SYD]
----

'repeat...times'ループを使って試行するoutステップを明示的に回数を指定することもできるが、これはもちろん、空港間で検索したい経由地の数があらかじめわかっていることを前提とする。次のセクションでは、'repeat'ループから返されるものの振る舞いをより細かく制御できる'emit'ステップを導入する。

[source,groovy]
----
g.V().has('code','AUS').repeat(out()).times(2).has('code','SYD').path().by('code')

[AUS,DFW,SYD]
[AUS,LAX,SYD]
[AUS,SFO,SYD]
----

前のクエリは、この次のクエリと同等ではあるが、この方法で行うと、'out'ステップの数を簡単に変更できないという点で、柔軟性が低下する。例えば、現在の2ホップではなく、5ホップを次に試したいとする。

[source,groovy]
----
g.V().has('code','AUS').out().out().has('code','SYD').path().by('code')
----

Gremlinを使う場合によくあることだが、同じ結果を得るための方法は複数ある。どれだけループのじっこうを繰り返すかを制御するのに利用できる'loops'ステップは基本的に'times'ステップと同等だ。下記の2つのクエリをみていただきたい。どちらも同じ結果が得られる。1つ目は'loops'を使っているのに対し、2つ目は'times'を使っている。私は'times'を使った方が読みやすいので好みだ。

[source,groovy]
----
g.V(3).repeat(out()).until(loops().is(2)).count()

5894

g.V(3).repeat(out()).times(2).count()

5894
----

NOTE: 2つの空港間にロートがあるかどうかを単に見つけたいのであれば、使用できる優れた最適化がある。これは、本書の後半にある"<<doesanyrouteexist>>"のセクションで説明している。

次のセクションでは、どのように'emit'を使って、'repeat...times'ループの振る舞いを調整することができるか見ていく。

[[emit]]
==== emitを使ってrepeat ループ中に結果を返す

トラバーサルの実行時に、トラバーサル結果を返すことができると便利なことがある。下記の例は、サンタフェ空港(SAF) から出発して、'repeat'を使ってそこから出る。'repeat'の直後に'emit'を置くことにより、トラバーサルがたどるパスを参照することができる。ここに'emit'を置かなかった場合、このクエリは、'repeat'には終了条件がないので、非常に長時間実行されるだろう。

[source,groovy]
----
g.V().has('code','SAF').repeat(out()).emit().path().by('code').limit(10)

[SAF,DFW]
[SAF,LAX]
[SAF,PHX]
[SAF,DEN]
[SAF,DFW,ATL]
[SAF,DFW,ANC]
[SAF,DFW,AUS]
[SAF,DFW,BNA]
[SAF,DFW,BOS]
[SAF,DFW,BWI]
----

'emit'が役に立つ別のところは、'repeat'と'times'を一緒に使って頂点間のパスを見つけることだ。通常、'times(3)'などのようなステップを使うと、クエリは3ホップ出た結果だけを返すだろう。しかしながら、'emit'を使うと、ホップ数が少ない結果も参照することができる。まず、'emit'を使わない下記のクエリとそれが生成する結果を見てほしい。

[source,groovy]
----
g.V(3).repeat(out()).times(3).has('code','MIA').
       limit(5).path().by('code')
----

返されたパスはオースティンからマイアミへ2か所経由して行く方法を選んだことを示しているが、結果には、経由地が2か所未満のものはない。これは本当に求めていたことだろうか？

[source,groovy]
----
[AUS,YYZ,MUC,MIA]
[AUS,YYZ,MAN,MIA]
[AUS,YYZ,YUL,MIA]
[AUS,YYZ,SVO,MIA]
[AUS,YYZ,GRU,MIA]
----

次に、クエリを'emit'を使うように変更しよう。今回のくえりは、「最大3ホップ」あるいは、航空会社の用語で、「最大2ストップ」と考えることができる。

[source,groovy]
----
g.V(3).repeat(out().simplePath()).emit().times(3).has('code','MIA').
       limit(5).path().by('code')
----

御覧のとおり、'emit'を追加することで、まったく異なる結果セットが返された。これは本当に便利で強力な機能だ。「高々３つ」などのアイデアを表現できることにより、このような場合に、非常にきれいなクエリを書くことができる。

[source,groovy]
----
[AUS,MIA]
[AUS,YYZ,MIA]
[AUS,LHR,MIA]
[AUS,FRA,MIA]
[AUS,MEX,MIA]
----

前のクエリでemit ステップを使うと、基本的に同じことを行うこのクエリのよりコンパクトな形式を書くことができるようになることに注目してほしい。この例では、インラインで'or'ステップを使っていることに注意してほしい。

[source,groovy]
----
g.V(3).repeat(out().simplePath()).
         until(has('code','MIA').or().loops().is(3)).
       has('code','MIA').
       path().by('code').limit(5)
----

実行すると、御覧の通り、同じ結果が返される。

[source,groovy]
----
[AUS,MIA]
[AUS,YYZ,MIA]
[AUS,LHR,MIA]
[AUS,FRA,MIA]
[AUS,MEX,MIA]
----

'emit'ステップは、'has'ステップなどのパラメータを使って関心のない中間結果を除外することもできる。下記のクエリでは、指定された条件を満たせば'repeat'が動作するので、中間結果のみが表示される。この場合の条件は、パスがプラハ(PRG) 空港の頂点を通過している必要がある、ということだ。'limit'ステップは最初の10件の結果のみを表示するのに使われる。

[source,groovy]
----
g.V(3).repeat(out().simplePath()).emit(has('code','PRG')).
       path().by('code').limit(10)
----

これは、クエリを実行した結果だ。

[source,groovy]
----
[AUS,YYZ,PRG]
[AUS,LHR,PRG]
[AUS,FRA,PRG]
[AUS,DTW,YYZ,PRG]
[AUS,DTW,LHR,PRG]
[AUS,DTW,CDG,PRG]
[AUS,DTW,FRA,PRG]
[AUS,DTW,PVG,PRG]
[AUS,DTW,AMS,PRG]
[AUS,DTW,MUC,PRG]
----

'emit'ステップの一部として条件がないと、グラフトラバーサルがたどるすべてのパスが表示されるので、異なる結果が得られる。

[source,groovy]
----
g.V(3).repeat(out().simplePath()).emit().path().by('code').limit(10)

[AUS,DTW]
[AUS,YYZ]
[AUS,LHR]
[AUS,FRA]
[AUS,MEX]
[AUS,PIT]
[AUS,PDX]
[AUS,ONT]
[AUS,CLT]
[AUS,CUN]
----

これまでのところ、興味深いものではあるが、示されている結果の多くは、一見、'emit'を使わずに生成されたものであるように見える。しかしながら、下記のクエリは、'until'ステップを使って、シェトランド諸島のラーウィック(LSI)から到達することに関心のあるオースティン(AUS)のターゲットの空港を指定しているという点でより興味深い。また、'emit'ステップの一部として、オースティンに到着するかどうかに関係なく、ニューヨーク州にある任意の空港を含む参照したい見つかった経路も指定する

[source,groovy]
----
g.V().has('code','LSI').
     repeat(out().simplePath()).
        emit(has('region','US-NY')).
        until(has('code','AUS')).
     path().by('code').limit(10)
----

これは、このクエリが生成した結果だ。ニューヨークの空港とオースティンが最終目的地としてどのように混在しているか注目してほしい。

[source,groovy]
----
LSI,EDI,JFK]
LSI,EDI,EWR]
LSI,EDI,SWF]
LSI,GLA,JFK]
LSI,GLA,EWR]
LSI,EDI,JFK,AUS]
LSI,EDI,JFK,ROC]
LSI,EDI,JFK,BUF]
LSI,EDI,JFK,SYR]
LSI,EDI,EWR,ROC]
----

'emit'は'repeat'ステップの前に置くこともできる。これによりクエリの前のステップの結果が次のステップの結果の前に出力される。下記の例では、オースティンを出発し、'repeat'ループを使って2ホップ移動する。見つかった場所の最初の10件の空港コードが返される。'emit'を使っているために、最初の値としてどのようにAUSが返されるかに注意してほしい。

[source,groovy]
----
g.V().has('airport','code','AUS').
      emit().repeat(out().simplePath()).times(2).limit(10).
      values('code').fold()

[AUS,YYZ,ZRH,YOW,BRU,MUC,RSW,MAN,YUL,YEG]
----

場合によっては、'repeat'ステップのあとに置かれた'emit'は'until'ステップと同じ効果がある。下記の両方のクエリはヨハネスブルク(JNB)とシドニー(SYD)間の経路を検索する。

[source,groovy]
----
g.V().has('code','JNB').repeat(out()).until(has('code','SYD')).
      path().by('code').limit(3)

g.V().has('code','JNB').repeat(out()).emit(has('code','SYD')).
      path().by('code').limit(3)
----

いづれかのクエリを実行すると、下記の結果が返される。

[source,groovy]
----
[JNB,SYD]
[JNB,BKK,SYD]
[JNB,DOH,SYD]  
----

'emit'が使われる例は、もう少し後の、"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#btree[順序付けられた二分木をグラフとしてモデル化する]のセクションにもう少しある。

[[nestedrepeat]]
==== ネストされた、名前付けられたrepeat ステップ

Apache TinkerPop リリース 3.4 以降、'repeat'ステップを別の'repeat'ステップと'emit'あるいは'until'ステップの内部でネストできるようになった。

TIP: これらの新機能の公式ドキュメントは次の場所に置いてある:
http://tinkerpop.apache.org/docs/current/reference/#repeat-step

トラバーサルの後で参照できるように、repeat ステップに名前をラベル付けすることも可能だ。ネストされた'repeat'ステップによりより興味深い新しいグラフトラバーサルパターンが可能となる。例えば、一連の出エッジをトラバースしていて、途中の各頂点について入エッジをトラバースしたいことがある。air-routes グラフにはネストされた'repeat'ステップの理想的なユースケースをお見せできる関連はないが、下記のクエリは、簡単な例を示している。

[source,groovy]
----
g.V().has('code','SAF').
      repeat(out('route').simplePath().
        repeat(__.in('route')).times(3)).
      times(2).
      path().by('code').
      limit(3).
      toList()
----

クエリを実行すると、下記に示すのと同様の結果が生成される。サンタフェ(SAF)を出発し、発経路を使って、ダラスフォートワース(DFW)に到着する。次に、コーパスクリスティ(CRP)、らぼっく(LBB)、オースティン(AUS)を出力する3つの入り経路を参照する。次に、DFWからの別の発ホップを調べ、アトランタ(ATL) で自分自身を見つける。次に、アトランタからの3つの入経路を調べて、ラゴス(LOS)、アディスアベバ(ADD)、オスロ(OSL)、バンコク(BKK)あるいはムンバイ(BOM)のいづれかを見つける。

[source,groovy]
----
[SAF,DFW,CRP,LBB,AUS,ATL,LOS,ADD,OSL]
[SAF,DFW,CRP,LBB,AUS,ATL,LOS,ADD,BKK]
[SAF,DFW,CRP,LBB,AUS,ATL,LOS,ADD,BOM]
----

前述したように、air-routes データセットを操作することはおそらくネストされたrepeat ステップを使う上での理想的なユースケースではない。ほとんどのエッジは経路であり、ほとんどの頂点は、空港だ。しかしながら、データにさまざまな頂点タイプやエッジタイプがあるのであれば、この機能は非常に便利な場合がある。

NOTE: sample-code フォルダに、小さなソーシャルグラフを生成し、様々なネストされたrepeatステップ操作を実行するスタンドアロンのサンプルがある。このサンプルは下記に置いてある: https://github.com/krlawrence/graph/blob/main/sample-code/nested-repeat.groovy

ネストされた'repeat'ステップを使う際、'loops'ステップがどのrepeatステップに接続されているかを知るには、各'repeat'ステップに独自のラベル名を付ける必要がある。下記の例では、'repeat'ステップに'"r1"'のラベルをつけ、そのラベルを後続の'loops'ステップで参照している。明らかに、この例にはネストされた繰り返しは含まれていないが、この新しいラベル付け機能がどのように使えるかは示せているのではないかと思う。

[source,groovy]
----
g.V().has('code','SAF').
      repeat('r1',out().simplePath()).
        until(loops('r1').is(3).or().has('code','MAN')).
      path().by('city').
      limit(3).
      toList()
----

下記の例は、マンチェスターを一度見つけ、残りの2回は、'loops'制限に達したことを示している。

[source,groovy]
----
[Santa Fe,Los Angeles,Manchester]
[Santa Fe,Dallas,Buenos Aires,Atlanta]
[Santa Fe,Dallas,Buenos Aires,Houston]
----


[[depthlimit]]
==== 各深度での結果を制限する

'repeat'ステップを使ってグラフを調べているときに、トラバーサルの任意の深度で返される結果の量を制限することが望ましいことがある。この結果を得ることは想定されるより少し複雑だ。'limit'ステップは下記に示すようにグローバルスコープなので、この場合には全く必要とはしない。

[source,groovy]
----
g.V().has('code','SFO').
      repeat(out().simplePath()).times(3).
      limit(5).
      path().by('code')
----

クエリを実行すると、サンフランシスコ(SFO)から深さ3(3ホップ） の5つの結果が返る。興味深いことだが、これは、この件で、求めている結果ではない。

[source,groovy]
----
[SFO,ANC,DFW,ATL]
[SFO,ANC,DFW,AUS]
[SFO,ANC,DFW,BNA]
[SFO,ANC,DFW,BOS]
[SFO,ANC,DFW,BWI]  
----

一見すると、単に'limit'ステップを'repeat'ステップの本体の内側に移動するだけでよいように見えるかもしれないが、'limit'ステップのグローバルな性質のために、別のアプローチを取る必要がある。

[source,groovy]
----
g.V().has('code','SFO').
      repeat(out().simplePath().limit(5)).times(3).
       path().by('code')  
----

ごらんのとおり、クエリを実行すると、'limit'が'repeat'ステップ本体の外側にある場合と同じ結果が得られる。

[source,groovy]
----
[SFO,ANC,DFW,ATL]
[SFO,ANC,DFW,AUS]
[SFO,ANC,DFW,BNA]
[SFO,ANC,DFW,BOS]
[SFO,ANC,DFW,BWI]      
----

各深度で5つの結果を得るトラバーサルを構築するために、クエリにいくつかの追加のステップを導入する必要がある。最後のクエリに直接飛ばすのではなく、中間ステップをいくつか見てみよう。

まず、SFOを出発して3ホップの深さまで、各深度で、最終的に到達できる場所がいくつあるかカウントするクエリを書いてみよう。これを行うには、'groupCount'ステップのキーとして'loops'ステップを使うことができる。'loops'は'repeat'ステップを実行中に今いる深度を知らせてくれることを覚えておいてほしい。'loops'ステップの深度カウンターはゼロから始まるので、ゼロの値は、実際には深度１にいることを意味する。深度1を超えて同じ空港に到達する方法は複数あるので、このクエリで生成されたカウントには重複が含まれているが、これは作成中のクエリでは、問題とならない。

[source,groovy]
----
g.V().has('code','SFO').
       repeat(out().simplePath().
              groupCount('airports').by(loops())).
       times(3).
       cap('airports')
----

ラベル（この場合は、「'airport'」）が指定されると、'groupCount'ステップが副作用として機能する。これは、、通過するものをカウントするが、クエリの後続のステップに渡されるものは変更しないことを意味する。クエリの終わりにある'cap'ステップは、明示的にカウントを返す。下記にあるように、実行すると、クエリは最初の深度3での経路のカウントのマップを生成する。ここで深度は、マップのキーで、カウントは、マップの値である。ちなみに、このようなクエリがどれほど迅速に、「ファンアウト」できるかを見ることは興味深いことだ。すべての重複アクセスを考慮して、基本的に、深度3 で、836,000回以上空港頂点に、アクセスした。

[source,groovy]
----
[0:141,1:11587,2:836707]  
----

これで、各深度で、アクセスしている頂点の数をカウントできるクエリができたので、これを使って、返す数を制限する制約を追加することができる。

TIP: 下記のクエリは、下記にあるsample-code フォルダのrestricted-repeat.groovy というスクリプトとして利用可能である。
https://github.com/krlawrence/graph/tree/main/sample-code.

クエリの更新したバージョンを下記に示す。最初に'groupCount'によって生成されたマップを選択し、そこから現在の'loops'の値を使ってマップからエントリを選択する'where'ステップが追加された。頂点は、これまでに5つ以下が検出された場合にのみ、'where'ステップフィルタによって渡される。

[source,groovy]
----
g.V().has('code','SFO').
       repeat(out().simplePath().groupCount('airports').by(loops()).
              where(select('airports').select(loops()).is(lte(5)))).
       emit().
       times(3).
       path().
         by('code')  
----

修正したクエリを実行すると、出力は全く異なる。今回は、各深度ごとで、5つの経路が返される。これが我々が求めていた結果だ。

[source,groovy]
----
[SFO,ANC]
[SFO,AUS]
[SFO,BNA]
[SFO,BOS]
[SFO,BWI]
[SFO,ANC,DFW]
[SFO,ANC,PDX]
[SFO,ANC,IAH]
[SFO,ANC,FAI]
[SFO,ANC,LAX]
[SFO,ANC,DFW,ATL]
[SFO,ANC,DFW,AUS]
[SFO,ANC,DFW,BNA]
[SFO,ANC,DFW,BOS]
[SFO,ANC,DFW,BWI]  
----

一見すると、上記で使われた'where'ステップは混乱を招くかもしれない。この振る舞いをより簡単に説明するための一助になると思われるいくつかの例を下記に示す。まず、下記のクエリは、単に、キーが単に定数リテラルの値である、5つの頂点IDに基づいて'groupCount'を使ってまっぷを生成するだけだ。'where'ステップが存在しないので、5つの入力頂点全てが結果に含まれている。

[source,groovy]
----
g.V(1,2,3,4,5).groupCount('x').by(constant('A')).select('x')

[A:1]
[A:2]
[A:3]
[A:4]
[A:5]
----

3番目の頂点だけが、'where'ステップのフィルタを通過するようにしたいのであれば、下記のようにクエリを調整するとよい。これは基本的に、「各深度で5つ」のクエリが実行することだが、おそらく追うのは簡単だ。

[source,groovy]
----
g.V(1,2,3,4,5).groupCount('x').by(constant('A')).
               where(select('x').select('A').is(3))

v[3]
----

最後に、制約を3以下に変更するとどうなるかを確認しよう。最初の3つの頂点のみが、結果に含まれる。

[source,groovy]
----
g.V(1,2,3,4,5).groupCount('x').by(constant('A')).
               where(select('x').select('A').is(lte(3)))

v[1]
v[2]
v[3]
----

NOTE: local ステップと limit ステップの組み合わせを使ってrepeatステップの結果を制限する別の例が、本書後半にある、"<<randwalk>>"のセクションにある。

このように、ステップを分解することで、この非常に便利なGremlin のクエリがどのように機能するかがよく理解できるようになると思う。

[[cyclicpath]]
==== 前にここに来たことないだろうか？ - cyclicPath を導入する

'cyclicPath'ステップを使うと、トラバーサルの前半でアクセスした頂点を再度アクセスするグラフ内のパスを見つけることができる。これは、開始頂点を再度アクセスすることを意味するわけではなく、グラフをトラバース中に、それがすでにアクセス済みの頂点である可能性がある。循環パスの例をいくつか下記に示す。下記の幾分不自然なクエリは、出発点と終了点の両方がオースティンで途中1回経由をする10件の経路を見つける。

[source,groovy]
----
// From Austin and back again with one stop.
g.V().has('code','AUS').
      out().out().cyclicPath().
      limit(10).path().by('code')
----

これが、クエリを実行した結果だ。

[source,groovy]
----
[AUS,TUS,AUS]
[AUS,PHL,AUS]
[AUS,DTW,AUS]
[AUS,YYZ,AUS]
[AUS,LHR,AUS]
[AUS,FRA,AUS]
[AUS,MEX,AUS]
[AUS,PIT,AUS]
[AUS,PDX,AUS]
[AUS,ONT,AUS]
----

'repeat'ループの終了条件として'cyclicPath'を使うこともできる。下記のクエリは、出発点に戻るまで、出'route'エッジを追跡し続ける。ここでも、最初の10件の結果のみが選択される。

[source,groovy]
----
g.V().has('code','AUS').
      repeat(out('route')).until(cyclicPath()).
      limit(10).path().by('code')
----

クエリを実行した結果はこのとおり。ごらんのとおり、このインスタンスでも同じ結果が生成されたが、10回より長く実行すると、開始点から1ホップだけという制限がなくなるので、最終的にはより多くの循環パスが見つかる。実際、結果の数を制限しなかった場合、クエリは最終的にグラフ中のすべての循環パスを見つける。そのクエリはかなり長時間実行される可能性があるので、試そうとしないことをお勧めする。

[source,groovy]
----
[AUS,TUS,AUS]
[AUS,PHL,AUS]
[AUS,DTW,AUS]
[AUS,YYZ,AUS]
[AUS,LHR,AUS]
[AUS,FRA,AUS]
[AUS,MEX,AUS]
[AUS,PIT,AUS]
[AUS,PDX,AUS]
[AUS,ONT,AUS]
----

前のクエリを数百回実行すると、循環が開始頂点へ戻っていない例が表示され始める。下記の2つの結果は、クエリに500の循環パスを検出させることによって生成された。2つめのケースでは、循環は開始頂点(AUS)ではなく、マイアミ(MIA)に戻っている点に注意してほしい。

[source,groovy]
----
[AUS,MIA,BUF,AUS]
[AUS,MIA,BUF,MIA]
----

'cyclicPath'を'not'述部と組み合わせて使って、クエリから循環的な結果が返らないようにすることもできる。

[source,groovy]
----
g.V().has('code','AUS').
      out().
      out().not(cyclicPath()).limit(10).
      path().by('code')
----

'air-routes'グラフの場合、これは、下記のようにクエリを書いた場合と同じ効果が得られる点に注意してほしい。

[source,groovy]
----
g.V().has('code','AUS').as('a').
      out().
      out().where(neq('a')).limit(10).
      path().by('code')
----

一部のグラフにはすぐに同じ頂点へループバックするエッジをもつ頂点をが含まれている。IDが3の頂点から同じ頂点へ戻る'loop'のラベルがついたエッジを生成する下記のコードを見てみてほしい。

[source,groovy]
----
g.V(3).as('a').addE('loop').to('a')

e[56951][3-loop->3]
----

次に、'cyclicPath'ステップを使ってグラフ内のそのようなループを見つけることができる。

[source,groovy]
----
g.V().out().cyclicPath().path()

[v[3],v[3]]
----

エッジを結果に含めるには、下記のように少し変更するだけでよい。

[source,groovy]
----
 g.V().outE().inV().cyclicPath().path()

[v[3],e[56951][3-loop->3],v[3]]
----

[[pathwarn]]
==== パスファインディングは、メモリとCPUを集中的に使用するかもしれないという警告

下記のクエリを見ていただきたい。これは、シェトランド諸島の小さな空港であるパパストゥール(PSV)からオースティン(AUS)までの 最初の10件の経路を返す。'simplePath'ステップが同じ正確なパスが2回参照されないようにするために使われている。このクエリは素早く実行され、いくつかの便利な結果を返す。

[source,groovy]
----
g.V().has('code','PSV').
      repeat(out().simplePath()).
      until(has('code','AUS')).
      limit(10).
      path().
        by('code')
----

これが、返された経路のいくつかだ。

[source,groovy]
----
[PSV,LWK,FIE,KOI,EDI,JFK,AUS]
[PSV,LWK,FIE,KOI,EDI,EWR,AUS]
[PSV,LWK,FIE,KOI,EDI,LHR,AUS]
[PSV,LWK,FIE,KOI,EDI,FRA,AUS]
[PSV,LWK,FIE,KOI,GLA,JFK,AUS]
[PSV,LWK,FIE,KOI,GLA,MCO,AUS]
[PSV,LWK,FIE,KOI,GLA,EWR,AUS]
[PSV,LWK,FIE,KOI,GLA,PHL,AUS]
[PSV,LWK,FIE,KOI,GLA,YYZ,AUS]
[PSV,LWK,FIE,KOI,GLA,LHR,AUS]
----

下記に示すように、クエリを逆にすると、問題が発生する可能性がある。実際このクエリをラップトップ上で実行すると、CPU使用率が高く、ファンノイズが増加した後、クエリが使用可能なメモリを使い果たしたというエラーが発生する可能性がある。

[source,groovy]
----
g.V().has('code','AUS').
      repeat(out().simplePath()).
      until(has('code','PSV')).
      limit(10).
      path().
        by('code')
----

これが発生する理由が次の通り。PSVからの経路が非常に少なく、PSVが密接に接続されている空港からの経路はそれほど多くはない。なので、もしPSVからクエリを開始すると、AUSに到達するパスをかなり素早く見つけることができる。しかしながら、AUSから始めると、PSVに近づく前に、Gremlin が探索すべき可能な経路がたくさんある。それが役立つ場合は、PSVが狭い方の端にあり、AUSがもう一方の端にある漏斗を考えてみてほしい。これはクエリの方向に応じて、可能なルートの「ファンアウト」が高いまたは低いと言われることもある。

[[pathstepwarn]]
==== pathとasステップもメモリを大量に消費する可能性があるという警告

Gremlinの'path'ステップは非常に便利で、私はそれを頻繁に利用している。しかしながら、'path'を使うことには、特に、グラフ全体で些細ではない結果を検索する場合には、いくつかの欠点もある。たとえ、検索しているパスが前のセクションよりも難しくなくても、検索しているパスをすべて追跡し、'path'ステップを使ってそれを取得するには、大量のメモリを必要とすることに注意すべきだ。

NOTE: pathとasステップは大量のメモリを使う可能性があり、場合によっては、それが問題を引き起こす。

非常に多くのメモリが消費される可能性がある理由は、'path'ステップは、たとえ'simplePath'が正確に同じパスを複数回以上トラバースするのを避けるために使われていても、実際に我々が関心を持っているものを見つける前に、クエリプロセッサが非常に大きい数の結果を格納するので潜在的に必要とするからである。なので、'path'ステップは非常に便利ではあるが、大量のパスを追跡する必要があるような場合には、注意して使わないと問題が発生する可能性があるので注意してほしい。Gremlin クエリプロセッサには、指定されたクエリを実行するのに使用できるメモリが制限されている。大量のパス情報を格納すると、その制限を超えてクエリの実行が失敗する可能性がある。

すぐにはわからないかもしれないが、'as'ステップを使うと、クエリプロセッサは、少なくとも部分的には、大量のメモリを必要とするパス情報を格納する必要がある。'as'ステップを使うと、トラバーサルの以前の状態を参照することができるが、複雑なクエリ中にこの状態を保持するには、多くのメモリが必要になる可能性がある。

メモリ制限の問題が発生したら、クエリを作成するための様々なアプローチを使って問題を回避するということがよくある。このようなケースの例は、"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#sackpredicate[プロパティと定数を袋の値と比較する]" のセクションにある。

[[nd]]
=== 頂点の次数を計算する

グラフを扱っている際に、頂点に入るエッジの数(in 次数)、頂点から出ていくエッジの数(out 次数）、潜在的に出入りするエッジの数(次数）を説明する際に'degree'という単語が使われる。下記の例に示すように、Gremlin を使えば、様々な尺度の次数を計算するのは非常に簡単だ。

頂点の次数を計算する最も簡単な方法は、下記に示すように、単にエッジを数えることだ。

[source,groovy]
----
// Outgoing degree
g.V().has('airport','code','LHR').out().count()

191

// Incoming degree
g.V().has('airport','code','LHR').in().count()

193

// Overall degree
g.V().has('airport','code','LHR').both().count()

384
----

複数の頂点の次数の値を計算したいのであれば、'group'ステップを使うともっと簡単にできる。下記のクエリは、グラフ中のすべての空港について出経路の数を計算する。このクエリを実行すると、グラフには3,300を超える空港があるので、かなり多くの結果データが返される

[source,groovy]
----
// Out degree (number of routes) from each vertex (airport)
g.V().hasLabel('airport').group().by('code').by(out('route').count())
----

下記のクエリは前のクエリに基づいているが、結果のいくつかを選択するだけだ。

[source,groovy]
----
// Outbound routes (degree) from LHR, JFK and DFW
g.V().hasLabel('airport').group().by('code').by(out('route').count()). 
      select('LHR','JFK','DFW')
----

クエリを実行すると出力はこのようになる。

[source,groovy]
----
[LHR:191,JFK:187,DFW:221]
----

クエリを少し変更してin 次数を計算することができる。JFK には入経路が、出経路よりも1本少ないことがわかることに注意してほしい。

[source,groovy]
----
g.V().hasLabel('airport').
      group().by('code').by(__.in('route').count()).
      select('LHR','JFK','DFW')

[LHR:191,JFK:186,DFW:221]
----

下記のクエリは少し複雑だが、出経路の数が最も多い10件の空港を見つけるのに使うことができる。'local'スコープなど、使われる概念の一部については、少し後の "https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#localcollect[コレクションでローカルスコープを使う]" のセクションで詳しく説明する。

[source,groovy]
----
g.V().hasLabel('airport').
      group().by('code').by(out().count()).
      order(local).by(values).unfold().tail(10).fold()
----

クエリを実行した結果はこれだ。ごらんのとおり、フランクフルト空港(FRA) の発経路が最も多い。経路分析のトピックについては、"https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#mostroutes[経路が最も多い空港]" のセクションで詳しく説明する。

[source,groovy]
----
[DFW=221,DXB=229,ORD=232,ATL=232,PEK=234,MUC=237,CDG=262,AMS=269,IST=270,FRA=272]
----

次のクエリは、10件の空港の、全ての入経路と出経路に基づいて、経路の次数を計算する。このクエリは、TinkerPop 3.2 で導入された'project'ステップを利用する。

[source,groovy]
----
// Calculate degree (in and out) for each vertex.
g.V().hasLabel('airport').limit(10).
      project("v","degree").by('code').by(bothE('route').count())
----

これが、このクエリが生成する出力である。

[source,groovy]
----
[v:ATL,degree:464]
[v:ANC,degree:78]
[v:AUS,degree:118]
[v:BNA,degree:110]
[v:BOS,degree:260]
[v:BWI,degree:178]
[v:DCA,degree:186]
[v:DFW,degree:442]
[v:FLL,degree:284]
[v:IAD,degree:272]
----

もちろん、下記に示すように、'group'ステップを使って同じクエリを書くこともできる。

[source,groovy]
----
g.V().hasLabel('airport').limit(10).
      group().by('code').by(bothE('route').count())
----

下記の結果は、クエリを実行して生成された。

[source,groovy]
----
[DCA:186,BNA:110,DFW:442,BWI:178,ANC:78,BOS:260,FLL:284,ATL:464,IAD:272,AUS:118]
----

[[mathstep]]
=== Gremlin  の関数電卓 - math を導入する

これまでのいくつかのセクションで見たように、Gremlin ステップには、'sum'、'count'、'mean'などのような、かなり基本的な算術演算を行うために使用できるものが用意されている。Apache TinkerPop 3.3.1 では、新しい'math'ステップが導入され、Gremlin グラフトラバーサルの一部として、関数電卓スタイルの算術演算を実行できるようになった。これらの演算子はJava Math クラスに基づいているので、まだ慣れていないのであれば、精通する価値がある。この機能はグラフの実装が、Apache TinkerPop 3.3.1 以降をサポートしている場合にのみ利用可能であることに注意してほしい。

次の表は、使用可能な演算子をアルファベット順にソートしたサマリである。

.関数電卓の演算子
[cols="1,5"]
|==============================================================================
|+       | Arithmetic plus.
|-       | Arithmetic minus.
|*       | Arithmetic multiply.
|/       | Arithmetic divide.
|%       | Arithmetic modulo (remainder).
|^       | Raise to the power. (n^x).
|abs     | Absolute value
|acos    | Arc (inverse) cosine in radians.
|asin    | Arc (inverse) sine in radians.
|atan    | Arc (inverse) tangent in radians.
|cbrt    | Cube root
|ceil    | Returns the smallest (closest to negative infinity) double value that is greater than or equal to the argument and is equal to a mathematical integer.
|cos     | Cosine of angle given in radians.
|cosh    | Hyperbolic cosine.
|exp     | Returns Euler's number '"e"' raised to the given power '(e^x)'
|floor   | Returns the largest (closest to positive infinity) double value that is less than or equal to the argument and is equal to a mathematical integer.
|log     | Natural logarithm (base 'e')
|log10   | Logarithm (base 10)
|log2    | Logarithm (base 2)
|signum  | Returns the 'signum' function of the argument; zero if the argument is zero, 1.0 if the argument is greater than zero, -1.0 if the argument is less than zero.
|sin     | Sine of angle given in radians. 
|sinh    | Hyperbolic sine
|sqrt    | Square root
|tan     | Tangent of angle given in radians. 
|tanh    | Hyperbolic tangent.
|==============================================================================

'math'ステップは式全体が1つの文字列として渡される限り、これまで見てきた他のステップとは異なるように振る舞う。これは、つまり、トラバーサルの一部として割り当てたラベルを使うことができるが、式自体の内部で、外部変数、あるいは'Math.PI'のような静的な定数参照を使うことができない。しかしながら、下記で説明するように、これを簡単に回避する方法がある。使用されているすべての単一演算子の例を示そうとはしていないが、用意した例は、算術演算子をGremlin クエリに組み込みのに必要なすべての基本的な構成要素を提供するはずだ。

TIP: これらの機能は使っているグラフデータベースシステムがTinkerPop 3.3.1 以降をサポートしている必要とする。

[[arithmentic]]
==== 単純な算術演算を実行する

いくつかの基本的な例を見ることから始めよう。まず、下記のクエリは、トラバーサルの一部としてリテラル値に対し、算術演算を実行できることを示している。この場合、トラバーサルの開始時に見つかった頂点はmathステップでは使われない。

[source,groovy]
----
g.V().limit(1).math('100/2')

50.0
----

トラバーサルの前のステップの結果を'math'ステップの一部として使いたいのであれば、下記に示すように、特別なシンボル'"_"'(アンダースコア）を使うことができる。'inject'ステップを使えば、'math'ステップで試しながら値を入力するためのすぐれた方法が利用できる点に注意してほしい。

[source,groovy]
----
g.inject(100).math('_ /2')

50.0
----

次に、'math'ステップで頂点プロパティをどのように使えばよいかを見ていこう。これを行うために、'math'演算の一部として名前付きトラバーサルステップを使うことができる。下記の例は、DFW空港とSFO 空港に滑走路がいくつあるかをチェックすることから始まる。次に、'math'ステップを使って、これらの値をトラバーサルの一部としてどのように加算できるか示す。

[source,groovy]
----
// How many runways does DFW have?
g.V().has('airport','code','DFW').values('runways')

7

// How many runways does SFO have?
g.V().has('airport','code','SFO').values('runways')

4
----

次に、'math'を使って単一のトラバーサルの一部として値を足し算する。２つの整数値を足し算しても、結果は倍精度型の値として返されることに注意してほしい。また、名前付きステップ '+++'+++a+++'+++' と +++'+++b+++'+++' は、mathステップに渡される単一の文字列内で指定されていることに注意してほしい。これは、ステップ内で1つ以上のトラバーサルラベルを参照する他のすべてのステップとの主要な違いだ。最後に、'by'モジュレータを使って'math'ステップにどのプロパティを足し算したいのかを伝えていることに注意してほしい。

[source,groovy]
----
// Use named steps to add some results together.
g.V().has('airport','code','DFW').as('a').
      out().has('code','SFO').as('b').
      math('a + b').by('runways')

11.0
----

下記の例は、'count'ステップの結果で使われる割り算演算子と剰余演算子を示している。

[source,groovy]
----
g.V(3).out().count()

59

g.V(3).out().count().math('_ / 2')

29.5

g.V(3).out().count().math('_ % 5')

4.0
----

アンダースコア文字を使うと、 カウントステップに'+++'+++a+++'+++'のラベルがついている、下記で使われているようなパターンを使って前のクエリを書く必要がなくなることに注意してほしい。

[source,groovy]
----
g.V(3).out().count().as('a').math('a / 2')

29.5
----

[[mathby]]
==== math ステップと一緒にby モジュレータを使う

多くの Gremlin ステップと同様、'math'ステップを1つ以上の'by'モジュレータと組み合わせて使うことができる。まず、サンタフェ(SAF)およびそこから飛ぶことができるすべての場所の滑走路の数を調べる簡単なクエリを書いてみよう。

[source,groovy]
----
g.V().has('code','SAF').as('a').
      out().as('b').
      select('a','b').
        by(values('code','runways').fold())

[a:[SAF,3],b:[DFW,7]]
[a:[SAF,3],b:[LAX,4]]
[a:[SAF,3],b:[PHX,3]]
[a:[SAF,3],b:[DEN,6]]
----

次に、クエリを'math'ステップを使って、空港の各ペアにある滑走路の数を足し算するように修正してみよう。

[source,groovy]
----
g.V().has('code','SAF').as('a').
      out().as('b').
      math('a + b').by('runways')

10.0
7.0
6.0
9.0  
----

もちろん、これは、'math'が実際には必要ない簡単な例だが、'by'モジュレータを'math'ステップで使う方法を示せていると思う。完全を期するために、'sum'ステップを使うように書き換えたクエリを示す。この場合結果は整数値だが、'math'ステップは常に不動小数点の値を返すことに注意してほしい。

[source,groovy]
----
g.V().has('code','SAF').as('a').
      out().as('b').
      select('a','b').by('runways').select(values).sum(local) 

10
7
6
9
----

[[mathconvert]]
==== フィートをメーターに変換する

グラフの各空港で最も長い滑走路の長さは、フィートの単位で格納されている。簡単な'math'ステップを使えば、その値をメートルに変換できる。

[source,groovy]
----
g.V().has('code','DFW').values('longest').math('_ * 0.3048')

4084.6248
----

クエリに'project'ステップを追加すると、結果をもう少し興味深いものにすることができる。

[source,groovy]
----
g.V().has('code','DFW').
      project('Longest runway at','feet','meters').
        by('code').
        by('longest').
        by(values('longest').math('_ * 0.3048'))

[Longest runway at:DFW,feet:13401,meters:4084.6248]
----


[[mathtrig]]
==== 三角関数を使う

三角関数演算子は、期待通りに機能する。すべての角度は度ではなく、ラジアンで指定する必要がある。自分でラジアンに変換するか、必要に応じて、Javaの'Math.toRadians'ヘルパーメソッドを使うとよい。下記のクエリは、'math'ステップを使って、サイン60度を計算し、結果を '"x"'という変数に格納する。

[source,groovy]
----

// Calculate the sine of 60 degrees
x=g.inject(60*(Math.PI/180)).math('sin(_)').next()

0.8660254037844386
----

変数'"x"'を使ってアークサインを計算できる。

[source,groovy]
----
// Calculate the arcsine
g.inject(x).math('asin(_)')

1.0471975511965976
----

Gremlin コンソールを計算機として使うと、正しい答えが返ってくることを証明することができる。

[source,groovy]
----
// Prove this is the right answer
Math.toRadians(60)

1.0471975511965976
----

Java Math ライブラリを使う場合と同様、丸め誤差の可能性に注意すべきであることに注意してほしい。下記の計算では1.0 が返ると予想されるが、45度からラジアンへの変換はMath ライブラリには十分な精度ではないので、そうはならない。Java 'Math.toRadians'メソッドを使っても求めた結果が得られないことに注意してほしい。

[source,groovy]
----
// Manual conversion
g.inject(45*(Math.PI/180)).math('tan(_)')

0.9999999999999999
----

同じ実験だが、ヘルパーメソッドを使っている。

[source,groovy]
----
// Libraray conversion
g.inject(Math.toRadians(45)).math('tan(_)')

0.9999999999999999
----

これにより、'math'ステップが提供する別の演算子を試す機会が得られる。'ceil'演算子を使って、結果を最も近い整数値に切り上げることができる。

[source,groovy]
----
g.inject(Math.toRadians(45)).math('tan(_)').math('ceil(_)')

1.0
----


[[mathsignum]]
==== signum を使って選択する

'signum'演算子を使うと、下記に示すように、数値が正の数、負の数、あるいはゼロであるかに従って条件分岐することができる。

[source,groovy]
----
g.inject(-10).math('signum(_)')
-1.0

g.inject(10).math('signum(_)')
1.0

g.inject(0).math('signum(_)')
0.0
----

この機能を使うと、空港がグリニッジ子午線のどちらにあるかをレポートするクエリを作ることができる。'math'は倍精度の結果を返すので、'option'ステップの数値に'"D"'サフィックスを使う必要があることに注意してほしい。

[source,groovy]
----
g.V().hasLabel('airport').sample(12).
      project('IATA','city','position').
        by('code').
        by('city').
        by(choose(values('lon').math('signum(_)')).
          option(0D,constant('on the meridian')).
          option(1D,constant('East')).
          option(-1D,constant('West')))

----

クエリの実行からの出力の例を示す。

[source,groovy]
----
[IATA:LGW,city:London,position:West]
[IATA:STN,city:London,position:East]
[IATA:LIM,city:Lima,position:West]
[IATA:SYD,city:Sydney,position:East]
[IATA:VCE,city:Venice,position:East]
[IATA:FCO,city:Rome,position:East]
[IATA:OAK,city:Oakland,position:West]
[IATA:GVA,city:Geneva,position:East]
[IATA:LAS,city:Las Vegas,position:West]
[IATA:NRT,city:Tokyo,position:East]
[IATA:DME,city:Moscow,position:East]
[IATA:ALC,city:Alicante,position:West] 
----


[[stddev]]
==== 標準偏差を計算する

新しい'math'ステップを使って、グラフ内にある各空港の滑走路の本数についての標準偏差を計算するクエリを実装することができる。これから、'sqrt'と power(+++^+++)演算子を使っているのがわかる。ソリューションを無理やり1つのクエリにまとめるのではなく、3つのクエリに分割した。今でも3つのうちの最後のクエリは十分に複雑だと思っている。複数の'math'ステップが同じクエリ内で使われていて、1つのステップの結果が次のステップへの入力として使われていることに注意してほしい。

まず、グラフ中の滑走路の本数の平均値を計算してみよう。当然のことながら、空港の大多数には滑走路が1本か2本しかないので、この数は、1.5 近くになる。

[source,groovy]
----
// Average number of runways
mean=g.V().hasLabel('airport').values('runways').mean().next()

1.4309425014819206
----

また、標準偏差の計算の一部として分散を計算できるようにグラフにいくつの空港があるかを知る必要もある。

[source,groovy]
----
// Total number of airports
count = g.V().hasLabel('airport').count().next()

3374
----

これで平方根演算子とべき乗演算子を使って標準偏差を計算する準備が整った。注意点として、標準偏差はデータセットの分散の平方根を取ることによって求めることができる。分散自体は、空港ごとに、滑走路の本数から平均を引いて、それを2乗し、それらの値を合計し、最後に、その合計を空港の数で割ることで計算できる。それらをすべて実行できるクエリを書いてみよう。

[source,groovy]
----
// Calculate the standard deviation
g.withSideEffect("m",mean).
  withSideEffect("c",count).
  V().hasLabel('airport').values('runways').
  math('(_ - m)^2').sum().math('_ / c').math('sqrt(_)')

0.7510927827902234
----

別のクエリを使って、グラフ内の滑走路の分布を確認し、標準偏差の結果が信じられるかを確認できる。

[source,groovy]
----
 g.V().hasLabel('airport').groupCount().by('runways')

[1:2316,2:762,3:225,4:51,5:14,6:4,7:1,8:1]
----

大多数の空港には滑走路が1本か2本しかないという分布をみると、結果はかなり理にかなっているように見える。明らかに、滑走路が6本、7本、8本もあるいくつかの空港はこのサンプルの中で外れ値であり、計算した平均値からの標準偏差から大きく外れている。

楽しみにために、再度同じ基本的な手順を使ってみよう。ただし、今回はグラフ内の発経路数の標準偏差を計算する。

前と同様、データセットの平均値を見つける必要がある。今回は、グラフ内の発経路の平均値を見つける必要がある。もちろん、空港の数は同じだ。

[source,groovy]
----

mean=g.V().hasLabel('airport').local(out().count()).mean().next()

12.863070539419088

count = g.V().hasLabel('airport').count().next()

3374
----

これで、空港ごとのすべての発経路を表すデータセットの標準偏差を再度計算する準備が整った。

[source,groovy]
----
g.withSideEffect("m",mean).
  withSideEffect("c",count).
  V().hasLabel('airport').local(out().count()).
  math('(_ - m)^2').sum().math('_ / c').math('sqrt(_)')

28.356862649682018
----

今回は、滑走路を見たときと比べて、はるかに大きい数が返ってきた。これは主要空港とマイナーな空港との間の経路の分布の違いを反映している。

[[stddevone]]
==== 1つのクエリで標準偏差を計算する

前のセクションでは、標準偏差を計算する手順を3つのグラフクエリに分割した。下記に示すように、1つのクエリでタスク全体を実行することができる。

[source,groovy]
----
g.V().hasLabel('airport').
      values('runways').fold().as('runways').
      mean(local).as('mean').
      select('runways').unfold().
      math('(_-mean)^2').mean().math('sqrt(_)') 

0.7510927827902234
----

このアプローチを使うことは必要な値を生成するためにグラフへの複数のラウンドトリップを回避することができることを意味する。クエリは実際にはそれほど複雑ではない。どの手法がより便利かは個人の好みに依るかもしれない。一般的に複数のクエリを作ることが必ずしも悪いことではないが、この場合単一のクエリを使うことは、関連する手順にそれほど複雑さを付加しないので理にかなっていると思う。

[[mathproject]]
==== project を使って値をmath に入力する

'project'ステップを使ってキー／値のペアのマップを生成し、それを'math'ステップに渡すことができる。まず、オースティン空港における入経路と出経路の数を含んだ単純な射影を生成するクエリを作ってみよう。

[source,groovy]
----
g.V().has('code','AUS').
      project('in','out').
        by(__.in('route').count()).
        by(out('route').count())

[in:59,out:59]
----

これで、'project'ステップによって作られたマップのキー名を使って、その値を一緒に追加する'math'ステップを追加する。

[source,groovy]
----
g.V().has('code','AUS').
      project('in','out').
        by(__.in('route').count()).
        by(out('route').count()).
      math('in + out')

118.0
----

明らかに例を用意できていない演算子がまだほかにもいっぱいあるが、私がご用意した例は'math'ステップを使って興味ぶかいクエリを作成する方法を提供できているのでは、と思う。

[[withindex]]
=== 結果にインデックスを含める - withIndex と indexed を導入する

なんらかの理由によりクエリの結果の一部として、インデックス値を含めたいのであれば、下記に示すように、Groovyの'withIndex'あるいは'indexed'メソッドを使うとよい。 

NOTE: 次のセクションで説明するように、ネイティブの Gremlin の index ステップは Apache TinkerPop 3.4 リリースで導入された。

'withIndex'メソッドはリストの最後にインデックス値を追加するが、'indexed'メソッドはリストの最初にインデックス値をちゅいかする。開始のインデックス値をパラメータとして指定できる。もし値が指定されていないと、最初のインデックスのデフォルト値はゼロになる。


[source,groovy]
----
g.V().has('region','US-OK').values('code').withIndex()

[OKC,0]
[TUL,1]
[LAW,2]
[SWO,3]
----
NOTE: indexed と withIndex は Groovy のメソッドであり Gremlin トラバーサルステップではないことに注意してほしい。これらは、Groovy コードをクエリの一部に含めることができるグラフデータベースを使っている場合のみ機能する。

これは、前と同じクエリだが、開始インデックスとして1を使っている。

[source,groovy]
----
g.V().has('region','US-OK').values('code').withIndex(1)

[OKC,1]
[TUL,2]
[LAW,3]
[SWO,4]
----

下記は、再度使用されるクエリだが、今回は、'indexed'メソッドを使ってインデックス値が生成されている。

[source,groovy]
----
g.V().has('region','US-OK').values('code').indexed(1)

[1,OKC]
[2,TUL]
[3,LAW]
[4,SWO]
----

[[tp34index]]
==== TinkerPop 3.4 で追加された新しい index ステップ

2019年の初頭にリリースされた Apache TinkerPop バージョン 3.4では、ネイティブ'index'ステップが Gremlin 言語に追加された。index ステップのふるまいを制御するために使うことができる新しい'with'モジュレータも追加された。ネイティブの'Groovy'メソッドとは異なり、インデックスの範囲の開始値を指定する方法がない。 

TIP: index ステップに関する公式の Apache TinkerPop ドキュメントは、下記のリンクにある。 http://tinkerpop.apache.org/docs/current/reference/#index-step

'index'を使うのは、'list'や'map'などのようなコレクションのコンテキストでのみ本当に意味がある。下記に示すように、'fold'ステップがクエリにないと、結果セットはすべてインデックスがゼロの多数の個々のリストから成る。

[source,groovy]
----
g.V().has('code','LHR').
      out().limit(5).
      values('code').index()

[[HKG,0]]
[[PEK,0]]
[[PVG,0]]
[[FCO,0]]
[[BOM,0]]
----

しかしながら、'index'を呼び出す前に'fold'ステップがあれば、結果は、ゼロから1つずつインクリメントしたインデックス付けされる。 

[source,groovy]
----
g.V().has('code','LHR').
      out().limit(5).
      values('code').fold().index()

[[HKG,0],[PEK,1],[PVG,2],[FCO,3],[BOM,4]]
----

'unfold'ステップを追加すると、それぞれに空港コードとそのインデックスが含まれた個々のリストのセットが得られる

[source,groovy]
----
g.V().has('code','LHR').
      out().limit(5).
      values('code').fold().index().
      unfold()

[HKG,0]
[PEK,1]
[PVG,2]
[FCO,3]
[BOM,4]
----

新しい'with'モジュレータを使うと、'index'が生成するコレクションのタイプを制御することができる。結果をキーがインデックス値のマップとして返すためには、クエリは下記のように変更するとよい。

[source,groovy]
----
g.V().has('code','LHR').
      out().limit(5).
      values('code').fold().
      index().with(WithOptions.indexer,WithOptions.map)

[0:HKG,1:PEK,2:PVG,3:FCO,4:BOM]
----

最後に、下記の例はデフォルトであるリストとして結果を要求するたに使われる'with'ステップを示している。次に結果は、逆の順序でソートされる。

TIP: 'WithOptions'を使って指定可能なすべての値は、下記の場所の公式の Apache TinkerPop JavaDoc ドキュメントにある。
http://tinkerpop.apache.org/javadocs/current/full/org/apache/tinkerpop/gremlin/process/traversal/step/util/WithOptions.html

このクエリは現在非推奨の'decr'ではなく、'desc'を使って降順の結果を要求していることに注意してほしい。

[source,groovy]
----
g.V().has('code','LHR').
      out().limit(5).
      values('code').fold().
      index().with(WithOptions.indexer,WithOptions.list).
      unfold().
      order().by(tail(local,1),desc)

[BOM,4]
[FCO,3]
[PVG,2]
[PEK,1]
[HKG,0]
----


[[index-reverse]]
==== index を使ってリストを逆にする

Gremlin クエリ言語には、リストや他のコレクションの内容を逆順にするためのビルトインステップや関数は用意されていない。しかしながら、これは'index'ステップを使うと実現できる。下記の例は、indexステップを使って、リストの各要素にインデックス番号を付与している。

[source,groovy]
----
g.inject(['A','B','C','D']).index()

[[A,0],[B,1],[C,2],[D,3]]   
----

そのビルディングブロックが指定されるとそれらのインデックス値を使って、リストを並べ替えることができる。

[source,groovy]
----
g.inject(['A','B','C','D']).index().
  unfold().
  order().
    by(tail(local,1),desc)

[D,3]
[C,2]
[B,1]
[A,0]   
----

インデックス値が結果の一部にならないように、クエリをさらに絞り込むことができる。

[source,groovy]
----
g.inject(['A','B','C','D']).index().
  unfold().
  order().
    by(tail(local,1),desc).
  limit(local,1).
  fold()  

[D,C,B,A]     
----

同じ手法をクエリの一部として生成された任意のコレクションに対して使うことができる。

[source,groovy]
----
g.V().has('code','SAF').out().values('code').fold().index()

[[DFW,0],[LAX,1],[PHX,2],[DEN,3]] 
----

ここでも、index 値を使って結果を並べ替えることができる。

[source,groovy]
----
g.V().
  has('code','SAF').
  out().
  values('code').
  fold().
  index().
  unfold().
  order().
    by(tail(local,1),desc).
  limit(local,1).
  fold()

  [DEN,PHX,LAX,DFW]
----

[[sx]]
=== これまで取り上げてきた概念を使ったさらなる例

本セクションの例は、これまで取り上げてきたトピックに基づいている。下記のクエリは、ハワイ諸島のどの空港からでも飛ぶことができる都市を検索する。

[source,groovy]
----
// Which cities can I fly to from any airport in the Hawaiian islands? 
g.V().has('airport','region','US-HI').out().path().by('city')
----

このクエリを実行すると、下記と同様の結果が返る。結果セットのフルセットの一部のみが表示されている。

[source,groovy]
----
[Honolulu,San Francisco]
[Honolulu,Osaka]
[Honolulu,San Diego]
[Honolulu,Sapporo]
[Honolulu,Las Vegas]
[Honolulu,Sacramento]
[Honolulu,Denver]
[Kahului,Portland]
[Kahului,Sacramento]
[Kahului,Lahaina]
[Lihue,Oakland]
[Lihue,Vancouver]
[Lihue,Seattle]
[Lihue,San Francisco]
----

下記のクエリは開始点として'EU'のコードを持つ大陸の頂点を使って、ヨーロッパにある空港を検索する。結果は昇順でソートされ、リストにまとめられる。

[source,groovy]
----
// Find all the airports that are in Europe (The graph stores continent information 
// as "contains" edges connected from a "continent" vertex to each airport vertex.
g.V().has('continent','code','EU').out('contains').values('code').order().fold()
----

このクエリを実行すると、次のようになる。

[source,groovy]
----
[AAL,AAQ,AAR,ABZ,ACE,ACH,ACI,AER,AES,AEY,AGB,AGF,AGH,AGP,AHO,AJA,AJR,ALC,ALF,AMS,ANE,ANG,ANR,ANX,AOI,AOK,ARH,ARN,ARW,ASF,ATH,AUR,AVN,AXD,BAY,BCM,BCN,BDS,BDU,BEB,BEG,BES,BFS,BGO,BGY,BHD,BHX,BIA,BIO,BIQ,BJF,BJZ,BLE,BLK,BLL,BLQ,BMA,BNN,BNX,BOD,BOH,BOJ,BOO,BRE,BRI,BRN,BRQ,BRR,BRS,BRU,BSL,BTS,BUD,BVA,BVE,BVG,BWK,BZG,BZK,BZO,BZR,BZZ,CAG,CAL,CCF,CDG,CDT,CEE,CEG,CFE,CFN,CFR,CFU,CGN,CHQ,CIA,CIY,CLJ,CLY,CMF,CND,CPH,CRA,CRL,CSH,CSY,CTA,CUF,CVT,CVU,CWC,CWL,DBV,DCM,DEB,DIJ,DLE,DME,DND,DNK,DNR,DOK,DOL,DRS,DSA,DTM,DUB,DUS,EAS,EBA,EBJ,EBU,EDI,EFL,EGC,EGO,EGS,EIN,EMA,ENF,EOI,ERF,ESL,ETZ,EVE,EVG,EXT,FAE,FAO,FCO,FDE,FDH,FIE,FKB,FLR,FLW,FMM,FMO,FNC,FNI,FOA,FRA,FRO,FSC,FUE,GCI,GDN,GDZ,GEV,GIB,GLA,GLO,GMZ,GNB,GOA,GOJ,GOT,GPA,GRO,GRQ,GRV,GRW,GRX,GRZ,GSE,GVA,GWT,HAA,HAD,HAJ,HAM,HAU,HDF,HEL,HER,HFS,HFT,HHN,HMV,HOR,HOV,HRK,HUY,IAR,IAS,IBZ,IEV,IFJ,IFO,IJK,ILD,ILY,INI,INN,INV,IOA,IOM,ISC,IST,IVL,JER,JIK,JKG,JKH,JKL,JMK,JNX,JOE,JSH,JSI,JSY,JTR,JTY,JYV,KAJ,KAO,KBP,KEF,KEM,KGD,KGS,KHE,KID,KIR,KIT,KIV,KKN,KLR,KLU,KLV,KLX,KOI,KOK,KRF,KRK,KRN,KRP,KRR,KRS,KSC,KSD,KSF,KSJ,KSO,KSU,KTT,KTW,KUF,KUN,KUO,KVA,KVK,KVX,KZI,KZN,KZR,KZS,LAI,LBA,LBC,LCG,LCJ,LCY,LDE,LDY,LED,LEH,LEI,LEJ,LEN,LEQ,LGG,LGW,LHR,LIG,LIL,LIN,LIS,LJU,LKL,LKN,LLA,LMP,LNZ,LPA,LPI,LPK,LPL,LPP,LPY,LRH,LRS,LRT,LSI,LTN,LUG,LUX,LUZ,LWK,LWO,LXS,LYC,LYR,LYS,MAD,MAH,MAN,MCX,MEH,MHG,MHQ,MJF,MJT,MJV,MLA,MLN,MLO,MME,MMK,MMX,MOL,MPL,MQF,MQN,MRS,MRV,MSQ,MST,MUC,MXP,MXX,NAL,NAP,NBC,NCE,NCL,NDY,NDZ,NNM,NOC,NQY,NRK,NRL,NRN,NTE,NUE,NVK,NWI,NYO,ODS,OER,OGZ,OLA,OLB,OMO,OMR,OPO,ORB,ORK,ORY,OSD,OSI,OSL,OSR,OST,OSW,OSY,OTP,OUL,OVD,OZH,PAD,PAS,PDL,PDV,PED,PEE,PEG,PES,PEZ,PGF,PGX,PIK,PIS,PIX,PJA,PLQ,PMF,PMI,PMO,PNA,PNL,POR,POZ,PPW,PRG,PRN,PSA,PSR,PSV,PUF,PUY,PVK,PXO,RDZ,REG,REN,RET,REU,RGS,RHO,RIX,RJK,RJL,RKV,RLG,RMI,RNB,RNN,RNS,ROV,RRS,RTM,RTW,RVK,RVN,RYG,RZE,SBZ,SCN,SCQ,SCV,SCW,SDL,SDN,SDR,SEN,SFT,SGD,SIP,SJJ,SJZ,SKE,SKG,SKN,SKP,SKU,SKX,SLM,SMA,SMI,SNN,SOF,SOG,SOJ,SOU,SOY,SPC,SPU,SRP,SSJ,STN,STR,STW,SUF,SUJ,SVG,SVJ,SVL,SVO,SVQ,SXB,SXF,SYY,SZG,SZY,SZZ,TAY,TBW,TEQ,TER,TFN,TFS,TGD,TGK,TGM,THN,TIA,TIV,TKU,TLL,TLN,TLS,TMP,TOS,TPS,TRD,TRE,TRF,TRN,TRS,TSF,TSR,TUF,TXL,TYF,TZL,UCT,UDJ,UFA,UIP,UKS,ULV,ULY,UME,URE,URO,URS,USK,UTS,UUA,VAA,VAR,VAW,VBY,VCE,VDB,VDE,VDS,VGO,VHM,VIE,VIN,VIT,VKO,VLC,VLL,VLY,VNO,VOG,VOL,VOZ,VRN,VST,VTB,VUS,VXO,WAT,WAW,WIC,WMI,WRO,WRY,XCR,XFW,XRY,ZAD,ZAG,ZAZ,ZIA,ZQW,ZRH,ZTH]
----

次のクエリは6本以上の滑走路がある空港を検索する2つの方法を示している。

[source,groovy]
----
g.V().where(values('runways').is(gte(6))).values('code')

g.V().has('runways',gte(6)).values('code')
----

次に、南アメリカにある空港からマイアミへのフライトを検索する2つの方法を見てみよう。最初のクエリは、TInkerPop 2の時代には必要があった'select'を使う。2つ目のクエリは、私にはすっきりしているように感じるが、TinkerPop 3 で導入された'path'と'by'ステップの組み合わせを使っている。

[source,groovy]
----
g.V().has('continent','code','SA').out().as('x').out().as('y').
      has('code','MIA').select('x','y').by('code')

g.V().has('continent','code','SA').out().out().
      has('code','MIA').path().by('code')
----

このクエリはオースティン(AUS)をダラスフォートワース(DFW)と接続するエッジを検索し、そのエッジの'dist'プロパティを返すので、その旅程の距離がわかる。

[source,groovy]
----
// How far is it from DFW to AUS?
g.V().has('code','DFW').outE().as('a').inV().has('code','AUS').select('a').values('dist')

190
----

別のアプローチとして、空港コードと距離の両方を含んだパスを返すことができる。パスの一部としてエッジも必要とするので、'by'ステップを使って'dist'プロパティを取得できるように、'out'だけでなく、'outE'と'inV'を使う必要がある点に注目してほしい。

[source,groovy]
----
g.V().has('code','DFW').outE().inV().has('code','AUS').path().by('code').by('dist')

[DFW,190,AUS]
----

ブリスベンからオースティンへ経由1回で行ける方法があるかどうか見つけたいのであれば、このクエリを使うとよい。

[source,groovy]
----
// Routes from BNE to AUS with only one stop
g.V().has('code','BNE').out().out().has('code','AUS').path().by('code') 

[BNE,LAX,AUS]
----

これは同じことを行う別の方法ではあるが、繰り返しになるが、'path'を使うほうがすっきりしているように思える。このクエリの唯一の利点は、必要としているものは、途中の空港の名前だけの場合、それだけを得ることができることだ。

[source,groovy]
----
g.V().has('code','BNE').out().as('stop').
                        out().has('code','AUS').select('stop').values('code')

LAX
----

グラフを使っている際によくあることは、何かを数えることだ。次のクエリは出経路が5本未満の空港のすべてを検索し、それらを数える。これは、'route'のラベルがついた出エッジが5本未満の空港の数をカウントすることで行う。この少数の目的地を提供する空港は驚くほどいっぱいある。

[source,groovy]
----
// Airports with fewer than 5 outgoing edges
g.V().hasLabel('airport').where(out('route').count().is(lt(5))).count()

2058
----

同様に、このクエリは200を超えるの出経路を持つ空港を見つける。2つ目のクエリは、多くの場合、'where'が'filter'の同義語であることを示している。

[source,groovy]
----
g.V().hasLabel("airport").where(outE('route').count().is(gt(200))).values('code')

g.V().hasLabel("airport").filter(outE("route").count().is(gt(200))).values('code')
----

ここに、特定の条件を満たすものを見つけるさらに2つのクエリがある。1つ目は、距離が正確に100マイルの経路を見つけ、出発地と到着地の空港コードを返す。最初のクエリは、'as'と'select'を使って、2つ目のクエリは'path'を使い、結果に距離を含めている。

[source,groovy]
----
// List ten (or less) routes where the distance is exactly 100 miles
g.V().as('a').outE().has('dist',eq(100)).limit(10).inV().as('b').
      select('a','b').by('code')

[a:IAD,b:RIC]
[a:HNL,b:OGG]
[a:OGG,b:HNL]
[a:SJO,b:LIR]
[a:SVG,b:KRS]
[a:RIC,b:IAD]
[a:LIR,b:SJO]
[a:KRS,b:SVG]
[a:CYB,b:GCM]
[a:GCM,b:CYB]
----

前のクエリと同様ではあるが、'path'を使って空港コードと一緒に距離を表示している。

[source,groovy]
----
g.V().outE().has('dist',eq(100)).limit(10).inV().path().by('code').by('dist')  

[IAD,100,RIC]
[HNL,100,OGG]
[OGG,100,HNL]
[SJO,100,LIR]
[SVG,100,KRS]
[RIC,100,IAD]
[LIR,100,SJO]
[KRS,100,SVG]
[CYB,100,GCM]
[GCM,100,CYB]
----

このクエリは標高が10,000フィートを超える空港を検索する。多かれ少なかれ同じ結果が得られる2つの方法が示されている。1つ目は、'valueMap'を使っていて、2つ目は、代わりに'project'ステップを使っている。

[source,groovy]
----
// Airports above 10,000ft sorted by ascending elevation
g.V().has('airport','elev', gt(10000)).
      order().by('elev',asc).valueMap('city','elev')


g.V().has('airport','elev', gt(10000)).order().by('elev',asc).
      project('city','elevation').by('city').by('elev')
----

'project'ステップを使っているクエリを実行すると、このように返されるはずだ。

[source,groovy]
----
[city:Xiahe,elevation:10510]
[city:Leh,elevation:10682]
[city:Shangri-La,elevation:10761]
[city:Cusco,elevation:10860]
[city:Jauja,elevation:11034]
[city:Andahuaylas,elevation:11300]
[city:Jiuzhaigou,elevation:11327]
[city:Navoi,elevation:11420]
[city:Hongyuan,elevation:11598]
[city:Lhasa,elevation:11713]
[city:Oruro,elevation:12152]
[city:Xigaze,elevation:12408]
[city:Golog,elevation:12427]
[city:Juliaca,elevation:12552]
[city:Yushu,elevation:12816]
[city:Potosi,elevation:12913]
[city:Quijarro,elevation:12972]
[city:La Paz / El Alto,elevation:13355]
[city:Shiquanhe,elevation:14022]
[city:Kangding,elevation:14042]
[city:Bangda,elevation:14219]
[city:Daocheng,elevation:14472]
----

次のクエリはオースティンとシドニー間の経由地を1か所しか必要としない経路を見つける。'by'ステップを'path'と組み合わせて使ったきれいな方法を提供する。

[source,groovy]
----
g.V().has('code','AUS').out().out().has('code','SYD').path().by('code')
----

下記の3つのクエリは、すべて同じ結果が得られる。これらはアフリカ内の任意の空港からUS内の任意の空港へのフライトを検索している。これらのクエリは大陸の情報がグラフに大陸頂点と接続された空港頂点を結ぶエッジとして表現されるので、興味深い。これは Gremlin がSQLのジョイン文を得られたのとほぼ同じだ。

最初のクエリは空港を調べることから始まる、2つ目のクエリはアフリカを表す頂点から開始する。2つ目のクエリは'where'を使って同じ結果が得られる別の方法を示している。

[source,groovy]
----

g.V().hasLabel('airport').as('a').in('contains').has('code','AF').
      select('a').out().has('country','US').as('b').select('a','b').by('code')

g.V().hasLabel('continent').has('code','AF').out().as('a').
      out().has('country','US').as('b').
      select('a','b').by('code')

g.V().hasLabel('airport').where(__.in('contains').has('code','AF')).as('a').
      out().has('country','US').as('b').select('a','b').by('code')
----

このクエリを実行するとこのような結果が得られるはずだ。スペースを節約するために、2列にした。

[source,groovy]
----
[a:JNB, b:ATL]    [a:ACC, b:JFK]
[a:JNB, b:JFK]    [a:CMN, b:IAD]
[a:CAI, b:JFK]    [a:CMN, b:JFK]
[a:ADD, b:IAD]    [a:GCK, b:DFW]
[a:ADD, b:EWR]    [a:DKR, b:IAD]
[a:LOS, b:ATL]    [a:DKR, b:JFK]
[a:LOS, b:IAH]    [a:LFW, b:EWR]
[a:LOS, b:JFK]    [a:RAI, b:BOS]
[a:ACC, b:IAD]
----

下記のクエリは、TinkerPop 3 で導入された'project'ステップを使って、'order'や'select'と一緒に使って、滑走路の本数と一緒に、オースティンから飛ぶことができる空港のソート済みテーブルを生成する方法を示している。'limit'ステップは、上位10件の結果のみ返すために使われている。本書のどこかに、この一連のステップのバリエーションを使う例がいくつかある。

[source,groovy]
----
g.V().has('code','AUS').out().project('ap','rw').by('code').by('runways').
      order().by(select('rw'),desc).limit(10)
----

クエリを実行して得られる結果はこの通り。

[source,groovy]
----
[ap:ORD, rw:8]
[ap:DFW, rw:7]
[ap:BOS, rw:6]
[ap:DEN, rw:6]
[ap:DTW, rw:6]
[ap:YYZ, rw:5]
[ap:MDW, rw:5]
[ap:ATL, rw:5]
[ap:IAH, rw:5]
[ap:FRA, rw:4]
----

[[beq]]
== 基本的なクエリを超えて

これまで、主に、既存のグラフに対するクエリについてみてきた。これからのセクションでは、Gremlin を使う際に慣れておくことが重要な他の多くのトピックについてみていく。これらのトピックには、クエリに、Groovy コードや Java のコードを混在させることや、頂点（ノード）やエッジ、プロパティをグラフに追加、あるいは削除することが含まれる。また、サブグラフの生成方法や、グラフをXMLやJSONファイルなどに保存することについても見ていく。ではクエリレイアウト、予約語、データモデリングについて簡単に説明するところから始めよう。

[[indents]]
=== レイアウトとインデントについて一言

より複雑な Gremlin クエリを書き始めると、かなり長くなることがある。他の人が読みやすいように、複数行にわけて、意味のある方法でインデントすうｒことをお勧めする。私はインデント標準を提示するつもりはなく、これは個人的な好みに委ねるべきだと思うが、いくつか指摘しておきたいことがある。Gremlin コンソールを使う際に、クエリを複数行に分けたい場合は、各行をバックスラッシュで終わらせるか、ピリオドやコンマなどの文字で終了して、Gremlin パーサーにさらにクエリが続くことを知らせる必要がある。

下記の例は、本書のブール演算のセクションですでに見てきたクエリを示しているが、今回は、Gremlin コンソールに直接コピーペーストできるように編集されている。

[source,groovy]
----
g.V().hasLabel('airport') \
     .has('region',within('US-TX','US-LA','US-AZ','US-OK'))   \
     .order().by('region',asc)   \
     .valueMap().select('code','region')

----

クエリを下記のようにレイアウトすれば、バックスラッシュを使うのを回避できる。各行をさらにステップが続くことをパーサーに伝えるピリオドで終える。

[source,groovy]
----
g.V().hasLabel('airport').
      has('region',within('US-TX','US-LA','US-AZ','US-OK')).
      order().by('region',asc).
      valueMap().select('code','region')

----

パーサーにこれらのさらに続くことを伝えないと、Gremlin コンソールは次の行を待たずに各行を実行しようとする。

中には、各ステップ、あるいはモジュレータがごとに行をわけて適切にインデントした方が読みやすいという人もいる。なので、クエリを下記のようにレイアウトすることもできるが、これでも問題なく機能する。

[source,groovy]
----
g.V().hasLabel('airport').
      has('region',within('US-TX','US-LA','US-AZ','US-OK')).
      order().
        by('region',asc).
      valueMap().
      select('code','region')

----

バックスラッシュを継続文字として使うか、前の行にピリオドを残すかは、実際には個人的な好みだ。Gremlinコンソールで複数行のクエリを使うのであれば、必ずどちらか一方を使っていただきたい。より複雑なクエリをレイアウトする際に、何行にするか、インデントをどれだけするかについての黄金ルールはない。しかしながら、何に決めたとしても、あなたが作ったものを呼んでいる他の人にとっては、良くレイアウトされ、適切にインデントされたステップは読みやすく理解しやすいということを覚えておいてほしい。

[[rword]]
=== 予約語のコンフリクトと衝突に関する警告

ほとんどの場合、これから説明をする問題は、問題にはならない。しかしながら、Gremlin  ステップの名前が予約語や Groovy のメソッド名とコンフリクトする場合がある。覚えておいてほしいのは、Gremlin は Groovy や Java でコーディングされているということだ。これらのケースのいずれかに遭遇してしまったら、表示されたエラーメッセージでは、この特定の問題が発生したことが全く明確にならないことがよくある。いくつかの例を見てみよう。この名前の強豪に遭遇するGremlin のステップ名の１つは、'in'ステップだ。しかしながら、全ての場合において、これについて心配する必要はない。まず下記のクエリを見ていただきたい。

[source,groovy]
----
g.V().has('code','AUS').in()
----

このクエリはエラーを引き起こさず、正しく'AUS'頂点への入エッジとして接続されているすべての頂点を返す。ここでは、名前のコンフリクトはない。というのも、'in'参照は has ステップの結果へ適用されることが明らかだからだ。しかしながら、このクエリを見てほしい。

[source,groovy]
----
g.V().has('code','AUS').union(in(),out())
----

この場合、'in'はそれ自体であり、前のステップに'dot'接続されていない。Gremlin ランタイム (Groovy で書かれていることを覚えておいてほしい）はこれを解釈しようとし、エラーをスローする。というのも、これは'in'メソッドへの参照であるとみなすことができるからだ。このクエリを動かすには、下記のように、構文を少し調整する必要がある。

[source,groovy]
----
g.V().has('code','AUS').union(__.in(),out())
----

in ステップの前に、"\_\_."(アンダースコア、アンダースコア、ピリオド）を追加したことに注目してほしい。これは"現在参照しているもの" の短縮形なので、この場合は、has\_\_ ステップの結果だ。

現在、心配するべき Groovy の予約語は、それほど多くはない。注意すべき３つは、'in','not'そして'as'であり、ｋろえらはGremlin やGroovy の両方で特別な意味を持っている。但し覚えておいてほしいのは、'in'などの予約語が何に適用されるかが明確ではないときだけ '"__."' 表記を使う必要があるということだ。
'not'が '"__."' プレフィクスと一緒に使われている例は、少し後に出てくる "<<btree>>" のセクションにある。

[[dmodel]]
=== データモデルについて考える

効率的なGremlinクエリがうまく書けるようになることは重要ではあるが、それ以上ではないにせよ、データをグラフとしてどのようにモデル化するかを慎重に検討することも同様に重要だ。理想的には、グラフをアレンジして、処理する必要があると予測される最も一般的なクエリを効率的にサポートできるようにするとよい。

このクエリの説明を検討してみていただきたい。"アフリカ大陸と米国のどこかの空港間に存在するすべての飛行経路を見つけよ。"air-routes'グラフをまとめるときに、大陸を独自の頂点としてモデル化することにした。なので、７つの大陸それぞれに頂点がある。各頂点は"contains"というラベルの付いたエッジによりその大陸内にある空港と接続されている。

大陸を各空港頂点のプロパティにすることもできたが、そうしていたら、質問、”　”へ回答するには、グラフ中のすべての単一空港頂点を参照して、それがどの大陸に含まれているかを確認しなければならない。各大陸を独自の頂点とすることにより作成すべきクエリを大幅に簡略化できるようになる。

下記のクエリを見ていただきたい。まず、大陸の頂点だけを探す。次に、アフリカの頂点とそれが持つ接続のみを確認する（それぞれが異なる空港に接続される）。このやり方でクエリを開始することにより、効率的にグラフにある多数の空港を参照するのを回避できた。最後にアフリカにある空港から米国に到着する経路を参照する。これにより少なからずよくできたシンプルなクエリが得られる。というのも、グラフ中のデータモデルが非常簡単に実行できるからだ。

[source,groovy]
----
// Flights from any Airport in Africa to any airport in the United States
g.V().hasLabel('continent').has('code','AF').out().as('a').
      out().has('country','US').as('b').select('a','b').by('code')
----

また、各空港を調べて、それがアフリカにあるかどうかを確認することからクエリを始めることもできるが、それはさらに多くの頂点を調べる必要がある。ここで重要なのは、データモデルが優れていても、常に、より効率的にクエリを書く方法を検討する必要がある、ということだ。

[source,groovy]
----
// Gives same results but not as efficient
g.V().hasLabel('airport').as('a').in('contains').has('code','AF').
     .select('a').out().has('country','US').as('b').select('a','b').by('code')
----

'air-routes'のような非常に単純なグラフであれば、この効率性に関する議論はおそらくそれほど重要ではないが、大規模なグラフを扱い始めると、データモデルを正しくすることがクエリのレスポンスタイムの良し悪しの違いになる可能性がある。データモデルが悪い場合、巧妙なクエリを書くだけでその結果を常に回避できるとは限らない。

==== 同じグラフ内の２か所に情報を保持する

時々、クエリの効率を改善するために、同じグラフ内の複数の場所に、データを利用できるようにするとよいことがある。航空経路グラフのこの例では、私が国をモデル化することにした方法だ。国ごとに一意の頂点があるが、各空港頂点にも国コードをプロパティとして保持している。小さなグラフでは、これはおそらく過剰であり、私はそれを指摘した。下記の同じ結果、グラフ内で空港があるポルトガルの都市を返す２つのクエリを見てほしい。

[source,groovy]
----
g.V().has('country','code','PT').out("contains").values('city')

g.V().has('airport','country','PT').values('city')
----

最初のクエリはポルトガルの国の頂点を検索し、次に、それに接続されているすべての国を検索する。２つ目のクエリは、すべての空港頂点を調べて、国のプロパティとして'PT'が含まれているかを調べる。

最初の例では、3,000を超える空港頂点があるが、国の頂点は300未満なので、いくつかのエッジもウォークされるが、最初の例よりもはるかに少ない頂点が表示されるようだ。また、インデックスが設定されている本番システムでは、'Portugal'頂点の検索は非常に高速であるはずだ。

逆に、別の理由で、すでに空港頂点にアクセスしていて、それがどの国にあるかを確認したい場合は、その頂点の'country'プロパティを確認するだけの方が便利だ。

なので、ここには黄金ルールはないが、データモデルを設計する際に考えるべきことがいくつかある。

==== 他のデータソースへのインデックスとしてグラフを使う

グラフに何を保持すべきかというトピックにおいて、多くの場合に引き込まれるのを抗うことは、全てをグラフに完全に保持したい、という欲望だ。例えば、air routes グラフでは、私は空港に関するすべての単一の詳細（無線周波数、滑走路名、気象情報等）を空港の頂点に保持しているわけではない。これらの情報は他の場所でアクセスでき、すぐに見つけることができる。本番システムでは、グラフに何が必要か、そして自然に他の場所に何が属するかを注意深く検討する必要がある。私にできることの1つは、各空港頂点のプロパティとして空港のホームページや、すべての情報を含む他のリソースを指すURLを追加することだ。これだと、グラフは他のデータリソースへの高品質のインデックスになる。これはグラフを扱う際に一般的で便利なパターンだ。この複数のデータソースが連携するモデルは、'Polyglot storage'と呼ばれる。

==== スーパーノードに関して一言

グラフ内の頂点に多数のエッジがあり、それが不均衡にグラフ内の他の多くの頂点と接続されている場合、すべてはないにしても、結果の多くのグラフトラバーサルにその頂点が含まれることが多い。このような頂点(ノード）は'supernodes'と呼ばれることがある。'supernodes'があることが避けられない場合もあるが、グラフモデルを設計する際に慎重に計画することで、頂点が'supernodes'になる可能性を減らすことができる。'supernodes'について心配する理由は、グラフトラバーサルのパフォーマンスに大きな影響を与える可能性があるからだ。これは、そのような頂点をたどるグラフトラバーサルは、トラバーサルの一部としてその頂点に接続されている、すべてではないにしても、ほとんどのエッジを参照する必要がある可能性があるからだ。

'air-routes'グラフには'supernodes'として分類できるものは、実際にはない。エッジが最も多い頂点は、およそ980のエッジをもつ北米の大陸の頂点である。最も混雑する空港はISTとAMSで、両方とも530を少し超えるエッジがある。したがって、'air_routes'グラフの場合、あまり心配する必要はない。

有名人を含んだソーシャルネットワークのグラフを作成しているとしたら、心配する必要があるかもしれない。Twitterで数百万人のフォロワーを抱える人を何人か考えてみよう。いくつかの予防策を講じないと、グラフとしてモデル化されたそのようなソーシャルネットワークは問題に直面するかもしれない。

グラフモデルを設計する際、おそらく多数のエッジを接続する必要がある頂点としてより頂点プロパティとしてモデル化するほうが適切な場合があることは検討に値する。例えば、航空経路グラフでは、国の頂点があり、各空港は国頂点の1つと接続される。航空経路グラフでは、グラフ内のすべての空港がすべて同じ国にあり、その頂点に接続されているエッジが3,500未満であっても、これは問題ではない。しかしながら、非常に多くの人を含むグラフを作成している場合を想像してみてほしい。グラフ内の数百万人の人が同じ国に住んでいる場合、'lives in'エッジを使ってすべての人の頂点を国の頂点と接続することでその関連をモデル化すると、それは確実に'supernode'ができる。そのような状況では、人が住んでいる国をその人の頂点のプロパティとするほうがはるかに賢明だろう。

'supernode'の軽減に関する詳細な議論は、本書の範疇を超えるが、グラフを設計する際には常にその可能性について検討し、大きな問題になるのを防ぐ方法について検討するとよいと思われる。

[[grv]]
=== Gremlin をさらに Groovier にする

すでに議論してきたように、 Gremlin コンソールは Groovy コンソール上に構築されていて、Groovy 自体は Java でコーディングされている。これは Groovy や Java のプログラムを作成中に利用可能だと想定するすべてのクラスやメソッドが、Gremlin コンソールで作業する際にも利用可能であるということを意味する。必要に応じて、Groovy クラスと Java クラスの追加機能を、TinkerPop3 クラスによって提供される機能と組み合わせることができる。この機能により、 Gremlin はさらに強力になる。また、Gremlin サーバや他のTinkerPop 対応グラフサービスを使う場合にもこれらの機能を使うことができるが、サーバにとってもし潜在的なセキュリティリスクとみなされた場合、あるいは単にサポートされていないために、いくつかの機能はブロックされる可能性があることに注意してほしい。

これまで紹介したすべてのGremlin クエリは、実際には有効なGroovy でもある。すでに値を変数に格納し、単一のあるいは複数の部分からなるGremlin クエリの一部としてGroovy 構造を使ってループする例をお見せした。

本セクションでは、さらに1歩すすんで、Groovy 構文を使って、Gremlin コンソール内で実行できるいくつかのメソッドを実際に定義する。単純な例として、2つの空港がどれだけ離れているかを返してそれを呼び出すメソッドを定義してみよう。

[source,groovy]
----
// A simple function to return the distance between two airports
def dist(g,from,to) {
  d=g.V().has('code',from).outE().as('a').inV().has('code',to)
         .select('a').values('dist').next()
  return d }

// Can be called like this
dist(g,'AUS','MEX')
----

この次の例は、頂点の次数に関する情報を人に読みやすい形式で出力する少し長いメソッドを定義する方法を示している。

[source,groovy]
----
// Groovy function to display vertex degree
def degree(g,s) {
  v = g.V().has('code',s).next();
  o=g.V(v).out().count().next();
  i=g.V(v).in().count().next() ;
  println "Edges in  : " + i;
  println "Edges out : " + o;
  println "Total     : " +(i+o);
}  

// Can be called like this
degree(g,'LHR')
----

これは、グラフをクエリして、値のリストを取得し、次に'for'ループを使ってそれらを表示する方法を示す例だ。今回は、最初にクエリの結果を変数'x'に格納する方法に注目してほしい。'toList'を呼ぶ出すと'x'に返された値のリスト(配列）が含められる。

[source,groovy]
----
// Using a Groovy for() loop to iterate over a list returned by Gremlin
x=g.V().hasLabel('airport').limit(10).toList()
for (a in x) {println(a.values('code').next()+" "+a.values('icao').next()+" "+a.values('desc').next())}

// We can also do this just using a 'for' loop and not storing anything into a variable.
for (a in g.V().hasLabel('airport').limit(10).toList()) {println(a.values('code').next()+""+a.values('icao').next())}
----

時々（上述したように）変数に返されると期待する結果を得るために'next'を呼び出す必要がある。

[source,groovy]
----
number = g.V().hasLabel('airport').count().next()
println "The number of airports in the graph is " + number
----

これが'for'ループ内に Gremlin クエリを作成する別の例だ。

[source,groovy]
----
for (a in 1..10) print g.V().has(id,a).values('code').next()+" "
----

この例は、頂点ラベルをキーとして、コードプロパティを値として、頂点のハッシュを返す。次にラベル名を使って返されたハッシュにアクセスする。
                                          
[source,groovy]
----
a=g.V().group().by(label).by('code').next()
println(a["country"].size())  
println(a["country"][5])  
println(a["airport"][2]) 
----

これは、別の例だ。今回は、入力としてトラバーサルオブジェクトと空港のコードを受け取るメソッドを定義する。次に、これらのパラメータを使って単純な Gremlin クエリを実行し、その空港から飛ぶことができるすべての場所を取得する。次に、単純な'for'ループを使って結果をテーブルに出力する。'next'を'println'の一部に使っていることに注意してほしい。これは、探している実際の値を取得するために必要とされる。'next'の呼び出しを含めていなかったら、実際の値ではなく、実際にはイテレータオブジェクト自体が返される。

[source,groovy]  
----
// Given a traversal and an airport code print a list of all the places you can 
// fly to from there including the IATA code and airport description.
def from(g,a) {
  places=g.V().has('code',a).out().toList();
  for (x in places) {println x.values('code').next()+" "+x.values('desc').next()}
}

// Call like this
from(g,'AUS')
----

この例では、IATAコードをキーとして使ってすべての空港のハッシュマップを生成する。次に、IATAコードを使ってマップにアクセスし、それらの空港の情報を照会することができる。注意していただきたいのは、クエリの最後にある ';[]'は、コンソールが不要な出力を表示しないようにするだけであることだ。

[source,groovy]
----
// Create a map (a) of all vertices with the code property as the key
a=g.V().group().by('code').next();[]

// Show the description stored in the JFK vertex
a['JFK'][0].values('desc')  
----

変数を使う別の便利な方法は、変数を確立して次に'fill'ステップを使ってクエリの結果を変数に入れるというものだ。下記の例では、'german'という空のリストを作る。次にクエリはドイツにある空港のすべての頂点を検索し、'fill'ステップを使ってそれらを変数に格納している。

[source,groovy]
----
german = []
g.V().has('airport','country','DE').fill(german)
----

そのあとは想定通りにリストを使うことができる。Gremlin コンソール内で実行しているので、スタンドアロンの Groovy アプリケーションを作成する場合のように、明示的にリストをイテレートする必要がない点は覚えておいてほしい。

[source,groovy]
----
// How many results did we get back?
german.size

32

// Query some values from one of the airports in the list
german[0].values('city','code')

FRA
Frankfurt

// Feed an entry from our list back into a traversal
g.V(german[1]).values('city')

Munich

g.V(german[1]).out().count()

237
----

本書の終わりのほうの、"<<groovyapp>>"のセクションで、Gremlin コンソールの外部でスタンドアロンアプリケーションとして実行してTinkerPop API を使って Gremlin クエリを発行する スタンドアロンの Groovy コードの書き方について説明する。

[[varaus]]
==== 変数を使ってトラバーサルをフィードする

クエリの結果を変数に格納し、後でその変数を使って新しいトラバーサルを開始するととても便利なことがある。前のセクションの最後の例で、'german'変数をトラバーサルにフィードバックしていたことにお気づきかもしれない。別の簡単な例として、下記のコードは、最初のクエリ結果を変数'austin'に格納し、それを使って2つ目のクエリでオースティンからの経路を検索している。オースティン頂点を含む変数を'V()'ステップに渡すことで行う方法に注目してほしい。

[source,groovy]
----
 austin=g.V().has('code','AUS').next()
 g.V(austin).out()
----

この手法をさらに1歩進めて、保存されている頂点のリスト全体を'V()'に渡すことができる。次の例では、まずスコットランドにあるすべての空港のリストを生成し、次にそのリスト全体を'V()'に渡し、まず、それらの空港からの経路の数をカウントし、それらの空港からドイツの空港への経路を検索する他のクエリを開始する。

[source,groovy]
----
// Find all airports in Scotland
a=g.V().hasLabel('airport').has('region','GB-SCT').toList()

// How many routes from these airports?
g.V(a).out().count()

// How many of those routes end up in Germany?
g.V(a).out().has('country','DE').values('code')
----

変数を使ってトラバーサルを駆動するこの例では、再度空港のリストを生成する。今回はテキサスにあるすべての空港を検索する。次に、Groovyの'each'ループを使ってリスト全体をイテレートする。リストにある各空港について、出発空港のコードを出力し、次にそこから飛ぶことができるすべての空港のコードを出力する。

[source,groovy]
----
// Find all of the airports in Texas
texas=g.V().has('region','US-TX').toList()

// For each airport, print a list of all the airports that you can fly to from there.
texas.each {println it.values('code').next() + "===>" + 
                    g.V(it).out().values('code').toList()}
----

この例では、確かに少し工夫されているが、'has'ステップ内で変数を使っている。最初にグラフ内の各空港のすべての IATA コードを含むリストを作成する。次にそのリストをイテレートして、各場所からの出経路の数を計算し、空港のIATAコードとその空港の数を含む文字列を出力する。これは Groovy コードを追加せずに、Gremlin クエリを使うだけで簡単に実行できることに注意してほしい。この例のポイントは、Gremlin 、Groovy、および変数が混成された別の例を示すことである。この種のことができることを知っていると、Gremlin を使ったより複雑なグラフデータベースアプリケーションを書き始める際に役に立つ場合がある。Gremlin だけを使って実行するこのタイプのクエリについては、本書の後半にある "<<unwantededges>>"というセクションにある。

[source,groovy]
----
m=g.V().hasLabel('airport').values('code').toList()
for (a in m) println a + " : " + g.V().has('code',a).out().count().next()
----

最後に、これは、値の配列を使ってクエリをシードする例である。

[source,groovy]
----
['AUS','RDU','MCO','LHR','DFW'].
     each {println g.V().has('code','JFK').outE().inV().
                         has('code',it).path().by('code').by('dist').next()}
----

これは、このコードを実行した出力である。

[source,groovy]
----
[JFK, 1520, AUS]
[JFK, 427, RDU]
[JFK, 945, MCO]
[JFK, 3440, LHR]
[JFK, 1390, DFW]
----


[[addnodes]]
=== 頂点、エッジ、プロパティを追加する

本書のこれまでのところ、ファイルからグラフをロードし、それに対しクエリを実行することに主にフォーカスしてきた。独自のグラフの構築を開始する際に、GraphML, CSV, GraphSON あるいはその他のフォーマットでテキストファイルとして保存されたグラフから開始できるとは限らない。空のグラフから開始し、頂点やエッジを段階的に追加していくこともできる。air routes グラフのようなグラフから始めて、ファイルから読みこむが、時間の経過とともに、頂点やエッジ、プロパティを追加したくなることがある。本セクションではそれを行うための様々な方法について説明する。

頂点とエッジは'graph'オブジェクトを使ってグラフに直接追加するか、あるいはグラフトラバーサルの一部として追加することもできる。これよりこれらの両方の手法について説明していく。

==== 空港（頂点）と経路（エッジ）を追加する

下記のコードは最初に'air-routes'グラフをロードする際に作成した'graph'オブジェクトを使って新しい空港頂点（ノード）を生成し、そこから既存のDFW頂点への経路（エッジ）を追加する。頂点の作成中に、ラベル名（'airport') と必要な数のプロパティを指定できる。この場合、3つ指定している。頂点が作成された後、頂点プロパティを追加したり削除したりできる。このように'graph'オブジェクトを使う方法は機能するが、代わりにトラバーサルソースオブジェクト'g'を使って、トラバーサルを使って頂点とエッジを追加することを強くお勧めする。そのやり方の例が次に出てくる。

[source,groovy]
----
// Add an imaginary airport with a code of 'XYZ' and connect it to DFW
xyz = graph.addVertex(label,'airport',
                      'code','XYZ',
                      'icao','KXYZ',
                      'desc','This is not a real airport')

// Find the DFW vertex
dfw = g.V().has('code','DFW').next()

// Create a route from our new airport to DFW
xyz.addEdge('route',dfw)
----

多くの場合、トラバーサルオブジェクト'g'だけを使って前の各操作を実行するほうが便利であり、おすすめする。下記の例は、まさにそれを行っている。まず架空の空港の新しい空港頂点を生成し、その頂点を変数'xyz'に格納する。そのあと、トラバーサルを使ってエッジを作る際にその保存された値を使うことができる。 Gremlin 言語の多くの部分と同様、同じ結果を得る方法は多数ある。

[source,groovy]
----
// Add an imaginary airport with a code of 'XYZ' and connect it to DFW
xyz = g.addV('airport').property('code','XYZ').
                        property('icao','KXYZ').
                        property('desc','This is not a real airport').next()

----

上記のコードでは、複数のプロパティを追加する際に、各プロパティステップを前のステップに連鎖させる方法に注目してほしい。頂点の作成中に行う必要がある場合でも、あとで頂点のプロパティを追加および編集する必要がある場合でも、同じ'property'ステップを使うことができる。

NOTE: 頂点はエッジを追加、更新、削除する際は、トラバーサルソースオブジェクト g を使うことを強くお勧めする。グラフオブジェクトを直接つかうことは TInkerPop のベストプラクティスとはみなされない。

これで、DFWからXYZへの経路を追加することができる。'xyz'変数を使って'to'ステップを使って新しい経路の宛先を指定する。

[source,groovy]
----
// Add a route from DFW to XYZ
g.V().has('code','DFW').addE('route').to(xyz)
----

前に変数に何も保存していなかったら、2つ目の'V()'ステップを使うように前の行を書けたはずだ。この2つ目の'V()'ステップを使うことはローカルで機能するがクエリをGremlin サーバに送付する（本書の後半で扱うトピック）と、この構文はサポートされないし、動作しない点に注意してほしい。

[source,groovy]
----
g.V().has('code','DFW').addE('route').to(V().has('code','XYZ'))
----

また、XYZからDFWに戻る経路を追加することもできる。上記の'to'ステップを使ったのと同じ方法で'from'ステップを使ってこれを行うことができる。

[source,groovy]
----
// Add the return route back to DFW
g.V().has('code','DFW').addE('route').from(xyz)
----

エッジを作成するために選択できた別の方法は、as ステップを使って"XYZ"頂点にラベルをつけることだ。下記の例ではこれを示している。'V'ステップをどのように使って、現在のトラバーサルの途中で新しいトラバーサルを開始するのかにも注目してほしい。as ステップを使って作られたラベルは新しいエッジのターゲット頂点についての to ステップを構築するのに使われる

[source,groovy]
----
g.V().has('code','XYZ').as('a').V().has('code','DFW').addE('route').to('a')
----

NOTE: Apache TinkerPop の以前のバージョンでは、addOutE ステップがあった。ここのステップはその後非推奨となり、言語から削除され、常にaddE を使うようになった。

頂点やエッジを作成する際に'as'ステップを使ったもっと大きな例が、"<<testgraph>>"のセクションにあり、まもなく登場する。

[[addlabeldynamic]]
==== トラバーサルを使って新しいラベル名を決定する

TinkerPop 3.3.1 で新しい機能が'addV'や'addE'ステップに追加された。この新しい機能により、トラバーサルを使って、新しい頂点やエッジで使われるラベルを決定できるようになった。下記のクエリを見ていただきたい。このタイプのクエリは、本書の前のほうで使われている。これは、単にオースティン(AUS)空港を表す頂点が持っているラベルを示しているだけだ。

[source,groovy]
----
g.V().has('code','AUS').label()

airport
----

TinkerPop 3.3.1 で追加された新しい機能により、下記に示すように、'addV'ステップ内に上記のトラバーサルを含めることができるようになった。提供されたトラバーサルによって返された最初の文字列の結果がラベル名として使われる。

[source,groovy]
----
g.addV(V().has('code','AUS').label()).property('code','XYZ')

v[53768]
----

'valueMap'を使って新しい頂点を検査し、ラベルが正しく割り当てられているかを確認することができる。

[source,groovy]
----
g.V(53768).valueMap(true)

[id:53768,code:[XYZ],label:airport]
----

TIP: これらの機能を使うには、使っているグラフデータベースシステムが TinkerPop の 3.3.1 以降をサポートしていることが必要である。

これで、新しい空港とオースティンの間のエッジのラベルを動的に計算するのと同様のことができる。

[source,groovy]
----
g.V(53768).addE(V().has('code','AUS').outE().limit(1).label()).
           to(V().has('code','AUS'))

e[53770][53768-route->3]
----

NOTE: 本書の後半で、これらの概念に基づいて、１つの頂点からプロパティのキーと値、並びにラベルを新しい頂点へ単一のクエリを使ってコピーする方法を示す。

繰り返すが、'valueMap'ステップを使うと、新しいエッジラベルが正常に見えることを確認できる。

[source,groovy]
----
g.E(53770).valueMap(true)

[id:53770,label:route]
----


[[proptraversal]]
==== トラバーサルを使ってプロパティにリストをシードする

トラバーサルの結果を使ってプロパティを生成、あるいは更新することができる。下記の例では、オースティン空港の頂点に'places'という新しいプロパティを生成している。そのプロパティの値は、その空港から旅することができるすべての場所を見つけ、その'code'の値をリストにまとめた結果である。

[source,groovy]
----
// Add a list as a property value
g.V().has('code','AUS').property('places',out().values('code').fold())
----

'valueMap'ステップを使ってプロパティが期待通りに生成されたことを確認することができる。ご覧のとおり、'places'という新しいプロパティが生成され、その値としてコードのリストが含まれている。

[source,groovy]
----
g.V().has('code','AUS').valueMap('places')

[places:[[YYZ, LHR, FRA, MEX, PIT, PDX, CLT, CUN, MEM, CVG, IND, MCI, DAL, STL, ABQ, MDW, LBB, HRL, GDL, PNS, VPS, SFB, BKG, PIE, ATL, BNA, BOS, BWI, DCA, DFW, FLL, IAD, IAH, JFK, LAX, MCO, MIA, MSP, ORD, PHX, RDU, SEA, SFO, SJC, TPA, SAN, LGB, SNA, SLC, LAS, DEN, MSY, EWR, HOU, ELP, CLE, OAK, PHL, DTW]]]
----

コードあるいは Gremlin コンソールのクエリからこれらの値にアクセスするには、'next'ステップを使うとよい。'values'を使って'places'プロパティの値を取得し、次に'size'を使ってリストにエントリをがいくつあるかを確認する簡単な例を下記に示す。

[source,groovy]
----
g.V().has('code','AUS').values('places').next().size()

59
----

値のリストへのアクセスができるようになると、通常の Groovy の配列の構文を使ってそれらにアクセスできるようになる。下記の例は、インデックスが２から４の間の３つの値を返す。

[source,groovy]
----
g.V().has('code','AUS').values('places').next()[2..4]

FRA
MEX
PIT
----

[[injectid]]
==== inject を使って新しい頂点のIDの値を指定する

使っているグラフデータベースがユーザの指定するIDの値をサポートしているのであれば、新しい頂点のID値を指定する１つの方法として'inject'ステップを使うことができる。例えば下記の例を考えてみよう。

[source,groovy]
----
g.inject(99999L).addV().property(id,identity())

v[99999]
----

複数の頂点を作成した場合は、複数のID値を指定することもできる。

[source,groovy]
----
g.inject(99997L,99998L).addV().property(id,identity())

v[99997]
v[99998]
----

興味深い例を提供するために、'inject'を使い方を示すことにした。しかしながら、この方法で新しいIDを生成することは必要ではない。下記の両方の例は、同じことを行うための正しい方法でもある。最初の例ではリテラル値を使っているだけだ。

[source,groovy]
----
g.addV().property(id,99999L)

v[99999]
----

あるいは、変数を渡すこともできる。

[source,groovy]
----
n=99999L;
g.addV().property(id,n)

v[99999]
----

NOTE: これらのIDを指定する方法は、使っているグラフデータベースで独自のID値を指定できる場合に限り機能することに注意してほしい。これは、グラフデータベースの実装により異なるので、独自のカスタムID値を作成できると仮定する前に、使っているシステムのドキュメントを確認すべきだ。

使っているグラフデータベースがユーザ指定のID値をサポートしている場合でも、それらの使用できるデータ型を確認するべきだ。上記の例はいづれもLONG値を使っている。しかしながら、一例として、グラフデータベースの中には独自のカスタムID値に、文字列値しかサポートしないものもある。なので、重要な点は、グラフの作成を始める前にドキュメントを確認することだ。

グラフデータベースがカスタムID値をサポートしていない場合でも、既存のIDを使って頂点を作成しようとすると、操作は失敗する。下記の例は、TinkerGraph に既存のIDを使って頂点を追加しようとするとどうなるかを示している。

[source,groovy]
----
g.inject(99999L).addV().property(id,identity())

Vertex with id already exists: 99999
----

[[testgraph]]
==== テスト用のグラフを素早く構築する

テストをしたり、問題を報告したり、メーリングリストで助けを求めたりする際に、使用できる小さなスタンドアロンのグラフがあると便利だ。下記のコードは、Gremlin コンソールに小さいバージョンのair routes グラフを作成する。すべての頂点とエッジが、各ステップが結合されている１つのクエリで生成されている点に注目してほしい。

[source,groovy]
----
graph=TinkerGraph.open()
g=graph.traversal()
g.addV('airport').property('code','AUS').as('aus').
  addV('airport').property('code','DFW').as('dfw').
  addV('airport').property('code','LAX').as('lax').
  addV('airport').property('code','JFK').as('jfk').
  addV('airport').property('code','ATL').as('atl').
  addE('route').from('aus').to('dfw').
  addE('route').from('aus').to('atl').
  addE('route').from('atl').to('dfw').
  addE('route').from('atl').to('jfk').
  addE('route').from('dfw').to('jfk').
  addE('route').from('dfw').to('lax').
  addE('route').from('lax').to('jfk').
  addE('route').from('lax').to('aus').
  addE('route').from('lax').to('dfw')                                               
----

NOTE: g.addV(label, "airport", "code", "AUS") のような頂点やプロパティを生成できりょうにするためのaddV の形式は廃止されたので、使わないように。

[[addloop]]
==== ループを使って頂点とエッジを追加する

グラフに追加しようとしている頂点やエッジの詳細を配列に定義して、単純な'for'ループを使って繰り返し各頂点やエッジを追加すると効率的な場合がある。下記の例は、そのようなループを使って架空の空港を直接グラフに追加している。作りたい各頂点にIDを指定する必要ない点に注目してほしい。グラフは新しい頂点ごとに、一意のIDを割り当てる。

[source,groovy]
----
vertices = [["WYZ","KWYZ"],["XYZ","KXYZ"]]
for (a in vertices) {graph.addVertex(label,"airport","code",a[0],"iata",a[1])}
----

下記のように、トラバーサルオブジェクト'g'を使って頂点を追加することもできる。'next()'の呼び出しに注目してほしい。これがないと、頂点の生成は思った通りに機能しない。

[source,groovy]
----
vertices = [["WYZ","KWYZ"],["XYZ","KXYZ"]]
for (a in vertices) {g.addV("airport").property("code",a[0],"iata",a[1]).next()}
----

'for'ループを使って頂点やエッジを生成するこの手法は、HTTP接続を介してリモートでグラフを扱う際にも便利だ。これは、一連の作成ステップを１つのREST API 呼び出しの中で組み合わせるのにとても便利な方法である。

よりGroovy ライクな構文をいいのであれば、このようにもできる。

[source,groovy]
----
vertices = [["WYZ","KWYZ"],["XYZ","KXYZ"]]
vertices.each {g.addV("airport").property("code",it[0],"iata",it[1]).next()}
----

[[coaladdv]]
==== coalesce を使って存在しない場合のみ頂点を追加する

<<coalconst>> のセクションでは、探している他のエンティティが存在しない場合に、定数値を返すためにcoalesce が使える方法を見てきた。そのパターンを再利用してまだ頂点が生成されていない場合にのみグラフに頂点を追加するトラバーサルを生成することができる。

コードが'"XYZ"'の新しい空港を追加したいが、その空港がすでに追加されているかどうかわからないとしよう。

基本的な'has'ステップを使うと、その空港が存在するかどうかを確認することができる。

[source,groovy]
----
g.V().has('code','XYZ')
----

まだ存在しない場合、その場合はないが、何も返されない。さらに１歩進んで、空港が存在しない場合は、'fold'ステップをクエリに追加して、空のリスト'[]'を返すようにクエリを変更するとよい。

[source,groovy]
----
g.V().has('code','XYZ').fold()

[]
----

これで、頂点が存在しない場合に、空のリストを返すことができるクエリができたので、'coalesce'ステップでこれを使うことができる。下記のクエリは、空港がすでに存在するかを確認して、その結果を'coalesce'ステップに渡す。'coalesce'は、最初に調べたトラバーサルの結果を返し、それがよい結果を返すことに注意してほしい。最初のパラメータは'coalesce'や'unfold'ステップに渡すことができる。このように、空港が存在しない場合、'unfold'は何も返さないので、'coalesce'は２番目のステップを試みる。この場合、２番めのステップで空港 '"XYZ"' の頂点を生成する。

[source,groovy]
----
g.V().has('code','XYZ').fold().coalesce(unfold(),addV().property('code','XYZ'))

v[53865]
----

ご覧の通り、上記のクエリは、IDが53865 の新しい頂点を'XYZ'空港がまだ存在しなかったので、生成した。しかしながら、同じクエリを再度実行すると、新しい頂点ではなく、作成したばかりの同じ頂点が返されることに注意してほしい。これは、今回は'coalesce'ステップが、'unfold'ステップの結果を*検出し*、'addV'ステップを試行する前に完了したからだ。

[source,groovy]
----
g.V().has('code','XYZ').fold().coalesce(unfold(),addV().property('code','XYZ'))

v[53865]
----

[[upsert]]
==== coalesce を使ってアップサーとパターンを導出する

このように、'coalesce'を使うと、更新や作成を試みる前に、すでに存在するかどうかを確認するという一般的に実行されるタスクの有用なパターンが得られる。これは、操作が頂点の存在の有無に基づいて、頂点を更新あるいは挿入するので、しばしば'"upsert"'パターンと呼ばれる。

下記のクエリは、おそらく'"upsert"'の好例だと思われる。このクエリは、IDが3 の頂点がすでに存在するかどうかを確認する。もしあれば、 その頂点の'runways'プロパティの値を３に更新する。もし存在しなければ、新しい頂点とプロパティを作成する。頂点 v[3] がすでに存在そ、クエリがそれを返すので、'runways'プロパティが更新された。

[source,groovy]
----
g.V(3).fold().
       coalesce(unfold().property('runways',3),
       addV('airport').property('runways',3))

v[3]
----

ここで、頂点 v{3] のプロパティを調べると、'runways'の値が３に設定されていることがわかる。

[source,groovy]
----
g.V(3).valueMap().unfold()

country=[US]
code=[AUS]
longest=[12250]
city=[Austin]
elev=[542]
icao=[KAUS]
lon=[-97.6698989868164]
type=[airport]
region=[US-TX]
runways=[3]
lat=[30.1944999694824]
desc=[Austin Bergstrom International Airport]
----

air routes グラフには、IDが9999999の頂点がない。なので、前の'"upsert"'クエリを実行すると、今回は新しい頂点が作成される。

[source,groovy]
----
g.V(9999999).fold().
             coalesce(unfold().property('runways','3'),
             addV('airport').property('runways',3))

v[57343] 
----

新しい頂点の'valueMap'を見ると、予想通りに、作成されていることがわかる。

[source,groovy]
----
g.V(57343).valueMap().unfold()

runways=[3]
----

この手法は、現在、Gremlin で'"upsert"'操作を実行する上での推奨される方法である。

[[vertexcopy]]
==== 別の頂点に基づいて１つの頂点を作成する

既存の頂点からラベルとプロパティを使って新しい頂点を生成できると便利な場合がある。"<<addlabeldynamic>>" のセクションで他のラベルを使って新しいラベルを作るいくつかの方法をすでに見てきたが、ある頂点から別の頂点へプロパティを複製する方法については、まだ説明していない。これを行う手法は"<<dfwcopy>>" のセクションで説明している。読み飛ばしていただいてもよいが、そのセクションで使われている手法についてはまだ完全には説明していないので、途中で他のセクションを参照することをお勧めする。

[[deleting]]
=== 頂点、エッジ、プロパティを削除する

本書ではこれまで、新しい頂点、エッジ、プロパティを作成するためのいくつかの例を見てきたが、それらを削除する方法については、まだ説明できていない。Gremlin では、グラフから何かを削除できるように'drop'ステップが用意されている。

==== 頂点を削除する

以前のいくつかの例では、コード'XYZ'の架空の空港の頂点を作成し、それを air routes グラフに追加した。それを削除したい場合は、下記の Gremlin コードを使うことができる。頂点を削除すると、その頂点に接続して作成したエッジもすべて削除されることに注意してほしい。

[source,groovy]
----
// Remove the XYZ vertex
g.V().has('code','XYZ').drop()
----

[[deledge]]
==== エッジを削除する

特定のエッジを削除するために、'drop'を使うこともできる。下記のコードはAUS と LHR 間の両方向のフライトを削除する。

[source,groovy]
----
// Remove the flight from AUS to LHR (both directions).
g.V().has('code','AUS').outE().as('e').inV().has('code','LHR').select('e').drop()
g.V().has('code','LHR').outE().as('e').inV().has('code','AUS').select('e').drop()
----

[[delprop]]
==== プロパティを削除する

最後に、'drop'を使って特定の頂点から特定のプロパティの値を削除することができる。'air-routes'グラフで定義されたサンフランシスコ空港のプロパティをクエリすることから始めよう。

[source,groovy]
----
g.V().has('code','SFO').valueMap()

[country:[US],code:[SFO],longest:[11870],city:[San Francisco],elev:[13],icao:[KSFO],lon:[-122.375],type:[airport],region:[US-CA],runways:[4],lat:[37.6189994812012],desc:[San Francisco International Airport]]
----

次に、'desc'プロパティを削除して、プロパティの値を再度クエリして削除されたことを確認しよう。

[source,groovy]
----
g.V().has('code','SFO').properties('desc').drop()

g.V().has('code','SFO').valueMap()

[country:[US],code:[SFO],longest:[11870],city:[San Francisco],elev:[13],icao:[KSFO],lon:[-122.375],type:[airport],region:[US-CA],runways:[4],lat:[37.6189994812012]]
----

現在、SFO空港の頂点に関連づけられているプロパティをすべて削除したい場合は、下記のようにする。

[source,groovy]
----
g.V().has('code','SFO').properties().drop()
----

==== グラフにあるすべてのエッジ、あるいは頂点を削除する

これは、あまり頻繁に実行したいことではないかもしれないが、グラフのすべてのエッジを削除したい場合は、トラバーサルオブジェクト'g'を使って下記のように実行できる。非常に大きなグラフの場合、これはグラフストアがこのリクエストを処理する方法によっては、最も効率的な方法ではないかもしれない点に注意してほしい。

[source,groovy]
----
// Remove all the edges from the graph
g.E().drop()
----

'graph'オブジェクトを使ってもこれを行うことができる。下記のコードは、graphオブジェクトを使ってすべてのエッジを取得し、それらを繰り返して、１つずつ削除する。繰り返しになるが、非常に大きなグラフの場合、これはすべてのエッジ定義をメモリに読み込む必要があるので、この方法は、理想的なアプローチではないかもしれない。この場合、グラフトラバーサルを使っていないので、'drop'を使うのではなく、'remove'メソッドを呼び出すことに注意してほしい。

[source,groovy]
----
// Remove all the edges from the graph
graph.edges().each{it.remove()}
----

すべての頂点を削除することにより、グラフ全体、頂点、エッジを削除することもできる。

[source,groovy]
----
// Delete the entire graph!
g.V().drop()
----

[[pkvrevisited]]
=== プロパティのキーと値を修正する

本書の前半で、特定のプロパティの値を何らかの方法で取得、生成、操作する多数のクエリをすでに見てきた。しかしながら、プロパティに関して詳細に説明していないことがまだいくつかある。これまで見てきたプロパティ値のほとんどは、文字列や整数のような単純なタイプだった。本セクションでは、プロパティについて詳しく見て、リストや値のセットを格納するのに、実際にどのように使えるのか説明する。本セクションでは、プロパティIDの概念についても説明する。

[[vertexprop]] 
==== プロパティと VertexProperty インタフェース

TinkerPop 3 対応のグラフでは、すべてのプロパティは'Property'インタフェースの実装である。頂点プロパティはそれ自体が、'Property'インタフェースを extend した'VertexProperty'インタフェースを実装したものである。これらのインタフェースはApache TinkerPop 3 の JavaDoc の一部としてドキュメントされている。インタフェースはコードの中で頂点プロパティオブジェクトを扱う際に使うことができるメソッドを定義する。頂点プロパティに関して注意すべき重要なことの１つは、不変である、ということだ。これらを作ることができるが一度作ったものは更新できない。

TinkerPop 3 が定義している Java インタフェースについて 本書の少し後で、"<<javatinker>>" のセクションで詳しく見ていく予定だ。

VertexProperty インタフェースではそれ自体の基本的なコンストラクタ以外の「セッター」メソッドは何も定義されていない。こう説明すると、「でも、'property'ステップを使ってプロパティの値を変更できることを知ってる。」と即座に反論されるかもしれない。実際、本書ではこれを行う方法をすでに説明してきた。しかしながら、その背景で、プロパティを変更すると実際に何が起こるかというと、新しいプロパティオブジェクトが生成されて、前のと置き換えられる。これについて後ほど詳しく見ていくが、まずプロパティの基本的な概念についていくつか再検討しよう。

'property graph'では、頂点とエッジの両方に１つ以上のプロパティを含めることができる。我々はすでにDFW空港の頂点に関連づけられた各プロパティキーから値を取得する下記のようなクエリをみてきた。

[source,groovy]
----
g.V().has('airport','code','DFW').values()

US
DFW
13401
Dallas
607
KDFW
-97.0380020141602
airport
US-TX
7
32.896800994873
Dallas/Fort Worth International Airport
----

しかしながら、これまで言及していないものは、前のクエリがこのクエリの短縮形である、ということだ。

[source,groovy]
----
g.V().has('airport','code','DFW').properties().value()

US
DFW
13401
Dallas
607
KDFW
-97.0380020141602
airport
US-TX
7
32.896800994873
Dallas/Fort Worth International Airport
----

DFW 頂点に関連づけられたプロパティの各々のVertexProperty '(vp)'オブジェクトを取得したい場合、それも実行できる。多くの場合、１つ以上のプロパティの値にアクセスするには、'values'や'valueMap'を使うだけで十分ではあるが、プロパティIDを見るとわかるように、頂点プロパティオブジェクト自体にアクセスできると便利な場合もある。

[source,groovy]
----
g.V().has('airport','code','DFW').properties()

vp[country->US]
vp[code->DFW]
vp[longest->13401]
vp[city->Dallas]
vp[elev->607]
vp[icao->KDFW]
vp[lon->-97.0380020141602]
vp[type->airport]
vp[region->US-TX]
vp[runways->7]
vp[lat->32.896800994873]
vp[desc->Dallas/Fort Worth In]
----

どのように頂点やエッジにある各プロパティがキーと値のペアとして表現されているかについてはすでに見てきた。指定された頂点に関連づけられたプロパティキーすべてのリストを取得したい場合は、'air-routes'グラフでDFW頂点に関連づけられたすべてのプロパティキーのリストを見つける下記のようなクエリを書くことができる。

[source,groovy]
----
g.V().has('airport','code','DFW').properties().key()

country
code
longest
city
elev
icao
lon
type
region
runways
lat
desc
----

このクエリを使って、DFW頂点から出エッジに関連づけられたプロパティキーの名前を、重複を除去しながら同様に見つけることもできる。エッジプロパティは'Property'の実装であり、'VertexProperty'ではない点に注意してほしい。

[source,groovy]
----
g.V().has('code','DFW').outE().properties().key().dedup()

dist
----

グラフ中のすべての最長の滑走路の値と滑走路数を合計する下記のようなクエリを構築するために、任意のプロパティのキーと値の部分の両方を具体的に参照する方法がわかったという事実を使うことができる。最初にプロパティキーでグループ化し、次に値の合計でグループ化する。

[source,groovy]
----
g.V().hasLabel("airport").
      properties("runways","longest").
      group().by(key).by(value().sum())

[longest:25497644, runways:4816]
----

[[propmap]]
==== propertyMap トラバーサルステップ

これまでに、'valueMap'ステップを使って、頂点やエッジに関連づけられているすべてのプロパティのキーと値のペアのマップを生成した。同様の結果を得るために使える'propertyMap'ステップもあるが、マップには各プロパティの頂点プロパティオブジェクトが含まれている。

[source,groovy]
----
g.V().has('code','AUS').propertyMap()
----

これは、返されたプロパティだ。

[source,groovy]
----
[country:[vp[country->US]], code:[vp[code->AUS]], longest:[vp[longest->12250]], city:[vp[city->Austin]], lon:[vp[lon->-97.6698989868164]], type:[vp[type->airport]], places:[vp[places->[YYZ, LHR, FRA, MEX,]], elev:[vp[elev->542]], icao:[vp[icao->KAUS]], region:[vp[region->US-TX]], runways:[vp[runways->2]], lat:[vp[lat->30.1944999694824]], desc:[vp[desc->Austin Bergstrom Int]]]
----

[[propid]]
==== プロパティもIDを持つ

頂点とエッジの両方が一意のIDを持っていることを示す多くの例をすでに見てきた。しかしながら明確ではなかったかもしれないが、プロパティにもIDがある。頂点やエッジのIDとは異なり、プロパティのIDは、グラフ全体で一意であるとは限らない。確かに、TinkerGraphでは、ちょい点とプロパティが同じＩＤを共有する場合がある。これは実際には問題ではない。というのも、関連するグラフ要素にアクセスするために異なる方法で使われるからだ。

下記のクエリは、値が'London'であるグラフ中の任意のプロパティの頂点プロパティオブジェクト(vp) を返す

[source,groovy]
----
g.V().properties().hasValue('London')
----

このクエリは、いくつかの London の値を見つける。

[source,groovy]
----
vp[city->London]
vp[city->London]
vp[city->London]
vp[city->London]
vp[city->London]
vp[city->London]
----

一見すると、上記で返された値の各々は同じように見える。しかしながら、IDの値を照会してみよう。

[source,groovy]
----
g.V().properties().hasValue('London').id()
----

ご覧の通り、各プロパティは異なる、一意のIDをもつ。

[source,groovy]
----
583
595
1051
1123
2467
7783
----

これらのIDは、以前の例のいくつかの頂点やエッジの場合と同じ方法で他のクエリで使うことができる。

[source,groovy]
----
g.V().properties().hasId(583)

vp[city->London]
----

期待通りに、このプロパティの値を照会できる。

[source,groovy]
----
g.V().properties().hasId(583).value()

London
----

プロパティキーの名前は、下記のように取得できる。

[source,groovy]
----
g.V().properties().hasId(583).key()

city
----

'key'の代わりに'label'を使うこともできる。

[source,groovy]
----
g.V().properties().hasId(583).label()

city
----

このプロパティがどの要素（頂点あるいはエッジ）に属するかを確認することもできる。

[source,groovy]
----
g.V().properties().hasId(583).next().element()

v[49]
----

IDが583 のプロパティを含む要素の他のプロパティの値を確認することもできる。

[source,groovy]
----
g.V().properties().hasId(583).next().element().values('desc')

London Heathrow
----

必要に応じて、このプロパティがどのグラフに含まれているかを確認することもできる。この場合は TinkerGraph の一部だ。

[source,groovy]
----
g.V().has('airport','code','DFW').properties('city').next().graph()

tinkergraph[vertices:3619 edges:50148]
----

各プロパティがIDを持っていることをさらに示すために、下記のコードは頂点'V(3)'に関連づけられているすべての頂点プロパティのリストを取得し、プロパティキーを対応するＩＤとともに出力する。

[source,groovy]
----
p = g.V(3).properties().toList()
p.each {println it.key + "\t:" + it.id}

country :28
code    :29
longest :30
city    :31
elev    :32
icao    :33
lon     :34
type    :35
region  :36
runways :37
lat     :38
desc    :39
----

NOTE: プロパティを更新すると、実際には、プロパティを新しいIDが割り当てられた新しいプロパティに置き換えられるので、そのID値は変更される。

下記の例をみていただきたい。まず、頂点'V(4)'から'city'プロパティのIDをクエリする。次に、その値を'newname'に変更して、そのプロパティIDを再度照会する。このIDは変更されていることに注意していただきたい。上述したように、頂点プロパティは不変である。'property'ステップを使ってプロパティの値を更新すると、前のぷろぱてぃを置き換える新しいプロパティオブジェクトが生成される。

[source,groovy]
----
g.V(4).properties('city').id()

43

g.V(4).property('city','newname')

g.V(4).properties('city').id()

53361
----

グラフ内のすべてのプロパティにIDがある、という事実は、特に大きなグラフでプロパティにアクセスするパフォーマンスを向上させる。

[[listprop]]
==== 複数の値(リストあるいはセット）を単一プロパティにアタッチする

頂点プロパティの値は、文字列や整数などの基本的な型にすることができるが、複数の値を含んだセットやリストなど、より高度なものにすることもできる。これらの値を配列として考えることもできるが、作成方法に応じて、異なる方法で操作する日露がある。本セクションでは、単一のプロパティキーに対して複数の値を作成する方法を見ていくこととする。そのような値は、頂点が最初に生成されたとき、あるいは後から追加されたときに設定できる。これらのより複雑なタイプのプロパティ値は、エッジではサポートされない。

オースティン空港のIATAやICAOのコードを、個別のプロパティではなく、単一のプロパティに関連づけられたリストに格納したい場合、オースティンの頂点を作成したときにそれらを作成することができる。また、値のリストを持つ既存の頂点にプロパティを追加することもできる。本セクションの後半でこれのやり方を見ていく。

[source,groovy]
----
g.addV().property('code','AUS').property('code','KAUS')
----

NOTE: g.addV('coe, AUS,code,KAUS')のように指定できるバージョンのaddV は非推奨になったので、使わないように。

この方法で'code'プロパティを作成することで、そのカーディナリティタイプは'SINGLE'ではなく 実質的に'LIST'になる。TinkerGraph を使っている際は、プロパティタイプに明示的なスキーマをセットアップする必要はない。しかしながら、JanusGraphのような、より高度なグラフシステムを使うようになると、それらは、求めているものであり実行する必要があるものとなる。カーディナリティについてのトピックは、本書のあとのほうにある "<<janusmgmt>>" のセクションで詳しく扱う。

これで、値のリストをもつ'code'プロパティを作成したので、リスト内の値のいづれかを照会することができる。下記の例のクエリから返される値のマップを見ると、プロパティ'code'に関連づけられたリストに両方の値があることがわかる。

[source,groovy]
----
g.V().has('code','AUS').valueMap()

[code:[AUS,KAUS]]

g.V().has('code','KAUS').valueMap()

[code:[AUS,KAUS]]
----

通常通り値を照会することもできる。

[source,groovy]
----
g.V().has('code','AUS').values()

AUS
KAUS
----

'properties'ステップを使って、頂点プロパティ (vp) として結果を返すこともできる。頂点プロパティについては、"<<vertexprop>>" のセクションで詳しく説明する。

[source,groovy]
----
g.V().has('code','AUS').properties()

vp[code->AUS]
vp[code->KAUS]
----

完全を期すために、このようにもできる。 

[source,groovy]
----
g.V().properties().hasValue('AUS')

vp[code->AUS] 
----

[[propertycaution]]
==== 注意の言葉 ー　プロパティによるふるまいの違い

.注意せよ。

'property'を使う際に注意すべき微妙な点がある。何が起こるかは、それが使われるコンテキストによって異なる。'addV'ステップの一部として実行され、直後に同じキー値を使う複数の'property'ステップが続く場合に限り、リストが作成される。下記の２つの例をみていただきたい。これらは、同じ結果にならない。

[source,groovy]
----
g.addV().property('one','hi').
         property('one','hello').
         property('two','goodbye').
         property('one','hello again').
         valueMap()

[one:[hi,hello,hello again],two:[goodbye]]
----

なので、最初のクエリは、'one'というキーを使ってプロパティを生成し、そのあとに'[hi, hello, hellop again]'を含むリストを作成する。同じテストをもう一度実行するが、今回は、まず頂点を生成し、すでに作成した頂点を使ってプロパティを追加する。

[source,groovy]
----
v = g.addV().next()

g.V(v).property('one','hi').
       property('one','hello').
       property('two','goodbye').
       property('one','hello again').
       valueMap()  

[one:[hello again],two:[goodbye]]
----

今回は、同じ一連の手順の一部として頂点を作成していなかったので、ふるまいが変わる。プロパティキーの'one'が使われるたびに、既存の値がリストの一部として追加されるのではなく、置き換えられる。私はこれまで、このふるまいが混乱を引き起こすのを何度も見てきたので、注意すべきポイントである。次のセクションでは、Gremlin にこの動作を説明するように求める。

[[explainstep]]
==== Gremlinは何をした？ - explain を導入する

Gremlin がクエリを実行可能な形式にコンパイルする方法を知りたい場合は、クエリの最後に'explain'ステップを追加して、通知するように求めることができる。クエリは実行されず、その代わり、Gremlin がどのようにクエリを最適化するのを決定したかが表示される。実際には、検討されたすべての選択が表示されるが、下記の例では、それぞれの場合に選択したものだけを示している。

よって、コンテキストに応じて、'property'の動作が異なるという前の説明を考えると、'explain'ステップを使ってGremlin にクエリの実行方法を表示させると、２つの形式の違いが明確にわかる。簡単にするために、出力は割愛した。

これが、'explain'ステップを使った場合に、最初のクエリでGremlin が表示したものだ。ご覧のとおり、クエリは２つのプロパティをもつ'AddVertexStep'にコンパイルされ、そのうちの１つはリストである。

[source,groovy]
----
g.addV().property('one','hi').
         property('one','hello').
         property('two','goodbye').
         property('one','hello again').
         explain()

Final Traversal    [AddVertexStartStep({one=[hi, hello, hello
                      again], two=[goodbye]})]
----

ここで、すでに頂点を作成している場合をみて、'explain'が何を返すか見てみよう。わかったことは、今回Gremlin はクエリを TinkerGraphStep にコンパイルし、各プロパティを１つずつ処理している、ということだ。これにより、毎回同じキーが再利用され、前の値が置き換えられるという結果となる。

[source,groovy]
----
g.V(v).property('one','hi').
       property('one','hello').
       property('two','goodbye').
       property('one','hello again').
       explain()

Final Traversal  [TinkerGraphStep(vertex,[v[54800]]),
                    AddPropertyStep({value=[hi], key=[one]}), 
                    AddPropertyStep({value=[hello], key=[one]}), 
                    AddPropertyStep({value=[goodbye], key=[two]}
                    ), AddPropertyStep({value=[hello again], key=[one]})]

----

頂点が作成されたあとでプロパティを操作してリストとして扱う必要がある場合は、次のセクションで説明するように、'property'ステップの一部として'list'キーワードを明示的に追加する必要がある。

[[updatelist]]
==== リストに格納されたプロパティを更新する

これで、更新する必要があるプロパティのリスト内のプロパティ値を使って頂点を作る方法がわかった。最初のパラメータが'list'で、それに続くのは既存のリストの更新でリスト全体の置換でないことを示している'property'ステップの特別な形式を使うとこれを行うことができる。

下記の例では、オースティン空港について話す際に使われることがある別のコードをコードのリストに追加している。'list'パラメータを省略した場合、プロパティ全体が'ABIA'の値で上書きされる。

[source,groovy]
----
g.V().has('code','AUS').property(list,'code','ABIA')
----

プロパティを再度照会すると、'code'プロパティに今は値が３つあることがわかる。

[source,groovy]
----
g.V().has('code','AUS').properties()
vp[code->AUS]
vp[code->KAUS]
vp[code->ABIA]
----

'valueMap'の結果を再度確認すると、同じであることが分かる。

[source,groovy]
----
g.V().has('code','AUS').valueMap()
[code:[AUS,KAUS,ABIA]]
----

リストからプロパティの1つを削除したい場合、'drop'を使うと削除できる。'ABIA'を削除した後に値マップを見ると、実際にリストから削除されていることがわかる。

[source,groovy]
----
g.V().has('code','AUS').properties().hasValue('ABIA').drop()

g.V().has('code','AUS').valueMap()
[code:[AUS,KAUS]]
----

1つ以上の値を含むプロパティ全体を削除したい場合は、下記のようにする。

[source,groovy]
----
g.V().has('code','AUS').properties('code').drop()
----

同じクエリで複数の値を同じプロパティキーに追加するには、下記に示すように、'property'ステップを連鎖させるだけでよい。

[source,groovy]
----
g.V().has('code','AUS').
      property(list,'desc','Austin Airport').
      property(list,'desc','Bergstrom')
----

この手法を使うと、すでに値のリストがある既存のプロパティを更新したり、値のリストを使って新しいプロパティを追加したりできる。

LIST のカーディナリティをもつプロパティに同じ値が複数回現れることがある。下記のコードフラグメントは、'dups'プロパティに関連付けられた重複した値をいくつか持つ新しい頂点を生成する。

[source,groovy]
----
g.addV('test').property('dups','one').property('dups','two').property('dups','one')

g.V().hasLabel('test').valueMap()

[dups:[one,two,one]]
----

頂点が作成された後、重複する値を追加することができる。

[source,groovy]
----
g.V().hasLabel('test').property(list,'dups','two')

g.V().hasLabel('test').valueMap()

[dups:[one,two,one,two]]
----

[[propsets]]
==== セットを格納するプロパティを生成する

これまでのところ、'LIST'カーディナリティをもつリストに値を作成した。これは、重複すする値が許容されることを意味する。これを回避したい場合はプロパティを追加する際に、'set'キーワードを使ってカーディナリティを強制的に'SET'にする。

下記の例では、頂点'V(3)'に複数の値を持つ'hw'という新しいプロパティを作成するが、以前に使った'list'キーワードではなく、'set'キーワードを使う。次に'hw'プロパティのvalueMap を調べて、実際にsetが生成されていることを確認する。

[source,groovy]
----
g.V(3).property(set,'hw','hello').property(set,'hw','world')

g.V(3).valueMap('hw')

[hw:[hello,world]]
----

いくつかの値を追加して、セットが実際にセットとして機能していることをテストしよう。すでに、前の手順で、値'hello'が追加されているので、カーディナリティが'SET'であれば、セットの中にすでに'hello'の値があるので、無視されると予想できる。再度valueMap を表示して、セットに一意の値のみが含まれていることを確認しよう。

[source,groovy]
----
g.V(3).property(set,'hw','hello').property(set,'hw','apple')

g.V(3).valueMap('hw')

[hw:[hello,world,apple]]
----

[[setlistnote]]
==== セットやリストについての注意点

本セクションで示した他の例は、リストを直接プロパティ値として追加することと同じではない点に注意してほしい。下記の例は、リスト全体が単一の値として扱われている。

[source,groovy]
----
g.V().has('code','AUS').property('x',['AAAA','BBBB'])

g.V().has('code','AUS').valueMap('x')

[x:[[AAAA,BBBB]]]
----

[[metaprop]]
==== 他のプロパティへプロパティを追加する（メタプロパティ）

TinkerPop 3 ではプロパティを別のプロパティに追加する機能が導入された。これは、プロパティに関するメタデータをプロパティ自体に少し追加できると考えてほしい。この機能は当然のことながら、"プロパティへメタプロパティを追加する"よ呼ばれることがしばしばある。この機能が非常に役に立つユースケースは多数ある。一般的なものとしては、プロパティが最後に更新された日付を追加したり、アクセス制御情報をプロパティに追加したりする場合がある。

下記の例は、'date'のキーで値が'6/6/2017'のメタプロパティを、キーが'code'で値が'AUS'のプロパティに追加している。

[source,groovy]
----
g.V().has('code','AUS').properties().hasValue('AUS').property('date','6/6/2017')
----

現在の値がどうであれ、'code'プロパティに日付を追加したい場合は、これを実行するとよい。

[source,groovy]
----
g.V().has('code','AUS').properties('code').property('date','6/6/2017')
----

下記のように、'code'プロパティなどの特定のプロパティのすべてのメタプロパティを取得できる。

[source,groovy]
----
g.V().has('code','AUS').properties('code').properties()

p[date->6/6/2017]
----

日付が'6/6/2017'のメタプロパティをもつAUS頂点に関連づけられているすべてのプロパティを見つけたいのであれば、下記のようにするとよい。

[source,groovy]
----
g.V().has('code','AUS').properties().has('date','6/6/2017')

vp[code->AUS]
----

下記のように特定のメタプロパティを照会することができる。これによりキーが'date'のメタプロパティが返される。

[source,groovy]
----
g.V().has('code','AUS').properties().hasValue('AUS').properties('date')

p[date->6/6/2017]
----

プロパティの作成中に、プロパティに複数のメタプロパティを追加することができる。下記は、'comment'というプロパティを頂点'V(3)'追加し、コメントが作成された日付と作成者を表す2つのメタプロパティも追加する。

[source,groovy]
----
g.V(3).property('comment','I like this airport','date','6/6/2017','user','Kelvin')
----

グラフを照会して、すべてが想定どおりに機能していることを確認できる。

[source,groovy]
----
g.V(3).properties('comment')

vp[Comment->I like this airport]

g.V(3).properties('comment').properties()

p[date->6/6/2017]
p[user->Kelvin]
----

'drop'を使ってメタプロパティを削除できるが、削除する際は注意が必要だ。下記のクエリを見ると、これはメタプロパティ'date'を削除しているようだが、実際には、頂点全体が削除される。

[source,groovy]
----
g.V().has('code','AUS').properties().hasValue('AUS').property('date','6/6/2017').drop()
----

単一のメタプロパティを削除すうｒには、このように drop を使うとよい。

[source,groovy]
----
 g.V().has('code','AUS').properties('code').properties('date').drop()
----

メタプロパティを際限なく連鎖させることはできない点に注意してほしい。頂点のメインプロパティは、'VertexProperty'型だ。メタプロパティは'Property'型で、それらに別のプロパティを追加することはできない。しかしながら、1つ以上のメタプロパティを同じ頂点プロパティへ追加することはできる。

なので、上述したように、メタプロパティはメタデータを別のプロパティにアタッチすることができる。これにより、日付やACL情報を個々のプロパティに付与するなど、多くの重要なユースケースが可能となる。

[[tp34vmmetaprop]]
==== メタプロパティに unfold と WithOptions を使う

Apache TinkerPop バージョン 3.4 で新機能が導入され、より簡単にプロパティとメタプロパティの両方を'properties'ステップに続く'valueMap'ステップの結果に含めることができるようになった。

TIP: WithOptions を使って指定できるすべての可能な値は、ここにある Apache TinkerPop JavaDoc 公式ドキュメントにある。
http://tinkerpop.apache.org/javadocs/current/full/org/apache/tinkerpop/gremlin/process/traversal/step/util/WithOptions.html

この新機能を使うには、使っているグラフデータベースがメタプロパティとTinkerPop 3.4 の両方をサポートしている必要がある。下記の例は前のセクションで示した例に基づいたものである。

まず、'properties'ステップを使って頂点に存在するプロパティを検査する方法がわかる。

[source,groovy]
----
g.V().has('code','AUS').properties()

vp[country->US]
vp[code->AUS]
vp[longest->12250]
vp[city->Austin]
vp[elev->542]
vp[icao->KAUS]
vp[lon->-97.6698989868164]
vp[type->airport]
vp[region->US-TX]
vp[runways->2]
vp[lat->30.1944999694824]
vp[desc->Austin Bergstrom ...]
----

また、'properties'ステップの後に'valueMap'ステップ、あるいは2つ目の'properties'ステップを実行してメタプロパティを参照する方法もわかる。しかしながら、値はプロパティがメタプロパティを持っている場合にのみ返される。他のすべてのプロパティの場合、結果は単に空のリストになる。

[source,groovy]
----
g.V().has('code','AUS').properties().valueMap()

[]
[date:6/6/2017]
[]
[]
[]
[]
[]
[]
[]
[]
[]
[]
----

新しい'with'ステップを使って、'WithOptions'を使ってオプションを指定すると、プロパティ値とそれぞれのメタプロパティを含む'valueMap'から結果を生成することができる。下記の例は、全てのプロパティの値に加えて、存在するメタプロパティのキーと値を含んだマップを生成する。

[source,groovy]
----
g.V().has('code','AUS').
      properties().
      valueMap().with(WithOptions.tokens,WithOptions.values)
----

値はすべてのプロパティについて表示されるが、'date'メタプロパティがある場合も表示される。

[source,groovy]
----
[value:US]
[value:AUS,date:6/6/2017]
[value:12250]
[value:Austin]
[value:542]
[value:KAUS]
[value:-97.6698989868164]
[value:airport]
[value:US-TX]
[value:2]
[value:30.1944999694824]
[value:Austin Bergstrom International Airport]
----

同様に、結果にキー名を含めることもできる。

[source,groovy]
----
g.V().has('code','AUS').
      properties().
      valueMap().with(WithOptions.tokens,WithOptions.keys)
----

ここでも、'date'メタプロパティのキーと値が表示される。

[source,groovy]
----
[key:country]
[key:code,date:6/6/2017]
[key:longest]
[key:city]
[key:elev]
[key:icao]
[key:lon]
[key:type]
[key:region]
[key:runways]
[key:lat]
[key:desc]
----

キーと値の両方をメタプロパティとともに結果に含めるには、'WithOptions.all'を使うとよい。

[source,groovy]
----
g.V().has('code','AUS').
      properties().
      valueMap().with(WithOptions.tokens,WithOptions.all)
----

この場合、各プロパティのIDも表示される点に注意してほしい。

[source,groovy]
----
[id:28,key:country,value:US]
[id:29,key:code,value:AUS,date:6/6/2017]
[id:30,key:longest,value:12250]
[id:31,key:city,value:Austin]
[id:32,key:elev,value:542]
[id:33,key:icao,value:KAUS]
[id:34,key:lon,value:-97.6698989868164]
[id:35,key:type,value:airport]
[id:36,key:region,value:US-TX]
[id:37,key:runways,value:2]
[id:38,key:lat,value:30.1944999694824]
[id:39,key:desc,value:Austin Bergstrom International Airport]
----

[[deduce]]
=== クエリを使ってグラフのスキーマを推定する

グラフを扱っていて、データモデルやスキーマが分からないことに気づくことがある。単純な Gremlin クエリを使っていると、グラフに含まれる主要な要素をとても簡単に把握できる。この手法は、使っているグラフデータベースでグラフのスキーマを扱う明示的なAPIが用意されていない場合にのみ使うべきだ。まず、下記にあるように使っている頂点ラベルが把握できる。'dedup'ステップは一意のラベル名のリストを確実に得られる。

[source,groovy]
----
g.V().label().dedup()

version
airport
country
continent
----

同様に、グラフ中のエッジラベルの名前を見つけることができる。

[source,groovy]
----
g.E().label().dedup()

route
contains
----

ラベル名がわかったので、特定のラベルを持つ頂点のプロパティキーの名前を取得するのは非常に簡単だ。下記のクエリでは、'airport'頂点で見つかったプロパティキーの名前を表示している。

[source,groovy]
----
g.V().hasLabel('airport').limit(1).next().keys()

country
code
longest
city
elev
icao
lon
type
region
runways
lat
desc
----

見つかった各頂点ラベルごとに反復処理をしたいのであれば、前のクエリを単純なループ内に簡単に配置できる。頂点と同様に、エッジを照会してキー名を見つけることもできる。下記のクエリは、'route'エッジのプロパティキーの名前を見つける。

[source,groovy]
----
g.E().hasLabel('route').limit(1).next().keys()

dist
----

最後に、ラベル名がわかり、プロパティキー名を見つける方法がわかったので、各キーに関連づけられているタイプを把握することもできる。下記のコードは、'pkeys'という、'airport'頂点のすべてのプロパティキー名を含む配列を生成する。それが完了すると、コードは単純なループでリストを繰り返し、各キーのタイプを見つける。示されているコードは、Gremlin コンソール内で実行することを目的としている。

[source,groovy]
----
pkeys=g.V().hasLabel('airport').limit(1).next().keys()

pkeys.each {
  printf("%10s : %s\n" , it, 
          g.V().hasLabel('airport').limit(1).
            values(it).next().class)};[]
----

実行すると、キー名とそのタイプを示す、適切にフォーマットされたテーブルが返される。

[source,groovy]
----
   country : class java.lang.String
      code : class java.lang.String
   longest : class java.lang.Integer
      city : class java.lang.String
      elev : class java.lang.Integer
      icao : class java.lang.String
       lon : class java.lang.Double
      type : class java.lang.String
    region : class java.lang.String
   runways : class java.lang.Integer
       lat : class java.lang.Double
      desc : class java.lang.String
----

後ほど、"<<janusmgmt>>" のセクションで、JanusGraph で明示的にスキーマを定義する方法と、グラフ管理APIを使ってスキーマを照会する方法について説明する。 

[[collrev]]
=== コレクション再訪

これまでの例で多く見てきたように、トラバーサルの途中、あるいは終了時、あるいはその両方で、ある種のコレクションを生成することがよくある。本セクションでは、これらのコレクションとその操作方法についてさらに詳しく見ていく。以降のセクションでは、コレクションと、いわゆる'reducing barrierトラバーサルステップを組み合わせて、効率的に使う方法について説明する。

[[collsteps]]
==== コレクションを生成するステップ

まずは、コレクションを生成する方法をいくつか確認するところからこの議論を始めよう。コレクションの簡単な例は、下記の例に示すように、'group'ステップによって生成されるマップだ。

[source,groovy]
----
g.V(1..5).group().by('code').by('runways')

[BNA:[4],ANC:[3],BOS:[6],ATL:[5],AUS:[2]]
----

同様に、マップは'groupCount'ステップを使うと生成される。

[source,groovy]
----
g.V().hasLabel('airport').limit(40).groupCount().by('region')

[US-FL:5,PR-U-A:1,US-NV:1,US-MN:1,US-HI:1,US-IL:1,US-TX:6,US-AK:1,US-WA:1,US-VA:1,US-NY:4,US-CO:1,US-NC:1,US-LA:1,US-MD:1,US-IA:1,US-MA:1,US-CA:6,US-DC:1,US-UT:1,US-AZ:1,US-GA:1,US-TN:1]
----

同様に、fold ステップを使うとリストが生成される。リストの中身を並べ替えたい場合は、'order'ステップと'local'スコープを使うとよい。

[source,groovy]
----
g.V().hasLabel('airport').limit(20).values('runways').
      fold().order(local)

[2,2,2,3,3,3,3,3,4,4,4,4,4,4,4,5,5,6,7,8]
----

これは、2つの値のリストを生成する'union'ステップとそれに続く'_fold'ステップの例だ。'union'ステップには'identity'ステップが含まれていて、union の最初の項目として、入り頂点の値を求めていることを示している。その頂点をその頂点(DFW)からのすべての経路の数を結合して、最終的に'fold'ステップを使ってリストを生成する。

[source,groovy]
----
g.V().has('airport','code','DFW').union(identity(),out().count()).fold()

[v[8],221]
----

上記の構文は、下記の省略形であることに注意してほしい。

[source,groovy]
----
g.V().has('airport','code','DFW').as('a').union(select('a'),out().count()).fold()

[v[8],221]
----

リストではなく、キーと値を使ってマップを生成したい場合は、'group'ステップを使うとよい。この場合、頂点がキーであり、出経路の数が、値だ。

[source,groovy]
----
g.V().has('airport','code','DFW').group().by().by(out().count())

[v[8]:221]
----

マップを生成する別の方法は'project'ステップを使う方法だ。

[source,groovy]
----
g.V().has('airport','country','IE').project('loc','iata').by('city').by('code')

[loc:Dublin,iata:DUB]
[loc:Shannon,iata:SNN]
[loc:Cork,iata:ORK]
[loc:Charleston,iata:NOC]
[loc:Killarney,iata:KIR]
[loc:Waterford,iata:WAT]
[loc:Donegal,iata:CFN]
----

また、'project'ステップを使うと、少し複雑になるが、この例では、2つのキーを持つマップを生成する。1つ目は'dfw'と呼ばれ、DFW空港の頂点を含んでいて、2つ目は、'route_count'と呼ばれ、DFWからの出経路の数を含んでいる。最初の'by'ステップにはパラメータがないので、実際の頂点が返される点に注目してほしい（選択できる頂点のプロパティではなく）。

[source,groovy]
----
 g.V().has('code','DFW').project('dfw','route_count').
       by().by(outE().count())

[dfw:v[8],route_count:221]
----

マップを生成するだけでなく、'store'ステップを使ってセットを生成し、重複する値が保存されないようにすることができる。'withSideEffect'ステップを使って、セットを初期化するとよい。'cap'ステップは、'store'ステップを使って作成した副作用から生じるコレクションを出力する。とりわけ、これにより、クエリの最終結果としてこのコレクションを返すことができる

[source,groovy]
----
g.withSideEffect('s', [] as Set).
  V().hasLabel('airport').limit(20).values('runways').
      store('s').cap('s').order(local)

[2,3,4,5,6,7,8]
----

'store'ステップは'by'モジュレータと組み合わせて使って、'保存する'ものを正確に指定することもできる。下記のクエリは、'store'ステップを使って滑走路のコレクションを生成するが、'values'ステップを使わないで済む。

[source,groovy]
----
g.V().has('region','US-TX').store('r').by('runways').cap('r')

[2,2,2,2,2,2,2,2,7,5,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,1]
----

'aggregate'ステップも、下記に示すようにコレクションを生成する。このコレクションは、すぐに確認できるように、実際には'BulkSet'だ。'store'ステップも BulkSet を生成する。

[source,groovy]
----
g.V().has('airport','country','IE').aggregate('ireland').cap('ireland')

[v[60],v[91],v[311],v[477],v[635],v[785],v[1269]]
----

下記のクエリは、'aggregate'ステップを使って、アイルランドにある空港から飛ぶことができるすべての国を見つけるが、アイルランド内の空港間の経路は除外する。

[source,groovy]
----
g.V().has('airport','country','IE').aggregate('ireland').
      out().where(without('ireland')).
      values('country').
      dedup().fold().order(local)
----

結果を見るとお分かりのように、アイルランドの国コード、'IE'はリストに出てこない。

[source,groovy]
----
[AE,AT,BE,BG,CA,CH,CY,CZ,DE,DK,ES,ET,FI,FR,GR,HR,HU,IM,IS,IT,JE,LT,LU,LV,MA,MD,MT,NL,NO,PL,PT,QA,RO,SE,SK,TR,UK,US]
----

'aggregate'と'store'は表面上、同じように見えるが、実際には異なるふるまいをする。'aggregate'ステップは前のトラバーサルからのすべてをブロックしてすぐに集めるが、'store'ステップは見た通り、コレクションに追加するだけだ。これは'lazy aggregation'と呼ばれることもある。また、'limit'に2 を指定した場合でも、limit ステップが適用される前に、すでに3つ目が確認されているので、'store'ステップが3つの要素を集める点に注意してほしい。

[source,groovy]
----
g.V().has('airport','country','IE').store('a').limit(2).cap('a')

[v[60],v[91],v[311]]

g.V().has('airport','country','IE').aggregate('a').limit(2).cap('a')

[v[60],v[91],v[311],v[477],v[635],v[785],v[1269]]
----

'aggregate'と'store'の両方は後に'by'モジュレータをつなげて、より正確に、何を収集すべきかを指定することができる。例えば、アイルランドの各空港にある滑走路の数を保存した場合、下記のようにできる。

[source,groovy]
----
g.V().has('airport','country','IE').
      aggregate('ireland').by('runways').cap('ireland')

[2,2,2,5,1,1,1]
----

作成されたオブジェクトのタイプが分からない場合は、'getClass'の呼び出しを使って調べることができる。

[source,groovy]
----
g.V(1..5).group().by('code').by('runways').next().getClass()

class java.util.HashMap

g.V(1..5).aggregate('a').cap('a').next().getClass()

class org.apache.tinkerpop.gremlin.process.traversal.step.util.BulkSet
----

これで、トラバーサル中にコレクションが生成される様々な方法を検討してきたので、コレクションの中身にアクセスして操作する方法を理解することが重要だ。

[[collaccess]]
==== コレクションの中身にアクセスする

キーワード'keys'と'values'を使って、マップであるコレクションの個々の部分にアクセスすることができる。下記の空港コードがキーでその都市名が値であるマップを返すクエリを見ていただきたい。

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city')

[BNA:[Nashville],ANC:[Anchorage],BOS:[Boston],ATL:[Atlanta],AUS:[Austin]]
----

'count'ステップを'local'スコープと合わせて使うと、コレクションの大きさを調べることができる。

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city').count(local)

5
----

下記のクエリは、'group'ステップが作成したマップからキーと値を抽出する。

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city').select(keys)

[BNA,ANC,BOS,ATL,AUS]

g.V().hasLabel('airport').limit(5).group().by('code').by('city').select(values)

[[Nashville],[Anchorage],[Boston],[Atlanta],[Austin]]
----

前に使った'project'ステップの結果からキーと値を抽出することもできる。値はDFW 頂点とDFWからの経路の数を含むリストとして返される点に注意してほしい。

[source,groovy]
----
g.V().has('code','DFW').project('dfw','route_count').
      by().by(outE().count()).select(values)

[v[8],221]
----

同様に、キーはリストに入る。

[source,groovy]
----
g.V().has('code','DFW').project('dfw','route_count').
      by().by(outE().count()).select(keys)

[dfw,route_count]
----

さらに具体的に、関心のある値を選択することもできる。

[source,groovy]
----
g.V().has('code','DFW').project('dfw','route_count').
       by().by(outE().count()).select('route_count')

221   
----

マップから直接DFW頂点へアクセスすることもできる。

[source,groovy]
----
g.V().has('code','DFW').project('dfw','route_count').
      by().by(outE().count()).select('dfw')

v[8]
----

頂点を抽出すると、そこから値を取得することができる。少しあとで、必要に応じて、おそらく、DFWからの出経路を検討するか、新しい経路を追加するか、この時点からトラバーサルを継続する方法について説明する。その議論については、"<<rbarriers>>" のセクションにある。

[source,groovy]
----
g.V().has('code','DFW').project('dfw','route_count').
      by().by(outE().count()).select('dfw').values('desc')

Dallas/Fort Worth International Airport
----

次の2つのセクションで説明するように、'unfold'ステップを使ってコレクションの中身にアクセスする必要がある場合もあれば、'local'スコープを使う必要がある場合もある。

[[unbundle]]
==== unfold を使ってコレクションをアンバンドルする

コレクションをさらに処理できるように、コレクションをアンバンドルするのが望ましいことがある。これは、'unfold'ステップで行う。前のクエリに'unfold'を適用すると、何が生成されるかがわかる。'group'ステップが生成したコレクションは、Java の HashMap である。'unfold'ステップは HashMap を一連の、HashMap.Node 要素に変換する。

[source,groovy]
----

g.V().hasLabel('airport').limit(5).group().by('code').by('city').unfold()

BNA=[Nashville]
ANC=[Anchorage]
BOS=[Boston]
ATL=[Atlanta]
AUS=[Austin]
----

値のリストを必要とするのであれば、下記のように、'unfold'を再度使うとよい。以前の議論より、たとえばプロパティが1つしかない場合でも、頂点プロパティがリスト、つまり長さが1のリストとして保存されていることを思い出すだろう。これは単一の'unfold'ステップはコレクションから要素を再帰的にアンバンドルしないことを示している点に注意していただきたい。

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city').
      select(values).unfold()

[Nashville]
[Anchorage]
[Boston]
[Atlanta]
[Austin]
----

2つ目の'unfold'を追加して都市名を戻して含まれているリストを削除することができる。

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city').
      select(values).unfold().unfold()

Nashville
Anchorage
Boston
Atlanta
Austin
----

別の方法として、下記に示すように、複数回 unfold したい場合は、'repeat'を使うとよい。

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city').
      select(values).repeat(unfold()).times(2)

Nashville
Anchorage
Boston
Atlanta
Austin
----

何回'unfold'するべきかわからない場合は、下記のようにクエリを変更するとよいだろう。'repeat'ループは、リストのリストが残るまでunfold する。最後のunfold は、残ったリストを削除してテキスト値だけが残る。

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city').
      select(values).repeat(unfold()).until(count(local).is(1)).unfold()

Nashville
Anchorage
Boston
Atlanta
Austin
----

'unfold'を使って都市名だけを文字列として抽出したら、'fold'ステップを使って空港名のリストを生成するために1回だけ再fold するとよい。この、展開して操作を実行して再度降りたたむパターンは、特により複雑なクエリで非常に頻繁に役に立つパターンだ。

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city').
      select(values).unfold().unfold().fold()

[Nashville,Anchorage,Boston,Atlanta,Austin]
----

'keys'と'valules'キーワードは、'valueMap'ステップのような単純なものにでも使うことができることはおそらく指摘しておく価値があるだろう。これは簡単な例だ。

[source,groovy]
----
g.V(3).valueMap().select(keys)

[country,code,longest,city,elev,icao,lon,type,region,runways,lat,desc]

g.V(3).valueMap().select(values)

[[US],[AUS],[12250],[Austin],[542],[KAUS],[-97.6698989868164],[airport],[US-TX],[2],[30.1944999694824],[Austin Bergstrom International Airport]]
----

[[localcollect]]
==== コレクションにローカルスコープを使う

コレクションの中身を扱いたい場合、ソートする場合でも、サブセットを選択する場合でも'local'スコープを使うべき場合がある。下記の例を書く方法は他にもあるが、私はコレクションを操作しながら、'local'スコープを'order'、'range'、'limit'並びに'tail'ステップと組み合わせるとよい方法をいくつかお見せしたい。

まず、もう一度アイルランドの空港を使ってコレクションを作成しよう。今回は、キーが空港コードで、値がその空港にある滑走路の数であるマップを作成する。

[source,groovy]
----
g.V().has('airport','country','IE').
      group().by('code').by('runways')

[DUB:[2],SNN:[5],NOC:[1],KIR:[2],ORK:[2],CFN:[1],WAT:[1]]
----

前の例を使ってマップからキーを選択する方法はすでにお分かりだが、完全を期すために、もう一度見てみよう。

[source,groovy]
----
g.V().has('airport','country','IE').
      group().by('code').by('runways').select(keys)

[DUB,SNN,NOC,KIR,ORK,CFN,WAT]
----

キーを昇順にソートしたいのであれば、'local'スコープで'order'ステップを使うとよい。

[source,groovy]
----
g.V().has('airport','country','IE').
      group().by('code').by('runways').select(keys).order(local)

[CFN,DUB,KIR,NOC,ORK,SNN,WAT]
----

これは、下記に示すように、代わりに'unfold'と'fold'パターンを使うことができた場合であることに注意してほしい。

[source,groovy]
----
g.V().has('airport','country','IE').
      group().by('code').by('runways').select(keys).
      unfold().order().fold()

[CFN,DUB,KIR,NOC,ORK,SNN,WAT]
----

次の例もまた、'limit'ステップと一緒に'local'スコープを使って最初の2つの空港のキーを取得する。

[source,groovy]
----
g.V().has('airport','country','IE').
      group().by('code').by('runways').select(keys).limit(local,2)

[DUB,SNN]
----

同じ'local'スコープを'tail'ステップと使って最後3つのキーを選択できる。

[source,groovy]
----
g.V().has('airport','country','IE').
      group().by('code').by('runways').select(keys).tail(local,3)

[ORK,CFN,WAT]
----

ご想像のとおり、'range'ステップで'local'スコープを指定することもできる。

[source,groovy]
----
g.V().has('airport','country','IE').
      group().by('code').by('runways').select(keys).range(local,3,5)

[KIR,ORK]
----

'limit'と'tail'ステップを'local'スコープと組み合わせて、下記に示すように、値のリストから開始エントリあるいは終了エントリを抽出するることができる。下記のクエリはテキサスにあるすべての空港のIATAコードを含んだリストを生成する。

[source,groovy]
----
g.V().has('region','US-TX').values('code').fold()

[AUS,DFW,IAH,SAT,HOU,ELP,DAL,LBB,HRL,MAF,CRP,ABI,ACT,CLL,BPT,AMA,BRO,GGG,GRK,LRD,MFE,SJT,SPS,TYR,VCT,AFW]
----

'local'スコープと'limit'ステップを使うと、リストから最初の2つのエントリだけを抽出することができる。

[source,groovy]
----
g.V().has('region','US-TX').values('code').fold().limit(local,2)

[AUS,DFW]
----

同様に、'local'スコープを'tail'ステップと使うと、リストから最後の2つのエントリを抽出することができる。

[source,groovy]
----
g.V().has('region','US-TX').values('code').fold().tail(local,2)

[VCT,AFW]
----

'local'スコープは'dedup'ステップとも使えることに注意してほしい。下記のクエリは、米国内の空港を見つけ、各地域に１つの空港のみがトラバーサルの次のステップに進むことを許可することにより、一意のリージョンコードでソートされたリストを生成する

[source,groovy]
----
g.V().has('country','US').dedup().by('region').values('region').order().fold() 
----

下記のクエリの書き直したバージョンでは、すべての空港のリージョンコードが集められ、次に結果として生じるコレクションに'local'スコープを使って'dedup'が適用される。前のクエリのほうがこれを行うには効率的なようだが、私は既存の値のコレクションが'local'スコープを使って'dedup'を適用できることを明確にしたかったのだ。

[source,groovy]
----
g.V().has('country','US').values('region').order().fold().dedup(local)

----

いずれかのクエリを実行すると、返される結果はこのようになる。

[source,groovy]
----
[US-AK,US-AL,US-AR,US-AZ,US-CA,US-CO,US-CT,US-DC,US-DE,US-FL,US-GA,US-HI,US-IA,US-ID,US-IL,US-IN,US-KS,US-KY,US-LA,US-MA,US-MD,US-ME,US-MI,US-MN,US-MO,US-MS,US-MT,US-NC,US-ND,US-NE,US-NH,US-NJ,US-NM,US-NV,US-NY,US-OH,US-OK,US-OR,US-PA,US-RI,US-SC,US-SD,US-TN,US-TX,US-UT,US-VA,US-VT,US-WA,US-WI,US-WV,US-WY]
----

最後に、前述の例のいくつかを組み合わせて、グループの中身を制限、順序づけ、重複除去をすることができる。下記のクエリには'limit'ステップが含まれていないので、すべての可能な結果が取得される。このクエリのゴールはキーとしてラベルを付けて、頂点の'code'プロパティを、AUS（オースティン）に接続されている入りと出の両方のエッジの値としてグループを構築することだ。結果は、重複除去されているので、空港コードが２回出てくることはない。

[source,groovy]
----
g.V().has('code','AUS').
      both().
      group().
        by(label).
        by(values('code').fold().dedup(local).order(local))
----

実行すると、下記の結果が返される。

[source,groovy]
----
[continent:[NA],country:[US],airport:[ABQ,ATL,BKG,BNA,BOS,BWI,CLE,CLT,CUN,CVG,DAL,DCA,DEN,DFW,DTW,ELP,EWR,FLL,FRA,GDL,HOU,HRL,IAD,IAH,IND,JFK,LAS,LAX,LBB,LGB,LHR,MCI,MCO,MDW,MEM,MEX,MIA,MSP,MSY,OAK,ORD,PDX,PHL,PHX,PIE,PIT,PNS,RDU,SAN,SEA,SFB,SFO,SJC,SLC,SNA,STL,TPA,VPS,YYZ]]
----

しかしながら、グループ内の任意のキーについて、クエリを最大１０件の結果に制限したいとしよう。下記に示すように、'local'スコープで'limit'ステップを追加することでこれを行うことができる。

[source,groovy]
----
g.V().has('code','AUS').
      both().
      group().
        by(label).
        by(values('code').fold().dedup(local).order(local).limit(local,10))
----

今回実行すると、返される結果の量が制限される。

[source,groovy]
----
[continent:[NA],country:[US],airport:[ABQ,ATL,BKG,BNA,BOS,BWI,CLE,CLT,CUN,CVG]]
----

次のセクションでは、引き続きGremlin のコレクションと、'バリア削減'ステップを組み合わせて、望ましい結果を得る方法についてみていく。また、コレクションの関心のある部分にアクセスするために'unfold'が必要となる他のケースについても見ていく。

[[rbarriers]]
=== コレクションとバリアステップの削減

Gremlin ユーザディスカッションリストでGremlin クエリを書く上でよくある質問を見ると、人々を混乱させることが繰り返しあると思われる分野の１つは、バリア削減ステップとして知られる特定のトラバーサルステップのふるまいだ。これらのステップは本質的にこれまでのトラバーサルの結果を単一のトラバーサルに減らすことであり、値だけあるいはある種のコレクションであり、その時点からクエリで以前に実行したことを参照することはできない。

.バリア削減ステップ
[cols="^1,4"]
|==============================================================================
|max     | Returns the maximum value from a set of values.
|min     | Returns the minimum value from a set of values.
|sum     | Returns the sum of a set of values.
|count   | Counts the number of current elements.
|fold    | Aggregates current traversal into a map.
|============================================================================== 

下記の例を見てほしい。表面的には、クエリがDFW空港からの発経路すべてをカウントし、空港の頂点'"a"'と合わせてカウント'"b"'を返すことを期待すると思う。

[source,groovy]
----
g.V().has('code','DFW').as('a').outE().count().as('b').select('a','b')
----

実際に起こることは、何も返されないということだ。これは、'count'ステップがいわゆる'バリア削減'ステップだからだ。'count'が処理されると、'barrier'を超えて、トラバーサル変数'"a"'が使えなくなる。下記に示すように、'count'ステップの後で定義されているので、それ自体を参照すれば、引き続き'"b"'にアクセスできる。

[source,groovy]
----
g.V().has('code','DFW').as('a').outE().count().as('b').select('b')

221
----

このようなケースでは、ほとんどの場合クエリの書き方を変更することで、求める結果を得ることができる。様々なトラバーサルステップがどのように機能するかを理解することが重要だ。そのためのすぐれた方法は、Gremlin コンソールを使って実験をして、様々なステップがどのように機能するかを確認することだ。以下の書き換えたクエリは当初の目的を得ることができる。

[source,groovy]
----
g.V().has('code','DFW').group().by().by(outE().count())

[v[8]:221]
----

これが必要なすべてである場合、我々の仕事は完了だ。キーとして頂点を含み、値として出経路の数を含むマップがある。しかしながら、このクエリをさらに進めたいのであれば、まだ問題がある。下記の例を見てほしい。このクエリには前のトラバーサルががカウントを含む小さなマップに減少したので、'"a"'を返すことができなくなっている。

[source,groovy]
----
g.V().has('code','DFW').as('a').group().by().by(outE().count()).select('a')
----

なんらかの理由で、'"a"'に格納された頂点を取得したい場合、代わりに'group'ステップが作成したマップから取得する必要がある。'select'ステップへのパラメータとして'keys'キーワードを使うとマップのキーにアクセスできる。

[source,groovy]
----
g.V().has('code','DFW').group().by().by(outE().count()).
                        select(keys)

[v[8]]
----

頂点がまだリストに返されているので、求める結果はまだ得られていない。なので、マップからキーをセレクトする前にマップを'unfold'するように再度クエリを修正するとよい。

[source,groovy]
----
g.V().has('code','DFW').group().by().by(outE().count()).
                        unfold().select(keys)
v[8]
----

キーの代わりに値を取得したのであれば、下記のように'values'キーワードを使うとよい。

[source,groovy]
----
g.V().has('code','DFW').group().by().by(outE().count()).
                        unfold().select(values)

221
----

ここからクエリに追加し続けることができることを示すために、最初に使った空港コードを取得しよう。

[source,groovy]
----
g.V().has('code','DFW').group().by().by(outE().count()).
                        unfold().select(keys).values('code')

DFW
----

それでは、クエリ追加して、'current_count'というプロパティを使って、DFWを起源とする経路の数を格納する'dfwcount'というラベルをもつ新しい頂点を生成しよう。

[source,groovy]
----
g.V().has('code','DFW').group().by().by(outE().count()).as('ct').
      addV('dfwcount').
      property('current_count',select('ct').unfold().select(values))

v[54931]
----

新しい頂点を調べて、クエリが意図したとおりに昨日したことを再確認することができる。

[source,groovy]
----
g.V(54931).valueMap(true)

[id:54931,current_count:[221],label:dfwcount]
----

うまくいけば、ここでパターンが見え始めている。どのステップが'バリア削減'ステップであるかを理解し、必要なことを実行できるクエリを書けるようにそれらを操作できることが重要だ。

[[sumcollection]]
==== コレクションの合計値を計算する

下記のクエリは、キーが空港のIATAコードで、値がその空港の滑走路の数であるマップを返す。結果は読みやすくするために並べ替えられている。

[source,groovy]
----

g.V().hasLabel('airport').limit(10).
      group().by('code').by(values('runways')).
      order(local).by(values)

[FLL:2,AUS:2,DCA:3,BWI:3,ANC:3,BNA:4,IAD:4,ATL:5,BOS:6,DFW:7]
----

このような空港と滑走路のコレクションがあると、存在する滑走路の総数を計算したくなると思う。下記のクエリはそれを実現している。コレクションから値を選択するために'unfold'ステップを使って、コレクションをストリームに戻してそこから値を選択できることに注意してほしい。

[source,groovy]
----
g.V().hasLabel('airport').limit(10).
      group().by('code').by(values('runways')).
      unfold().
      select(values).
      sum()

39
----

下記に示すように、'unfold'ステップではなく、'local'スコープを使ってクエリを書くこともできる。

[source,groovy]
----
g.V().hasLabel('airport').limit(10).
      group().by('code').by(values('runways')).
      local(select(values).sum(local))

39
----

[[mathcollection]]
==== コレクションに math ステップを使う

前のセクションの例に基づいて、この実験をさらに一歩進めて、1つ以上のコレクションの値に'math'ステップを適用する方法を見てみよう。コレクションに10個の値があることが分かっている場合、'math'ステップを使って簡単にそれらの値の平均を計算することができる。

[source,groovy]
----
g.V().hasLabel('airport').limit(10).
      group().by('code').by(values('runways')).
      unfold().
      select(values).
      sum().
      math('_ / 10') 

3.9
----

事前にコレクションにあるエントリの数がわかっているとは限らない。下記の修正した例では、'project'ステップを使って滑走路の合計の数と、コレクションの要素数を表す2つの値を'math'ステップにフィードする。

[source,groovy]
----
g.V().hasLabel('airport').limit(10).
      group().by('code').by(values('runways')).
      project('total','number').
        by(select(values).unfold().sum()).
        by(count(local)).
      math('total / number')

3.9
----

複数のコレクションの合計に対して計算を実行したいことがあるかもしれない。下記に示す2つのクエリは、ニューメキシコ州とアリゾナ州にあるすべての空港の空港と滑走路の キー/値のペアのマップを作成する。

[source,groovy]
----
g.V().has('region','US-NM').
      group().by('code').by(values('runways'))

[ABQ:4,SVC:4,CNM:4,FMN:2,SAF:3,LAM:1,HOB:3,CVN:3,ROW:3]
----

もし、ニューメキシコ州の空港の滑走路を合計すると、27本あることがわかり、同様に、アリゾナ州の空港には、26本の滑走路がある。

[source,groovy]
----
g.V().has('region','US-AZ').
      group().by('code').by(values('runways'))

[YUM:4,PRC:3,FLG:1,PHX:3,IFP:1,TUS:3,GCN:1,AZA:3,SOW:2,PGA:2,IGM:3]
----

これらの2つのコレクションがあるとして、１つの値のセットの合計をもう1つのセットで割ると、アリゾナとニューメキシコの滑走路の合計数の比率を計算することができる。下記のクエリはまさにそれを実行する。一目見ると、このクエリは少し複雑のようだが、実際にはこれまでに調べたいくつかのクエリを1つのクエリに組み合わせた結果にすぎない。

[source,groovy]
----
g.V().has('region','US-NM').
      group().by('code').by(values('runways')).
      select(values).
      unfold().
      sum().
      store('a').
      V().has('region','US-AZ').
      group().by('code').by(values('runways')).
      select(values).
      unfold().
      sum().
      store('b').
      project('first','second').
        by(select('a').unfold()).
        by(select('b').unfold()).
      math('first / second')

1.0384615384615385
----

ニューメキシコに滑走路が27本あり、アリゾナには26本あると計算できたので、 Gremlin コンソールを使って正しい結果が得られたことを確認できる。

[source,console]
----
gremlin> 27/26

==>1.0384615385
----


[[sackintro]]
=== 値を格納する方法として sack を導入する

うまくいけば、今明らかになっているように、特定のタイプのクエリを効率的に作成するには、トラバーサルが行われるときに要素のコレクションを構築する方法が必要だ。トラバーサル中に要素のコレクションを作成できる'aggregate'や'store'のようなステップについてはすでに見てきた。しかしながら、'sack'ステップにはどの要素をコレクションに追加するかを指定できるという追加機能が用意されている。例えば、加算、乗算、減算あるいは除算を使って追加できる。あるいは、ペアの値の最小値、あるいは最大値を保存できる。これらお酔い他の sack 演算子は本書の様々なところで使われている。

[[sackbasics]]
==== 基本的な sack 操作

下記の例に示すように、'sack'ステップは、副作用ステップである。つまり、トラバーサル中に値を格納できるが、次のステップに渡される内容には影響しない。

初めに、下記の例を見ていただきたい。現状のクエリでは、サンタフェ(SAF) から飛ぶことができる各空港の滑走路の数のリストを作成するだけだ。我々はまだ問題に'sack'ステップは導入していない。

[source,groovy]
----
g.V().has('code','SAF').out().values('runways').fold()

[7,4,3,6]
----

それではクエリでsack のいくつかの使い方を導入してみよう。'sack'を使う際は、通常、何らかの方法で sack を初期化する。下記の例では、値がゼロのsack を初期化するが、まだ何も実行していないので、結果は変更されない。

[source,groovy]
----
g.withSack(0).V().has('code','SAF').out().
              values('runways').fold()

[7,4,3,6]
----

今回は、sum 演算を使って滑走路を sack に追加するが、開始値がゼロなので、実際には最終的な結果を何も変更していない。これは、本質的に、滑走路の数ごとに、'0 + runways'の操作を実行してるからだ。最後のパラメータを指定しない'sack'の呼び出しは、現在の'sack'の中身が返される。 前と同様、'fold'ステップは何であれ'sack'から取得した結果をリストに格納する。

[source,groovy]
----
g.withSack(0).V().has('code','SAF').out().
              values('runways').sack(sum).sack().fold()

[7,4,3,6]
----

それでは、最終的に結果を変更することを実行しよう。開始値をゼロではなく1にして、何が起こるか見てみよう。

[source,groovy]
----
g.withSack(1).V().has('code','SAF').out().
              values('runways').sack(sum).sack().fold()

[8,5,4,7]
----

これで、'sum'演算子を使って滑走路の数が sack に追加されるたびに、実行された操作は、'1 + runways'だった。結果からお分かりのように、いづれの場合も、返される値は、前のクエリの値より1つ大きくなる。これはとても単純な例ではあるが、sack がどれほど便利かわかり始めるのにお役に立てると思う。

より興味深い例に進む前に、下記に示すように、'assign'演算子を使うと初期化もできること指摘しておく価値があると思う。この sack の初期化はクエリの開始時に行わなければならないわけではない点を注意することも重要だ。下記の例では、定数値１が使われているが、次の例にあるように、トラバーサルを使ってsack を初期化することもできる。

[source,groovy]
----
g.V().sack(assign).by(constant(1)).has('code','SAF').
      out().values('runways').sack(sum).sack().fold()

[8,5,4,7]
----

ここでクエリをもう少し面白くしよう。下記のクエリに示されてる興味深い新しい工夫がいくつかある。まず、sack はAUS頂点からの滑走路の数を含むように初期化されているが、以前は単純な定数を使っただけだった。次に、sack に追加する前に明示的に'values'を 呼び出すのではなく、'by'モジュレータを使ってsackに追加したいものを指定しているだけであることに注目していただきたい。

[source,groovy]
----
g.V().has('code','AUS').sack(assign).by('runways').
  V().has('code','SAF').out().
      sack(sum).by('runways').sack().fold()

[9,6,5,8]
----

今回、オースティン(AUS)空港には滑走路が２本あるので、実際の計算は、 2+ '滑走路'になった。

複数の'sack'ステップを使う少し複雑なクエリを確認する前に、他の演算子についていくつか確認しておくべきだ。これまでのところ我々は'sum'を使っただけだった。下記のクエリは'mult'を使っていて、これはその名前が示すように、値を加算するのではなく、乗算する。

[source,groovy]
----
g.V().has('code','AUS').sack(assign).by('runways').
  V().has('code','SAF').out().
      sack(mult).by('runways').sack().fold()

[14,8,6,12]
----

同様に、minus は値を sack に入れる前に減算する。値は、sack の初期化された値 **から** 減算されることに注意してほしい。

[source,groovy]
----
g.V().has('code','AUS').sack(assign).by('runways').
  V().has('code','SAF').out().
      sack(minus).by('runways').sack().fold()

[-5,-2,-1,-4]
----

sack の初期値を他の値から減算したいのであれば、単に負の値で初期化して'sum'演算を実行するだけでよい。

[source,groovy]
----
g.V().sack(assign).by(constant(-1)).has('code','SAF').
      out().values('runways').sack(sum).sack().fold()

[6,3,2,5]
----

[[sackminmax]]
==== sack に min と max  を使う

sack で使える演算子には、いろいろある。それらは、'Operator'と呼ばれる、TinkerPop Java Enum の一部として定義されている。利用できるそのような演算子の２つが、'min'と'max'である。下記の例では、SAFを開始点とするすべての経路の距離を調べて、各々の場合に、クエリの開始時に sack に割り当てられた距離の最小値あるいは400 を返す。

[source,groovy]
----
g.V().sack(assign).by(constant(400)).has('code','SAF').
      outE().sack(min).by('dist').sack().fold()

[400,400,369,303]
----

同様に、このクエリは実際の距離の最大値、あるいは400 を選択する。

[source,groovy]
----
g.V().sack(assign).by(constant(400)).has('code','SAF').
      outE().sack(max).by('dist').sack().fold()

[549,708,400,400]
----


[[sackcalc]]
==== sack を使って計算を行う

次に、もっと複雑で、できればもっと興味深い例を見てみよう。課題は、サンタフェ(SAF) を開始点として、経路が1か所ある経路を10件示すクエリを書くことだ。また、各ホップ間の距離と、2つのホップの合計の距離を返したい。これは'sack'を使うと便利なクエリの完全な例だ。完全を期すために、結果は全体的な経路の距離でソートされている。

[source,groovy]
----
g.withSack(0).
  V().has('code','SAF').
      repeat(outE().sack(sum).by('dist').inV()).times(2).limit(10).
      order().by(sack()).
      sack().path().
      by('code').by('dist').by('code').by('dist').by('code').by()
----

クエリを実行すると、下記に示す出力のようなものが返るはずだ。どのように'sack'からの出力 ( 各行の最後の項目 ) に2つの前の経路の距離が含まれているかに注目していただきたい。したがって、例えば、SAFから途中 DFW を経由してATLへの合計距離が 1278 マイルであることがわかる。

[source,groovy]
----
[SAF,549,DFW,190,AUS,739]
[SAF,549,DFW,225,IAH,774]
[SAF,549,DFW,630,BNA,1179]
[SAF,549,DFW,729,ATL,1278]
[SAF,549,DFW,1120,FLL,1669]
[SAF,549,DFW,1170,IAD,1719]
[SAF,549,DFW,1190,DCA,1739]
[SAF,549,DFW,1210,BWI,1759]
[SAF,549,DFW,1560,BOS,2109]
[SAF,549,DFW,3030,ANC,3579]
----

上記のクエリからは明確ではないかもしれないが、実際には同じクエリ内で複数の'sack'ステップを使っている。'repeat'を削除して、クエリを完全に書きなおすと、これはより明確になる。

[source,groovy]
----
g.withSack(0).
  V().has('code','SAF').
      outE().limit(10).sack(sum).by('dist').inV().
      outE().limit(10).sack(sum).by('dist').inV().
      sack().path().
      by('code').by('dist').by('code').by('dist').by('code').by()  
----

後ほど、"<<sackauslhr>>" のセクションにて、上記の例と同様のアプローチを使って、再度'sack'を使って複数ホップ経路の距離を計算する。

これまで、単純な整数値だけを使って、sackの初期化を行ってきた。しかしながら、sack を使う際には、マップなどの非プリミティブなタイプを使うこともできる。マップを生成するのに使う'sack'の例が、"<<anothersack>>" のセクションにある。

[[nonsackcalc]]
==== sack を使わずに計算を行う

前のセクションのクエリと同様の結果は、実際には'sack'を使わずに得ることができる。'sack'形式は非常に完結であるが、下記に示すように、'project'ステップを使っても同様の結果を得ることができることがわかった。このクエリに関して注目すべき重要なことは、クエリの前半で生成されたパスはエッジからの距離を得るために展開されることだ。air-routes グラフでは、エッジのみが'dist'プロパティをもっているので、coalesce ステップはエッジからの距離あるいはさもなければ、ゼロの定数値を生成するために使われる。これを行わなかった場合、空港頂点には'dist'プロパティがないので、クエリはエラーメッセージを生成する。

[source,groovy]
----
g.V().has('code','SAF').
      repeat(outE().inV().simplePath()).times(2).limit(10).
        project('path','total').
          by(path().by('code').by('dist')).
          by(path().unfold().coalesce(values('dist'),constant(0)).sum()).
          order().by(select('total'))
----

クエリを実行すると、下記の結果が生成される。出力には'path'や'total'キー名が含まれ、パスはリスト内にネストされたリストに含まれていることに注意してほしい。 

[source,groovy]
----
[path:[SAF,549,DFW,190,AUS],total:739]
[path:[SAF,549,DFW,225,IAH],total:774]
[path:[SAF,549,DFW,630,BNA],total:1179]
[path:[SAF,549,DFW,729,ATL],total:1278]
[path:[SAF,549,DFW,1120,FLL],total:1669]
[path:[SAF,549,DFW,1170,IAD],total:1719]
[path:[SAF,549,DFW,1190,DCA],total:1739]
[path:[SAF,549,DFW,1210,BWI],total:1759]
[path:[SAF,549,DFW,1560,BOS],total:2109]
[path:[SAF,549,DFW,3030,ANC],total:3579]
----

クエリはもう少し詳細化して、 それぞれの値を選択するだけで結果から'path'と'total'キー名を削除することができる。

[source,groovy]
----
g.V().has('code','SAF').
      repeat(outE().inV().simplePath()).times(2).limit(10).
        project('path','total').
          by(path().by('code').by('dist')).
          by(path().unfold().coalesce(values('dist'),constant(0)).sum()).
          order().by(select('total')).
          select(values)
----

これで、結果は'sack'を使ったバージョンのクエリと全く同じになった。これは、書くのに長いクエリだったが、グラフデータベースの実装によっては、クエリの後半まで結果の処理が残されるので、より効率的な場合がある。

[source,groovy]
----
[[SAF,549,DFW,190,AUS],739]
[[SAF,549,DFW,225,IAH],774]
[[SAF,549,DFW,630,BNA],1179]
[[SAF,549,DFW,729,ATL],1278]
[[SAF,549,DFW,1120,FLL],1669]
[[SAF,549,DFW,1170,IAD],1719]
[[SAF,549,DFW,1190,DCA],1739]
[[SAF,549,DFW,1210,BWI],1759]
[[SAF,549,DFW,1560,BOS],2109]
[[SAF,549,DFW,3030,ANC],3579]
----

さらに詳細化を加えて、結果を展開し、'local'スコープを使って再fold することにより、結果を'sack'を使ったバージョンのクエリの結果と全く同じにすることができる。

[source,groovy]
----
g.V().has('code','SAF').
      repeat(outE().inV().simplePath()).times(2).limit(10).
        project('path','total').
          by(path().by('code').by('dist')).
          by(path().unfold().coalesce(values('dist'),constant(0)).sum()).
          order().by(select('total')).
          select(values).local(unfold().unfold().fold()) 
----

これで、結果は'sack'を使って得た結果と全く同じになった。

[source,groovy]
----
[SAF,549,DFW,190,AUS,739]
[SAF,549,DFW,225,IAH,774]
[SAF,549,DFW,630,BNA,1179]
[SAF,549,DFW,729,ATL,1278]
[SAF,549,DFW,1120,FLL,1669]
[SAF,549,DFW,1170,IAD,1719]
[SAF,549,DFW,1190,DCA,1739]
[SAF,549,DFW,1210,BWI,1759]
[SAF,549,DFW,1560,BOS,2109]
[SAF,549,DFW,3030,ANC,3579]
----

クエリは同じ'path'や'coalesce'アプローチを使って書くこともできるが、今回は'local'スコープで'union'ステップを使った。これは、'project'を使ったバージョンより簡潔であり、キー名を使って結果の一部を個別に選択する必要がないのであれば、これで十分な場合もある。

[source,groovy]
----
g.V().has('code','SAF').
      repeat(outE().inV().simplePath()).times(2).limit(10).
      local(union(path().by('code').by('dist').unfold(),
                  path().unfold().coalesce(values('dist'),constant(0)).sum()).fold()).
      order().by(tail(local,1))
----

ここでも、'sack'または、'project'を使った場合と同じ結果が得られた。

[source,groovy]
----
[SAF,549,DFW,190,AUS,739]
[SAF,549,DFW,225,IAH,774]
[SAF,549,DFW,630,BNA,1179]
[SAF,549,DFW,729,ATL,1278]
[SAF,549,DFW,1120,FLL,1669]
[SAF,549,DFW,1170,IAD,1719]
[SAF,549,DFW,1190,DCA,1739]
[SAF,549,DFW,1210,BWI,1759]
[SAF,549,DFW,1560,BOS,2109]
[SAF,549,DFW,3030,ANC,3579]
----

これまで見てきたように、'sack'形式は非常に完結ではあるが、'project'形式や'union'形式には、結果のパスがどれだけ長くても変更されないという優れた機能がある。前のセクションですでにお気づきかもしれないが、クエリの'sack'バージョンは２ホップクエリの結果を生成するように調整されている。もちろん、下記に示すように、'sack'バージョンのを同じように柔軟に書き換えることもできる。主な違いは、sack からの結果は、パスに含まれていないが、後で'union'ステップ内で考慮される。

[source,groovy]
----
g.withSack(0).
  V().has('code','SAF').
      repeat(outE().sack(sum).by('dist').inV()).times(2).limit(10).
      order().by(sack()).
      local(union(path().by('code').by('dist'),
                  sack()).fold()).
      local(unfold().unfold().fold())
----

ここでも同じ結果が得られる。

[source,groovy]
----
[SAF,549,DFW,190,AUS,739]
[SAF,549,DFW,225,IAH,774]
[SAF,549,DFW,630,BNA,1179]
[SAF,549,DFW,729,ATL,1278]
[SAF,549,DFW,1120,FLL,1669]
[SAF,549,DFW,1170,IAD,1719]
[SAF,549,DFW,1190,DCA,1739]
[SAF,549,DFW,1210,BWI,1759]
[SAF,549,DFW,1560,BOS,2109]
[SAF,549,DFW,3030,ANC,3579]
----

よって、まとめると、ほとんどの場合のように、Gremlin クエリを使って必要な結果を得る方法は複数ある。

[[sackpathlength]]
==== sack を使ってホップ数を計算する

次のクエリでは、'sack'を使って、'path'を構成するフライトセグメント(あるいはホップ）の数を追跡している。これは、'path'の結果と合わせて、パスの'ホップ数'も返すことができるということだ。

下記のクエリでは、オースティンとウェリントン間の経路を検索し、見つかった最初の10件を、出発地の空港と目的地の空港の間を移動する必要のあるフライトの数と合わせて返す。'repeat'ステップの一部として、'out'ステップが実行されるたびに定数値の1が個々のpath のsack に追加される。最後に、'union'ステップを使って個々のパスが そのホップカウントと組み合わせられる。

[source,groovy]
----
g.withSack(0).V().
  has('code','AUS').
  repeat(out().simplePath().sack(sum).by(constant(1))).
    until(has('code','WLG')).
  limit(10).
  local(union(path().by('code'),sack()).fold())
----

このクエリを実行すると、訪問した空港と、個々のリストのホップ数を含んだ10個のリストが返される。

[source,groovy]
----
[[AUS,DFW,SYD,WLG],3]
[[AUS,IAH,AKL,WLG],3]
[[AUS,LAX,SYD,WLG],3]
[[AUS,LAX,MEL,WLG],3]
[[AUS,LAX,AKL,WLG],3]
[[AUS,LAX,BNE,WLG],3]
[[AUS,SFO,SYD,WLG],3]
[[AUS,SFO,AKL,WLG],3]
[[AUS,YYZ,HND,SYD,WLG],4]
[[AUS,YYZ,HND,AKL,WLG],4]
----

より長い経路が最初に来る結果を返すには、'order'ステップと一緒にsack の中の値を使うとよい。

[source,groovy]
----
g.withSack(0).V().
  has('code','AUS').
  repeat(out().simplePath().sack(sum).by(constant(1))).
    until(has('code','WLG')).
  limit(10).
  order().by(sack(),desc).
  local(union(path().by('code'),sack()).fold())
----

今回は、4つのホップ経路が結果の最初に現れる。

[source,groovy]
----
[[AUS,YYZ,HND,SYD,WLG],4]
[[AUS,YYZ,HND,AKL,WLG],4]
[[AUS,DFW,SYD,WLG],3]
[[AUS,IAH,AKL,WLG],3]
[[AUS,LAX,SYD,WLG],3]
[[AUS,LAX,MEL,WLG],3]
[[AUS,LAX,AKL,WLG],3]
[[AUS,LAX,BNE,WLG],3]
[[AUS,SFO,SYD,WLG],3]
[[AUS,SFO,AKL,WLG],3]
----

ちなみに、ホップカウントではなく、パスの長さを含めたい場合は、下記のようにクエリを変更するとよい。この場合、各パスの長さをカウントするだけなので、'sack'ステップは必要ではない。

[source,groovy]
----
g.V().has('code','AUS').
      repeat(out().simplePath()).
        until(has('code','WLG')).
      limit(10).
      local(union(path().by('code'),path().count(local)).fold())
----

今回は、出発空港が全体のカウントに含まれているので、表示されている数は前の例よりも1つ大きい。

[source,groovy]
----
[[AUS,DFW,SYD,WLG],4]
[[AUS,IAH,AKL,WLG],4]
[[AUS,LAX,SYD,WLG],4]
[[AUS,LAX,MEL,WLG],4]
[[AUS,LAX,AKL,WLG],4]
[[AUS,LAX,BNE,WLG],4]
[[AUS,SFO,SYD,WLG],4]
[[AUS,SFO,AKL,WLG],4]
[[AUS,YYZ,HND,SYD,WLG],5]
[[AUS,YYZ,HND,AKL,WLG],5]
----

[[sackbooleans]]
==== sack にブール演算を使う

'sack'を扱う場合、ブール演算子の'or'や'and'を使うこともできる。下記の例では、'true'と'false'の定数を使って基本的な機能をテストしているだけだ。最初の例では、'sack'で返された結果は、'and'演算時を使って、sackの初期値'true'と定数値'false'を合わせて'and'したので'false'だ。

[source,groovy]
----
g.V(3).sack(assign).by(constant(true)).sack(and).by(constant(false)).sack()

false
----

今回は'and'演算子を'or'に置き換えたら、結果は予想通り'true'になる。

[source,groovy]
----
g.V(3).sack(assign).by(constant(true)).sack(or).by(constant(false)).sack()

true
----

定数を使ってブール演算を実行できることを示すことは興味深いことではあるが、おそらくあまり便利ではない。この機能がより興味深くなるのは、使用されている値が、たとえば、頂点プロパティからのものであるかどうかだ。なので、それぞれがブール値のプロパティをもつ頂点をいくつか生成してみよう。

[source,groovy]
----
g.addV('happy').property('happy',true)

v[54852]

g.addV('sad').property('happy',false)

v[54854]
----

我々はすでに、ブール演算子を使ってsackに結果を生成するクエリを書くことができる。下記の例は、少し恣意的ではあるが、どのようにブール演算子を使うことができるかを示している。IDが3 の頂点からスタートして、'sack'を定数'true'で初期化し、'and'演算子を'happy'のラベルをもつ頂点の'happy'プロパティに適用する。結果はパスに返す。そのパスには開始頂点と、'and'演算の結果が含まれている。'happy'頂点には'happy'プロパティに'true'の値があるので、'and'の結果は'true'である。

[source,groovy]
----
g.V(3).sack(assign).by(constant(true)).sack(and).
       by(V().hasLabel('happy').values('happy')).sack().path()

[v[3],true]
----

クエリを繰り返すが、今回は'sad'頂点を使うと、'and'演算から期待された結果である、'false'が得られる。

[source,groovy]
----
g.V(3).sack(assign).by(constant(true)).sack(and).
       by(V().hasLabel('sad').values('happy')).sack().path()

[v[3],false]
----

[[sackaddall]]
==== sack に addAll とリストを使う

これまで、sack で数とブール値を使うのを見てきた。しかしながら、 sack にはリストや、後で説明するようにマップを含めることができる。

下記の例は、sack を空のリスト'"[]"'で初期化し、次に、'addAll'演算子を使って上記で生成されたのと同じ結果をリストに格納する。'fold'ステップはsackに追加できる値のリストを生成するために使われることに注意してほしい。後で、最初にすべてのトラバーサル結果をリストに折りたたまないsack を使ってリストを作成する他の方法を確認する。

[source,groovy]
----
g.withSack([]).V().has('code','SAF').out().
               values('runways').fold().sack(addAll).sack()

[7,4,3,6]
----

下記に示すように、'sack'をまったく使わず、'fold'ステップを使うだけで、同じ結果を得ることができたと考えているかもしれない。しかしながら、クエリのさまざまな部分の結果を含むリストを作成する必要がある場合は、'sack'を使うことの威力が明らかになる。

[source,groovy]
----
g.V().has('code','SAF').out().values('runways').fold()

[7,4,3,6]
----

下記の次の例は、複数の'sack'ステップを使ってリストを作成する方法について示している。'sack'は空のリストで初期化され、SAF から到達可能な空港の滑走路のカウントが'addAll'演算子を使って最初にリストに追加される。これが完了すると、AUS から到達可能な空港の滑走路のカウントが sack に追加される。お分かりのように出力は前に見たのと同じ、7,4,3,6 の並びで始まるが、2つ目の 'sack'ステップで追加された他のすべての値が続いている。

[source,groovy]
----
g.withSack([]).V().has('code','SAF').out().
               values('runways').fold().sack(addAll).
               V().has('code','AUS').out().values('runways').fold().
               sack(addAll).sack()

[7,4,3,6,3,4,6,5,2,4,2,4,3,2,4,2,4,4,3,3,3,4,4,5,3,3,2,2,2,1,4,1,4,5,4,6,3,3,7,2,4,5,4,4,4,4,4,8,3,3,3,4,3,3,1,3,2,4,4,6,2,3,4,3,3,4]
----

最後に、これが前のクエリだが、今回は、'sack'がすでにいくつかの値を含んでいるリストで初期化されている。上記で生成された値はsackが初期化された1,1,1,1のシーケンスの後で追加されたことが出力からわかる。

[source,groovy]
----
g.withSack([1,1,1,1]).
     V().has('code','SAF').out().
     values('runways').fold().sack(addAll).
     V().has('code','AUS').out().values('runways').fold().
     sack(addAll).sack()

[1,1,1,1,7,4,3,6,3,4,6,5,2,4,2,4,3,2,4,2,4,4,3,3,3,4,4,5,3,3,2,2,2,1,4,1,4,5,4,6,3,3,7,2,4,5,4,4,4,4,4,8,3,3,3,4,3,3,1,3,2,4,4,6,2,3,4,3,3,4]
----

これまでのところ、すべての例では、'sack'ステップの前に'fold'ステップを使っている。これにより有用な結果が得られているが、必ずしも求めている結果であるとは限らない。別の言い方をすると、返されるのは、トラバーサル中に生成された全ての値を含んだ単一のリストである。実際に求めていたものはリストのセットであり、各リストには、'sack'が初期化されたものに加えて、トラバーサーがたどる各パスに固有の値のみが、含まれる。言い換えると、'sack'がより多くのローカルスコープをもち、グローバル変数のように機能しないようにする必要がある。

これについて検討し、Gremlin コンソールを使って実験をいくつか行うと、最初に考えたのは、"これには、'local'ステップが使える" ということだった。なので、最初に下記に示すクエリを試した。しかしながら、ごらんのとおり、これは確かにいくつかの異なる出力を生成したが、私が望んだものではなかった。

[source,groovy]
----
g.withSack([1,1,1,1]).V().has('code','SAF').out().
     values('runways').local(fold().sack(addAll)).sack()

[1,1,1,1,7]
[1,1,1,1,7,4]
[1,1,1,1,7,4,3]
[1,1,1,1,7,4,3,6]
----

上記で起こっていることは、'sack'がまだローカル変数ではなく、グローバル変数のように動いているということだ。各'sack'ステップは前のステップに基づいたリストを生成した。

求めている結果を得るには、'clone'演算を使うことが必要だった。このクエリは Groovy のクロージャ、あるいは'Lambda'構文を使っている。この構文については、少し後の "<<lambdas>>" のセクションで詳しく説明するが、今、知っておくべきことは、'clone'は各トラバーサーが元の sack の独自のコピーを取得し、他のトラバーサーが'sack'に対して行うことからの影響は受けないということだ。Gremlin クエリ、あるいはトラバーサルは、本質的に、一連のトラバーサーがクエリのが要求するグラフのパスをたどる原因となることを覚えておいてほしい。

[source,groovy]
----
g.withSack{[1,1,1,1]}{it.clone()}V().has('code','SAF').
       out().values('runways').local(fold().sack(addAll)).sack()

[1,1,1,1,7]
[1,1,1,1,4]
[1,1,1,1,3]
[1,1,1,1,6]
----

後の、"<<lambdasack>>" のセクションで'sack'と ラムダ式のトピックを再検討し、前のクエリを書くことができたかもしれない別の方法について確認する。

[[sackpredicate]]
==== プロパティと定数をsack の値と比較する

トラバーサル中に、sack を段階的に変更し、頂点プロパティやエッジプロパティを sack の現在の中身と比較したいことがあるかもしれない。下記の例は、これを行う方法を示している。単純にするために、最初は値が6 に初期化され、変更されない sack を使う。これは各空港の滑走路の数をsack に格納された値と比較する方法を示している。

[source,groovy]
----

g.withSack(6).V().
  hasLabel('airport').as('a').
  where(gt('a')).
    by('runways').
    by(sack()).
  values('code')

DFW
ORD
----

"<<pathstepwarn>>" のセクションで述べたように、'as'ステップを使ってトラバーサルの前半部分を覚えておくことは、メモリ使用量の観点でコストがかかる可能性がある。これはair-routes のような小さいグラフでは問題とはならないが、より大きなグラフを扱う際には問題になる可能性がある。下記に示すように、'as'ステップを使わないように書き換えるとよいだろう。

[source,groovy]
----
g.withSack(6).V().
  hasLabel('airport').
  filter(project('a','b').
           by('runways').
           by(sack()).
         where('a', gt('b'))).
  values('code')

DFW
ORD
----

明らかに、これらの例はこれらの概念を示しているが、実際にはこれまでのところ、'sack'ステップを使うことを正当化するようなことは本当に何もしていない。クエリは下記のように簡単に書くことができる。しかしながら、これにより、sack とプロパティ値を比較できる基本的な構成要素が得られるのではと思う。

[source,groovy]
----
g.V().has('airport','runways',gt(6)).values('code')

DFW
ORD
----

より興味深くsack を使うようにクエリを変更しよう。下記のクエリはサンタフェ(SAF) から始まり、移動距離が10,000マイルを超えるまで出エッジをトラバースする。結果が5件だけ返された。

[source,groovy]
----
g.withSack(0).V().
  has('code','SAF').
  repeat(outE().
         sack(sum).by('dist').
         inV()).
  until(sack().is(gt(10000))).
  limit(5).
  path().
    by('code').
    by('dist')
----

クエリを実行すると、10,000マイル以上移動するとすぐに停止する一連の経路が返される

[source,groovy]
----
[SAF,549,DFW,1560,BOS,7952,HKG]
[SAF,549,DFW,1230,LAX,8287,DOH]
[SAF,549,DFW,1230,LAX,8372,AUH]
[SAF,549,DFW,1230,LAX,8314,JED]
[SAF,549,DFW,1230,LAX,8246,RUH]
----

最後に、クエリを再度修正して、SAFから始める経路をたどり続けるようにするが、今回は、各経路が 2,500 マイルを超えてはいけないという制約を追加する。8,000 マイル以上移動するまでは移動し続ける。これもまた、グラフトラバーサルの過程で sack を使って現在の合計を格納する方法を示している。今回は、合計距離と合わせてたどったパスが'union'ステップを使って組み合わせられている。また、'simplePath'ステップをクエリに追加して同じ空港を再訪しないようにした。

TIP: 長いクエリを複数行に分割すると、読みやすくて理解しやすくなる。

このセクションのクエリを複数行に分割していることに気づくだろう。クエリがより複雑になるにつれて、これはより重要になる。

[source,groovy]
----
g.withSack(0).
  V().
  has('code','SAF').
  repeat(outE().
         has('dist',lte(2500)).
         sack(sum).by('dist').
         inV().
         simplePath()).
  until(sack().is(gt(8000))).
  limit(5).
  local(union(path().
                by('code').
                by('dist').
              unfold(),
              sack()).
        fold())   
----

修正したクエリを実行した結果は下記の通り。

[source,groovy]
----
[SAF,708,LAX,2481,OGG,2401,SMF,2492,EWR,8082]
[SAF,708,LAX,2481,OGG,2401,SMF,2459,HNL,8049]
[SAF,708,LAX,2481,OGG,2352,SJC,2462,LIH,8003]
[SAF,708,LAX,2500,KOA,2375,OAK,2440,BWI,8023]
[SAF,708,LAX,2500,KOA,2375,OAK,2453,LIH,8036] 
----

[[lambdas]]
=== Lambda 関数を使う

Gremlin を使うと、コードフラグメント(ラムダ関数、あるいはクロージャと呼ばれることもある) をクエリの一部に含めることができる。これは通常'filter'、'map'あるいは'sideEffect'ステップの一部とじて実行されるが、'sack'を扱う場合などこの概念が使われるところは他にもある。この手法により、クエリの記述方法に多くの柔軟性が得られる。しかしながら、注意が必要だ。クエリを処理する際、Gremlin は可能な限り最適化しようとする。'out'や、'has'のような通常のトラバーサルステップでは、Gremlin はこの最適化を行う。しかしながら、クロージャ(中カッコ '{ }' 内のコード) の場合、Gremlin はこれを実行することはできず、依存するランタイムにクロージャを渡すだけだ。Gremlin を使い始めたばかりの人にとって、インラインコードを過度に使いたくなる大きな誘惑がある。これはプログラマにとって、慣れ親しんだプログラミングのように感じるので、自然なことだ。しかしながら、いつもではないにせよ、必要なことを実行するために使用できる純粋な Gremlin トラバーサルステップはよくある。もちろん、すべてのルールには例外があるものだ。

NOTE: セキュリティ上の理由により、すべてのグラフデータベース、特にホストされたサービスとして管理されているデータベースでは、ラムダをクエリに含めることができない。使っているグラフデータベースのドキュメントを常に確認すべきである。

非常に単純な例として、下記のコードは変数 '"c"'を宣言し、ゼロに初期化している。その次のGremlin クエリは、オレゴンにある空港の頂点を見つけるたびに'"c"'に1を加算する。次に'println'を使って、'"c"'の更新された値を表示する。

[source,groovy]
----
c = 0
g.V().has('region','US-OR').sideEffect{ c += 1 }.values('code').fold()

println "I found ${c} airports in Oregon"
----

クエリを実行すると、これが返される。

[source,groovy]
----
[PDX,EUG,LMT,MFR,OTH,RDM,PDT]
I found 7 airports in Oregon
----

もちろん、実際には、何かを数える際には'count'を使うかあるいは、リストに入れて返されるリストのサイズを確認するが、上記の例では、優れた、そして願わくは理解しやすい例として、'sideEffect'ステップの一部として使われているクロージャの例を示している。

完全を期すために、'sideEffect'あるいはクロージャを使わないでいくつかの別の方法でクエリを書き直してみたのがこれだ。もし、カウントだけが必要なのであれば、もちろんじっこうできる。

[source,groovy]
----
num = g.V().has('region','US-OR').values('code').count().next()
println "I found ${num} airports in Oregon"

I found 7 airports in Oregon
----

見つかった空港コードのリストを保存し、それらをカウントしたいのであれば、これを実行するとよい。

[source,groovy]
----
oregon = []
g.V().has('region','US-OR').values('code').fill(oregon);[]
println oregon
println "I found ${oregon.size} airports in Oregon"
----

これが出力で、今回は空港コードとカウントが含まれている。

[source,groovy]
----
[PDX, EUG, LMT, MFR, OTH, RDM, PDT]
I found 7 airports in Oregon
----

これは代わりに'has'ステップが使え、使うはずだったクロージャの別の例だ。

[source,groovy]
----
// What airports are located in London?
g.V().hasLabel('airport').filter{it.get().property('city').value() =="London"}
----

これは'has()'ステップを使っただけの同じクエリだ。これは Gremlin がそれ自体でこれをうまく処理できるので、ラムダ関数を使う必要ないケースだ。

[source,groovy]
----
// What airports are located in London?
g.V().hasLabel('airport').has('city','London')
----

2つ目のバージョンははるかに読みやすく、Gremlin がその機能を実行できるようになることに同意いただけると思う。

'sideEffect'ステップを含んだクエリの別の例をお見せする。クエリの主要部分は、滑走路が6本ある空港を見つけてそれをカウントする。その結果はまだ返されるが、副作用によりそれらの空港のコードも出力される。これは少し不自然な例ではあるが、クロージャと組み合わせたときに'sideEffect'はどのように振る舞うかを示している。

[source,groovy]
----
// Example of the 'sideEffect' step
g.V().has('runways',6).sideEffect{print it.get().values('code').next()+" "}.count()
----

TIP: ここでの教訓は、必要なことを達成する他の方右方が本当に見つからない場合でなければクロージャを避けることだ。純粋な Gremlin の方法を理解するよりも、やりたいことを実行するのにクロージャを思いつく方が簡単な場合があることを観察することはフェアだと思うが、可能であれば、Gremlin のステップだけを使うことお勧めする。ラムダ関数は一般的に推奨されていない。

Gremlin では現在言語に正規表現のサポートは組み込まれていない。しかしながら、後ほど"<<janpred>>" のセクションで説明するように、JanusGraph ではいくつかのサポートが用意されている。正規表現のサポートが組み込まれていない TinkerGraph などのグラフを扱う場合、下記の2つの例に示すように、ラムダと組み合わせた'filter'ステップを使うとよい。これらの例では、Java String  クラスで用意されているメソッドを利用している。追加のテキスト検索述部のサポートは将来の Apache TInkerPop のリリースで出てくるかもしれない。

[source,groovy]
----
g.V().hasLabel('airport').
      filter{ it.get().value('city').startsWith('Dal')}.
      values('city')
----

クエリを実行すると、パターンにマッチするすべての空港の都市名が見つかる。

[source,groovy]
----
Dallas
Dallas
Dalaman
Dalian
Dalcahue
Dalat
Dalanzadgad
----

次の例では、クロージャと組み合わせた'filter'ステップを使って、'"F."'のような文字'"F"'の後にピリオドが続く説明がある空港の頂点を検索する。これは興味深い例ではあるが、この結果を得る方法は他にもある。そのような方法の１つは、 混合インデックスと特殊なテキスト検索述部を使うことだ。但し、これはかなり後ろの方のトピックだ。

[source,groovy]
----
g.V().hasLabel('airport').as('a').values('desc').
     filter{it.toString().contains('F.')}.select('a').
     local(values('code','desc').fold())

[JFK,New York John F. Kennedy International Airport]
[BDA,Bermuda, L.F. Wade International International Airport]
[SLU,George F. L. Charles Airport]
[EUX,F. D. Roosevelt Airport]
----

ラムダ式を'filter'ステップで使う方法のさらなる例は、"<<fuzzyregs>>" のセクションにある。

[[mapstep]]
==== Map ステップを導入する

'map'ステップは、Ruby、Python または実際にGroovy などのプログラミング言語のユーザは慣れ親しんでいると思う。一連の結果、あるいはGremlin の場合であれば、グラフトラバーサルの現在の状態を取得し、その結果をトラバーサルの次の部分に渡す前に何らかの方法で変更できると便利なことが多い。'map'ステップでできることはそういうことだ。

'map'ステップはトラバーサル、あるいはクロージャを入力として受け入れることができる。トラバーサルの結果、あるいはクロージャは、トラバーサル全体の次のステップへ渡される。下記は、トラバーサルを使って渡されるものを変更する'map'ステップの単純な例だ。

[source,groovy]
----
g.V().hasLabel('airport').limit(10).map(properties('city'))
----

このクエリを実行すると返される出力は、選択された10けんの空港のそれぞれについて選択された頂点プロパティである。

[source,groovy]
----
vp[city->Atlanta]
vp[city->Anchorage]
vp[city->Austin]
vp[city->Nashville]
vp[city->Boston]
vp[city->Baltimore]
vp[city->Washington D.C.]
vp[city->Dallas]
vp[city->Fort Lauderdale]
vp[city->Washington D.C.]
----

さらに一歩進んで、'map'ステップを使ってキーと値のマップを生成することができる。

[source,groovy]
----
 g.V().hasLabel('airport').limit(10).
       map(properties('city').group().by(key()).by(value()))

[city:Atlanta]
[city:Anchorage]
[city:Austin]
[city:Nashville]
[city:Boston]
[city:Baltimore]
[city:Washington D.C.]
[city:Dallas]
[city:Fort Lauderdale]
[city:Washington D.C.]
----

上述したように、多くの場合、クエリの途中で'map'ステップを使って、次のステップへ渡される内容を変更する。下記の例は、'map'ステップからの出力を取得し、結果を都市名に基づいて降順にソートする。明らかに、このクエリを書くのにもっと簡単な方法があるが、これは'map'が非常にうまく機能することを示している。

[source,groovy]
----
g.V().hasLabel('airport').limit(10).
      map(properties('city').group().by(key()).by(value())).
      unfold().order().by(values,asc)
----

これは、ソートされた都市名を表示するクエリを実行した出力だ。

[source,groovy]
----
city=Anchorage
city=Atlanta
city=Austin
city=Baltimore
city=Boston
city=Dallas
city=Fort Lauderdale
city=Nashville
city=Washington D.C.
city=Washington D.C.
----

場合によっては、'map'ステップの省略形として使える'values'ステップなど、他のステップがある。例えば、下記の2つのクエリでは同じ結果が得られる。省略形がある場合、明示的な'map'ステップを書く必要はない。

[source,groovy]
----
g.V().hasLabel('airport').limit(10).map(values('city')).fold()

[Atlanta,Anchorage,Austin,Nashville,Boston,Baltimore,Washington D.C.,Dallas,Fort Lauderdale,Washington D.C.]

g.V().hasLabel('airport').limit(10).values('city').fold()

[Atlanta,Anchorage,Austin,Nashville,Boston,Baltimore,Washington D.C.,Dallas,Fort Lauderdale,Washington D.C.]
----

次に、ラムダ関数（クロージャ）が使われる例を見てみよう。まず、下記のクエリを見ていただきたい。これは単にグラフの最初の10けんの空港のIDを含むリストを返すだけだ。

[source,groovy]
----
g.V().hasLabel('airport').limit(10).id().fold()

[1,2,3,4,5,6,7,8,9,10]
----

上記のようなクエリを書きたいとして、このクエリは上記のクエリで返されたIDを、それぞれに１ずつ加算することで変更する。下記のクエリを見ていただきたい。我々はすでに、'map'ステップを導入した。'map'ステップはパラメータとしてクロージャ（あるいはラムダ）関するを取り、そこに流入する値をどのように操作したいかを指示する。'it'は'"流入したもの"'( この場合、トラバーサル) の Groovy 構文である。'get'は現在の頂点とそのプロパティにアクセスするのに必要である。最後に、頂点の'id'を取得し、それに 1 を加算する。変更された値はそのあとトラバーサルの次のステップに渡され、'fold'ステップによってリストになる。

[source,groovy]
----
g.V().hasLabel('airport').limit(10).map{it.get().id() + 1}.fold()

[2,3,4,5,6,7,8,9,10,11]
----

NOTE: これは、Groovy と Java で似ているが異なる構文の領域である。上記のクエリをJava のプログラムで使いたいのであれば、Java のラムダ関数構文を使う必要がある。

'map'ステップの優れている点は、'for each'型のループ構造を使って、クエリが完了した後で実行しないといけないことをクエリ自体の中で実行できることだ。

'map'ステップをについてもう1点注意すべきことは、クロージャには、セミコロンで区切られた複数のステップを含めることができるということだ。下記のクエリはそれを示している。

[source,groovy]
----
g.V().hasLabel('airport').limit(10).map{a=1;b=2;c=a+b;it.get().id() + c}.fold()

[4,5,6,7,8,9,10,11,12,13]
----

クロージャの最後の式からの値のみが'map'から返されることに注意してほしい。したがって、上述の例では、'c=a+b'、3 の結果が、各IDに追加される。

すでに見てきたように、Gremlin を使っていると、同じ結果を得るには多くの場合、複数の方法がある。また、パフォーマンスやその他の指標の点で、ほとんどの場合、他の方法よりもすぐれていることもある。"<<sackintro>>" では、'sack'ステップを使って下記のように一連の結果に1 を加算した。

[source,groovy]
----
g.withSack(1).V().has('code','SAF').out().
              sack(sum).by('runways').sack().fold()

[8,5,4,7] 
----

'map'ステップを使って、同じ結果を得ることができる。しかしながら、そうすることで、'sack'を使うバージョンを避けるためにクロージャを使う必要が生じる。不必要なクロージャを使うのを避けることはGremlinのベストプラクティスだ。

[source,groovy]
----
g.V().has('code','SAF').out().values('runways').map{it.get() + 1}.fold()

[8,5,4,7]
----

次のセクションでは、ラムダ式が非常に便利ないくつかの他のケースと、'map'ステップが使われる例をさらにいくつかを見ていく。

[[lambdasack]]
==== lambda を sack ステップで使う

"<<sackaddall>>" のセクションで、'sack'ステップがリストで機能する方法を紹介した。これで、'map'ステップと、Gremlin で Groovy のクロージャ(ラムダ関数) の使い方がもう少しわかったので、'sack'を扱うさらなる方法を調べることができる。

前に'sack'ステップとリストについてみたときは、例の1つとして下記のクエリを使った。

[source,groovy]
----
g.withSack{[1,1,1,1]}{it.clone()}V().has('code','SAF').
       out().values('runways').local(fold().sack(addAll)).sack()

[1,1,1,1,7]
[1,1,1,1,4]
[1,1,1,1,3]
[1,1,1,1,6]
----

'map'ステップについて確認できたので、必ずしも最善の方法ではないが、'map'の用法を示しているクエリを作成できる他の方法を下記に示す。

[source,groovy]
----
g.withSack{[1,1,1,1]}{it.clone()}V().has('code','SAF').out().
     values('runways').map{x->[x]}.sack(addAll).sack()

[1,1,1,1,7]
[1,1,1,1,4]
[1,1,1,1,3]
[1,1,1,1,6]
----

完全を期すために、'clone'(あるいは split) を使わずに同じクエリを実行した場合は、このようになる。

[source,groovy]
----
g.withSack([1,1,1,1]).V().has('code','SAF').out().
     values('runways').map{x->[x]}.sack(addAll).sack()

[1,1,1,1,7]
[1,1,1,1,7,4]
[1,1,1,1,7,4,3]
[1,1,1,1,7,4,3,6]
----

本書ではまだ説明していないが、クエリを書く別の方法はクロージャを直接'sack'ステップ自体に使うものだ。

[source,groovy]
----
 g.withSack([1,1,1,1]).V().has('code','SAF').out().
      values('runways').sack{a,v->a+=[v]}.sack()

[1,1,1,1,7]
[1,1,1,1,4]
[1,1,1,1,3]
[1,1,1,1,6]
----

下記のように、sack をリストの代わりにマップ'"[:]"'で初期化して、ラムダ関数を使って操作することもできる。

[source,groovy]
----
g.withSack{[:]}{it.clone()}.V().has('code','SAF').out().
     sack {m,v->m[v.values('code').next()]=v.values('runways').next();m}.sack()

[DFW:7]
[LAX:4]
[PHX:3]
[DEN:6]
----

何が起こるかを示すために、'clone'ステップを削除した同じクエリはこれだ。

[source,groovy]
----
g.withSack([:]).V().has('code','SAF').out().
     sack {m,v->m[v.values('code').next()]=v.values('runways').next();m}.sack()

[DFW:7]
[DFW:7,LAX:4]
[DFW:7,LAX:4,PHX:3]
[DFW:7,LAX:4,PHX:3,DEN:6]
----

返したいものが、上記の出力の最後の行にあるような、単一のキーと値のペアのリストだけであれば、それを実行するクエリを書くとよい。これを行う1つの方法は、下記に示すように'map'を使って'sack'をまったく使わないことだ。

[source,groovy]
----
g.V().has('code','SAF').out().
      map{m=[:];m[it.get().values('code').next()]=
      it.get().values('runways').next();m}.unfold().fold().next().getClass()

[DFW=7,LAX=4,PHX=3,DEN=6]
----

しかしながら、下記に示すように、'sack'を使ってこれを行うのは、私の見解ではよりきれいに思う。この場合、返されるものは Java の LinkedHashMap データ構造であり、前のクエリで生成されたものは LinkedHashMap.Enty の ArrayList オブジェクトである点に注意してほしい。また、この場合に求めている結果を取得するのに必要なことは、'fold'ステップを'sack'ステップの間に追加することだけだったことも注目に値する。

[source,groovy]
----
 g.withSack([:]).V().has('code','SAF').out().
      sack{m,v -> m[v.value('code')]=v.values('runways').next()}.fold().sack()

[DFW:7,LAX:4,PHX:3,DEN:6]
----

クロージャをまったく使わずにこのようなクエリを書く方法は他にもあるが、願わくは、これらの例が、クロージャを'sack'ステップと組み合わせることができる興味深い方法を示すことができていればと思う。

[[flatmap]]
==== flatMap ステップを導入する

他の Gremlin クエリ言語ステップの基礎となる一連の基本的なステップがある。それらの1つが'map'だ。他にも、これまで本書ではまだ見ていないものが、'flatMap'だ。この2つのステップは似ているが、これまで見てきた例からは明らかではないかもしれないが、根本的な違いがある。主な違いは下記の通り。'map'ステップが複数の入力を受け取ると、そのうちの最初のものだけが、次のステップに渡される。それに対し、'flatMap'ステップはそのすべてを次のステップに渡す。これを示すいくつかの例を見てみて、これを実際にのように活用できるか見てみよう。

下記の例は、'out'ステップが'map'ステップ内で使われた場合に何が起こるかを示している。検出された最初の頂点だけが返される。

[source,groovy]
----
g.V().has('code','SAF').map(out())

v[8]
----

同じ実験を'flatMap'ステップを使って行うと、すべての頂点が返されることが分かる。

[source,groovy]
----
g.V().has('code','SAF').flatMap(out())

v[8]
v[13]
v[20]
v[31]
----

'flatMap'が役に立つのは、次のような場合だ。この例は若干工夫されているが、このようなことができると非常に便利な場合がある。下記のクエリを見てほしい。これはAUS頂点を見つけるところから始まる。次に、すべての出エッジをトラバースし、それらのエッジの端にある頂点を見つけて、トラバースしたすべてのパスを返す。都市名とエッジの両方が結果に含まれている点に注目していただきたい。

[source,groovy]
----
g.V().has('code','AUS').outE().inV().
      path().by('city').by().limit(3)

[Austin,e[3712][3-route->43],Tucson]
[Austin,e[3713][3-route->45],Philadelphia]
[Austin,e[3714][3-route->46],Detroit]
----

エッジを確認する必要があるのには十分な理由があるが、エッジを結果の一部にふくめたくない場合を想像してみてほしい。我々にできることは、トラバーサルの'outE().inV()'の部分を'flatMap'の内部に配置することだ。上記のテストからわかるように、'flatMap'は渡されたすべての結果を返す。この場合は、エッジに接続された入頂点になる。ここで'path'ステップを実行すると、エッジの詳細は、'flatMap'ステップによってパスから本質的に削除されたので、パスの一部ではなくなる。これは、場合によっては便利な場合があるので、知っておくと便利なパターンである。

[source,groovy]
----
// Hide the edge from the path!
g.V().has('code','AUS').flatMap(outE().inV()).
      path().by('city').limit(3)

[Austin,Tucson]
[Austin,Philadelphia]
[Austin,Detroit]
----

下記に示すように、最初のパスのみを返すので、'map'ステップを使って同じ結果を得ることはできない。

[source,groovy]
----
g.V().has('code','AUS').map(outE().inV()).
      path().by('city').limit(3)

[Austin,Tucson]
----

もちろん、本当に望んでいたことが前のクエリの結果だけである場合は、これを行うことができる。

[source,groovy]
----
g.V().has('code','AUS').out().path().by('city').limit(3)

[Austin,Tucson]
[Austin,Philadelphia]
[Austin,Detroit]
----

最後に、'flatMap'が役に立つもう一つのケースを示す。下記の例では、'repeat'ステップの一部としてエッジのプロパティを確認したかったが、結果のパスにはエッジ自体が含まれていなかった。クエリは経路の距離を使って、空港間の距離が2,000マイルより短い経路を除外する。

[source,groovy]
----
g.V().has('code','AUS').
      repeat(flatMap(outE().has('dist',gt(2000)).inV())).
      times(2).
      path().
      limit(5)
----

クエリを実行すると、返される結果には頂点のみが含まれる。繰り返しになるが、'flatMap'ステップは'map'ステップとは異なり、探索されるパスごとに生成された最後の結果、この場合は'inV'ステップの結果、をトラバーサルの次の結果に渡すことができる点に注意してほしい。

[source,groovy]
----
[v[3],v[49],v[61]]
[v[3],v[49],v[64]]
[v[3],v[49],v[67]]
[v[3],v[49],v[69]]
[v[3],v[49],v[71]]
----

下記のクエリでは、'flatMap'ステップが削除されている。

[source,groovy]
----
g.V().has('code','AUS').
      repeat(outE().has('dist',gt(2000)).inV()).
      times(2).
      path().
      limit(5)
----

実行すると、今回の結果には、頂点だけだけでなくエッジも含まれる。

[source,groovy]
----
[v[3],e[5162][3-route->49],v[49],e[8448][49-route->61],v[61]]
[v[3],e[5162][3-route->49],v[49],e[8449][49-route->64],v[64]]
[v[3],e[5162][3-route->49],v[49],e[8450][49-route->67],v[67]]
[v[3],e[5162][3-route->49],v[49],e[8452][49-route->69],v[69]]
[v[3],e[5162][3-route->49],v[49],e[8454][49-route->71],v[71]]
----

[[fuzzyregs]]
==== 正規表現を使ってあいまい検索をする

クロージャを使うと役に立つと思われる１つのケース見てみよう。これはさまざまなデータベースを使う場合、ある種の曖昧なテキスト検索をしたり、正規表現を使って検索することは一般的な要件だ。TinkerPop 3 自体はこれを直接サポートしていない。言い換えると、現在、上記で見た基本的な'has()'タイプのステップを以外に高度なテキスト検索のメソッドは用意されていない。しかしながら、基盤となるグラフストアはそのような機能を提供することができる。

NOTE: あらゆる種類の本格的なデプロイで使いたいほとんどの TinkerPop 対応のグラフストアはSolr や Elasticsearch のようなインデックス技術によって支えられている。そのような場合、より高度な検索方法が理世う可能となる可能性がある。使っているシステムのドキュメントを常にチェックして、推奨事項を確認する必要がある。

TinkerGraph と Gremlin コンソールを使う場合、'city == "Dallas"'のような非常に基本的なことを超えるある種のテキスト検索する場合は、ラムダ関数の概念を頼り、基盤となる Groovy と Javaの特徴を利用する必要がある。本当のインデックスに裏付けられたグラフシステムでもこれから説明する例は機能するが、推奨される方法ではない可能性があることに注意してほしい。

それでは、いくつかの例をみてみよう。まず、air routes グラフのすべての空港には、DFW の場合にはダラスフォートワース国際空港のような説明が含まれている。説明に'Dallas'という単語がある空港のグラフ内の頂点を検索したい場合、Groovy の String.contains() メソッドを利用してこのように実行することができる。

[source,groovy]
----
// Airport descriptions containing the word 'Dallas'
g.V().hasLabel('airport').filter{it.get().property('desc').value().contains('Dallas')}
----

さらに興味深いのは、クエリの一部として正規表現を使いたい場合だ。下記の最初の例は、実際に正確な文字列比較を行っているので、Gremlinの'within()'ステップを使っても実現できるが、正規表現を含んだクエリを書くためのテンプレートになる。次の例は'Dal'で始まる名前の都市にあるすべての空港を検索するので、Dallas, Dalaman, Dalian, Dalcahue, Dalat そして、Dalanzadgad が見つかる。

[source,groovy]
----
// Using a filter to search using a regular expression
g.V().has('airport','type','airport').filter{it.get().property('city').value ==~/Dallas|Austin/}.values('code')

// A regular expression to find any airport with a city name that begins with "Dal"
g.V().has('airport','type','airport').filter{it.get().property('city').value()==~/^Dal\w*/}.values('city')
----

したがって、要約すると、クロージャと、フィルタでそれらを使う方法について知っておくと役に立つが、上述したように、"純粋なGremlin" の代替手段がない場合にのみ、慎重に使っていただきたい。

NOTE: 実際には、さらに1歩進んで、正規表現を処理するカスタム述部(次のセクションを参照してほしい）　を作成できる。

[[pred]]
=== カスタムテスト(述部）を作成する

TinkerPopには値をテストするのに利用できる一連のビルトインのメソッドが用意されている。これらのメソッドは一般的に'述部'と呼ばれる。既存の Gremlin 述部の例には、'gte()'、'lte()'、'neq()'のようなものがある。しかしながら、Gremlin クエリの一部として'has()'、'where()'、'filter()'ステップに渡すことができる、独自のカスタム述部を定義できると便利な場合がある。

次の例では、Groovy クロージャ構文を使って、渡された2つの値をテストして、'x'が'y'の2倍よりも大きいかどうかを確認する'f'と呼ばれるカスタム述部を定義する。この新しい述部は'test()'メソッドへのパラメータとして使うことにより'has()'ステップの一部として ことができる。'f'が呼び出されると、2つのパラメータが渡される。1つ目は'has()'に'longest'というプロパティを返すように要求したときにレスポンスで返される値になる。'f'に渡される2つめのパラメータは指定する'a'の値になる。これは単純な例だが、Gremlin で 基本的な述部を拡張するために用意されている柔軟性を示している。 

[source,groovy]
----
// Find the average longest runway length.
a = g.V().hasLabel('airport').values('longest').mean().next()

// Define a custom predicate
f = {x,y -> x > y*2}

// Find airports with runways more than twice the average maximum length.
g.V().hasLabel('airport').has('longest',test(f,a)).values('code')   
----

==== 正規表現述部を作成する

前のセクションでは、正規表現を使って値をフィルタリングするためにクロージャを使った。これで独自の述部の作り方がわかったので、さらに一歩進んで、正規表現を受け入れる述部を作成しよう。

[source,groovy]
----
// Create our method
f = {x,y -> x ==~ y}

// Use it to find any vertices where the description string starts with 'Dal'
g.V().has('desc',test(f,/^Dal.*/)).values('desc')
----

実際には、さらに一歩進んで、'test'メソッドを直接使うのではなく、'regex'というカスタムメソッドを作成するとよい。次のコードが少し不明確に見えるのであれば、あまり心配する必要はない。これはちゃんと動くし、あなたが知るべきことのすべてかもしれない。しかしながら、TinkerPop API をより詳しく理解したいのであれば、Apache TinkerPop ウェブページにあるドキュメントで'P'などの詳細が説明されている。また、Gremlin は Groovy/Java で記述されていて、ここでもそれを利用していることを忘れないでほしい。

次の例では、'test'を直接使うのではなく、Java 8 の一部である'BiPredicate'関数型インタフェースを使う。'BiPredicate'は2つのパラメータを取るので、'2-arity'述部と言われる。'bp'というインタフェースの実装を作成する。このインタフェースは、2つのオブジェクト間で実際に比較処理を行い、単純な true あるいは false の結果を返す'test'という1つのメソッドが必要だ。前のセクションで行ったように、単に、==~ 演算子を使って正規表現の比較を実行するだけだ。

次に'bp'の実装を使って、'regex'と呼ぶ、名前付きクロージャを構築する。TinkerPop には Java Predicate 関数型インタフェースの実装である述部クラス P が用意されている。'P'を使って新しい'regex'メソッドを構築するとよい。次に、'regex'を'has'などのステップに直接渡すことができる。

[source,groovy]
----
// Create a new BiPredicate that handles regular expression pattern matching 
bp = new java.util.function.BiPredicate<String, String>() {
         boolean test(String val, String pattern) {
           return val ==~ pattern  }}

// Create a new closure we can use for regular expression pattern matching.
regex = {new P(bp, it)}

// Use our new closure to find descriptions that start with 'Dal'. As this
// unwinds, the contents of 'desc' are passed to the test method as the first parameter
// and the regex pattern as the second paramter.
g.V().has('desc', regex(/^Dal.*/)).values('desc')
----

[[vmunroll]]
=== valueMap によって返されたリストを展開する

"<<tp34vm>>" のセクションでは、'valueMap'ステップに続く'by(unfold())'を使って、プロパティ値を展開するいくつかの例を示した。ご存知だと思うが、これは、単一のプロパティ値はリスト内にラップされて返されないことを意味する。この機能は TinkerPop 3.4 で導入された。しかしながら、以前のバージョンの TinkerPop を使っても少し手間はかかるが、同じ結果を得ることができる。

本セクションに読み飛ばしてきたのであれば、これが、新しい機能とそれが生成する出力の例だ。

[source,groovy]
----
g.V().has('code','SFO').valueMap().by(unfold()).unfold()

country=US
code=SFO
longest=11870
city=San Francisco
elev=13
icao=KSFO
lon=-122.375
type=airport
region=US-CA
runways=4
lat=37.6189994812012
desc=San Francisco International Airport
----

下記のようなクエリを使って同じ結果が得られる。'map'ステップは'valueMap'ステップの結果をリストから展開した値でアンパッケージしてから再度パッケージ化するのにつかわれる。

[source,groovy]
----
g.V().has('code','SFO').
      valueMap().
      map(unfold().group().by(keys).by(select(values).unfold())).
      unfold()
----

出力は前のクエリの出力と同じように見えるが、これは良いことだ。しかしながら、クエリにはまだ問題がある。プロパティに値のリストもしくはセットが関連づけられている場合、望んでいることを完全には実行しない。

[source,groovy]
----
country=US
code=SFO
longest=11870
city=San Francisco
elev=13
icao=KSFO
lon=-122.375
type=airport
region=US-CA
runways=4
lat=37.6189994812012
desc=San Francisco International Airport
----

サンフランシスコ空港の頂点に、"ベイエリア" という地域分類を追加したいと想像してみてほしい。下記に示したようなことをすると思う。

[source,groovy]
----
g.V().has('code','SFO').property(list,'region','Bay Area')
----

'region'プロパティのvalueMapを調べるとリストがあることを確認できる。

[source,groovy]
----
g.V().has('code','SFO').valueMap('region')

[region:[US-CA,Bay Area]]
----

作ったばかりの'map'ステップを使うと、このプロパティを展開しようとするがこの場合、リストを保持したいので、これは望んでいるものではない。これを少し修正して、長さが1の場合にのみ、リストを展開する'choose'ステップを含めるとよい。

[source,groovy]
----
g.V().has('code','SFO').
      valueMap().
      map(unfold().
        group().
          by(keys).
          by(choose(select(values).count(local).is(1),
                    select(values).unfold(),
                    select(values)))).
      unfold()
----

今回はリストのままの'region'プロパティを除いて、結果は展開されたままだ。

[source,groovy]
----
country=US
code=SFO
longest=11870
city=San Francisco
elev=13
icao=KSFO
lon=-122.375
type=airport
region=[US-CA, Bay Area]
runways=4
lat=37.6189994812012
desc=San Francisco International Airport
----



[[graphvars]]
=== graph 変数を使ってメタデータをグラフと関連づける

TinkerPop 3 ではグラフ変数の概念が導入された、グラフ変数は、グラフ自身に関連付けられたキー／値のペアだ。グラフ変数はGremlin トラバーサルで処理されるグラフ一部とはみなされないが、本質的にはグラフにメタデータを関連づける方法である。グラフオブジェクトの'variables'メソッドを使ってグラフ変数を設定し、取得することができる。誰が'air-routes'グラフのメンテナーで最終更新日がいつかを記録することができるメタデータをいくつか追加したいとしよう。下記のようにすることができる。

[source,groovy]
----
graph.variables().set('maintainer','Kelvin')
graph.variables().set('updated','July 18th 2017')
----

グラフ変数のキーに名前をつける際は、意味のある任意の文字列を使うことができる。'keys'メソッドを使って、今グラフ変数として設定されているキーの名前を取得することができる。

[source,groovy]
----
graph.variables().keys()

updated
maintainer
----

'asMap'メソッドは、今キー／値のペアのマップとして設定されている任意のグラフ変数を返す

[source,groovy]
----
graph.variables().asMap()

updated=July 18th 2017
maintainer=Kelvin
----

'get'メソッドを使って、特定のキーの値を取得することができる。その返された値は、'java.util.Optional'クラスのインスタンスであることに注意してほしい。

[source,groovy]
----
graph.variables().get('updated')

Optional[July 18th 2017]
----

グラフ変数を削除したい場合は、'remove'メソッドを使うとよい。この次の例では、'maintainer'グラフ変数を削除し、変数マップを再クエリしてそれが削除されたことを確認する。

[source,groovy]
----
graph.variables().remove('maintainer')
graph.variables().asMap()

updated=July 18th 2017

----

[[tre]]
=== グラフをツリーに変換する

TinkerPop は Tree API を定義しているが、それほど充実されておらず、長期間更新されていない。'tree'ステップではGremlin トラバーサルを使ってグラフの一部からツリーを生成できる。下記の例では、深さ3で、オースティン(AUS) 頂点をルートとするツリーを作成する。ツリーの次の階層はAUSに直接接続されているすべての頂点だ。3つめの階層は、前の階層の頂点へ経路によって接続されたすべての頂点で構成される。

[source,groovy]
----
//Generate a tree the AUS vertex and its neighbors and their neighbors
tree = g.V().has('code','AUS').
             repeat(out()).
               times(2).
             tree().by('code').next()
----

変数'tree'に返されるオブジェクトは org.apache.tinkerpop.gremlin.process.traversal.step.Util.Tree クラスのインスタンスである。このクラスにはツリーを操作する際に使うことができる一連のメソッドが用意されている。

[source,groovy]
----
// Look at part of the tree directly
tree['AUS']['DFW']

// You can also use the TinkerPop Tree API to work with the tree
tree.getLeafObjects()
tree.getObjectsAtDepth(1)
tree.getObjectsAtDepth(1)
tree.getObjectsAtDepth(2)
----

後ほどの、"<<btree>>" のセクションで、再度使われるTree API を確認する。

[[subgraph]]
=== サブグラフを作成する

Gremlin を使うと、扱っている大規模なグラフ内の頂点とエッジのサブセットである。サブグラフを作成することができる。一度作成すると、サブグラフを扱うために、その新しいグラフに固有でメイングラフの処理に使われているものとは別のトラバーサルソースオブジェクトを生成する。サブグラフは、'subgraph'トラバーサルステップを使って生成される。'subgraph'は（頂点ではなく）エッジで機能し、それらのエッジとそれらが接続する頂点の両方を、作成される新しいサブグラフに追加されることに注意してほしい。

TIP: すべてのサンプルデータは本書のGitHub リポジトリにある。
https://github.com/krlawrence/graph/tree/main/sample-data

簡単な例から始めよう。本書に同梱されているサンプルデータセットの1つは、air-routes-small.graphml という、メインの''air-routes''グラフの小さいバージョンだ。これには完全グラフの最初の46空港間の経路が含まれている。エッジと頂点を完全グラフから抽出することによって、これらの空港間のフライトを表すサブグラフを生成するクエリを非常に簡単に書くことができる。下記のクエリを見てほしい。まず、IDが1から46に含まれる全ての頂点を見つける。次に、すべての出エッジを見つけるが、１から46 の同じIDの範囲内の空港に到達しないものはすべて除外する。最後に、'subgraph'ステップを使ってそれらのエッジと頂点を新しいサブグラフに追加する。この'subgraph'ステップにはラベルを付ける必要があることに注意してほしい。この場合、私は、'+++'+++a+++'+++'を使った。これにより、必要に応じて、トラバーサルの複数の部分から新しいサブグラフを追加できるようになる。この場合、これ以上追加する必要はないので、'cap'ステップを使って、'subgraph'の作成を完了する。変数'subg'には新しく作成されたグラフへの参照が含まれる。


[source,groovy]
----
subg=g.V(1..46).outE().
       filter(inV().hasId(within(1L..46L))).
       subgraph('a').cap('a').next()
----

クエリを実行すると、Gremlin は46個の頂点と1326 本のエッジを含む新しい TinkerGraph を作成したことを表示していることに注意してほしい。

[source,groovy]
----
tinkergraph[vertices:46 edges:1326]
----

これで、サブグラフが作成されたので、サブグラフに対しクエリを発行できるようにトラバーサルソースオブジェクトを作成する必要がある。Gremlin は作成された新しいトラバーサルソースオブジェクトの詳細を表示する。

[source,groovy]
----
sgt = subg.traversal()

graphtraversalsource[tinkergraph[vertices:46 edges:1326], standard]
----

これで、新しく作成したサブグラフのトラバーサルソースオブジェクトができたので、サブグラフに対して、クエリを発行することができる。

[source,groovy]
----
// What airports are in the subgraph?
sgt.V().values('code').fold()

[ATL,ANC,AUS,BNA,BOS,BWI,DCA,DFW,FLL,IAD,IAH,JFK,LAX,LGA,MCO,MIA,MSP,ORD,PBI,PHX,RDU,SEA,SFO,SJC,TPA,SAN,LGB,SNA,SLC,LAS,DEN,HPN,SAT,MSY,EWR,CID,HNL,HOU,ELP,SJU,CLE,OAK,TUS,SAF,PHL,DTW]

// How many of the 46 airports can you fly to from LAX?
sgt.V().has('code','LAX').out().count()

40
----

ここで、サブグラフを操作するいくつかの例を示す。下記のクエリは、直接オースティン(AUS) 頂点に接続されているすべての頂点とエッジのサブグラフを作成する。'bothE'を使うと、入りと出のエッジを取得することに注意してほしい。これらの例では、より意味のあるラベル'subGraph'を使って作成中のサブグラフにラベルを付けている。

[source,groovy]
----
subg = g.V().has('code','AUS').bothE().
             subgraph('subGraph').cap('subGraph').next()
----

オースティンからの発経路のみが欲しい場合は、代わりに'outE'ステップを使うようにクエリを変更するとよい。

[source,groovy]
----
subg = g.V().has('code','AUS').outE('route').
             subgraph('subGraph').cap('subGraph').next()
----

下記の例は、もう少し洗練されている。オースティンの頂点で始まるサブグラフを作成するが、今回は、2ホップで終了する。これは、'repeat'ステップを使って実現する。

[source,groovy]
----
subg = g.V().has('code','AUS').
       repeat(bothE().subgraph('subGraph').outV()).times(2).
       cap('subGraph').next()

[tinkergraph[vertices:1294 edges:11336]
----

前と同様に、新しく作成されたサブグラフを操作できる。

[source,groovy]
----
// Get a traversal source object so that we can traverse 
// the newly created sub graph.
sgt = subg.traversal()

// What sort of vertices ended up in the subgraph?
sgt.V().groupCount().by(label)

[continent:2,country:5,airport:1287]
----

もっと複雑な例を示す。このクエリはヨーロッパ内にある空港と経路だけのサブグラフを生成する。事実上これにより、ヨーロッパだけの航空路のメイングラフとなる。一見すると、このクエリは少し圧倒されそうだが、ゆっくり読んで、各ステップを見ると何をやっているか理解できるはずだ。経路と空港をサブグラフに抽出するだけでなく、関連するすべての国と大陸も抽出するという点で前の例よりもかなり洗練されている。このクエリは複数の'subgraph'ステップも使っていることに注意してほしい。

[source,groovy]
----
// Create a sub graph only of airports in Europe and routes between those airports

subg = g.V().hasLabel('continent').has('code','EU').
             outE('contains').subgraph('eu-air-routes').inV().as('a').
             inE('contains').subgraph('eu-air-routes').
             outV().hasLabel('country').
             select('a').outE().as('r').
             inV().hasLabel('airport').in().hasLabel('continent').
             has('code','EU').select('r').subgraph('eu-air-routes').
             cap('eu-air-routes').next()

tinkergraph[vertices:630 edges:13665]
----

以前と同様、新しく作ったサブグラフを操作することができる。

[source,groovy]
----
// Create a traversal source object for the subgraph
sgt = subg.traversal()

// How many routes are there in the subgraph?
sgt.E().hasLabel('route').count()

12499

// What sort of vertices ended up in the subgraph?
sgt.V().groupCount().by(label)

[continent:1,country:46,airport:583]
----

次のクエリでは、新しいヨーロッパだけのサブグラフを使って、ロンドンのヒースロー(LHE) からどこに飛ぶことができるかを検索する。

[source,groovy]
----
sgt.V().has('code','LHR').out().values('code').fold()

[FAO,JMK,FCO,JTR,KBP,AMS,RJK,TLS,PRG,BCN,LED,MAD,OPO,VIE,ZRH,GVA,LCG,BRU,MUC,MAN,INN,CGN,INV,GOT,BLL,VCE,KRK,SNN,MJV,OSL,MPL,ARN,EDI,PUY,GLA,BDS,DME,SVO,ORY,NCE,MXP,ATH,ZAG,BUD,BIO,IBZ,WAW,MLA,SOF,BEG,IST,HAM,STR,PSA,BLQ,NTE,CPH,LUX,DUS,TXL,LIS,GIB,KEF,PMI,AGP,LBA,ABZ,NCL,BSL,SVG,BGO,TLL,ORK,VKO,SPU,BHD,HAJ,LIN,LYS,MRS,OTP,CDG,RTM,FRA,HEL,DUB]
----

より大きなグラフからサブグラフを作成できることは、Gremlin で用意されている非常に強力な機能だ。大きなグラフがあるがその一部のみを扱いたい場合、そのグラフからサブグラフを作成して、クエリを実行しながら、そのサブグラフをメモリ内でローカルに操作できると便利だ。

[[graphmlandjsonintro]]
=== GraphML や GraphSON を扱う

Apache TinkerPop はGraphML や GraphSON を使ってグラフ全体のロードと保存をサポートしている。GraphML はグラフ全体を表現するのに使うことができる、広くサポートされているXML標準である。GraphSONは Apache TinkerPop プロジェクトの一部として定義されたJSON形式であり、グラフ全体を表現することもできる。また、GraphSON を使ってGremlin グラフクエリ の結果をJSON形式で表現することもできる。本セクションでは、これらのトピックをすべて扱う。GraphML や GraphSON の使用に関する主題全体については本書の後半で何度か再検討する。Gremlin サーバを使い始めると、GraphSON の知識が特に重要になる。これらのトピックはもう少し後の"<<gremlinserver>>" のセクション で詳しく扱う。GraphML と GraphSON の両方は "<<serialize>>" のセクションで詳しく扱う。 

NOTE: 公式Apache TinkerPop ドキュメントには、このトピックに関する優れた記事が含まれている。そのドキュメントは http://tinkerpop.apache.org/docs/current/reference/#_gremlin_i_o にある。

現在 GraphSON には3つのバージョンがある。元の 1.0 バージョンと型情報フォーマットに追加したバージョン2.0 および 3.0 だ。これらは TInkerPop バージョン 3.2.2 と 3.3 でそれぞれ追加された。明示的に指定されない限り、デフォルトの形式は、現在の GraphSON 3.0 である。

[[sav]]
==== グラフを GraphML(XML) や GraphSON(JSON) として 保存（シリアライズ）する

TinkerPop 3 を使うと、グラフをGraphML または GraphSON 形式で保存できる。GraphML はグラフを記述するための業界標準の XML 形式であり、Gephi などの他の多くのアプリケーションで認識されている。GraphSON は TinkerPop プロジェクトの一部として定義されていて、TinkerPop 対応のツールとグラフ以外ではあまり広くサポートされていない。しかしながら、GraphML は一部のグラフの敗者とみなされている。(TinkerPop 3 で使われるすべてのデータ型や構造をサポートしているわけではない）GraphSON は敗者とはみなされない。

グラフを GraphML ファイルに保存するには、下記の Gremlin 式を使う。グラフの1つで試して生成された出力を確認することをお勧めする。また（人が読みやすいように）きれいにレイアウトされた GraphML ファイルを見たければ、本書と一緒に配布されている air-routes.graphml ファイルも確認するとよいだろう。デフォルトでは、TinkerPop はコードビューティファイアを最初に使わなければ、人が簡単に読み取れない方法でグラフを保存することに注意してほしい。最新のテキストエディタのほとんどは、XMLファイルをきれいにすることもできる。

[source,groovy]
----
// Save the graph as GraphML
graph.io(graphml()).writeGraph('my-graph.graphml')
----

TinkerPop 3 は2つの異なるJSONパッケージオプションが用意されている。これらは3つの異なる構文バージョンと混同しないでほしい。デフォルトのエンコーディングオプションは、グラフ内の各頂点とそのすべてのエッジを単一のJSONドキュメントとして保存する。これはグラフのすべての頂点に対して繰り返される。これは本質的に、'隣接リスト'形式として知られるものだ。このメソッドを使ってグラフをファイルへシリアライズして、後でそのファイルを見ると、各行( 非常に幅が広いかもしれない）がスタンドアロンのJSONオブジェクトであることがわかる。

2つ目のバリアントは、'ラップされた隣接リスト'形式と呼ばれる。このフレーバーでは、すべての頂点とエッジが、囲んでいる'vertices'オブジェクト内の1つの大きなJSONオブジェクトに格納される。

NOTE: 生成された GraphSON ファイルは Python の json ツール (python -m json.tool my-graph.json) のようなものを使うか、JSON をきれいに表示できるテキストエディタを使わない限り、人に読める形式にはならない。

下記の Gremlin 行は、GraphSON の'隣接リスト'形式を含むファイルを生成する。

[source,groovy]
----
// Save the graph as unwrapped JSON
graph.io(graphson()).writeGraph("my-graph.json")
----

下記は、GraphSONの'ラップされた隣接リスト'形式を含むファイルを生成する

[source,groovy]
----
// Create a single (wrapped) JSON file
fos = new FileOutputStream("my-graph.json")

GraphSONWriter.build().wrapAdjacencyList(true).create().writeGraph(fos,graph)
----

TIP: TinkerPop 3 対応のグラフに大量のデータを取り込むのであれば、ラップされていないフレーバーの GraphSON が GraphML やラップされた GraphSON  よりもはるかに優れた選択肢となる可能性がある。この形式を使うと、グラフ全体を潜在的に巨大なJSONファイルとして一度の送信するのではなく一度に1つの頂点ずつグラフにデータをストリームできる。 

デフォルトでは、グラフはGraphSON 3.0 形式を使って保存されることに注意してほしい。古い形式の1つを使いたい場合は、使うこともできるが、Gremlinに生成するバージョンを明示的に指定する必要がある。下記の例では、グラフは GraphSON 1.0 形式で保存されている。これを行うには、必要な形式を生成ｓるうマッパを作成して使う必要がある。

[source,groovy]
----
fos = new FileOutputStream("my-graph.json")

mapper = graph.io(IoCore.graphson()).
         mapper().version(GraphSONVersion.V1_0).create()

graph.io(IoCore.graphson()).
    writer().mapper(mapper).
    create().writeGraph(fos, graph)
----

GraphML や GraphSON 形式の詳細について詳しく知りたいのであれば、本書の終わり近くにある"<<serialize>>" のセクションで詳しく説明されている。

[[reload]]
==== GraphML (XML) や GraphSON(JSON) として保存されたグラフをロードする

セクション２では、air-routes.graphml ファイルをロードする方法を説明した。そこを読み飛ばしたのであれば、GraphMLファイルのロードについて簡単に要約し、GraphSON の JSON 形式のファイルのロードについても見ていこう。

GraphML ファイルと GraphSON ファイルのロードの唯一の違いは、使う TinkerPop3 の IoCore クラス のメソッドの名前にある。GraphML ファイルを読み込みたい場合は'IoCore.graphml()'を指定する。

[source,groovy]
----
// Load a graphML file
graph.io(IoCore.graphml()).readGraph('my-graph.graphml')
----

GraphSON 形式のファイルを読み込みたいのであれば、代わりに'IoCore.graphson()'を指定する。

[source,groovy]
----
// Load a grapSON file
graph.io(IoCore.graphson()).readGraph('my-graph.json')
----



[[graphsonmapper]]
==== クエリ結果を JSON に変換する

上記のセクションでは、グラフ全体をGraphSON(JSON) または、GraphML (XML) を使って保存および読み込む方法を説明した。しかしながらこれまでまだ見ていないのは、Gremlin コンソール内でJSONオブジェクトとして表現されたクエリ結果を表示する方法だ。"<<gremlinserver>>" のセクションで説明するようにアプリケーションや、コマンドラインからGremlin サーバと通信を行う場合、curl のようなツールを使ってHTTPまたはWebSockets を介してグラフにクエリを送信すると、結果がJSONオブジェクトとして返される。

NOTE: 同等のXMLオブジェクトマッピング機能はない。これは、GraphML がグラフ全体を含み、クエリ結果を含まないように設計されているからだ。

Gremlinコンソールを使うとクエリの結果が適切かつかなり完結な方法で表示され、JSONは表示されない。ほとんどの場合、これはまさに我々が望んでいることだ。しかしながら、何らかの理由により、クエリ結果のJSONがどのように見えるかを確認したいのであれば、そうすることは可能だ。これを行うには、通常の Gremlin コンソール と TinkerGraph を用いて行うことができる。これから照会する例を使うためにGremlin サーバに接続する必要はない。 

最初にするべきことは、クエリ結果からJSONを生成するのに使うことができるGraphSON マッパーのインスタンスを生成することだ。TinkerPop 3.2.2 以降、GraphSON 形式には複数のバージョンが存在することに注意してほしい。オリジナルの 1.0 バージョンには型情報が含まれていなかった。バージョン2.0 でJSONないにデータ型を含めるという概念が導入された。TinkerPop 3.3 の一部として、いくつかの型を追加するためにGraphSON 3.0 が導入された。3つの形式すべてが引き続きサポートされている。デフォルトは、GraphSON 3.0になった。

下記の例では、GraphSON 1.0 形式のJSONを生成する'GraphSONMapper'オブジェクトを生成する。

[source,groovy]
----
json_mapper = GraphSONMapper.
                build().
                version(GraphSONVersion.V1_0).
                create().
                createMapper()

----

次に、ロサンゼルス(LAX) 空港を表す頂点を見つける簡単なクエリを実行してみよう。

[source,groovy]
----
lax = g.V().has('code','LAX').next()
----

生成したばかりのJSONマッパーを使ってクエリ結果をJSONとして表示できるようになった。

[source,groovy]
----
json_mapper.writeValueAsString(lax)
----

これは、生成されたJSONだ。読みやすくするために整形をした。このJSONにはすべてのプロパティのID値が含まれていることに注目してほしい。

[source,json]
----
{"id":13,"label":"airport","type":"vertex",
 "properties":
   {"country":[{"id":148,"value":"US"}],
   "code":[{"id":149,"value":"LAX"}],
   "longest":[{"id":150,"value":12091}],
   "city":[{"id":151,"value":"Los Angeles"}],
   "elev":[{"id":152,"value":127}],
   "icao":[{"id":153,"value":"KLAX"}],
   "lon":[{"id":154,"value":-118.4079971}],
   "type":[{"id":155,"value":"airport"}],
   "region":[{"id":156,"value":"US-CA"}],
   "runways":[{"id":157,"value":4}],
   "lat":[{"id":158,"value":33.94250107}],
   "desc":[{"id":159,"value":"Los Angeles International Airport"}]}}
----

別の'GraphSONMapper'インスタンスを生成しよう。今回は バージョン 3.0 の GraphSON を生成する。

[source,groovy]
----
json_mapper_v3 = GraphSONMapper.
                 build().
                 version(GraphSONVersion.V3_0).
                 create().
                 createMapper()
----

GraphSON3.0 形式には、さらに多くの情報が含まれているので、出力が多すぎないように、LAX頂点に含まれるプロパティのいくつかに対し、少し単純なクエリを使ってvalueMapを生成することにした。

[source,groovy]
----
lax = g.V().has('code','LAX').valueMap(true,'code','city').next()
----

以前と同様、マッパーを使ってJSONを生成することができる。

[source,groovy]
----
json_mapper_v3.writeValueAsString(lax)
----

今回は、ご覧のとおり、返されるJSONには、さらに多くの情報が含まれている。注目すべき重要な点は、すべての'@type'キーと'@value'キーの存在だ。 

[source,json]
----
{
  "@type": "g:Map",
  "@value": [
    {
      "@type": "g:T",
      "@value": "id"
    },
    {
      "@type": "g:Int64",
      "@value": 13
    },
    "code",
    {
      "@type": "g:List",
      "@value": [
        "LAX"
      ]
    },
    "city",
    {
      "@type": "g:List",
      "@value": [
        "Los Angeles"
      ]
    },
    {
      "@type": "g:T",
      "@value": "label"
    },
    "airport"
  ]
}
----

前述したように、Gremlin サーバを使い始めると、JSONの主題が再度浮かび上がる。本セクションでは、GraphML あるいは GraphSON を使ってグラフ全体の保存と読み込みの方法を示し、クエリの結果をJSONとして表示したい場合に使用できるようにしたいと考えている。グラフ全体をJSONとして保存する場合は、特に指定しない限り、デフォルトの形式は、GraphSON 3.0 であることを覚えておいてほしい。

[[performance]]
=== クエリのパフォーマンスを分析する

Apache TinkerPop には、クエリの実行にかかる時間を計測するために使うことができるメソッドが用意された TimeUtil というクラスが含まれている。ProfileStep と呼ばれる2つめのクラスは、クエリ実行中に時間が費やされたところのより詳細な分析を取得する方法を提供する。本セクションでは、いくつかのクエリの実行時間を分析するために用意されているメソッドの使い方のいくつかの例を提供する。'air-routes'データをメモリ内の TinkerGraph にロードして、Gremlin コンソールを使ってラップトップでテストを実行した。

[[clock]]
==== クエリを時間計測する - clock と clockWithResult を導入する

'TimeUtil'クラスには時間を扱う際に使うことができるいくつかのメソッドが用意されている。その中から2つ、'clock'と'clockWithResult'に焦点をあてる。これらのメソッドを使うと、実行時間をトラッキングしながら、クエリを1回以上実行できる。すべてのイテレーションが完了すると、クエリにかかった平均時間（ミリ秒単位）が返される。特に長いクエリの場合、返される時間は、ストップウォッチを使って同じ'clock'プロシージャを測定しようとした場合と同じように、返される時間は表示されないことに注意してほしい。これは、これらのメソッドが両方とも、実際のタイミングを実行する前にウォーミングアップパスを実行するからだ。ウォームアップは単にタイミングを開始する前にクエリを1回実行するだけだ。これは単一のタイミングのイテレーションであれば、'人間に認識できる時間'は'clock'分析によって返される時間の約2倍になることを意味する。いくつかの例を見てみよう。

下記は、'clock'ステップを使ってグラフ内の中国にあるすべての空港の頂点を見つけるのにかかる時間を計測するとても簡単な例だ。clock ステップは2つのパラメータを取ることに注意してほしい。1つ目はクエリを実行する回数を示す整数値だ。2つ目は、中カッコ'"{...}"'で囲んだ実行するクエリ、つまりクロージャだ。下記の例では、パラメータ１が'clock'メソッドに渡されるので、クエリは1回だけ実行される。結果から、このクエリを私のラップトップで1回実行すると、1.3 ミリ秒より少し長くかかったことがわかる。

[source,groovy]
----
clock(1) {g.V().has('airport','country','CN').next()}

1.364199
----

クエリにかかる時間をより正確に評価するには、複数回試行して時間を平均するのがよい。これにより、ランダムなシステムイベントが全体的な結果に与える影響を減らすことができる。下記の例では、前のクエリを繰り返しているが、100回の反復でかかった時間の平均を測定している。特に長時間実行されるクエリの場合、返される時間は、ストップウォッチを使ってこのプロセスにかかる時間を自分で計測しようとした場合と同じにはならない点に注意してほしい。これは、clock ステップが実際のテストを実行する前に、ウォームアップパスを実行するためである。このウォームアップステップは時間計測を開始する前に基本的にクエリを1回実行する。これは、1回のイテレーションで、'人が認識できる時間'が'clock'分析によって返される時間の約2倍になるという意味だ。結果からわかることは、100回以上繰り返して計測した時間を平均すると、所用時間がわずかに短くなることだ。これらの数字を厳密で迅速な回答として使うのではなく、クエリにかかる一般的な時間を把握するために使うべきだ。このテストを5回繰り返すと、5つの似たような、厳密には異なる結果が得られる。

[source,groovy]
----
clock(100) {g.V().has('country','CN').next()}

0.70694013
----

これは、計測時間がほぼ同じであることを確認するためだけに同じクエリを1000回実行したものだ

[source,groovy]
----
clock(1000) {g.V().has('country','CN').next()}

0.6931818670000001
----

前に "<<sp>>" のセクション下記のクエリを見た。ご存知かもしれないが、オースティンとアグラ間には10件の経路がある。アゴラに到達する方法はそれほど多くないので、このクエリは多くのグラフトラバーサルを必要とし、完了するまで時間がかかる。このクエリを1回実行するのにかかる時間を計測してみよう。

[source,groovy]
----
clock(1){
    g.V().has('airport','code','AUS').
          repeat(out()).until(has('code','AGR')).
          limit(10).path().by('code').toList()}

4643.605562
----

御覧の通り、中国の空港を検索するよりも実行にかなり時間がかかった。実際、実行には4秒以上かかった。同じクエリを100回実行して、平均所要時間がどのようになるか見てみよう。

[source,groovy]
----
clock(100){
    g.V().has('airport','code','AUS').
          repeat(out()).until(has('code','AGR')).
          limit(10).path().by('code').toList()}

4816.6515936999995
----

したがって、クエリを100回実行すると、この場合は非常によく似た結果が得られた。興味深い観察として、アグラをスタートして、オースティンへの経路を見つけるのにかかった時間の違いに注目してほしい。100回の繰り返しの平均所要時間は10ミリ秒弱だ。なので、興味深い最適化の可能性を発見した。オースティンへ行く方法は多数あるので、10件の経路を見つけるのにそれほど時間はかからなかった。これは常に可能であるとは限らないが、グラフをモデル化し、クエリを設計する際に、どこから開始するかによって大きな違いが生じることがあることに注意してほしい。

[source,groovy]
----
clock(100){
   g.V().has('airport','code','AGR').
         repeat(out()).until(has('code','AUS')).
         limit(10).path().by('code').toList()} 

9.068097369999998         
----

'clock'メソッドは、クエリの実行にかかる時間のみを表示し、クエリを実行した実際の結果は表示しない点に気づいたかもしれない。ここで、'clockWithResult'メソッドが登場する。'airports in China'クエリを再利用することも可能だが、今回は、クエリの結果も返されることに注意してほしい。

[source,groovy]
----
clockWithResult(1) {g.V().has('country','CN').count().next()}

0.918276
209
----

'clockWithResult'を使って'Austin to Agra'のクエリを実行すると、実際に経路とタイミングは返されることがわかる。

[source,groovy]
----
clockWithResult(1){
    g.V().has('airport','code','AUS').
          repeat(out()).until(has('code','AGR')).
          limit(10).path().by('code').toList()}

4266.584279

[[AUS,YYZ,BOM,AGR],[AUS,LHR,BOM,AGR],[AUS,FRA,BOM,AGR],[AUS,EWR,BOM,AGR],[AUS,CLE,YYZ,BOM,AGR],[AUS,CLE,EWR,BOM,AGR],[AUS,OAK,EWR,BOM,AGR],[AUS,PHL,EWR,BOM,AGR],[AUS,PHL,YYZ,BOM,AGR],[AUS,PHL,LHR,BOM,AGR]]
----

ただの興味本位ではあるが、次の4つのクエリでは、オースティン(AUS) からロサンゼルス（LAX) までの、経由が0回、1回2回、あるいは3回で飛べる全ての方法を探す。クエリはオースティンを再訪する経路を避け、'simplePath'を使って同じ経路を2回繰り返さないようにする。最後のクエリに到達するまえに３経由地かかることが分かるように、クエリの完了するにはかなり時間がかかる。

[source,groovy]
----
clockWithResult(1){
    g.V().has('code','AUS').as('a').
          repeat(out().where(neq('a'))).times(1).simplePath().
          has('code','LAX').path().by('code').count().next()}

1.698357
1
----

ご想像のとおり、経由地が１つしかない経路を探すのに、それほどの時間はかからない。

[source,groovy]
----
clockWithResult(1) {
    g.V().has('code','AUS').as('a').
          repeat(out().where(neq('a'))).times(2).simplePath().
          has('code','LAX').path().by('code').count().next()}

7.988092999999999
51
----

正確に経由地が2か所の経路を探すには、かなり時間がかかるが、それでもかなり速い。

[source,groovy]
----
clockWithResult(1) {
    g.V().has('code','AUS').as('a').
          repeat(out().where(neq('a'))).times(3).simplePath().
          has('code','LAX').path().by('code').count().next()}

435.423921
3389
----

最後のクエリに到達するまでにわかるように、正確に3つの経由地を探すが、完了するまではかなり時間がかかる。

[source,groovy]
----
clockWithResult(1) {
    g.V().has('code','AUS').as('a').
          repeat(out().where(neq('a'))).times(4).simplePath().
          has('code','LAX').path().by('code').count().next()}

35295.633811
203359
----

'clock'メソッドと'clockWithResult'メソッドが正しく機能するためには、'next'や、'toList'などの終端ステップでクエリを終了する必要があることに注意してほしい。あるいは、'iterate'でクエリを終了してもよい。私がテストしたところ、'iterate'を使うと、正しく機能するとは限らないことがわかったので、私は避けるようにしている。

[[profile]]
==== どこに時間がかかってるかを分析する - profile を導入する

'profile'ステップを使って、Gremlin により詳しくクエリの処理に費やされた時間のサマリを返すように指示することもできる。下記の例を見てほしい。

[source,groovy]
----
g.V().has('region','US-TX').out().has('region','US-CA').
                            out().has('country','DE').profile()
----

クエリを実行したあと、結果を表示する代わりに、Gremlin はクエリのコンポーネントの処理にかかった時間を表示する。

[source,console]
----
Step                                       Count  Traversers  Time (ms)    % Dur
===============================================================================
TinkerGraphStep(vertex,[region.eq(US-TX)])   26          26      1.810     9.71
VertexStep(OUT,vertex)                      701         701      0.877     4.70
HasStep([region.eq(US-CA)])                  47          47      0.561     3.01
VertexStep(OUT,vertex)                     3464        3464     12.035    64.54
NoOpBarrierStep(2500)                      3464         224      3.157    16.93
HasStep([country.eq(DE)])                    59           4      0.206     1.11
   >TOTAL                                     -           -     18.650        -
----

前のセクションの、'Austin'から'Agra'へのクエリのプロファイルを作成すると、ほとんどすべての時間が、経路を検索する'repeat'ループの内側で費やされたことがわかる。この場合、驚くべきことではないが、より複雑なクエリの場合、'profile'はそれらを詳細化するのに役に立つ。

[source,groovy]
----
g.V().has('airport','code','AUS').
      repeat(out()).until(has('code','AGR')).limit(10).
      path().by('code').profile()
----

これが、'profile'レポートだ。1ページに収まるように、テキストの一部を "..." で割愛した。

[source,console]
----
Step                              Count  Traversers       Time (ms)    % Dur
============================================================================
TinkerGraphStep(vertex,[~l...         1           1           2.125     0.02
RepeatStep([VertexStep(OUT,..        11          11        9357.962    99.97
  HasStep([code.eq(AGR)])                                  2627.621
  VertexStep(OUT,vertex)        1799981     1799981         509.392
  RepeatEndStep                      11          11        8848.030
RangeGlobalStep(0,10)                10          10           0.278     0.00
PathStep([value(code)])              10          10           0.126     0.00
   >TOTAL                             -           -        9360.493        -
----

[[tinkerindex]]
==== TinkerGraph インデックスを導入する

TinkerGraph には基本的なインデックス作成機能が用意されているが、それを使うと、クエリのパフォーマンス全体を改善することができる。2つのメソッド、'createIndex'と'dropIndex'はインデックスを作成、削除するために用意されている。頂点とエッジのプロパティには必要に応じてインデックスを張ることができる。３つめのメソッド、'getIndexedKeys'はどのインデックスが作成されているかを照会するのに使うことができる。下記の例では、'code'頂点プロパティにインデックスがある場合とない場合の前のテストのいくつかで使ったクエリを実行する

[source,groovy]
----
clock(1){
    g.V().has('code','AUS').repeat(out().simplePath()).
          until(has('code','AGR')).limit(10).path().by('code').toList()}

2019.8820959999998
----

ここで、すべての頂点の'code'プロパティのインデックスを作成してクエリを再試行しよう。下記で使われる'Vertex'は、'Vertex.class'の省略形であることに注意してほしい。

[source,groovy]
----
graph.createIndex('code',Vertex)

 clock(1){
     g.V().has('code','AUS').repeat(out().simplePath()).
           until(has('code','AGR')).limit(10).path().by('code').toList()}

1298.386245
----

下記のように、作成したインデックスを照会することができる

[source,groovy]
----
graph.getIndexedKeys(Vertex)

code
----

では、インデックスを削除してみよう。

[source,groovy]
----
graph.dropIndex('code',Vertex)
----

air routes グラフは小さいので、Vertex プロパティインデックスは全体的なパフォーマンスにほとんど影響しない。しかしながら、エッジの数が多いので、エッジプロパティインデックスを作成すると、一部もクエリに役に立つ可能性がある。実験してみよう。次のクエリは、'dist'プロパティが1000であるすべてのエッジを検索する。

[source,groovy]
----
clockWithResult(100) {g.E().has('dist',1000).count().next()}

9.80906926
24
----

では、'dist'というエッジプロパティのインデックスを作成して、クエリを再度実行してみよう。以前と同様、作成されたエッジインデックスを確認することもできる。

[source,groovy]
----
graph.createIndex('dist',Edge)

graph.getIndexedKeys(Edge)

dist
----

今回は、作ったインデックスが大きな違いを生んだことがわかる。

[source,groovy]
----
clockWithResult(100) {g.E().has('dist',1000).count().next()}

0.046712609999999995
24
----

２つのクエリの所要時間の違いは、インデックスに起因する可能性がある。最初のケースでは、グラフ内のすべてのエッジ（50,000本以上) を検査する必要があった。2つ目のケースでは、インデックスを使って、'dist'が1000のエッジに直接アクセスしてすべてのエッジを検索する必要はなかった。インデックスは正確な比較にのみ役に立つことに注意してほしい。下記のようなクエリでは、インデックスは利かない。

[source,groovy]
----
clockWithResult(100) {g.E().has('dist',gt(1000)).count().next()}

11.980037119999999
16430
----

後ほど、JanusGraph でのインデックスの利用と、より複雑なタイプの比較述部をサポートする Apache Solr や Elasticsearch などの外部インデックス技術について見ていく。

[[olapoltp]]
=== OLTP vs OLAP

グラフ処理について議論する際、2つの用語が定期的に出てくる。これらの用語は、オンライントランザクション処理( OLTP ) と オンライン分析処理 (OLAP) だ。これまで見てきたクエリのほとんどは、間違いなく OLTP のカテゴリに分類される。グラフのほんの一部のみを参照するクエリ、単一のノード、あるいは小さなノードのグループから開始し、そこからいくつかのホップをトラバースするクエリは、OLTP 操作とみなされる。通常、OLTPクエリを実行するには、数秒ほどかかる。これらは、ほぼリアルタイムにに返答する必要のあるユーザクエリへの応答に使われることがしばしばある。air routes グラフは小さいので、TinkerGraph と Gremlinコンソールを使うだけで、非常に複雑なクエリを実行することもできる。グラフに数十億の頂点やエッジが含まれている場合、これは当てはまらない。そうはいっても、TinkerGraph 環境で実行するのに数分かかる可能性がある、リモート空港への経路を検索するクエリなど、いくつかのOLTP タイプのクエリを見てきた。

NOTE: TinkerPopのドキュメントにはサポートされている様々なOLAP機能が詳細に記載されている。
http://tinkerpop.apache.org/docs/current/reference/#graphcomputer

OLAP が発揮するのは、グラフ全体にわたり、詳細な分析を実行する場合だ。これは、グラフが大きくなり、グラフを支えるために強力なノードのクラスタは必要になるため、特に当てはまる。通常OLTPクエリの商用時間は数秒ほどであるが、OLAPクエリを完了するのには、数分あるいは数時間かかる場合がある。

Apache TinkerPop ではすぐに使用できるOLAPグラフ処理を大幅にサポートし、Apache Spark や Apache Hadoop などの分散バックエンドシステムやソフトウェアで適切に機能するように設計されている。

NOTE: 通常OLAP処理は、強力なクラスタを使って実行されるが、メモリ内のスタンドアロンの TinkerGraph を使うだけで簡単な実験を実行することができる。

OLAP処理の詳細な説明は、本書の現在の範疇を超えるが、少なくとも何ができるかについて、少しでも洞察を提供できるように、下記にいくつかの簡単な例を示す。　TinkerPopのドキュメントには、TinkerPop対応のグラフでOLAP 操作を実行する方法について詳しく説明されているので、もし、OLAPスタイルのグラフ処理を実行する場合には、このドキュメントを読むことをお勧めする。

[[graphcomputer]]
==== TinkerPop Graph Computer を導入する

バージョン３リリースの一部として、TinkerPop フレームワークに多くの新機能が追加された。そのような新機能の1つは、'Graph Computer'の概念だ。具体的には、GraphComputer は 様々なバックエンド環境に機能を提供するために他の TinerPop クラスが実装するJava のインタフェースである。GraphComputer と合わせて、VertexProgram の概念も導入されている。 頂点プログラムを使うと、グラフ全体で実行したい操作を指定できる。これは、マップリデュース操作と組み合わせて使用できる可能性がある。TinkerPopには、事前に構成された頂点プログラムと頂点プログラムステップのセットが用意されている。もちろん、自分で書くこともできる。

事前設定された頂点プログラムの1つは、ペイジランクである。それを使う１つの方法を見てみよう。

[[pagerank]]
==== ペイジランクで実験する

おそらく、ビッグデータの世界で最も有名なアルゴリズムの1つはペイジランクだ。元々は、Googleで開発されたペイジランクアルゴリズムは、ウェブページの相対的な重要度を測定する方法として作成された。大まかに言えば、このアルゴリズムは、あるウェブページへの接続数と、それらの接続の品質を（目立つ場所からの接続として）調べる。このアルゴリズムは、Webのように、密に接続されたデータ構造なので、グラフデータベース環境にグラフとしてうまくポーティングできる。我々のグラフデータベース環境では、ペイジランクアルゴリズムを使って、グラフを評価し、特定の頂点にアクセスする任意のトラバーサルの可能性を計算することができる。新しいグラフコンピュータの機能は、分散システムを念頭においてゼロから設計されているが、スタンドアロンの TinkerGraph を使っていくつかの機能を試すことができる。

下記の例は、'air-routes'データがロードされたGremlin コンソール内でローカルに実行されているTinkerGraph があることのみを前提としている。本書でこれまで見てきた例とはいくつかの違いに気づくだろう。まず、グラフトラバーサルソースオブジェクトを作成する際に、'withComputer'への呼び出しを追加し、グラフコンピュータ機能を必要とするいくつかのことを実行するつもりであることを示す。トラバーサルソースを作ったら、ペイジランクをセットアップできる。空港の頂点のみをランキングしたいので、クエリは最初、空港空港でない頂点を除外している。次に、'pageRank'ステップが呼び出される。'by'モジュレータはペイジランクアルゴリズムに　どのようにランキングしたいか、ランキング結果にどのようなラベルを付けるかを知らせる。この場合、出経路エッジを確認し、すべての結果に'r'のラベルを付ける。結果を返す前に、ランキングの値に基づいて降順にソートする。

[source,groovy]
----
// Page rank based on outgoing routes
g3 = graph.traversal().withComputer()

g3.V().hasLabel('airport').pageRank().by(outE('route')).by('r').
      order().by('r',desc).valueMap('code','r').limit(10)
----

これが、ペイジランクアルゴリズムを実行した出力だ。結果には、空港コードが計算されたペイジランクの値とともに表示される。

[source,groovy]
----
[r:[15.527963207609702],code:[IST]]
[r:[15.005583346944613],code:[DFW]]
[r:[14.673184454287105],code:[ORD]]
[r:[14.365370693500969],code:[ATL]]
[r:[14.099719956639161],code:[PEK]]
[r:[14.061408826784106],code:[DXB]]
[r:[13.729782985109942],code:[DEN]]
[r:[13.552238441619048],code:[DME]]
[r:[13.502681833743711],code:[FRA]]
[r:[13.189393240835944],code:[CDG]]
----

参考までに、下記のクエリは、最も入り経路がある上位10件の空港を検索する。

[source,groovy]
----
g.V().hasLabel('airport').
      order().by(inE('route').count(),desc).limit(10).
      project('a','b').by('code').by(inE('route').count())
----

御覧のとおり、ペイジランクの結果と最も多くの入り経路がある空港との間にはなんらかの相関関係があるがこれはおそらく驚くべきことではない。しかしながら、ペイジランクアルゴリズムは、単純なノード次数テストでは出てこなかった空港がいくつか出てきていることに注意してほしい。

[source,groovy]
----
[a:FRA,b:282]
[a:AMS,b:275]
[a:IST,b:271]
[a:CDG,b:267]
[a:MUC,b:240]
[a:PEK,b:239]
[a:ORD,b:237]
[a:DXB,b:237]
[a:ATL,b:235]
[a:DFW,b:221]
----

前のクエリで使われた'pageRank'ステップは、なんらかのランキングを素早く生成するための優れた便利な方法だ。しかしながら、グラフコンピュータをより直接的に使って、頂点プログラムを送信する場合、どのようにクエリが書かれているかを理解することが重要だ。下記の例では、'PageRankVertexProgram'をセットアップして、実行している。返される結果には、3624 個の頂点があり、エッジがない新しいグラフが含まれている点に注意してほしい。

[source,groovy]
----
dcr = graph.compute().
      program(PageRankVertexProgram.build().
      edges(hasLabel('airport').outE('route')).
      create()).submit().get()

result[tinkergraph[vertices:3624 edges:0],memory[size:0]]
----

もし、興味があれば、頂点プログラムの作成から果オブジェクトの正確な型をチェックするとよい。

[source,groovy]
----
dcr.getClass()

class org.apache.tinkerpop.gremlin.
      process.computer.util.DefaultComputerResult
----

返された結果が新しいグラフであるとすると、新しいトラバーサルを作成して検査をすることができる。このグラフのイスタンブール(IST) 頂点には、'gremlin.pageRankVertexProgram.pageRank'という追加されたプロパティが含まれている点に注意してほしい。このプロパティにはこの頂点に対して返されたペイジランクのスコアが含まれている。

[source,groovy]
----
g2 = dcr.graph().traversal()

g2.V().has('code','IST').valueMap(true)

[id:161,country:[TR],code:[IST],longest:[9843],gremlin.pageRankVertexProgram.pageRank:[0.0047038762655771775],city:[Istanbul],lon:[28.8145999908],type:[airport],label:airport,elev:[163],icao:[LTBA],region:[TR-34],runways:[3],lat:[40.9768981934],desc:[Ataturk International Airport]]
----

元のグラフが変更されていないことを確認するために、そのグラフのIST頂点を確認してみよう。ごらんのとおり、新しいプロパティが現れない。

[source,groovy]
----
g.V().has('code','IST').valueMap(true)

[id:161,country:[TR],code:[IST],longest:[9843],city:[Istanbul],lon:[28.8145999908],type:[airport],label:airport,elev:[163],icao:[LTBA],region:[TR-34],runways:[3],lat:[40.9768981934],desc:[Ataturk International Airport]]
----

最後に、ペイジランクのスコアで降順にソートされた10件の空港を見てみよう。ごらんのとおり、スコアリングシステムは異なるが、選択された空港は、インライン'pageRank'ステップによって返される空港と同じである。

[source,groovy]
----
g2.V().order().by('gremlin.pageRankVertexProgram.pageRank',desc).limit(10).
       valueMap('code','gremlin.pageRankVertexProgram.pageRank')

[code:[IST],gremlin.pageRankVertexProgram.pageRank:[0.004594389373424941]]
[code:[DFW],gremlin.pageRankVertexProgram.pageRank:[0.004440623428637068]]
[code:[ORD],gremlin.pageRankVertexProgram.pageRank:[0.004342068075230758]]
[code:[ATL],gremlin.pageRankVertexProgram.pageRank:[0.004251005124367605]]
[code:[PEK],gremlin.pageRankVertexProgram.pageRank:[0.004172537469821617]]
[code:[DXB],gremlin.pageRankVertexProgram.pageRank:[0.004161183557641767]]
[code:[DEN],gremlin.pageRankVertexProgram.pageRank:[0.004063035588247088]]
[code:[DME],gremlin.pageRankVertexProgram.pageRank:[0.004009614722586433]]
[code:[FRA],gremlin.pageRankVertexProgram.pageRank:[0.003994862262812258]]
[code:[CDG],gremlin.pageRankVertexProgram.pageRank:[0.0039023184469861244]]
----

本セクションでは、これらの新しい TinkerPop OLAP 機能についてほとんど説明していない。もしこれがあなたの関心のある分野なのであれば、私は公式の TInkerPop リファレンスドキュメントを読むことを強くお勧めする。

[[msc]]
== その他のクエリとその結果

本章では、'air-routes'グラフで動作するその他の Gremlin クエリについて説明する。これらのクエリはすべて、前のセクションで説明したトピックに基づいている。本セクションでは、クエリを実行して返された出力の例をたくさん含めた。出力がかなり長い場合は、読みやすくしてスペースを節約するために一部割愛するか2列にレイアウトした。また、本セクションの例をよむことにより、分析に使う際にグラフとしてモデル化されたデータがどれだけ優れているかが理解いただけることを願っている。また、本セクションのクエリは、いくつかのOLTPスタイルのクエリとTinkerGraph を使うだけであなたが役に立つ結果をグラフから得られることを示していると考える。これは実際にはTinkerGraph の理想的なユースケースのすぐれた例である。たとえ、大規模にホストされたグラフに主要なデータがあったとしても、その一部を抽出して、TinkerGraph を使ってローカルで分析することはとても生産的な手法である。

[[countmore]]
=== より多くのものをカウントする

始めるにあたり、基本的に何らかの発生と分散を数えるだけだが、本書の前半でこれまで見てきた例より少し複雑な例をいくつか見てみよう。

[[noairports]]
==== 空港がない国はどれ？

この最初のクエリは、出エッジがない'country'頂点を検索する。これは、これらの国には、グラフに空港がないことを示している。

[source,groovy]
----
// Are there any countries that have no airports?
g.V().hasLabel('country').not(out()).values('desc')
----

なので、空港が見つからなかった国は六か国あるようだ。

[source,groovy]
----
Andorra
Liechtenstein
Monaco
Montserrat
Pitcairn
San Marino
----

前のクエリは、下記の2つのクエリよりわずかに短い形式であり、どちらも同じ結果が得られる。2つ目のクエリの'not'ステップ'の前に'"__"'のプレフィクスを使っている点に注意してほしい。これは、'not'は Groovy の予約語であり、前のステップにドットで直接接続されていない場合は、この方法でプレフィクスを付ける必要があるからだ。

[source,groovy]
// Are there any countries that have no airports?
----
g.V().hasLabel('country').where(out().count().is(0)).values('desc')

g.V().hasLabel('country').where(__.not(out())).values('desc') 

----

[[noroutes]]
==== 経路がない空港はどれ？

グラフには、現在商用経路がない空港がいくつかある。これは、以前はサービスされていたが廃止されたか、サービスの開始を待っている新しい空港だからだ。これらの「孤立した」空港を簡単に見つけるためのクエリを書くことができる。これは、air-routes.graphml のバージョン 0.77 に基づくクエリであることに注意してほしい。

TIP: 本書の例で用いられている air-routes.graphml ファイルのバージョンと最新のデータセットは, https://github.com/krlawrence/graph/tree/main/sample-data にあるsample-data フォルダにある。

データセットの最近の更新では、これらの空港の一部に商用空港会社のサービスがある。

[source,groovy]
----

g.V().hasLabel('airport').not(bothE('route')).values('code').fold()
----

クエリを実行すると、出経路と入り経路がない孤立した空港ノードがかなりの数みつかることがわかる。

[source,groovy]
----
[ILG,TWB,TUA,BVS,KGG,RIG,INT,APA,BWU,BID,NBW,SFH,CVT,AFW,PSY,HLE]
----

[[runwaydist]]
==== 滑走路の分布は何？

滑走路の空港ごとの分布を簡単に数えることができる。クエリを実行した結果から、グラフにある空港の大部分に1本または2本の滑走路があることがわかる。

[source,groovy]
----
// What is the distribution of runways in the graph
g.V().hasLabel('airport').groupCount().by('runways')

[1:2316,2:762,3:225,4:51,5:14,6:4,7:1,8:1]
----

[[mostroutes]]
==== 経路が最も多い空港

この次のクエリでは、180を超える出経路があるすべての空港を見つけ、そのIATA コードを返す。

[source,groovy]
----
// Airports with more than 180 outgoing routes
g.V().hasLabel('airport').
      where(out('route').count().is(gt(180))).values('code').fold()

[ATL,DFW,IAH,JFK,LAX,ORD,DEN,EWR,YYZ,LHR,LGW,CDG,FRA,DXB,PEK,PVG,FCO,AMS,BCN,MAD,MUC,MAN,STN,DME,IST]
----

クエリを少し改良して、返される結果にIATAコードと出経路の正確な数を含めることができる。これを行うにはいくつかの異なる方法がある。非常に便利な方法の1つは、'group'を使うことだ。

[source,groovy]
----
// Same basic query but return the airport code and the route count
g.V().hasLabel('airport').
      where(out('route').count().is(gt(180))).
      group().by('code').by(out().count())
----

結果を読みやすくするために、グリッド状にレイアウトした。

[source,groovy]
----
[ORD:232,PVG:201,LAX:195,CDG:262,
 STN:186,JFK:187,DFW:221,LHR:191,
 MUC:237,DME:214,EWR:182,AMS:269,
 IST:270,DEN:188,BCN:190,DXB:229,
 IAH:192,MAD:192,FCO:189,FRA:272,
 PEK:234,ATL:232,YYZ:181,MAN:182,
 LGW:200]
----

クエリにさらに改良を1つ加えることができる。今回は、結果は番号あるいは経路の降順でソートされている。'local'を使って、'order'が'group'ステップにより生成されたコレクションの中身に適用されることに注意してほしい。

[source,groovy]
----
// Same query with ordered results
g.V().hasLabel('airport').
      where(out('route').count().is(gt(180))).
      group().by('code').by(out().count()).
      order(local).by(values,desc)
----

再度、結果をグリッドにレイアウトした。

[source,groovy]
----
[FRA:272,IST:270,AMS:269,CDG:262,
 MUC:237,PEK:234,ORD:232,ATL:232,
 DXB:229,DFW:221,DME:214,PVG:201,
 LGW:200,LAX:195,IAH:192,MAD:192,
 LHR:191,BCN:190,FCO:189,DEN:188,
 JFK:187,STN:186,EWR:182,MAN:182,
 YYZ:181]
----

本書の前半で述べたように、航空会社がフライトの経路をどのように運用しているかにより、特定の空港の入り経路と出経路の数は必ずしも同じではない。下記のクエリは、400 を超える(入りと出）経路がある空港を探す。

[source,groovy]
----
// Airports with more than 400 total routes
g.V().hasLabel('airport').
      where(both('route').count().is(gt(400))).
      values('code').fold()

[ATL,DFW,ORD,CDG,FRA,DXB,PEK,PVG,AMS,MUC,DME,IST]
----

[[oneroute]]
==== 滑走路が1本しかない空港

おそらく驚くべきことに、経路が１つしかない空港が多数ある。下記のクエリは、そのカテゴリに分類される数を把握する。

[source,groovy]
----
// How many airports have only one route?
g.V().hasLabel('airport').
  where(out().count().is(eq(1))).count()

770
----

[[onerunway]]
==== 最も経路の多い、滑走路が1本しかない空港

滑走路が１本しかない空港がどれほど忙しいかを見るのは興味深いことだ。下記のクエリは、滑走路が１本しかない空港のなかで、出経路が最も多い10件を探す。'or'ステップを使って、クエリに ロンドンのガトウィック空港を含めたことにはお気づきだろう。これは、技術的には、ガトウィックは2本の滑走路を持つ空港としてグラフにリストされているが、実際には2つ目の滑走路は誘導路として使われていて、緊急用途のために予約されているからだ。したがって、ガトウィック空港は実際には滑走路が1本しかない空港である。これによりクエリが少し興味深くなる。

[source,groovy]
----
g.V().or(has('airport','runways',1),has('code','LGW')).
      order().by(out().count(),desc).limit(10).
      project('apt','city','routes').
      by('code').by('city').by(out().count())
----

クエリを実行するとこのような結果が返される。１つ興味深いのは、最も混雑している空港上位5件のうち3件が、Englanfにあることだ。

[source,groovy]
----
[apt:LGW,city:London,routes:200]
[apt:STN,city:London,routes:186]
[apt:CTU,city:Chengdu,routes:124]
[apt:LIS,city:Lisbon,routes:116]
[apt:BHX,city:Birmingham,routes:109]
[apt:SAW,city:Istanbul,routes:109]
[apt:KMG,city:Kunming,routes:107]
[apt:ALC,city:Alicante,routes:106]
[apt:CKG,city:Chongqing,routes:106]
[apt:XIY,city:Xianyang,routes:105]
----

[[runwaycountproject]]
==== 滑走路を数える他の方法

グラフにある滑走路の数を数え、滑走路の数とその数の滑走路を持つ空港の数の総数に、それぞれ意味のあるラベルを付けた簡単なマップの結果を作成したいとしよう。これを行う方法の1つは、'groupCount'ステップを使って滑走路の分散を計算し、'project'ステップを使って適切にラベル付けされた結果を生成することだ。下記のクエリはこれを行っている。'unfold'ステップが使われていて、そのため'groupCount'の結果自体がマップを生成し、さらに処理できるようになっている点に注目してほしい。

[source,groovy]
----
g.V().hasLabel('airport').
      groupCount().by('runways').
      unfold().
      project('runways','count').by(keys).by(values)
----

実行すると、滑走路の数とそれぞれの総数を示すきれいなマップが返される。各値には、'runways'と'count'という意味のあるキー名がそれぞれある。

[source,groovy]
----
[runways:1,count:2316]
[runways:2,count:762]
[runways:3,count:225]
[runways:4,count:51]
[runways:5,count:14]
[runways:6,count:4]
[runways:7,count:1]
[runways:8,count:1]
----

unfold ステップが使われないと、まったく異なる結果が生成される点に注目してほしい。

[source,groovy]
----
g.V().hasLabel('airport').
      groupCount().by('runways').
      project('runways','count').by(keys).by(values) 

[runways:[1,2,3,4,5,6,7,8],count:[2316,762,225,51,14,4,1,1]]
----

[[canadamost]]
==== カナダで最も経路が多い空港

次のクエリはカナダにある上位10件の空港を見つけ、出経路の数で降順にソートする。ただの興味本位で、今回は'index'メソッドを使って、結果の一部として1から始まる項番を付与した。

[source,groovy]
----
g.V().has('country','code','CA').out().
      order().by(out().count(),desc).limit(10).
      project('apt','city','routes').
      by('code').by('city').by(out().count()).indexed(1)
----

追加したインデックスも合わせて、クエリを実行した結果はこの通り。

[source,groovy]
----
[1,[apt:YYZ,city:Toronto,routes:181]]
[2,[apt:YUL,city:Montreal,routes:101]]
[3,[apt:YVR,city:Vancouver,routes:94]]
[4,[apt:YYC,city:Calgary,routes:68]]
[5,[apt:YEG,city:Edmonton,routes:41]]
[6,[apt:YHZ,city:Halifax,routes:40]]
[7,[apt:YWG,city:Winnipeg,routes:32]]
[8,[apt:YOW,city:Ottawa,routes:31]]
[9,[apt:YZF,city:Yellowknife,routes:20]]
[10,[apt:YQB,city:Quebec City,routes:19]]
----

[[ukdist]]
==== UKの空港の分布

イングランド、スコットランド、ウェールズ、北アイルランドの英国の各地域には空港がいくつあるか？

[source,groovy]
----
g.V().has('country','code','UK').out('contains').groupCount().by('region')

[GB-ENG:27,GB-WLS:3,GB-NIR:3,GB-SCT:25]
----

[[countrydist]]
==== 国ごとの空港の分布

このクエリは'groupCount'を使って、キーと値のペアのマップを生成する。キーは2文字のISO国コードで、値はその国にある空港の数である。

[source,groovy]
----
// How many airports does each country have in the graph?
g.V().hasLabel('airport').
      groupCount().by('country')
----

クエリを実行するとかなりの量の出力が生成される。値がソートされていないので、最も空港が多い国を見つけるのは困難だ。'groupCount'ステップには空港がない国は含まれない点に注意してほしい。言い換えると、カウントがゼロの場合、その国はスキップされる。

[source,groovy]
----
[PR:6,PT:14,PW:1,PY:2,QA:1,AE:10,AF:4,AG:1,AI:1,AL:1,AM:2,AO:14,AR:36,AS:1,AT:6,RE:2,AU:124,AW:1,AZ:5,RO:14,BA:4,BB:1,RS:2,BD:7,BE:5,RU:120,BF:2,BG:4,RW:2,BH:1,BI:1,BJ:1,BL:1,BM:1,BN:1,BO:15,SA:26,BQ:3,SB:17,BR:115,SC:2,BS:18,SD:5,SE:39,BT:1,SG:1,BW:4,SH:2,SI:1,BY:2,BZ:13,SK:2,SL:1,SN:3,SO:5,CA:203,SR:1,SS:1,CC:1,CD:11,ST:1,SV:1,CF:1,CG:3,CH:5,SX:1,CI:1,SY:2,SZ:1,CK:6,CL:17,CM:5,CN:209,CO:50,CR:13,TC:4,TD:1,CU:12,CV:7,TG:1,TH:32,CW:1,CX:1,CY:3,TJ:4,CZ:5,TL:1,TM:1,TN:8,TO:1,TR:48,TT:2,DE:33,TV:1,TW:9,TZ:8,DJ:1,DK:8,DM:1,DO:7,UA:15,UG:4,UK:58,DZ:29,US:579,EC:15,EE:3,EG:10,EH:2,UY:2,UZ:11,ER:1,VC:1,ES:42,ET:14,VE:24,VG:2,VI:2,VN:21,VU:26,FI:20,FJ:10,FK:2,FM:4,FO:1,FR:58,WF:2,GA:2,WS:1,GD:1,GE:3,GF:1,GG:2,GH:5,GI:1,GL:14,GM:1,GN:1,GP:1,GQ:2,GR:39,GT:2,GU:1,GW:1,GY:2,HK:1,HN:6,HR:8,HT:2,YE:9,HU:2,ID:67,YT:1,IE:7,IL:5,IM:1,IN:73,ZA:20,IQ:6,IR:44,IS:5,IT:36,ZM:8,JE:1,ZW:3,JM:2,JO:2,JP:63,KE:14,KG:2,KH:3,KI:2,KM:1,KN:2,KP:1,KR:15,KS:1,KW:1,KY:3,KZ:20,LA:8,LB:1,LC:2,LK:6,LR:2,LS:1,LT:3,LU:1,LV:1,LY:10,MA:14,MD:1,ME:2,MF:1,MG:13,MH:2,MK:1,ML:1,MM:14,MN:10,MO:1,MP:2,MQ:1,MR:3,MS:1,MT:1,MU:2,MV:8,MW:2,MX:59,MY:34,MZ:10,NA:4,NC:1,NE:1,NF:1,NG:18,NI:1,NL:5,NO:49,NP:10,NR:1,NZ:25,OM:4,PA:5,PE:20,PF:30,PG:26,PH:38,PK:21,PL:13,PM:1]
----

数値を使ってリストを降順にソートしたい場合は、下記のようにクエリを調整するとよい。再度、'local'を使って順序づけをどのように適用するかを指定していることに注意してほしい。

[source,groovy]
----
g.V().hasLabel('airport').
      groupCount().by('country').
      order(local).by(values,desc)
----

今回は、どの国が最も空港があるかを確認するのがはるかに簡単だ。

[source,groovy]
----
[US:579,CN:209,CA:203,AU:124,RU:120,BR:115,IN:73,ID:67,JP:63,MX:59,UK:58,FR:58,CO:50,NO:49,TR:48,IR:44,ES:42,SE:39,GR:39,PH:38,AR:36,IT:36,MY:34,DE:33,TH:32,PF:30,DZ:29,SA:26,VU:26,PG:26,NZ:25,VE:24,VN:21,PK:21,FI:20,ZA:20,KZ:20,PE:20,BS:18,NG:18,SB:17,CL:17,BO:15,UA:15,EC:15,KR:15,PT:14,AO:14,RO:14,ET:14,GL:14,KE:14,MA:14,MM:14,BZ:13,CR:13,MG:13,PL:13,CU:12,CD:11,UZ:11,AE:10,EG:10,FJ:10,LY:10,MN:10,MZ:10,NP:10,TW:9,YE:9,TN:8,TZ:8,DK:8,HR:8,ZM:8,LA:8,MV:8,BD:7,CV:7,DO:7,IE:7,PR:6,AT:6,CK:6,HN:6,IQ:6,LK:6,AZ:5,BE:5,SD:5,SO:5,CH:5,CM:5,CZ:5,GH:5,IL:5,IS:5,NL:5,PA:5,AF:4,BA:4,BG:4,BW:4,TC:4,TJ:4,UG:4,FM:4,NA:4,OM:4,BQ:3,SN:3,CG:3,CY:3,EE:3,GE:3,ZW:3,KH:3,KY:3,LT:3,MR:3,PY:2,AM:2,RE:2,RS:2,BF:2,RW:2,SC:2,SH:2,BY:2,SK:2,SY:2,TT:2,EH:2,UY:2,VG:2,VI:2,FK:2,WF:2,GA:2,GG:2,GQ:2,GT:2,GY:2,HT:2,HU:2,JM:2,JO:2,KG:2,KI:2,KN:2,LC:2,LR:2,ME:2,MH:2,MP:2,MU:2,MW:2,PW:1,QA:1,AG:1,AI:1,AL:1,AS:1,AW:1,BB:1,BH:1,BI:1,BJ:1,BL:1,BM:1,BN:1,BT:1,SG:1,SI:1,SL:1,SR:1,SS:1,CC:1,ST:1,SV:1,CF:1,SX:1,CI:1,SZ:1,TD:1,TG:1,CW:1,CX:1,TL:1,TM:1,TO:1,TV:1,DJ:1,DM:1,ER:1,VC:1,FO:1,WS:1,GD:1,GF:1,GI:1,GM:1,GN:1,GP:1,GU:1,GW:1,HK:1,YT:1,IM:1,JE:1,KM:1,KP:1,KS:1,KW:1,LB:1,LS:1,LU:1,LV:1,MD:1,MF:1,MK:1,ML:1,MO:1,MQ:1,MS:1,MT:1,NC:1,NE:1,NF:1,NI:1,NR:1,PM:1]
----

国コード、つまり'key'でソートしたい場合は、それに応じてクエリを変更するとよい。この場合、'by(keys,asc)'を使って昇順にソートする。もしキーの降順にソートしたいのであれば、代わりに'by(keys, desc)'を使うとよい。

[source,groovy]
----
g.V().hasLabel('airport').
      groupCount().by('country').
      order(local).by(keys,asc)
----

今回は、結果は国コードを使ってアルファベットの昇順でソートされている。

[source,groovy]
----
[AE:10,AF:4,AG:1,AI:1,AL:1,AM:2,AO:14,AR:36,AS:1,AT:6,AU:124,AW:1,AZ:5,BA:4,BB:1,BD:7,BE:5,BF:2,BG:4,BH:1,BI:1,BJ:1,BL:1,BM:1,BN:1,BO:15,BQ:3,BR:115,BS:18,BT:1,BW:4,BY:2,BZ:13,CA:203,CC:1,CD:11,CF:1,CG:3,CH:5,CI:1,CK:6,CL:17,CM:5,CN:209,CO:50,CR:13,CU:12,CV:7,CW:1,CX:1,CY:3,CZ:5,DE:33,DJ:1,DK:8,DM:1,DO:7,DZ:29,EC:15,EE:3,EG:10,EH:2,ER:1,ES:42,ET:14,FI:20,FJ:10,FK:2,FM:4,FO:1,FR:58,GA:2,GD:1,GE:3,GF:1,GG:2,GH:5,GI:1,GL:14,GM:1,GN:1,GP:1,GQ:2,GR:39,GT:2,GU:1,GW:1,GY:2,HK:1,HN:6,HR:8,HT:2,HU:2,ID:67,IE:7,IL:5,IM:1,IN:73,IQ:6,IR:44,IS:5,IT:36,JE:1,JM:2,JO:2,JP:63,KE:14,KG:2,KH:3,KI:2,KM:1,KN:2,KP:1,KR:15,KS:1,KW:1,KY:3,KZ:20,LA:8,LB:1,LC:2,LK:6,LR:2,LS:1,LT:3,LU:1,LV:1,LY:10,MA:14,MD:1,ME:2,MF:1,MG:13,MH:2,MK:1,ML:1,MM:14,MN:10,MO:1,MP:2,MQ:1,MR:3,MS:1,MT:1,MU:2,MV:8,MW:2,MX:59,MY:34,MZ:10,NA:4,NC:1,NE:1,NF:1,NG:18,NI:1,NL:5,NO:49,NP:10,NR:1,NZ:25,OM:4,PA:5,PE:20,PF:30,PG:26,PH:38,PK:21,PL:13,PM:1,PR:6,PT:14,PW:1,PY:2,QA:1,RE:2,RO:14,RS:2,RU:120,RW:2,SA:26,SB:17,SC:2,SD:5,SE:39,SG:1,SH:2,SI:1,SK:2,SL:1,SN:3,SO:5,SR:1,SS:1,ST:1,SV:1,SX:1,SY:2,SZ:1,TC:4,TD:1,TG:1,TH:32,TJ:4,TL:1,TM:1,TN:8,TO:1,TR:48,TT:2,TV:1,TW:9,TZ:8,UA:15,UG:4,UK:58,US:579,UY:2,UZ:11,VC:1,VE:24,VG:2,VI:2,VN:21,VU:26,WF:2,WS:1,YE:9,YT:1,ZA:20,ZM:8,ZW:3]
----

'select'を使って返されたキーと値のペアの完全なセットを1つ以上だけを返すことができることに注意してほしい。これがまさにその例である。

[source,groovy]
----
// Only return the values for Germany, China, Holland and the US.
g.V().hasLabel('airport').
      groupCount().by('country').
      select('DE','CN','NL','US')

[DE:32, CN:179, NL:5, US:566]
----

'air-routes'グラフにも国固有の頂点があるので、前のクエリを別の方法で記述するのを選択することができる。国の頂点を見つけるところから始めて、いくつの空港の頂点がそれに接続されているかを調べることができる。この場合、'group'ステップが使われているので、空港のない国が含まれている。

[source,groovy]
----
// Another way to ask the question above, this time by counting the
// edges (out degree) from each country

g.V().hasLabel('country').
      group().by('code').by(outE().count()).
      order(local).by(values,desc)
----

今回は、空港がない国が結果に**含まれている** 。

[source,groovy]
----
[US:579,CN:209,CA:204,AU:125,RU:122,BR:115,IN:74,ID:67,JP:63,MX:59,UK:58,FR:58,CO:50,NO:49,TR:48,IR:45,ES:42,SE:39,GR:39,PH:39,AR:37,IT:36,MY:34,DE:33,TH:32,PF:30,DZ:29,SA:26,VU:26,PG:26,NZ:25,VE:24,VN:21,PK:21,FI:20,ZA:20,KZ:20,PE:20,BS:18,NG:18,SB:17,CL:17,BO:15,UA:15,EC:15,KR:15,PT:14,AO:14,RO:14,ET:14,GL:14,KE:14,MA:14,MM:14,BZ:13,CR:13,MG:13,PL:13,CU:12,CD:11,UZ:11,AE:10,EG:10,FJ:10,LY:10,MN:10,MZ:10,NP:10,TW:9,YE:9,TN:8,TZ:8,DK:8,HR:8,ZM:8,LA:8,MV:8,BD:7,CV:7,DO:7,IE:7,PR:6,AT:6,CK:6,HN:6,IQ:6,LK:6,AZ:5,BE:5,SD:5,SO:5,CH:5,CM:5,CZ:5,GH:5,IL:5,IS:5,NA:5,NL:5,PA:5,AF:4,BA:4,BG:4,BW:4,TC:4,TJ:4,UG:4,FM:4,OM:4,BQ:3,SN:3,CG:3,CY:3,EE:3,GE:3,ZW:3,KH:3,KY:3,LT:3,MR:3,PY:2,AM:2,RE:2,RS:2,BF:2,RW:2,SC:2,SH:2,SI:2,BY:2,SK:2,SY:2,TT:2,EH:2,UY:2,VG:2,VI:2,FK:2,WF:2,GA:2,GG:2,GQ:2,GT:2,GY:2,HT:2,HU:2,JM:2,JO:2,KG:2,KI:2,KN:2,LC:2,LR:2,ME:2,MH:2,MP:2,MU:2,MW:2,PW:1,QA:1,AG:1,AI:1,AL:1,AS:1,AW:1,BB:1,BH:1,BI:1,BJ:1,BL:1,BM:1,BN:1,BT:1,SG:1,SL:1,SR:1,CC:1,SS:1,ST:1,CF:1,SV:1,SX:1,CI:1,SZ:1,TD:1,TG:1,CW:1,CX:1,TL:1,TM:1,TO:1,TV:1,DJ:1,DM:1,ER:1,VC:1,FO:1,WS:1,GD:1,GF:1,GI:1,GM:1,GN:1,GP:1,GU:1,GW:1,HK:1,YT:1,IM:1,JE:1,KM:1,KP:1,KS:1,KW:1,LB:1,LS:1,LU:1,LV:1,MD:1,MF:1,MK:1,ML:1,MO:1,MQ:1,MS:1,MT:1,NC:1,NE:1,NF:1,NI:1,NR:1,PM:1,AD:0,SM:0,LI:0,MC:0,PN:0]
----

ソートされた結果の最後のいくつかだけを表示したいのであれば、クエリに'local'スコープ付の'tail'ステップを追加するとよい。

[source,groovy]
----
g.V().hasLabel('country').
      group().by('code').by(outE().count()).
      order(local).by(values,desc).
      tail(local,20)

[LV:1,MD:1,MF:1,MK:1,ML:1,MO:1,MQ:1,MS:1,MT:1,NC:1,NE:1,NF:1,NI:1,NR:1,PM:1,AD:0,SM:0,LI:0,MC:0,PN:0]

----

[[continentdist]]
==== 大陸ごとの空港の分布

上記のクエリと同様のクエリを使って、7つの大陸のそれぞれに空港がいくつあるかを調べることができる。出力からわかるように、キー／値のマップが再び返される。このキーは大陸コードで値はその大陸にある空港の数だ。現在南極大陸に定期便のある空港がないことに注意してほしい。

[source,groovy]
----
// How many airports are there in each continent?
g.V().hasLabel('continent').group().by('code').by(out().count())

[EU:583,AS:932,NA:978,OC:284,AF:294,AN:0,SA:303]
----

==== 空港ごとの経路の分布

グラフ内の経路の分布を計算する様々な方法をすでに調べた。次のクエリは各空港ごとに、キーが空港コードで、値がその空港から出る経路の数のキーと値のペアを返す。グラフには、3000を超える空港があるので、このクエリは大きな結果を生成する。この結果をここに含めないことにした。2つ目のクエリは、いくつかの空港のマップから結果を返すだけだ。その結果は表示されている。

[source,groovy]
----
// How many flights are there from each airport?
g.V().hasLabel('airport').out().groupCount().by('code')

// count the routes from all the airports and then select a few.
g.V().hasLabel('airport').out().groupCount().by('code').
      select('AUS','AMS','JFK','DUB','MEX')

[AUS:59,AMS:272,JFK:186,DUB:165,MEX:105]
----

この次のクエリは、基本的に各空港にいくつの出経路があるかという同じ問をする。しかしながら、各空港、それぞれの件数を返すのではなく、同じ経路数の空港をグルーピングする。このクエリは大量のデータを返すので、クエリの下の完全な結果から数行を含めた。

[source,groovy]
----
// Same query except sorted into groups by ascending count
g.V().hasLabel('airport').
      group().by(out().count()).by('code').
      order(local).by(keys)

----

今回見られるように、カウントの値がキーで、空港コードが値だ。

[source,groovy]
----
76:[TPA,BNE,PDX],77:[RIX,WUH],78:[IBZ,PTY],79:[ADD,AYT],80:[MNL,BOG,XMN,CSX],81:[SFB],82:[GLA,HND],83:[CAI,MDW,OTP],84:[VCE,BRS,HGH],85:[JNB,MLA,NAP,RUH],86:[BOM,SHJ],89:[BWI],90:[CMN],91:[LPA,VKO],92:[SXF],93:[DCA,GRU,LYS],94:[SLC,YVR,SYD,MRS,TFS],95:[STR,CRL],97:[NCE,AUH],98:[BUD,WAW],101:[YUL],102:[BGY],104:[LTN,JED,SZX],105:[PHX,MEX,TLV,HAM,XIY],106:[ALC,CUN,CKG],107:[HEL,EDI,KMG],108:[DEL],109:[BHX,SAW],110:[TPE],112:[NRT],113:[GVA],114:[SEA],115:[PRG],116:[CGN,LIS],118:[ATH,TXL],119:[OSL],122:[KUL],123:[MCO],124:[MXP,CTU],126:[AGP],127:[ORY],129:[PHL],130:[BOS],132:[BKK],133:[LED],136:[IAD],137:[DTW],141:[SFO],142:[FLL],143:[ARN,PMI],144:[MSP,ICN],145:[LAS,CPH],146:[SIN],151:[HKG],152:[ZRH],156:[SVO],162:[VIE],163:[DOH],164:[CAN],165:[DUB],166:[DUS],168:[CLT],171:[MIA],180:[BRU],181:[YYZ],182:[EWR,MAN],186:[STN],187:[JFK],188:[DEN],189:[FCO],190:[BCN],191:[LHR],192:[IAH,MAD],195:[LAX],200:[LGW],201:[PVG],214:[DME],221:[DFW],229:[DXB],232:[ATL,ORD],234:[PEK],237:[MUC],262:[CDG],269:[AMS],270:[IST],272:[FRA]]

----

上記のクエリは大量のデータを返すので、下記のように、関心のある特定の値を抽出することもできる。105の発経路がある空港だけが選択される。

[source,groovy]
----
// Which of these airports have 105 outgoing routes?
g.V().hasLabel('airport').
      group().by(out().count()).by('code').next().get(105L)
----

NOTE: 現在 select は文字列の値のみをキーとして取ることができるので、結果から数値のキーを得るには、少し厄介な next().tget() の構文を使う必要がある。

今回の結果には、105の発経路がある空港の身が含まれている。

[source,groovy]
----
PHX
MEX
TLV
HAM
XIY
----


[[groupvar]]
==== groupCounte をトラバーサル変数と一緒に使う

これまでは、パラメータなしで、'groupCount'を使ってきた。このように使うと、'groupCount'は、変換されたデータを次のステップに渡すという点で'map'ステップのようにふるまう。しかしながら、トラバーサル変数の名前をパラメータとして指定すると、カウントの結果はその変数に格納され、'groupCount'は'sideEffect'と同じように動作し、'groupCount'から次のステップへは何も渡されない。この機能を使って、クエリの実行中、トラバーサルの全体的な状態を実際に変更することなく、追跡することができる。

下記の例では、頂点'V(3)'からスタートし、そこから'out'へ進む。次に、'groupCount'ステップを使って アクセスした頂点を、そこの滑走路の数のカウントによってグルーピングする。次に、再度'out'を進み、いくつ頂点が見つかるかカウントし、その結果を変数'b'に保存する。このように使われる場合、'groupCount'後続のステップに何も渡さないことに注意してほしい。最後に、'select'を使って2つの変数をクエリの結果として返す。

[source,groovy]
----
g.V(3).out().groupCount('a').by('runways').
       out().count().as('b').select('a','b')

[a:[1:2,2:9,3:17,4:22,5:4,6:3,7:1,8:1],b:5942]
----

次のセクションでは、トラバーサル変数を使う'groupCount'ステップの他の例について見ていく。

[[gcconstant]]
==== groupCount と定数を組み合わせる

結果で使われるキーの名前を設定する1つの方法として、'groupCount'ステップと組み合わせて'constant'値を使うことができる。下記の例は、トラバーサル変数'"a"'がパラメータとして提供され、'by'モジュレータの一部として定数が提供される'groupCount'ステップを示している。クエリはUSのオクラホマ州にある空港を見つけることから始める。'constant'ステップは、'groupCount'ステップに、結果のキー名として何を使うのかを伝えるのに使われる。クエリの終わりに、'cap'ステップを使って、'"a"'の内容をクローズして返す。

[source,groovy]
----
g.V().has('airport','region','US-OK').groupCount('a').by(constant('OK')).cap('a')
----

クエリを実行すると、これが返されるものだ。キーは定数値'"OK"'で、値はオクラホマに見つかった空港の数であることに注意してほしい。

[source,groovy]
----
[OK:4]
----

上記の例は、'constant'値を'groupCount'で使うことができるという事実を示すことのみを目的としている。しかしながら、この特別な例では、おそらく代わりに下記のようにクエリをコーディングするだろう。

[source,groovy]
----
g.V().has('airport','region','US-OK').groupCount().by('region')

[US-OK:4]
----

[[chainchoose]]
==== choose と groupCount を組み合わせる

上述したアイデアを使って、いくつかの'choose'ステップを連鎖させて、カウントしたい様々なものを表す様々なキー：値のペアで構成される結果セットを構築するクエリを書くことができる。下記のクエリは、空港を表す全ての頂点を調べる。見つかった頂点ごとに、'choose'ステップを使って、様々なプロパティが調べられる。テストが'true'カウントを返す場合、トラバーサル変数'"a"'に格納されているカウントがインクリメントされる。各choose ステップがどのように'ドットで連鎖'されているか注意してほしい。このように使われると、'choose'は'sideEffect'と同じように動作し、'if'テストにパスしたものだけでなく、すべての空港の頂点が次の選択に渡される。

[source,groovy]
----
g.V().hasLabel('airport').
      choose(has('runways',4), groupCount('a').by(constant('four'))).
      choose(has('runways',lte(2)), groupCount('a').by(constant('low'))).
      choose(has('runways',gte(6)), groupCount('a').by(constant('high'))).
      choose(has('country','FR'), groupCount('a').by(constant('France'))).
      groupCount('a').by(constant('total')).cap('a')
----

クエリを実行すると、このように返されるだろう。合計3375 件の空港を数え、6つ以上の滑走路を持つ6つの空港、2つ以下の滑走路を持つ3079の空港を見つけ、フランスは58の空港が見つかった。

[source,groovy]
----
[total:3374,high:6,low:3078,four:51,France:58]
----

このように'choose'と'groupCount'を使うと、トラバーサル中にやや異なるものをカウントするための非常に優れたパターンが提供される。

[[nestedgroup]]
==== ある group ステップを別の groupステップ内にネストする

'groupCount'と'group'の両方のステップの多くの例は、本書ですでに紹介されている。しかしながら、これまで触れてこなかったことは、今では明らかかもしれないし、そうではないかもしれないが、1つの 'group'ステップを別のステップにネストできるということだ。これにより、'group'ステップにグループ化したいものを正確に伝えるために使う'by'モジュレータが任意のトラバーサルを実行できるという事実により可能となる。下記の例を見ていただきたい。インデントにより読みやすくなっていると思う。単に5つの空港を見つけてグルーピングを始める。各グループのキーはこれらの各空港のコードの1つになる。これは最初の'by'モジュレータによって指定されている。2つ目の'by'モジュレータで指定されている各グループの値の部分について、2つ目のトラバーサルが開始される。このトラバーサルは、最初に見つけた5つの空港から飛ぶことができる5つの場所を見つけることにより開始する。次に別の'group'ステップを使ってこれらの空港の各々をその空港からの出経路の数によってグループ化する。

[source,groovy]
----
g.V().hasLabel("airport").limit(5).
      group().
        by('code').
        by(out("route").limit(5).
           group().
             by('code').
             by(out("route").count()))
----

ここでクエリを実行すると、これが返される。期待した通り、外側のグループには最初の5つの空港を表すキーがある。内側のグループにはキーとして、5つの空港の目的地があり、それらの合計の出経路数を値とする。読みやすくするために、少し整形してある。

[source,groovy]
----
[BNA:[DCA:93,DFW:221,BWI:89,FLL:142,IAD:136],
 ANC:[IAH:192,LAX:195,DFW:221,PDX:76,FAI:19],
 BOS:[YVR:94,LHR:191,CDG:262,YYZ:181,LGW:200],
 ATL:[MEI:4,MLB:6,MSL:2,MCN:2,MBS:4],
 AUS:[MEX:105,FRA:272,LHR:191,PIT:54,YYZ:181]]
----

なので、作成したのは、空港コードをキーとして、追加のグループを値としてもつグループ、本質的にはマップだ。したがって、各グループがキーと値のペアで構成されていると、'select'ステップを使って結果の一部のみをピックアップできる。

[source,groovy]
----
g.V().hasLabel("airport").limit(5).
      group().
        by('code').
        by(out("route").limit(5).
           group().
             by('code').
             by(out("route").count())).
      select('ANC','ATL')
----

今回は、選択した結果のみが返される。

[source,groovy]
----
[ANC:[IAH:192,LAX:195,DFW:221,PDX:76,FAI:19],
 ATL:[MEI:4,MLB:6,MSL:2,MCN:2,MBS:4]]
----

内部グループから1つの結果を選択したいのであれば、'select'ステップを追加して行うこともできる。

[source,groovy]
----
g.V().hasLabel("airport").limit(5).
      group().
        by('code').
        by(out("route").limit(5).
           group().
             by('code').
             by(out("route").count())).
      select('ANC').
      select('IAH','LAX')
----

これにより、最初にANC のキーで結果が選択され、次に、そのグループから'IAH'と'LAX'のキーのみの結果が選択される。

[source,groovy]
----
[IAH:192,LAX:195]
----

[[eu-usa]]
==== ヨーロッパとUSA 間の経路を分析する

次のいくつかのクエリは'air-routes'のようなグラフを使って、特定の業界セグメントで分析を実行する方法を示す。次のクエリはヨーロッパの空港と米国の空港間の経路の分布と可用性の分析を行う。まず、ヨーロッパのどこかの空港と米国の空港間の経路の総数を調べてみよう。

[source,groovy]
----
// How many routes from anywhere in Europe to the USA?

g.V().has('continent','code','EU').
      out().out().has('country','US').
      count()

351
----

これで、３４５の異なる経路があることがわかった。ただし、'air-routes'グラフにはこれらの経路のいづれかを運航している航空会社の数を追跡していないことに注意してほしい。グラフには、少なくとも１つの航空会社がこれらの一意の経路のペアのそれぞれを運用しているデータが格納されている。この３４５の経路をもう少し掘り下げて、ヨーロッパから到着するフライトがある米国の空港の数を調べてみよう。

[source,groovy]
----
// How many different US airports have routes from Europe?

g.V().has('continent','code','EU').
      out().out().has('country','US').
      dedup().count()

38
----

よって、ヨーロッパの空港からの345本の経路が米国内の38の空港のうちの1つに到着していることがわかる。もう少し掘り下げて、38の空港にまたがるこれらの経路の分布をみることができる。

[source,groovy]
----
//What is the distribution of the routes amongst those US airports?

g.V().has('continent','code','EU').
      out().out().has('country','US').
      groupCount().by('code').
      order(local).by(values,asc)
----

ニューヨークのジョンFケネディ空港(JFK) はヨーロッパからの経路が最も多く、ニューアーク(NWR) が2番目に多いようだ。

[source,groovy]
----
[PHX:1,CVG:1,RSW:1,BDL:2,SJC:2,BWI:2,AUS:2,RDU:2,MSY:2,SAN:3,SLC:3,PDX:3,PIT:3,TPA:4,SFB:4,OAK:4,DTW:5,SWF:5,MSP:5,DEN:5,FLL:6,CLT:7,DFW:7,PVD:7,SEA:8,IAH:8,MCO:10,LAS:10,ATL:14,SFO:15,PHL:17,IAD:19,ORD:21,BOS:22,LAX:23,MIA:25,EWR:33,JFK:40]
----

ここで手順を繰り返すが、経路のヨーロッパ側の端を見てみよう。まず、米国へのフライトがあるヨーロッパの空港の数を計算できる。

[source,groovy]
----
// How many European airports have service to the USA?

g.V().has('continent','code','EU').
      out().as('a').
      out().has('country','US').
      select('a').dedup().count()

53
----

米国の空港でやったのと同じように、ヨーロッパの空港の経路の分布を把握することができる。

[source,groovy]
----
// What is the distribution of US routes amongst 
// the European airports?

g.V().has('continent','code','EU').
      out().as('a').
      out().has('country','US').
      select('a').groupCount().by('code').
      order(local).by(values,asc)
----

ロンドンのヒースロー(LHR) が最も多くの米国の目的地を提供し、フランクフルと(FRA) が2番目に多いようだ。

[source,groovy]
----
[RIX:1,TER:1,BRS:1,STN:1,NCE:1,KRK:1,ORK:1,KBP:1,PDL:1,DME:1,BEG:1,AGP:1,HAM:1,OPO:2,STR:2,VCE:2,BHX:2,ORY:2,ATH:2,MXP:3,BFS:3,BGO:3,GVA:3,VKO:3,HEL:3,WAW:4,SVO:4,GLA:4,EDI:5,SNN:5,CGN:5,TXL:6,VIE:6,LIS:6,BRU:7,ARN:7,OSL:8,IST:9,BCN:10,MAD:11,LGW:11,DUS:11,CPH:11,FCO:12,ZRH:13,MAN:13,DUB:15,MUC:16,AMS:18,KEF:18,CDG:22,FRA:24,LHR:27]
----

最後に、飛行した経路のリストが何であるかを知ることができる。この例では、345のうち10件を返すことにした。'path'ステップが大陸コード'EU'を含むトラバーサルのすべての部分を返す点に注意してほしい。結果の一部は、”<<pathintro>>”のセクションで前述したように、'from'モジュレータを追加することで削除できる。

[source,groovy]
----
// Selected routes from Europe to the USA.

g.V().has('continent','code','EU').
      out().out().
      has('country','US').
      path().by('code').
      limit(10)
----

最初の10件の返された結果には、ワルシャワ、ベオグラード、イスタンブールからの経路がリストアップされた。

[source,groovy]
----
[EU,WAW,JFK]
[EU,WAW,LAX]
[EU,WAW,ORD]
[EU,WAW,EWR]
[EU,BEG,JFK]
[EU,IST,ATL]
[EU,IST,BOS]
[EU,IST,IAD]
[EU,IST,IAH]
[EU,IST,JFK]
----

[[mapreduce]]
==== fold を使ってシンプルなマップーリデュース処理を行う

本書の前半で、'sum'を使って、値のコレクションをカウントする例を見た。'fold'を使って同様のことを行うこともできるが、より'map-reduce'タイプの方法で行うこともできる。

まず、これはこれまでに見た'fold'を使ったクエリだ。オースティンからのすべての経路を見つけ、'fold'ステップを使ってそれらの名前のリストを返す。

[source,groovy]
----
g.V().has('code','AUS').
      out('route').
      values('city').fold()
----

予想通りに、結果にはオースティンから飛ぶことができるすべての都市が1つのリストにまとめられていることが示されている。

[source,groovy]
----
[Toronto,London,Frankfurt,Mexico City,Pittsburgh,Portland,Charlotte,Cancun,Memphis,Cincinnati,Indianapolis,Kansas City,Dallas,St Louis,Albuquerque,Chicago,Lubbock,Harlingen,Guadalajara,Pensacola,Valparaiso,Orlando,Branson,St Petersburg-Clearwater,Atlanta,Nashville,Boston,Baltimore,Washington D.C.,Dallas,Fort Lauderdale,Washington D.C.,Houston,New York,Los Angeles,Orlando,Miami,Minneapolis,Chicago,Phoenix,Raleigh,Seattle,San Francisco,San Jose,Tampa,San Diego,Long Beach,Santa Ana,Salt Lake City,Las Vegas,Denver,New Orleans,Newark,Houston,El Paso,Cleveland,Oakland,Philadelphia,Detroit]
----

しかしながら、結果をさらに減らしたい場合はどうだろうか？下記のクエリの修正バージョンを見てほしい。オースティンからのすべての経路を見つけ、目的地の都市の名前を調べる。しかしながら、すべての名前を返すのではなく、今回は、'fold'ステップの使い方が異なり、都市名を1つの値に効果的に減らす。その値は、これらすべての都市の文字数の総数だ。本書の別のところで、'fold'が使われているのを見てきたが、今回は'fold'にパラメータとクロージャを渡す。パラメータは、最初の変数としてクロージャに渡され、2番目の変数として都市の名前が渡される。次に、クロージャは、ゼロと各名前の長さを加算して、現在の合計値を効率よく生成する。

[source,groovy]
----
g.V().has('code','AUS').out('route').values('city').
      fold(0) {a,b -> a + b.length()}

530
----

NOTE: このクエリは Gremlin コンソール内の TinkerGraph でそのまま機能するが、一部のグラフシステムではタイプチェックと Groovy  クロージャのサンドボックス化についてより厳しくなっている、安全のために、次のように、クロージャを明示的に型キャストするとよい。

[source,groovy]
----
g.V().has('code','AUS').out('route').values('city').
                       fold(0) {a,b -> (int)a + ((String)b).length()}
----


[[meanmode]]
==== グラフ内の経路の分布（モードと平均）

航空経路が例であるネットワークグラフで答えたいと思う一般的な質問の例は、「グラフ内の経路は空港の頂点間でどのように分布しているか？」である。この同じクエリを使って、一連の経路についての統計的'mode'（最も一般的な数）を見つけることもできる。

グラフ全体の経路の分布を分析する方法を示す次のクエリを見てほしい。我々は空港の頂点にのみ関心があり、それらの頂点について、各空港にある出経路の数をカウントしたい。結果をソートされた'key:value'ペアのセットとして返したい。ここで、キーは出経路の数で、値は、その数の出経路がある空港の数だ。

[source,groovy]
----
g.V().hasLabel('airport').
      groupCount().by(out('route').count()).
      order(local).by(values,desc)
----

クエリを実行すると、下記の結果が返される。結果は値により降順にソートされているので、'mode'(最も一般的）な出経路の数は実際には1つの経路があり、786の空港には出経路が1つしかないことがわかる。654の空港には、2本の経路しかないこともわかる。逆に多い方では、1つの空港に237の出経路があることもわかる。

[source,groovy]
----
[1:770,2:654,3:369,4:234,5:148,6:116,7:93,8:81,9:68,10:61,12:43,11:39,13:39,15:31,16:27,19:25,20:25,22:25,14:19,18:18,0:16,17:15,33:15,23:14,30:13,31:13,21:12,32:12,35:11,37:11,24:9,25:9,39:9,26:8,27:8,36:8,41:8,42:8,47:8,59:8,29:7,34:7,40:7,44:7,55:7,63:7,43:6,48:6,50:6,67:6,28:5,45:5,61:5,62:5,64:5,94:5,105:5,52:4,54:4,68:4,70:4,80:4,85:4,38:3,51:3,53:3,56:3,60:3,74:3,76:3,83:3,84:3,93:3,104:3,106:3,107:3,46:2,57:2,58:2,65:2,73:2,77:2,78:2,79:2,82:2,86:2,91:2,95:2,97:2,98:2,109:2,116:2,118:2,124:2,143:2,144:2,145:2,182:2,192:2,232:2,262:1,269:1,270:1,272:1,49:1,66:1,69:1,71:1,72:1,75:1,81:1,89:1,90:1,92:1,101:1,102:1,108:1,110:1,112:1,113:1,114:1,115:1,119:1,122:1,123:1,126:1,127:1,129:1,130:1,132:1,133:1,136:1,137:1,141:1,142:1,146:1,151:1,152:1,156:1,162:1,163:1,164:1,165:1,166:1,168:1,171:1,180:1,181:1,186:1,187:1,188:1,189:1,190:1,191:1,195:1,200:1,201:1,214:1,221:1,229:1,234:1,237:1]
----

上記のクエリを変更して、'out()'を'in()'に置き換えると、入り経路の分布を見つけることができる。air route ネットワークでは、航空会社が経路を計画する方法により、常に1対1ので同数の発経路と着経路が存在するとは限らないことを注意してほしい。

クエリに加えることができる他の変更は、各 key : value のペアのキーフィールドを使うように順序を変更し、今回は昇順にソートすることだ。

[source,groovy]
----
g.V().hasLabel('airport').
      groupCount().by(out('route').count()).
      order(local).by(keys,asc)
----

クエリを再実行すると、下記の結果が得られる。このようにソートされたデータを見ると、新しい興味深い事実が見えてくる。我々が気づくことができる最も興味深いことは、現在出経路が全くない空港が16あるということだ。

[source,groovy]
----

[0:16,1:770,2:654,3:369,4:234,5:148,6:116,7:93,8:81,9:68,10:61,11:39,12:43,13:39,14:19,15:31,16:27,17:15,18:18,19:25,20:25,21:12,22:25,23:14,24:9,25:9,26:8,27:8,28:5,29:7,30:13,31:13,32:12,33:15,34:7,35:11,36:8,37:11,38:3,39:9,40:7,41:8,42:8,43:6,44:7,45:5,46:2,47:8,48:6,49:1,50:6,51:3,52:4,53:3,54:4,55:7,56:3,57:2,58:2,59:8,60:3,61:5,62:5,63:7,64:5,65:2,66:1,67:6,68:4,69:1,70:4,71:1,72:1,73:2,74:3,75:1,76:3,77:2,78:2,79:2,80:4,81:1,82:2,83:3,84:3,85:4,86:2,89:1,90:1,91:2,92:1,93:3,94:5,95:2,97:2,98:2,101:1,102:1,104:3,105:5,106:3,107:3,108:1,109:2,110:1,112:1,113:1,114:1,115:1,116:2,118:2,119:1,122:1,123:1,124:2,126:1,127:1,129:1,130:1,132:1,133:1,136:1,137:1,141:1,142:1,143:2,144:2,145:2,146:1,151:1,152:1,156:1,162:1,163:1,164:1,165:1,166:1,168:1,171:1,180:1,181:1,182:2,186:1,187:1,188:1,189:1,190:1,191:1,192:2,195:1,200:1,201:1,214:1,221:1,229:1,232:2,234:1,237:1,262:1,269:1,270:1,272:1]
----

グラフで統計的な平均のルート数を見つけたいのであれば、次のようなクエリを簡単に書いて、グラフ内に空港と発経路の合計数がいくつあるかを知ることができる。

[source,groovy]
----
g.V().hasLabel('airport').union(count(),out('route').count()).fold()

[3374,43400]
----

次に Gremlin コンソールを使って除算を行い、平均を計算する。

[source,groovy]
----
gremlin> 43400/3374

==>12.8630705394
----

しかしながら、 Gremlin には、'mean'ステップもあり、この場合にこれを使う方法を見つけることができれば、使うことができる。次のクエリを見てほしい。ここで注意すべき重要な点は、'local'の使われ方だ。これはGremlin が本質的に上記でもう少し手動で行ったことを実行する。もし、'local'がなかったら、gremlin は基本的に43400/1 を計算するので、答えは出経路のトータルの数となる。local を使うことにより、Gremlin は基本的に各空港ごとの経路の数を含んだ配列を作成し、その値を合計して配列の要素数（空港の数）で除算する。それが理にかなっていると思う。混乱している場合は、クエリをGremlin コンソールで自分で試して、local の有無にかかわらず、'mean'ステップなしで試してみてほしい。代わりにすべての中間値が表示されると思う。

[source,groovy]
----
g.V().hasLabel('airport').local(out('route').count()).mean()

12.863070539419088
----

したがって、グラフには、どの方法で計算するとしても、空港ごとに平均12を超える発経路があるようだ。

これで空港ごとの発経路の数の平均を計算するクエリがわかったので、入り経路と、入り経路、出経路を組み合わせた場合にも同じように簡単に調整できる。

[source,groovy]
----
// Average number of incoming routes
g.V().has('type','airport').local(__.in('route').count()).mean()

12.863070539419088

// Average number of outgoing and incoming routes
g.V().has('type','airport').local(both('route').count()).mean()

25.726141078838175
----

==== ロンドン(UK) の空港からの経路はいくつあるか？

この次のクエリは、英国のロンドンにある（あるいはその近く）と分類された空港ごとに出経路がいくつあるかを見つけるのに使うことができる。最初に'has('region, GB-ENG')'を使って英国にあるすべての空港を見つけていることに注意してほしい。これを行わなかったら、カナダのオンタリオ州ロンドンなど、他の国の空港をピックアップすることになる。

[source,groovy]
----
g.V().has('region','GB-ENG').has('city','London').
      group().by('code').by(out().count())

[LCY:42,LHR:191,LTN:104,STN:186,LGW:200]
----

これは、上記テーマにひねりを加えたものだ。ロンドンから、ロンドンに戻るフライトを除いて2ホップでいくつの場所に行くことができるだろうか。2000以上の場所があることがわかった。'aggregate'を使うと、ロンドンの空港のセットをコレクションとして保存し、後でクエリ中で参照して、ロンドンに戻るフライトを除去するのに役立てることができる点に注意してほしい。

[source,groovy]
----
// Leave from London, fly with one stop, not ending back in London, how many places?
g.V().has('region','GB-ENG').has('city','London').aggregate('lon').
      out().out().dedup().where(without('lon')).count()

2236
----

前のクエリをこのように書いて、'aggregate'を使うのを避けることもできたが、私には、これは不器用で反復的に思える。

[source,groovy]
----
g.V().has('region','GB-ENG').has('city','London').out().out().dedup().
      not(and(has('city','London'),has('region','GB-ENG'))).count()

2236                        
----

[[englandroutes]]
==== UKの空港間にはいくつの経路があるか？

'aggregate'ステップを使って、非常にエレガントにイングランド内の空港間にある経路を見つけることができる。次のクエリはイングランドにあるすべての空港を見つけ、空港コードでソートする。次に、'aggregate'ステップを使ってそれらの空港を集める。最後に集めたコレクションを使って英国内の他の空港への経路を見つける。記述されているように、このクエリは存在すれば双方向の経路を見つけることに注意してほしい。

[source,groovy]
----
// Flights within England
g.V().has('region','GB-ENG').order().by('code').aggregate('a').
      out().where(within('a')).path().by('code')  
----

これは、クエリを実行して見つかった経路だ。スペースを節約するために、結果をカラムに配置した。

[source,groovy]
----
[BHX,NCL]   [LBA,SOU]   [MAN,NQY]   [NQY,ISC]
[BRS,NCL]   [LBA,NQY]   [MAN,NWI]   [NQY,LGW]
[EMA,SOU]   [LCY,MAN]   [MAN,EXT]   [NQY,MAN]
[EXT,MAN]   [LEQ,ISC]   [MAN,LHR]   [NQY,LPL]
[EXT,NQY]   [LGW,NQY]   [MAN,LCY]   [NQY,LBA]
[EXT,ISC]   [LGW,NCL]   [NCL,SOU]   [NWI,MAN]
[HUY,NWI]   [LHR,MAN]   [NCL,BRS]   [NWI,HUY]
[ISC,NQY]   [LHR,LBA]   [NCL,BHX]   [SOU,MAN]
[ISC,EXT]   [LHR,NCL]   [NCL,LHR]   [SOU,EMA]
[ISC,LEQ]   [LPL,NQY]   [NCL,LGW]   [SOU,LBA]
[LBA,LHR]   [MAN,SOU]   [NQY,EXT]   [SOU,NCL]
----

これは、このクエリを書く別の方法だ。今回は、'where'ステップを使って前に表示された空港のペアを除外し、片方向の経路のみを取得する。

[source,groovy]
----
g.V().has('region','GB-ENG').order().by('code').as('a').
      out().has('region','GB-ENG').as('b').
      where('a',lt('b')).by('code').
      path().by('code')
----

御覧のとおり、今回は、経路の方向に関わらず、各空港のペアが1回だけ取得される。

[source,groovy]
----
[BHX,NCL]   [LBA,NQY]
[BRS,NCL]   [LCY,MAN]
[EMA,SOU]   [LGW,NQY]
[EXT,MAN]   [LGW,NCL]
[EXT,NQY]   [LHR,MAN]
[EXT,ISC]   [LHR,NCL]
[HUY,NWI]   [LPL,NQY]
[ISC,NQY]   [MAN,SOU]
[ISC,LEQ]   [MAN,NQY]
[LBA,LHR]   [MAN,NWI]
[LBA,SOU]   [NCL,SOU]
----

[[topten]]
==== 経路数で上位10件の空港はどこ？

以前、どの空港に最も多くの経路があるかを計算した。これらの次の3つのクエリは似たような性質ではあるが、着経路、発経路、全経路の観点で、上位10件の空港のテーブルを生成する。前述したように、一部の航空会社のフライトのルーティング方法により、空港への発経路と着経路の数が常に同じとは限らない。例えば、KLMエアラインのアムステルダムからアフリカへのフライトの中には、アムステルダムに戻る前に、続けて他のアフリカの空港へ飛ぶものがある。結果として、それらの空港への入り経路の方がその空港からの出経路よりも多い。下記の各例では、'project'ステップを使って読みやすい形式で結果を生成している。

まず、このクエリは最も着経路がある10件の空港を見つけ、降順でソートする。

[source,groovy]
----
// Find the top ten overall in terms of incoming routes
g.V().hasLabel('airport').
      order().by(__.in('route').count(),desc).limit(10).
      project('ap','routes').by('code').by(__.in('route').count())
----

したがって、フランクフルトとアムステルダムは最も多くの着経路で結ばれているようだ。本書の例で使われているグラフのバージョンある瞬間を表していることは覚えておく価値がある。これらのクエリを後日新しいバージョンのグラフで再実行すると、結果は全く異なる可能性がある。これは、航空会社は定期的に航空路を追加し、場合によっては廃止するからだ。

[source,groovy]
----
[ap:FRA,routes:272]
[ap:AMS,routes:272]
[ap:IST,routes:270]
[ap:CDG,routes:262]
[ap:MUC,routes:237]
[ap:PEK,routes:235]
[ap:ATL,routes:232]
[ap:ORD,routes:232]
[ap:DXB,routes:229]
[ap:DFW,routes:221]
----

それでは、同じことを発経路に対して実行しよう。

[source,groovy]
----
// Find the top ten overall in terms of outgoing routes
g.V().hasLabel('airport').
      order().by(out('route').count(),desc).limit(10).
      project('ap','routes').by('code').by(out('route').count())
----

今回は、フランクフルトが最も多くの経路がある。これは、私が以前に指摘したことを補強する。特定の空港の着経路と発経路の数は常に同じとは限らない。これは空港会社がフライトをルーティングする方法が原因だ。一部のフライトは、戻る前に別の目的地に向かうので、2つの空港のペア間で両方向の直行便が常にあるとは限らない。私は乗客として、これがイライラするものであることを知っている。

[source,groovy]
----
[ap:FRA,routes:272]
[ap:IST,routes:270]
[ap:AMS,routes:269]
[ap:CDG,routes:262]
[ap:MUC,routes:237]
[ap:PEK,routes:234]
[ap:ATL,routes:232]
[ap:ORD,routes:232]
[ap:DXB,routes:229]
[ap:DFW,routes:221]
----

最後に、着経路と発経路の総数でソートされた上位10件の空港を見つけよう

[source,groovy]
----
// Find the top ten overall in terms of total routes
g.V().hasLabel('airport').
      order().by(both('route').count(),desc).limit(10).
      project('ap','routes').by('code').by(both('route').count())
----

予想通り、フランクフルトが全経路が最も多い空港だ。空港会社の経路についてのちょっとした注意点をば。グラフでは、経路が運航される頻度は追跡していない。これが意味するところは、最も経路が多い空港が必ずしも一番混雑しているわけではない、ということだ。これは、多くの経路が1日に複数回運航されているからだ。私は、このデータは、頻繁に変更されるため、これをグラフに含めようとはしなかった。

[source,groovy]
----
[ap:FRA,routes:544]
[ap:AMS,routes:541]
[ap:IST,routes:540]
[ap:CDG,routes:524]
[ap:MUC,routes:474]
[ap:PEK,routes:469]
[ap:ATL,routes:464]
[ap:ORD,routes:464]
[ap:DXB,routes:458]
[ap:DFW,routes:442]
----

[[localfold]]
==== モノを数えながら local を使う

以前のセクションのいくつかで、'local'スコープが使われている例を見た。これは、望む結果を得るために数を数えながら'local'スコープを使う別の例だ。

下記のクエリを見ていただきたい。これは、6本以上の滑走路を持つ空港を見つけ、次に、その空港が持つ滑走路の数と一緒に空港のIATAコードを返す。

[source,groovy]
----
g.V().has('airport','runways',gte(6)).values('code','runways').fold()
----

これが、クエリを実行して得られる出力である。ご覧のとおり、返されたものは、空港コードとそのあとに滑走路数が続くリストである。

[source,groovy]
----
[BOS,6,DFW,7,ORD,8,DEN,6,DTW,6,AMS,6]
----

前のクエリによって返された出力は悪くないが、返されるものがそれぞれ独自のリストにあるコードと滑走路のペアのセットだとよいだろう。この結果は、クエリの中間結果、あるいは'local'の結果に'fold'ステップを適用することにより得ることができる。

下記のクエリの変更されたものを見ていただきたい。クエリの一部が'local'ステップの内側にラップされるようになった。

[source,groovy]
----
g.V().has('airport','runways',gte(6)).local(values('code','runways').fold())
----

これは、変更された形式のクエリを実行して得られる出力だ。各空港コードと滑走路の値のペアは個別のリストに内包されるようになった。

[source,groovy]
----
[BOS,6]
[DFW,7]
[ORD,8]
[DEN,6]
[DTW,6]
[AMS,6]
----

[[noedges]]
==== エッジのない頂点はいくつあるか？

航空路のグラフでは、発エッジのない頂点、着エッジがない頂点、南極大陸の頂点などのようなどちらもない頂点がいくつかある。いくつかの簡単なクエリを使うと、各タイプがいくつ存在するかをカウントすることができる。

[source,groovy]
----
// Vertices with no outgoing edges.
g.V().not(outE()).count()

23

// Vertices with no incoming edges.
g.V().not(inE()).count()

245

// Vertices with no edges.
g.V().not(bothE()).count()

7
----

上記のクエリは、下記に示すように、'where'ステップを使って作成することもできるクエリを書くための優れた簡単な方法を提供する。

[source,groovy]
----
g.V().where(outE().count().is(0)).count()

23
----

[[wherefly]]
=== ここからどこへ飛ぶことはできるか？

このセクションでは、「ここからどこへ飛ぶことができるか？」という一文に沿って、様々な質問を調査するクエリのいくつかの例をさらに照会する。

[[doesanyrouteexist]]
==== 2つの空港間に経路はあるか？

下記のようなクエリを使って2つの空港間での最短ルート（ホップ単位）を発見するための様々な方法をすでに見てきた。このクエリは、オースティン(AUS) とカナダのオンタリオ州ピーアナック市の間の単一の経路を探す。たまたま、ピーアナックは air-routes グラフ全体で、オースティンから行くのが最も難しい場所の1つだ。実際、そこへ行くには、途中で6回の経由地を経る必要がある。そのことを念頭において、下記のクエリは、考えられるすべての経路を分析するために行うべき処理が非常に多いので、メモリが不足したり、単一の経路を見つけようとしてタイムアウトしたりする可能性がある。

[source,groovy]
----
g.V().has('code','AUS').
      repeat(out().simplePath()).
        until(has('code','YPO')).
      limit(1).
      path().by('code')
----

このような場合、経路が存在するかどうかがわかり、実際に非常に効率的に実行される、わずかに異なるアプローチをとることができる。このクエリは、複数の経路を見つけることができないが、「ルートがあるか？」という質問に答えようとする際には、とても役に立つ点に注意してほしい。

[source,groovy]
----
g.V().has('code','AUS').
      repeat(out().dedup()).
        until(has('code','YPO')).
      path().by('code')

[AUS,YYZ,YTS,YMO,YFA,ZKE,YAT,YPO]
----

2つのクエリの違いは、'dedup'ステップが追加されていることだ。これにより、経路の途中にある空港には、どのように到着したかにかかわらず一度だけ訪問することができる。これは、 トラバーサル中にループバックしないようにする'simplePath'ステップとは異なるが、別のパスを使ってそこに到達する限り、同じ空港に複数回アクセスできるようになる。たとえ、特定の経由地を明示的に回避することにより経路を見つけるタスクを困難にしたとしても、'dedup'ステップが使われているので、実行は非常に効率的だ。

[source,groovy]
----
g.V().has('code','AUS').
      repeat(out().has('code',without('YYZ')).dedup()).
        until(has('code','YPO')).
      path().by('code')

[AUS,BOS,YTZ,YTS,YMO,YFA,ZKE,YAT,YPO]
----

このトリックはグラフ内のルート（あるいはパス）がペアの頂点間のグループに存在するかどうかを見つけようとする場合にのみ役に立つことを頭にとどめておいてほしい。複数の経路を見つけるのには使うことはできないが、それでも知っておくと非常に役に立つパターンである。この手法のバリエーションが、"<<longestroutes>>" のセクションで再度使われる。

[[uscatoindia]]
==== USA あるいはカナダのどこにインドのどの空港からも飛べるか？

この最初のクエリはインドの任意の空港から米国、あるいはカナダへの経路を見つける。

[source,groovy]
----
// Where in the USA or Canada can I fly to from any airport in India?
g.V().has('country','code','IN').out().out().
      has('country',within('US','CA')).path().by('code')
----

これは、このクエリを実行した結果である。'path'ステップを使ったので、インドの国コードである "IN" が出力に含まれている点に注意してほしい。

[source,groovy]
----
[IN,DEL,IAD]
[IN,DEL,JFK]
[IN,DEL,ORD]
[IN,DEL,SFO]
[IN,DEL,EWR]
[IN,DEL,YYZ]
[IN,DEL,YVR]
[IN,BOM,EWR]
[IN,BOM,YYZ]
----

[[flleurope]]
==== ヨーロッパのどの都市に、フロリダの Ft.Lauderdale から飛ぶことができるか？

このクエリは、フロリダのフォートローダーデールからヨーロッパの都市への経路をは見つける。

[source,groovy]
----
// Where can I fly to in Europe from Ft. Lauderdale?
g.V().has('code','FLL').out().as('a').in('contains').
      has('code','EU').select('a').values('city')
----

これが、クエリを実行した結果だ。

[source,groovy]
----
London
Paris
Oslo
Stockholm
Copenhagen
----

[[clteusa]]
==== シャーロットからヨーロッパや南米の都市へはどこへ飛べるか？

このクエリは、ノースカロライナ州のシャーロットからヨーロッパ、あるいは南米の都市への経路を見つける。

[source,groovy]
----
// Flights from Charlotte to airports in Europe or South America
g.V().has('code','CLT').out().as('a').in('contains').
      has('code',within('EU','SA')).select('a').by('code')
----

これが、クエリを実行した結果だ。

[source,groovy]
----
LHR     FCO
CDG     MAD
FRA     MUC
GIG     DUB
GRU
----

[[usalon]]
==== USのどこからロンドンの空港に飛ぶことができますか？

このクエリは英国のロンドンエリアにある5つの空港のいづれかから最終的に米国に到着する経路を見つける。

[source,groovy]
----
// Where in the United States can I fly to non-stop from any of the
// airports in and around London in the UK?
g.V().has('airport','code',within('LHR','LCY','LGW','LTN','STN')).
      out().has('country','US').path().by('code')
----

これが、クエリを実行した結果だ。

[source,groovy]
----
[LHR,AUS]      [LHR,SEA]      [LHR,EWR]         
[LHR,ATL]      [LHR,RDU]      [LHR,DEN]         
[LHR,BWI]      [LHR,SJC]      [LHR,DTW]        
[LHR,BOS]      [LHR,SFO]      [LHR,PHL]        
[LHR,IAD]      [LHR,LAX]      [LGW,SFO]        
[LHR,DFW]      [LHR,JFK]      [LGW,LAS]        
[LHR,MSP]      [LHR,IAH]      [LGW,TPA]        
[LHR,MIA]      [LHR,LAS]      [LGW,FLL]        
[LHR,PHX]      [LHR,CLT]      [LGW,MCO]        
[LHR,ORD]      [LHR,SAN]      [LGW,JFK]        
----

[[txny]]
==== テキサス州にある空港からニューヨーク州のどこに飛ぶことができるか？

このクエリはテキサス州にある任意の空港からニューヨーク州の空港のいずれかに到着するすべての経路を見つける。

[source,groovy]
----
// Where in New York state can I fly to from any airport in Texas?
g.V().has('airport','region','US-TX').out().has('region','US-NY').path().by('code')
----

これが、クエリを実行した結果だ。

[source,groovy]
----
[AUS,JFK]      [IAH,EWR]
[AUS,EWR]      [SAT,EWR]
[DFW,EWR]      [SAT,JFK]
[DFW,JFK]      [HOU,JFK]
[DFW,LGA]      [HOU,LGA]
[IAH,JFK]      [HOU,EWR]
[IAH,LGA]     
----

[[denmex]]
==== デンバーからメキシコのどこの都市へ飛ぶことができるか？

このクエリは、デンバーからメキシコの任意の場所への経路を見つける。

[source,groovy]
----
// Where in Mexico can I fly to from Denver?
g.V().has('code','DEN').out().has('country','MX').values('city')
----

これが、クエリを実行した結果だ。

[source,groovy]
----
Puerto Vallarta
San Josa del Cabo
Cozumel
Mexico City
Cancun
----

[[deleu]]
==== インドのデリーからヨーロッパのどの都市へ飛べるか？

このクエリは、ヨーロッパの任意の空港に向かうデリーからの経路を見つける。

[source,groovy]
----
// Where in Europe can I fly to from Delhi?
g.V().has('code','DEL').out().as('a').in("contains").
      has('code','EU').select('a').by('city')
----

これが、クエリを実行した結果だ。

[source,groovy]
----
London
Paris
Frankfurt
Helsinki
Rome
Amsterdam
Madrid
Vienna
Zurich
Brussels
Munich
Stockholm
Moscow
Milan
Istanbul
Copenhagen
Birmingham
----

[[aggrroutes]]
==== ロンドン、ミュンヘン、パリ間のすべての経路を検索せよ

次の例では、ロンドン、ミュンヘン、パリにある空港間のすべての経路を見つける。'aggregate'を使って最初の'within'テストの結果を集めて、2番目の'within'で名前を繰り返す必要のない点に注目してほしい。これにより、集約されたコレクションを参照できる。

[source,groovy]
----
g.V().has('city',within('London','Munich','Paris')).aggregate('a').out().
      where(within('a')).path().by('code')
----

これが、クエリから返されたものだ。スペースを節約するために、カラムにレイアウトした。

[source,groovy]
----
[LHR,MUC]   [CDG,LHR]   [MUC,STN]   [STN,MUC]                              
[LHR,ORY]   [CDG,LGW]   [MUC,LHR]   [ORY,LCY]                              
[LHR,CDG]   [CDG,MUC]   [MUC,LGW]   [ORY,MUC]                              
[LGW,MUC]   [CDG,LCY]   [MUC,CDG]   [ORY,LHR]                              
[LGW,CDG]   [MUC,LTN]   [LCY,CDG]   [LTN,CDG]                              
[CDG,LTN]   [MUC,ORY]   [LCY,ORY]   [LTN,MUC]                              
----

[[moredist]]
=== 空港間の距離のさらなる分析

本セクションでは、空港間の距離を調べるクエリがいくつかある。下記のクエリは、オースティン(AUS) からのすべてのルートとその距離のリストを返す。結果は距離で昇順にソートされる。

[source,groovy]
----
// Distances of all routes from AUS along with destination IATA CODE
g.V().has('code','AUS').outE().order().by('dist',asc).
      inV().path().by('code').by('dist')
----

これが、クエリを実行した結果だ。読みやすくするために、結果を4列に分けた。

[source,groovy]
----
[AUS,142,IAH]      [AUS,755,GDL]       [AUS,1080,LAS]       [AUS,1430,PHL]  
[AUS,152,HOU]      [AUS,755,BNA]       [AUS,1080,SLC]       [AUS,1476,SJC]  
[AUS,183,DFW]      [AUS,768,DEN]       [AUS,1110,FLL]       [AUS,1493,OAK]  
[AUS,189,DAL]      [AUS,809,ATL]       [AUS,1140,DTW]       [AUS,1500,SFO]  
[AUS,274,HRL]      [AUS,866,PHX]       [AUS,1160,SAN]       [AUS,1500,EWR]  
[AUS,341,LBB]      [AUS,922,CUN]       [AUS,1173,CLE]       [AUS,1520,JFK]  
[AUS,444,MSY]      [AUS,925,TPA]       [AUS,1220,LGB]       [AUS,1690,BOS]  
[AUS,527,ELP]      [AUS,972,MDW]       [AUS,1230,LAX]       [AUS,1712,PDX]  
[AUS,558,MEM]      [AUS,973,ORD]       [AUS,1294,IAD]       [AUS,1768,SEA]  
[AUS,618,ABQ]      [AUS,994,MCO]       [AUS,1313,DCA]       [AUS,4901,LHR]  
[AUS,722,STL]      [AUS,1030,CLT]      [AUS,1339,BWI]       [AUS,5294,FRA]  
[AUS,748,MEX]      [AUS,1040,MSP]      [AUS,1357,YYZ]  
----

このクエリは4,000マイルを超えるDFWからのすべての経路を見つけ、空港コードとその距離を返す。このクエリで、2つの'by'モジュレータを使って、どの値をソース頂点、エッジ、宛先頂点からそれぞれ返される値を判断している点に注目してほしい。また、2つだけが指定されているが、3つの値が返されている点にも注意してほしい。これが機能するのは、'by'モジュレータよりも値が多い場合、'by'がラウンドロビン方式で処理されるからだ。

[source,groovy]
----
// Where can I fly to from DFW that is more than 4,000 miles away?
g.V().has('code','DFW').outE('route').has('dist',gt(4000)).inV().
                        path().by('code').by('dist')
----

これが、クエリを実行した結果だ。

[source,groovy]
----
[DFW,8105,HKG]   [DFW,8022,DXB]
[DFW,6951,PEK]   [DFW,6822,ICN]
[DFW,7332,PVG]   [DFW,5228,GIG]
[DFW,4905,AMS]   [DFW,5119,GRU]
[DFW,4950,MAD]   [DFW,5299,EZE]
[DFW,4736,LHR]   [DFW,4884,SCL]
[DFW,4933,CDG]   [DFW,7914,DOH]
[DFW,5127,FRA]   [DFW,8053,AUH]
[DFW,6410,NRT]   [DFW,5015,DUS]
[DFW,8574,SYD]   [DFW,5597,FCO]
----

前の結果は、何もソートされていない。結果は距離で降順にソートされるように'order'ステップを含めるようにクエリを修正するとよい。

[source,groovy]
----
g.V().has('code','DFW').outE('route').has('dist',gt(4000)).
      order().by('dist',desc).inV().
      path().by('code').by('dist')
----

これが、今ソートした結果である。

[source,groovy]
----
[DFW,8574,SYD]    [DFW,5299,EZE]
[DFW,8105,HKG]    [DFW,5228,GIG]
[DFW,8053,AUH]    [DFW,5127,FRA]
[DFW,8022,DXB]    [DFW,5119,GRU]
[DFW,7914,DOH]    [DFW,5015,DUS]
[DFW,7332,PVG]    [DFW,4950,MAD]
[DFW,6951,PEK]    [DFW,4933,CDG]
[DFW,6822,ICN]    [DFW,4905,AMS]
[DFW,6410,NRT]    [DFW,4884,SCL]
[DFW,5597,FCO]    [DFW,4736,LHR]
----

この次のクエリでも、4,000マイルを超えるすべての経路を見つけるが、今回がロンドンのガトウィック空港から出発している。エッジの距離を照会するために'where'を使っている点にも注意してほしい。'has'形式はより単純だが、私は、それを実行できる別の方法を示すためだけに'where'が使われていることに注意してほしい。返される値の各々が、それぞれの頂点とエッジの異なるプロパティからのものなので、このクエリは、3つの'by'モジュレータを使っていることに注意してほしい。

[source,groovy]
----
// Routes longer than 4,000 miles starting at LGW
g.V().has('code','LGW').outE().where(values('dist').is(gt(4000L))).
      inV().path().by('code').by('dist').by('city')
----

これが、クエリを実行した結果だ。

[source,groovy]
----
[LGW, 5287, MalT]              [LGW, 4380, Calgary]         
[LGW, 4618, Varadero]          [LGW, 5987, Cape Town]       
[LGW, 5147, Tianjin]           [LGW, 4680, Kingston]        
[LGW, 5303, Chongqing]         [LGW, 4953, Cancun]          
[LGW, 4410, Ft. Lauderdale]    [LGW, 5399, Colombo]         
[LGW, 5463, Los Angeles]       [LGW, 4197, Bridgetown]      
[LGW, 4341, Orlando]           [LGW, 4076, St. George]      
[LGW, 5374, San Francisco]     [LGW, 4408, Port of Spain]   
[LGW, 4416, Tampa]             [LGW, 4699, Montego Bay]     
[LGW, 5236, Las Vegas]         [LGW, 4283, Punta Cana]      
[LGW, 5364, Oakland]           [LGW, 5419, San Jose]        
[LGW, 4731, Vancouver]         [LGW, 4662, Havana]          
[LGW, 5982, Hong Kong]         [LGW, 6053, Port Louis]      
[LGW, 5070, Beijing]           [LGW, 4222, Vieux Fort]      
----

この次のクエリは前のと似ている。4,500 マイルを超える DFWからの経路を探す。しかしながら、このクエリには注目に値するいくつかの違いがある。まず、推奨される'has'手法を再び使って、距離をテストするが、前のクエリでは'where'を使った。また、今回は、距離と目的地の空港のコードをリストし、'sort'を使って最終結果をソートする。また、おそらくより簡潔な'path'と'by'ではなく'select'と'as'を使って効率的に同じ結果が得られる異なる方法を示す。'path'と'by'の組み合わせは、最近TinkerPop に導入された。ほとんどの場合、より便利な構文であることがわかったが、どちらの方法でも機能し、どちらにも利点がある。ここで'sort'を使っているのは、結果を並べ替える異なる方法を示すためだが、ほとんどの場合、クエリを'order'を使うように書き直すとよい。この'sort'を使うには、Groovy クロージャを使う必要がある。これはクロージャを許可しない商用のグラフデータベースを使う場合は機能しないかもしれない。'order'を使ったいくつかの例は、本書を通していくつかある。'order'ステップは"<<sort>>" のセクションで紹介されている。可能な限り、純粋な Gremlin の構文を使ってクロージャは避けることをお勧めする。

[source,groovy]
----
// Routes from DFW that are over 4,500 miles in length.
// Sorted into ascending order

g.V().hasLabel('airport').has('code','DFW').outE().has('dist',gt(4500)).as('e').
      inV().as('c').select('e','c').by('dist').by('code').sort(){it.e}
----

一般的に、'select'と'as'ではなく、'path'を使うほうがきれいだと思う。しかしながら、"<<pathwarn>>" というセクションで説明したように、'path'にはより複雑なクエリで遭遇する可能性が高いメモリを消費するという問題があるので、Gremlin クエリの方法で書くという選択肢をもつことは常によいことだ。これは、このクエリにより生成された出力だ。

[source,groovy]
----
[e:4736, c:LHR]     [e:5597, c:FCO]
[e:4884, c:SCL]     [e:6410, c:NRT]
[e:4905, c:AMS]     [e:6822, c:ICN]
[e:4933, c:CDG]     [e:6951, c:PEK]
[e:4950, c:MAD]     [e:7332, c:PVG]
[e:5015, c:DUS]     [e:7914, c:DOH]
[e:5119, c:GRU]     [e:8022, c:DXB]
[e:5127, c:FRA]     [e:8053, c:AUH]
[e:5228, c:GIG]     [e:8105, c:HKG]
[e:5299, c:EZE]     [e:8574, c:SYD]
----

完全を期すために、これは、後処理ステップとしてクエリの最後に'sort'を呼ぶ出すのではなく'order'ステップを使うように書き直されたクエリである。通常、これはソートされた結果を得るための推奨される方法だ。

[source,groovy]
----
g.V().hasLabel('airport').has('code','DFW').outE().has('dist',gt(4500)).
      order().by('dist').as('e').inV().as('c').
      select('e','c').by('dist').by('code')
----

結果は'select'ステップを使って集められる前にソートされていることに注意してほしい。これは修正したクエリを実行して得られる出力である。

[source,groovy]
----
[e:4736,c:LHR]     [e:5597,c:FCO]
[e:4884,c:SCL]     [e:6410,c:NRT]
[e:4905,c:AMS]     [e:6822,c:ICN]
[e:4933,c:CDG]     [e:6951,c:PEK]
[e:4950,c:MAD]     [e:7332,c:PVG]
[e:5015,c:DUS]     [e:7914,c:DOH]
[e:5119,c:GRU]     [e:8022,c:DXB]
[e:5127,c:FRA]     [e:8053,c:AUH]
[e:5228,c:GIG]     [e:8105,c:HKG]
[e:5299,c:EZE]     [e:8574,c:SYD]
----

クエリは、下記のように、'select'ステップの後に'order'ステップを使って書くこともできる。

[source,groovy]
----
g.V().hasLabel('airport').has('code','DFW').outE().has('dist',gt(4500)).as('e').
inV().as('c').select('e','c').by('dist').by('code').order().by(select('e') 
----

[[gt8k]]
==== 8,000 マイルより長い経路を見つけよ

この次の一連のクエリは8,000マイルを超えるすべての経路を見つけて表示する様々な方法を示す。各クエリは、いくつかの機能を追加したり、クエリを簡略化するステップを追加することにより、前のクエリを改善する。まず、8,000マイルを超えるすべての経路を見つけよう、これには、空港のペア間の両方向の経路が含まれている。

[source,groovy]
----
// All routes longer than 8,000 miles
g.V().as('src').outE('route').
      has('dist',gt(8000)).inV().as('dest').
      select('src','dest').by('code')
----

これが、クエリが生成したものだ。前のと同様、読みやすくするために出力をカラムに分けた。

[source,groovy]
----
[src:ATL,dest:JNB]    [src:DXB,dest:IAH]  
[src:DFW,dest:SYD]    [src:DXB,dest:LAX]  
[src:DFW,dest:DXB]    [src:DXB,dest:SFO]  
[src:DFW,dest:HKG]    [src:DXB,dest:AKL]  
[src:DFW,dest:AUH]    [src:HKG,dest:DFW]  
[src:IAH,dest:DXB]    [src:HKG,dest:JFK]  
[src:IAH,dest:DOH]    [src:HKG,dest:EWR]  
[src:JFK,dest:HKG]    [src:AKL,dest:DXB]  
[src:LAX,dest:DOH]    [src:AKL,dest:DOH]  
[src:LAX,dest:AUH]    [src:DOH,dest:IAH]  
[src:LAX,dest:JED]    [src:DOH,dest:LAX]  
[src:LAX,dest:RUH]    [src:DOH,dest:AKL]  
[src:LAX,dest:DXB]    [src:JNB,dest:ATL]  
[src:SFO,dest:SIN]    [src:MEX,dest:CAN]  
[src:SFO,dest:DXB]    [src:AUH,dest:DFW]  
[src:SFO,dest:AUH]    [src:AUH,dest:LAX]  
[src:EWR,dest:HKG]    [src:AUH,dest:SFO]  
[src:SYD,dest:DFW]    [src:JED,dest:LAX]  
[src:SIN,dest:SFO]    [src:RUH,dest:LAX]  
[src:DXB,dest:DFW]    [src:CAN,dest:MEX]  
----

次に、クエリ結果にある各経路の距離を含めるようにクエリを改善しよう。

[source,groovy]
----
// Find routes longer than 8,000 miles.
// Include the distance in returned values.
g.V().as('src').
      outE().has('dist',gt(8000)).as('e').
      inV().as('dest').
      select('src','e','dest').by('code').by('dist')
----

これは、空港間の距離を表示する、変更した出力である。

[source,groovy]
----
[src:ATL,e:8434,dest:JNB]     [src:DXB,e:8150,dest:IAH]
[src:DFW,e:8574,dest:SYD]     [src:DXB,e:8321,dest:LAX]
[src:DFW,e:8022,dest:DXB]     [src:DXB,e:8085,dest:SFO]
[src:DFW,e:8105,dest:HKG]     [src:DXB,e:8818,dest:AKL]
[src:DFW,e:8053,dest:AUH]     [src:HKG,e:8105,dest:DFW]
[src:IAH,e:8150,dest:DXB]     [src:HKG,e:8054,dest:JFK]
[src:IAH,e:8030,dest:DOH]     [src:HKG,e:8047,dest:EWR]
[src:JFK,e:8054,dest:HKG]     [src:AKL,e:8818,dest:DXB]
[src:LAX,e:8287,dest:DOH]     [src:AKL,e:9025,dest:DOH]
[src:LAX,e:8372,dest:AUH]     [src:DOH,e:8030,dest:IAH]
[src:LAX,e:8314,dest:JED]     [src:DOH,e:8287,dest:LAX]
[src:LAX,e:8246,dest:RUH]     [src:DOH,e:9025,dest:AKL]
[src:LAX,e:8321,dest:DXB]     [src:JNB,e:8434,dest:ATL]
[src:SFO,e:8433,dest:SIN]     [src:MEX,e:8754,dest:CAN]
[src:SFO,e:8085,dest:DXB]     [src:AUH,e:8053,dest:DFW]
[src:SFO,e:8139,dest:AUH]     [src:AUH,e:8372,dest:LAX]
[src:EWR,e:8047,dest:HKG]     [src:AUH,e:8139,dest:SFO]
[src:SYD,e:8574,dest:DFW]     [src:JED,e:8314,dest:LAX]
[src:SIN,e:8433,dest:SFO]     [src:RUH,e:8246,dest:LAX]
[src:DXB,e:8022,dest:DFW]     [src:CAN,e:8754,dest:MEX]
----

次に、少し簡略化しよう。'as'と'select'を使えば、やるべきことは終わるが、'path'と'by'を使うと、クエリが短くなり、読みやすくなる。前のと同様、'path'を使うと大量のメモリを消費する場合があるという警告を思い出してほしい。これは、かなり簡単なクエリを書いているので、問題にはならないはずだ。

[source,groovy]
----
// Note that this also changes the way the result is returned
g.V().outE().has('dist',gt(8000)).
       inV().path().by('code').by('dist')
----

実際、出力は読みやすくなった。

[source,groovy]
----
[ATL,8434,JNB]   [LAX,8314,JED]   [DXB,8150,IAH]   [DOH,8287,LAX] 
[DFW,8574,SYD]   [LAX,8246,RUH]   [DXB,8321,LAX]   [DOH,9025,AKL] 
[DFW,8022,DXB]   [LAX,8321,DXB]   [DXB,8085,SFO]   [JNB,8434,ATL] 
[DFW,8105,HKG]   [SFO,8433,SIN]   [DXB,8818,AKL]   [MEX,8754,CAN] 
[DFW,8053,AUH]   [SFO,8085,DXB]   [HKG,8105,DFW]   [AUH,8053,DFW] 
[IAH,8150,DXB]   [SFO,8139,AUH]   [HKG,8054,JFK]   [AUH,8372,LAX] 
[IAH,8030,DOH]   [EWR,8047,HKG]   [HKG,8047,EWR]   [AUH,8139,SFO] 
[JFK,8054,HKG]   [SYD,8574,DFW]   [AKL,8818,DXB]   [JED,8314,LAX] 
[LAX,8287,DOH]   [SIN,8433,SFO]   [AKL,9025,DOH]   [RUH,8246,LAX] 
[LAX,8372,AUH]   [DXB,8022,DFW]   [DOH,8030,IAH]   [CAN,8754,MEX] 
                                  
----

クエリはかなり見栄えがするが、同じ経路ペアを2回出力しないようになると便利だ。言い換えると、2つの空港間の1方向の距離だけが本当に求めているものだ。これは無視したい経路を除外する方法を見つける必要があるので、少し複雑さが増す。これを行う1つの方法は、発空港のコードが着空港のコードよりも小さいことを確認してそれを除外することだ。これは少し奇妙に思えるかもしれないが、要するに、まだアクセスしていない経路のペアだけが欲しい、ということだ。ATLとJNBの間の経路の場合について考えてみよう。未満 ('lt') のテストはATLとJNB間の経路は許すので機能するが、（ATLはアルファベットでJNBより早いので）JNBとATL間の経路は除外される。これは、不要な結果を除外する多くの状況でとても役に立つ便利な手法だ。それでは、クエリを下記の示すようにこのフィルタを適用するように修正してみよう。

[source,groovy]
----
// We could avoid returning both directions of 
// travel by refining our query as follows.
g.V().as('a').outE().has('dist',gt(8000)).
      inV().as('b'). 
      filter(select('a','b').by('code').where('a', lt('b'))).
      path().by('code').by('dist')
----

これは、修正したクエリを実行して得られる出力である。御覧の通り、ATLからJNBへの経路はまだ表示されているが、JNBからATLの逆の経路はもはや除外された。同じことが他の帰りの旅程にも当てはまる。

[source,groovy]
----
[ATL,8434,JNB]     [HKG,8054,JFK]
[DFW,8574,SYD]     [AKL,8818,DXB]
[DFW,8022,DXB]     [AKL,9025,DOH]
[DFW,8105,HKG]     [DOH,8030,IAH]
[LAX,8246,RUH]     [DOH,8287,LAX]
[SFO,8433,SIN]     [AUH,8053,DFW]
[EWR,8047,HKG]     [AUH,8372,LAX]
[DXB,8150,IAH]     [AUH,8139,SFO]
[DXB,8321,LAX]     [JED,8314,LAX]
[DXB,8085,SFO]     [CAN,8754,MEX]
----

最後に、求めていた経路がそろったので、クエリを微調整して経路が距離の降順でソートされるようにしよう。これを行うには、関心のある経路が見つかった後に'order'ステップを追加するとよい。

[source,groovy]
----
// As above but sorted by route lengths.
g.V().as('a').outE().has('dist',gt(8000)).
      order().by('dist',desc).
      inV().as('b').
      filter(select('a','b').by('code').where('a', lt('b'))).
      path().by('code').by('dist')
----

これが結果だ。今回は経路の距離の降順にソートされている。

[source,groovy]
----
[AKL,9025,DOH]     [LAX,8246,RUH]
[AKL,8818,DXB]     [DXB,8150,IAH]
[CAN,8754,MEX]     [AUH,8139,SFO]
[DFW,8574,SYD]     [DFW,8105,HKG]
[ATL,8434,JNB]     [DXB,8085,SFO]
[SFO,8433,SIN]     [HKG,8054,JFK]
[AUH,8372,LAX]     [AUH,8053,DFW]
[DXB,8321,LAX]     [EWR,8047,HKG]
[JED,8314,LAX]     [DOH,8030,IAH]
[DOH,8287,LAX]     [DFW,8022,DXB]
----

TinkerPop 3.2.3 リリースの一部として、'where'ステップに新機能が追加され、'by'モジュレータを後続できるようになった。これにより、必要に応じて、下記のようにクエリをもう少し単純化できるようになった。

[source,groovy]
----
//Query changed to take advantage of the where().by() construct
g.V().as('s').
      outE().has('dist',gt(8000)).
      order().by('dist',desc).inV().as('f').
      where('f',lt('s')).by('code').
      path().by('code').by('dist')
----

御覧の通り、変更したクエリから同じ結果が得られた。まぁ、ほぼ同じ結果だ。実際に'return routes'が返されたことに注目してほしい。なので、たとえば、前のケースで得られたAKL から DXB への経路ではなく、DXB から AKL への経路が得られた。これは、値を逆の順序で比較したからだ

[source,groovy]
----
[DOH,9025,AKL]     [RUH,8246,LAX]
[DXB,8818,AKL]     [IAH,8150,DXB]
[MEX,8754,CAN]     [SFO,8139,AUH]
[SYD,8574,DFW]     [HKG,8105,DFW]
[JNB,8434,ATL]     [SFO,8085,DXB]
[SIN,8433,SFO]     [JFK,8054,HKG]
[LAX,8372,AUH]     [DFW,8053,AUH]
[LAX,8321,DXB]     [HKG,8047,EWR]
[LAX,8314,JED]     [IAH,8030,DOH]
[LAX,8287,DOH]     [DXB,8022,DFW]
----

興味深い補足として、これは、上記のクエリにも当てはまる。'lt'を'gt'に置き換えると、経路が逆の順序で返される。

[source,groovy]
----
g.V().as('s').
      outE().has('dist',gt(8000)).
      order().by('dist',desc).inV().as('f').
      where('f',gt('s')).by('code').
      path().by('code').by('dist')
----

前のクエリを使うと、最初の結果は、'[DOH, 9025, AKL]'だった。 下記に示すように、最初の結果は、'[AKL, 9025, DOH]'になる。

[source,groovy]
----
[AKL,9025,DOH]     [LAX,8246,RUH]
[AKL,8818,DXB]     [DXB,8150,IAH]
[CAN,8754,MEX]     [AUH,8139,SFO]
[DFW,8574,SYD]     [DFW,8105,HKG]
[ATL,8434,JNB]     [DXB,8085,SFO]
[SFO,8433,SIN]     [HKG,8054,JFK]
[AUH,8372,LAX]     [AUH,8053,DFW]
[DXB,8321,LAX]     [EWR,8047,HKG]
[JED,8314,LAX]     [DOH,8030,IAH]
[DOH,8287,LAX]     [DFW,8022,DXB]
----

==== グラフ内で最長の経路20件を見つける

前のセクションのクエリを、最初にエッジを確認し、'as'と'select'ステップを使う代わりに'project'ステップを使って別の方法で書くことができる。通常、 グラフには、典型的に、頂点よりもエッジの方が多いので、'g.E()'でクエリを開始することはお勧めしないが、これは便利なパターンを示している。また、少し変更すると、8,000マイルを超える経路を探すのではなく、今回は20件の最長経路を見つけるだけだ。結果を再度フィルタリングして、片方向の経路のみを表示する。逆方向で同じ経路が除外されることが分かっているので、limit ステップは20ではなく、40がパラメータとして渡され、実際には20件の経路だけが返される点に注意してほしい。

[source,groovy]
----
g.E().hasLabel('route').
      order().by('dist',desc).limit(40).
      project('a','b','c').
        by(inV().values('code')).
        by('dist').
        by(outV().values('code')).
      filter(select('a','c')).where('a',lt('c'))
----

これが、クエリを実行して得られる結果だ。

[source,groovy]
----
[a:AKL,b:9025,c:DOH]    [a:LAX,b:8246,c:RUH]
[a:AKL,b:8818,c:DXB]    [a:DXB,b:8150,c:IAH]
[a:CAN,b:8754,c:MEX]    [a:AUH,b:8139,c:SFO]
[a:DFW,b:8574,c:SYD]    [a:DFW,b:8105,c:HKG]
[a:ATL,b:8434,c:JNB]    [a:DXB,b:8085,c:SFO]
[a:SFO,b:8433,c:SIN]    [a:HKG,b:8054,c:JFK]
[a:AUH,b:8372,c:LAX]    [a:AUH,b:8053,c:DFW]
[a:DXB,b:8321,c:LAX]    [a:EWR,b:8047,c:HKG]
[a:JED,b:8314,c:LAX]    [a:DOH,b:8030,c:IAH]
[a:DOH,b:8287,c:LAX]    [a:DFW,b:8022,c:DXB]
----

完全を期すために、クエリを少し書き直して、すべての'route'エッジではなく空港頂点で開始するが、前のセクションで使った'path'ステップを使うのではなく、'as'と'select'ステップを使う。'by'モジュレータが後続する'where'ステップは、まだここでは使われいている。なので繰り返しになるが、探している結果を得る方法は数多くあることは明らかだ。重要なのは、扱っているデータに対してどの形式のクエリが最も効果的かを考えることだ。 

[source,groovy]
----
g.V().hasLabel('airport').as('a').
      outE().as('b').
      order().by('dist',desc).limit(40).
      inV().as('c').
      where('a',lt('c')).by('code').
      select('a','b','c').by('code').by('dist')
----

クエリを実行すると、結果は前のクエリの結果を同じになる。

[source,groovy]
----
[a:AKL,b:9025,c:DOH]    [a:LAX,b:8246,c:RUH]
[a:AKL,b:8818,c:DXB]    [a:DXB,b:8150,c:IAH]
[a:CAN,b:8754,c:MEX]    [a:AUH,b:8139,c:SFO]
[a:DFW,b:8574,c:SYD]    [a:DFW,b:8105,c:HKG]
[a:ATL,b:8434,c:JNB]    [a:DXB,b:8085,c:SFO]
[a:SFO,b:8433,c:SIN]    [a:HKG,b:8054,c:JFK]
[a:AUH,b:8372,c:LAX]    [a:AUH,b:8053,c:DFW]
[a:DXB,b:8321,c:LAX]    [a:EWR,b:8047,c:HKG]
[a:JED,b:8314,c:LAX]    [a:DOH,b:8030,c:IAH]
[a:DOH,b:8287,c:LAX]    [a:DFW,b:8022,c:DXB]
----

[[longesteach]]
==== 各空港からの最長経路を見つける

次のクエリを使うと、グラフ内の各空港からの最長経路を見つけることができる。2,3 の結果だけが返されるように'limit'ステップを含めたが、これを削除すると、グラフ内のすべての空港がクエリ結果に表示される。local ステップを使うと、各空港ごとにすべての発経路が分析される。これらの経路は降順にソートされていて、いずれの場合も、最初の経路のみが選択される。

[source,groovy]
----
g.V().hasLabel('airport').limit(10).
      local(outE().
            order().by('dist',desc).
            inV().
            path().
              by('code').
              by('dist').
              limit(1))
----

クエリを実行すると、下記の結果が生成される。

[source,groovy]
----
[ATL,8434,JNB]
[ANC,3260,IAH]
[AUS,5294,FRA]
[BNA,1972,SEA]
[BOS,7952,HKG]
[BWI,3622,LHR]
[DCA,2434,SFO]
[DFW,8574,SYD]
[FLL,7808,DXB]
[IAD,7487,DEL]
----


[[aggrunion]]
==== aggregate, union, filter を組み合わせて距離を計算する

この次のクエリは "<<aggrroutes>>"のセクションで見たクエリを似ている。'aggregate'、'union'、'filter'および'where'を使ってクエリの内外で特定の空港を識別する。ロンドン、ミュンヘン、パリにあるすべての空港を見つけ、すべての経路の総距離を'union'の前半としてカウントする。'union'の後半では、選択した3つの都市のいずれかに到着する経路の距離をカウントするのみだ。

[source,groovy]
----
g.V().has('city',within('London','Munich','Paris')).
      aggregate('a').
      outE().
      union(values('dist').sum(),
            filter(inV().where((within('a')))).
              values('dist').sum())
----

これが、クエリを実行した結果だ。期待した通り、最初の数字は、選択した空港からのすべての経路の合計距離なので、2つ目の数字よりもはるかに大きいが、2つ目の数字はそれらの空港間のすべての合計距離が反映されるだけだ。

[source,groovy]
----
2276209
8906
----

==== 距離を分析するさらなるクエリ

2つの直接接続された空港間の距離を計算するのは非常に簡単だ。やるべきことは、両者を接続するエッジの'dist'プロパティを参照することだけだ。'select'と'as'ステップを使うか、あるいはTinkerPop の最新バージョンでは、'path'および'by'を使うことでこれを行うことができる。私は後者の手法を好む。オースティンとメキシコシティ間の距離を見つける下記の例に、両方の方法を示す。

[source,groovy]
----
// Distance between the AUS and MEX airports
g.V().has('code','AUS').outE().as('e').
      inV().has('code','MEX').
      select('e').values('dist')

748
----

上記と同様だが、'path'と'by'を使ったものだ。

[source,groovy]
----
// Distance between the AUS and MEX airports
g.V().has('code','AUS').outE().
      inV().has('code','MEX').
      path().by('code').by('dist')

[AUS, 748, MEX]
----

空港間の距離に基づくクエリがさらにいくつかある。最初のクエリは100～200マイルの間にある経路の数を計算する。演習として'count'の呼び出しを削除すると、クエリは経路をリストアップする。ご覧のとおり、たくさんあるのだ。

[source,groovy]
----
// Routes Between 100 and 200 miles in length 
g.V().outE().has('dist',within(100..200)).
      inV().
      path().by('code').by('dist').
      count()

3029
----

次のクエリは前のと似ているが、米国にある空港間の経路のみをカウントする。前と同様、'count'の呼び出しを削除すると、経路が返される。

[source,groovy]
----
// Routes Between 100 and 200 miles in length, but only within the US.
g.V().has('airport','country','US').
      outE().has('dist',within(100..200)).
      inV().has('country','US').
      path().by('code').by('dist').
      count()

583 
----

最後に、このクエリはサンアントニオからのすべての経路とその距離のリストを返す。結果の一部を示す。

[source,groovy]
----
// Return a list of routes and their distances,
// starting from San Antonio (SAT)

g.V().has('code','SAT').
  outE('route').inV().
  path().by('code').by('dist')
----

これが、クエリが返した結果のほんの一部を示す。

[source,groovy]
----
[SAT,872,ATL]      [SAT,1140,MIA]   
[SAT,820,BNA]      [SAT,698,MEX]    
[SAT,1410,BWI]     [SAT,1097,MSP]   
[SAT,248,DFW]      [SAT,1093,CLT]   
[SAT,1360,IAD]     [SAT,1040,ORD]   
[SAT,190,IAH]      [SAT,931,CUN]    
[SAT,1580,JFK]     [SAT,841,PHX]    
[SAT,1210,LAX]     [SAT,624,MEM]    
[SAT,1038,MCO]     [SAT,1772,SEA]   
[SAT,1423,YYZ]     [SAT,707,MCI]
----

[[AUSLHR-OS]]
==== AUSからLHRまで経由1回でどれぐらいの距離か？

次のクエリは、「AUS  から LHR まで経由1回でどれぐらいの距離か？」という質問に対峙し始める。Gremlin について現時点で分かっていることを踏まえると、AUSとLHR間に1回の経由地とそれぞれの経路の距離ですべての可能な選択肢を表示するクエリを非常に簡単に思いつくことができる。

[source,groovy]
----
// Return all ways of getting from AUS to LHR with one stop. 
// Include the distances between each of the airports in the 
// query result.

g.V().has('airport','code','AUS').
      outE().inV().outE().inV().
      has('code','LHR').
      path().by('code').by('dist')
----

クエリを実行した出力は、出発空港、途中の空港、目的地の空港をそれぞれの間の距離をマイル単位で示す優れたデータセットを生成する。それぞれの場合に移動しなければならない合計距離を示す方法を見つけることができれば、それは素晴らしいことだ。それは次のセクションのトピックだ。

[source,groovy]
----
[AUS,1476,SJC,5352,LHR]       [AUS,183,DFW,4736,LHR]    
[AUS,1500,SFO,5350,LHR]       [AUS,1339,BWI,3622,LHR]  
[AUS,1768,SEA,4783,LHR]       [AUS,1500,EWR,3453,LHR]  
[AUS,866,PHX,5255,LHR]        [AUS,1690,BOS,3254,LHR]  
[AUS,973,ORD,3939,LHR]        [AUS,768,DEN,4655,LHR]   
[AUS,1040,MSP,4001,LHR]       [AUS,1080,LAS,5213,LHR]  
[AUS,1230,LAX,5439,LHR]       [AUS,809,ATL,4198,LHR]   
[AUS,1520,JFK,3440,LHR]       [AUS,1160,SAN,5469,LHR]  
[AUS,1140,DTW,3753,LHR]       [AUS,1357,YYZ,3544,LHR]  
[AUS,142,IAH,4820,LHR]        [AUS,5294,FRA,406,LHR]   
[AUS,1430,PHL,3533,LHR]       [AUS,748,MEX,5529,LHR]   
[AUS,1294,IAD,3665,LHR]       [AUS,1030,CLT,3980,LHR]  
----

[[sackauslhr]]
==== sack を使って経由1回で最短の AUS-LHR 経路を計算する

空の旅の典型的なユースケースを考えてみよう。ある空港から別の空港まで経由1回だけで移動するのに必要な最短の距離を計算したいとする。実際の例を見てみよう。AUSからLHRまで経由1回での最短距離の10件はどれぐらいだろう？これまでのところで Gremlin について知っていることを踏まえると、前のセクションでやったように、AUSからLHR まで経由1回だけの経路を取得するクエリをかなり簡単に思いつくことができる。しかしながら、それほど明らかではないこと、これは TinkerPop ドキュメントが少し弱い分野であり、グラフをトラバースする際に値の合計を維持する方法を検討している。ここで'sack'ステップの出番だ。以前のセクションのいくつかから思い出していただきたいのだが、'sack'を使うと、グラフのトラバーサルを進めながら何かを入れておける場所を定義することができる。sack に初期値を指定し、トラバーサル中にそれに加算して、クエリが返す情報の一部としてそれを使うことができる、。下記のかなり長いクエリを見てほしい。読みやすいようにレイアウトしてある。

[source,groovy]
----
// Shortest distances from AUS to LHR with one stop
g.withSack(0).
  V().has('code','AUS').
      outE().
      sack(sum).by('dist').
      inV().
      outE().
      sack(sum).by('dist').
      inV().has('code','LHR').
      sack().
      order().by(asc).limit(10).
      path().
        by('code').
        by('dist').
        by('code').
        by('dist').
        by('code').
        by()
----

クエリの最初の行で、sack を値ゼロで初期化する。クエリの途中、出エッジを取得するたびに、そのエッジの距離の値をsack に加算する。LHR である宛先のみを保持することにより、通常の方法で経路を除外する。気になる経路を見つけたら、sack に保存されている値を取り出し、それを使って結果を昇順にソートする。最後に、たどったパスを処理する。sack の値はパス出力の一部に含まれていて、 パラメータのない'by'モジュレータを使って参照される点に注意してほしい。クエリを実行すると下記の結果が生成される。

[source,groovy]
----
[AUS, 1140, DTW, 3753, LHR, 4893]
[AUS, 1357, YYZ, 3544, LHR, 4901]
[AUS, 973,  ORD, 3939, LHR, 4912]
[AUS, 183,  DFW, 4736, LHR, 4919]
[AUS, 1690, BOS, 3254, LHR, 4944]
[AUS, 1500, EWR, 3453, LHR, 4953]
[AUS, 1294, IAD, 3665, LHR, 4959]
[AUS, 1520, JFK, 3440, LHR, 4960]
[AUS, 1339, BWI, 3622, LHR, 4961]
[AUS, 142,  IAH, 4820, LHR, 4962]    
----

NOTE: TinkerPop 3.3 では、sack の構文が変更された。以前は sack(sum, 'runways') のように書いていたが、今では、sack(sum).by('runways') と書く必要がある。以前の形式は、TinkerPop 3.2.5 ですでに非推奨だったは、TinkerPop 3.3 以降で完全に削除された。

クエリに少し後処理を追加して、空港コードと合計マイル数のみを出力するとよい。これが小さなデータセットの後処理であることを踏まえると、少しのインラインコードを使うことはそれほどひどいとは思わない。

[source,groovy]
----
g.withSack(0).V().
  has('code','AUS').
  outE().
  sack(sum).by('dist').
  inV().
  outE().
  sack(sum).by('dist').
  inV().has('code','LHR').
  sack().
  order().by(asc).limit(10).
  path().
    by('code').
    by('dist').
    by('code').
    by('dist').
    by('code').
    by().
  toList().
  each(){println "${it[0]} --> ${it[2]} --> ${it[4]} ${it[5]} miles"}[];
----

これが、Groovy の後処理が追加された修正したクエリが生成するものだ。

[source,groovy]
----
AUS --> DTW --> LHR 4893 miles
AUS --> YYZ --> LHR 4901 miles
AUS --> ORD --> LHR 4912 miles
AUS --> DFW --> LHR 4919 miles
AUS --> BOS --> LHR 4944 miles
AUS --> EWR --> LHR 4953 miles
AUS --> IAD --> LHR 4959 miles
AUS --> JFK --> LHR 4960 miles
AUS --> BWI --> LHR 4961 miles
AUS --> IAH --> LHR 4962 miles
----

[[anothersack]]
==== sack を使った他の例

下記のクエリは、200を超える経路があるすべての空港を見つけ、それらを空港コードと経路数のペアのマップとして返す。

[source,groovy]
----
// Print a table of airports with more than 200 routes and the number of routes
g.V().hasLabel('airport').
      where(out().count().is(gt(200))).
      group().
        by('code').
        by(outE().count())
----

これが、クエリが生成した結果だ。

[source,groovy]
----
[ORD:226, DFW:216, FRA:254, CDG:253, PEK:232, AMS:257, ATL:232, MUC:219, IST:259, DME:206, DXB:225]
----

前のクエリは、求めている結果を得るには完全によい方法だ。興味本位で、'sack'を使って同じ結果を生成してみよう。これは'sack'がどのように機能するかの例としてのみを意図していて、実際にこの特別なクエリを実行してほしいものではない。とはいっても、sack の中身が単純な整数値よりも複雑な例があると便利だ。クエリの開始時に、sackを空のマップ'[:]'で初期化する。クエリの後半で、200よりも多い出経路がある空港ごとに、空港コードと経路数をマップに追加してマップを更新する。各マップエントリの値の部分はトラバーサルを使って生成されたことに注意してほしい。したがって、このクエリはタスクに対して明らかにやりすぎではあるが（上記に、はるかに単純なクエリで示されているように）クエリを繰り返す際にデータを保存する強力な方法でsack を使う他の例を提供する。 

[source,groovy]
----
// The same query but done using the new sack() step in TinkerPop 3
// shown as an example only. The prior query works just fine for this.

g.withSack([:]).
  V().hasLabel('airport').
  where(out().count().is(gt(200))).
  sack{m,v -> m[v.value('code')]=g.V(v).out().count().next()}.
  fold().sack()
----

これが、新しいクエリが生成した結果だ。結果が異なる順序で返ってきたという事実を除けば、それらは同じだ。

[source,groovy]
----
[ATL:232, DFW:216, ORD:226, CDG:253, FRA:254, DXB:225, PEK:232, AMS:257, MUC:219, DME:206, IST:259]
----

'fold'ステップは上記のクエリで返される結果がマップとして返されるようにするために必要とされる。'fold'をオフのままにすると、sackに格納されている値が整数のリストとして返される。空港のリストは前のクエリと同じではあるが、順番は異なっていることに注意してほしい。これは、'group'ステップが前のクエリで機能した結果だ。順序は決して信頼すべきではないのだ。クエリの結果に特定の順序が必要なのであれば、必要に応じて、常に明示的に'order'ステップを実行することをお勧めする。

完全を期すために、経路数（値）の昇順で元のクエリの結果をソートする方法を下記に示す。

[source,groovy]
----
g.V().hasLabel('airport').
      where(out().count().is(gt(200))).
      group().by('code').by(outE().count()).
      order(local).by(values)

[DME:213,DFW:221,DXB:229,ORD:232,PEK:232,ATL:232,MUC:237,CDG:260,FRA:266,AMS:269,IST:270]
----

空港コードを使ってソートをしたいのであれば、下記のように行うとよい。今回は、'sack'ベースのクエリの結果をソートする。

[source,groovy]
----
g.withSack([:]).
  V().hasLabel('airport').where(out().count().is(gt(200))).
  sack{m,v -> m[v.value('code')]=g.V(v).out().count().next()}.
  fold().
  sack().
  order(local).by(keys)    

[AMS:269,ATL:232,CDG:260,DFW:221,DME:213,DXB:229,FRA:266,IST:270,MUC:237,ORD:232,PEK:232]                
----

'withSack'を使って'sack'を初期化するだけでなく、'assign'演算子を使ってそれを行うこともできる。下記のクエリは定数値 0 を使って sack を初期化し、次に sack を使ってオースティンから飛ぶことができる空港の数あるいは滑走路の数をカウントする。クエリの終わりに、個々の空港の滑走路の数を保持するリストを含むsack に対して'sum'ステップを実行するので、単一の総数を取得するにはそれらをすべて加算する必要がある。

[source,groovy]
----
g.V().has('code','AUS').
      sack(assign).by(constant(0)).
      out().
      sack(sum).by('runways').
      sack().sum()

212
----

[[latlonmanual]]
=== クエリで緯度、経度、地理的地域を使う

'air-routes'グラフは各空港の地理的座標(緯度と経度) を浮動小数点数として格納する。JanusGraph のようなグラフシステムの中には、地理的座標や形状（地理空間）関数が組み込まれているが、TinkerGraph には組み込まれていない。さらに、GraphML は特定の地理空間のサポートが提供されていない。単純さかつ柔軟性を保つために、航空路データセットは特定のバックエンド機能は想定されていない。基本的な浮動小数点数として座標を用意すれば、興味深い地理空間のクエリを作成することができる。

これまでのところ、クエリでこれらの緯度や経度の座標を利用していない。本セクションでは、標準の Gremlin ステップだけを使って興味深い地理空間の計算を実行するいくつかのクエリを含めた。

これは、北緯77度の北にある空港を見つける簡単なクエリだ。この場合は同義語なので、'filter'の代わりに'where'ステップを使うことができることに注意してほしい。

[source,groovy]
----
g.V().filter(values('lat').is(gt(77))).valueMap('city','lat')
----

本書の前半で説明したように、'where'または'filter'ステップの代わりに'has'ステップだけを使うことができる。前のクエリを次のように書くことができる。

[source,groovy]
----
g.V().has('lat',gt(77)).valueMap('city','lat')
----

いずれかの形式のクエリを実行した結果ではグラフの2つの空港だけが、下記に示すようにはるか北に位置していることがわかる。

[source,groovy]
----
[city:[Longyearbyen],lat:[78.2461013793945]]
[city:[Qaanaaq],lat:[77.4886016846]]
----

クエリを修正して指定された上限と下限の外側の緯度の値をもつ空港を見つけ、1つのクエリで最も北と南の空港を見うつけることができる。これはそのようなクエリの簡単な例だ。

[source,groovy]
----
g.V().has('lat',outside(-50,77)).order().by('lat',asc).valueMap('city','lat')
----

これは、クエリを実行して見つかった空港だ。

[source,groovy]
----
[city:[Ushuahia],lat:[-54.8433]]
[city:[Rio Grande],lat:[-53.7777]]
[city:[Punta Arenas],lat:[-53.0026016235352]]
[city:[Mount Pleasant],lat:[-51.8227996826172]]
[city:[Stanley],lat:[-51.6856994628906]]
[city:[Puerto Natales],lat:[-51.671501159668]]
[city:[Rio Gallegos],lat:[-51.6089]]
[city:[El Calafate],lat:[-50.2803001404]]
[city:[Qaanaaq],lat:[77.4886016846]]
[city:[Longyearbyen],lat:[78.2461013793945]]
----

上記のクエリを書いている際に、'-50..77'のような範囲で'without'ステップを使うことが適切であるように思われるだろうが、範囲内の値に正確にマッチするものを探さずにそれは機能しないし、生成された範囲は '-50','-49','-48'などの形式があるので、除外される空港は、範囲によって生成された値の1つに完全にマッチする緯度の値をもつ空港のみになる点に注意してほしい。これが、'outside'ステップがこのような場合に非常に役に立つ理由だ。

この次のクエリはロンドンヒースローの座標を返すだけだ。

[source,groovy]
----

// Query latitude and longitude for LHR
g.V().has('airport','code','LHR').valueMap('lat','lon')

[lon:[-0.461941003799], lat:[51.4706001282]]
----

この次のクエリはイングランドのロンドンにあるすべての空港のコード、緯度、経度を返す。カナダのオンタリオ州ロンドンのようにロンドンとも呼ばれる他の都市が世界中に存在するので、イングランドのロンドンにある空港のみを返すには地域コード'GB-ENG'を利用する必要があることに注意してほしい。　

[source,groovy]
----
g.V().has('airport','city','London').has('region','GB-ENG').valueMap('code','lat','lon')
[code:[LHR], lon:[-0.461941003799], lat:[51.4706001282]]
[code:[LGW], lon:[-0.190277993679047], lat:[51.1481018066406]]
[code:[LCY], lon:[0.055278], lat:[51.505278]]
[code:[STN], lon:[0.234999999404], lat:[51.8849983215]]
[code:[LTN], lon:[-0.368333011865616], lat:[51.874698638916]]
----

これで、地理的座標を照会する方法がわかったので、グラフ内のどの空港がグリニッジ子午線に非常に近いかを調べるためのクエリを書くことができる。この場合、経度が -01 から 0.1 の間にある空港を探す。

[source,groovy]
----
// Which airports are very close to the Greenwich Meridian ?
g.V().hasLabel('airport').has('lon',between(-0.1,0.1)).valueMap('code','lon')

[code:[LCY], lon:[0.055278]]
[code:[LDE], lon:[-0.006438999902457]]
[code:[LEH], lon:[0.0880559980869293]]
[code:[CDT], lon:[0.0261109992862]]
----

この次のクエリは赤道に最も近い空港を見つけるのに使うことができる。

[source,groovy]
----
// Which airports are closest to the Equator ?
g.V().hasLabel('airport').has('lat',between(-0.1,0.1)).valueMap('code','lat')

[code:[EBB], lat:[0.0423859991133213]]
[code:[MDK], lat:[0.0226000007242]]
[code:[KIS], lat:[-0.0861390009522438]]
[code:[MCP], lat:[0.0506640002131]]
[code:[LGQ], lat:[0.0930560007691]]
----

下記のコードはロンドンヒースロー付近の1度のボックスで定義された地理的エリア内にあるすべての空港を見つける。このタイプのものは JanusGraph で用意されている Geo shape クラスを使って行うことができるが、本のその部分にいないことを考慮して、これが次善の方法だ。

[source,groovy]
----
lat = g.V().has('code','LHR').values('lat').next()
lon = g.V().has('code','LHR').values('lon').next()

g.V().hasLabel('airport').where(and(
                          values('lon').is(between(lon-1,lon+1)),
                          values('lat').is(between(lat-1,lat+1)))).
                          valueMap('code','lat','lon')
----

本書の前半ですでに説明したように、'has'ステップを連鎖させることで、'and'ステップを使うのを避けることが可能な場合がある。下記のコードは、上記のコードと同等だが、'where'と'and'の使用を避けている。

[source,groovy]
----
lat = g.V().has('code','LHR').values('lat').next()
lon = g.V().has('code','LHR').values('lon').next()

g.V().hasLabel('airport').has('lon',between(lon-1,lon+1)).
                          has('lat',between(lat-1,lat+1)).
                          valueMap('code','lat','lon')
----

これは、Gremlin コンソール内で上記のコードスニペットのいづれかを実行することにより生成された出力だ。

[source,groovy]
----
[code:[LHR],lon:[-0.461941003799],lat:[51.4706001282]]
[code:[LGW],lon:[-0.190277993679047],lat:[51.1481018066406]]
[code:[LCY],lon:[0.055278],lat:[51.505278]]
[code:[STN],lon:[0.234999999404],lat:[51.8849983215]]
[code:[LTN],lon:[-0.368333011865616],lat:[51.874698638916]]
[code:[SOU],lon:[-1.35679996013641],lat:[50.9502983093262]]
----

"<<tranges>>" のセクションで、米国、あるいはカナダの空港を使い、機材の変更のために PHX と LAXを回避する 、オースティンとラスベガス間の経由1回の経路を見つけるクエリ（下記に示す）を思いついた。

[source,groovy]
----
g.V().has('airport','code','AUS').out().
      has('country',within('US','CA')).
      has('code',without('PHX','LAX')).out().
      has('code','LAS').path().by('code')
----

これで、air routes グラフに格納されている経度と緯度の座標の使い方がわかったので、このクエリを別のやり方で書くことができる。下記のクエリを見ると、'where'ステップが追加されていることがわかる。米国あるいはカナダの空港のみを確認しているが、'where'ステップでは、経度の値がオースティンの空港よりも小さい場合にのみ関心があるということによりさらに検討する空港を制限する。つまり、オースティンの西にある空港でのみ飛行機を乗り換えたい。これは実際には、他の場所の中でも特にニューヨークとナッシュビルでの飛行機の変更を含む経路を返す、前のクエリの改良である。新しいクエリでは、オースティンの東にある空港は飛行機を変更する場所とはみなされない。

[source,groovy]
----
// AUS to LAS with one stop but the stop has to be in the US or Canada 
// and West of Austin while avoiding PHX and LAX.

g.V().has('airport','code','AUS').as('aus').out().
      has('country',within('US','CA')).
      where(lt('aus')).by('lon').
      has('code',without('PHX','LAX')).out().
      has('code','LAS').path().by('code')
----

下記に、クエリの実行からの出力を示す。空港コードがわかっているのであれば、これらの空港はすべて実際にオースティンの西にあることがわかる。しかしながらオースティンの西にない近くの空港を考慮に入れるために、クエリをさらに改善したいことがあるだろう。例えば、ダラスフォートワース(DFW) はコースティンの北に位置しているので、結果には含まれないが、少し東に位置している。ダラスも含まれるように、クエリを改善することは演習として残しておく。

[source,groovy]
----
[AUS,PDX,LAS]
[AUS,ABQ,LAS]
[AUS,LBB,LAS]
[AUS,SEA,LAS]
[AUS,SFO,LAS]
[AUS,SJC,LAS]
[AUS,SAN,LAS]
[AUS,LGB,LAS]
[AUS,SNA,LAS]
[AUS,SLC,LAS]
[AUS,DEN,LAS]
[AUS,ELP,LAS]
[AUS,OAK,LAS]
----

これは、前のと同様のさらなる例である。まず、ダラス(DFW)空港の経度を変数'dfw'に格納する。次に、その変数を使ってラスベガス(LAS) へのオースティン(AUS) からの、1か所経由するがフェニックス(PHX) とロサンゼルス(LAX) を避け、ダラス、あるいはダラス西部でのみ飛行機の乗り換えがある経路を見つける。経度の値をテストする際は、'lt'ではなく'lte'を使うことに注意してほしい。代わりに'lt'を使ったが、選択肢としてダラスを除外する。このクエリは、前のと同様、ダラスではなく、オースティンの東にある空港での飛行機の変更を除外する、という効果がある。

[source,groovy]
----
dfw = g.V().has('code','DFW').values('lon').next()

g.V().has('airport','code','AUS').as('aus').out().
      has('country',within('US','CA')).
      has('lon',lte(dfw)).
      has('code',without('PHX','LAX')).out().
      has('code','LAS').path().by('code')
----

これが、クエリを実行した際に返ってきたものだ。LAXやPHX を回避してもまだたくさんの選択肢があるようだ。

[source,groovy]
----
[AUS,PDX,LAS]
[AUS,ONT,LAS]
[AUS,ABQ,LAS]
[AUS,LBB,LAS]
[AUS,DFW,LAS]
[AUS,SEA,LAS]
[AUS,SFO,LAS]
[AUS,SJC,LAS]
[AUS,SAN,LAS]
[AUS,LGB,LAS]
[AUS,SNA,LAS]
[AUS,SLC,LAS]
[AUS,DEN,LAS]
[AUS,ELP,LAS]
[AUS,OAK,LAS]
----

グラフ中のすべての空港頂点に存在する'region'プロパティを使う最後のクエリを見てみよう。

下記のクエリはDFW 空港をスタートして、米国内の全ての経路を探す。次に、それらの空港はその地域コードと空港コードによってグルーピングされる。最後に、いくつかの州が選択される。結果をもう少し読みやすくするために、クエリは'unfold'ステップで終了する。

[source,groovy]
----
g.V().has('airport','code','DFW').out().has('country','US').
      group().by('region').by('code').
      select('US-CA','US-TX','US-FL','US-CO','US-IL').unfold()

----

下記にクエリ結果を示す。選択された各州がDFWから到達可能な空港のリストとともに一覧表示されている。

[source,groovy]
----
US-CA=[LAX, SFO, SJC, SAN, SNA, OAK, ONT, PSP, SMF, FAT, SBA]
US-TX=[AUS, IAH, SAT, HOU, ELP, LBB, MAF, CRP, ABI, ACT, CLL, 
       BPT, AMA, BRO, GGG, GRK, LRD, MFE, SJT, SPS, TYR]
US-FL=[FLL, MCO, MIA, PBI, TPA, RSW, TLH, JAX, PNS, VPS]
US-CO=[DEN, COS, DRO, GJT, EGE, HDN, ASE, GUC, MTJ]
US-IL=[ORD, PIA, BMI, CMI, MLI, SPI]
----

次のセクションでは、上記の例に基づいて、空港の頂点に存在する緯度と経度の座標を使って距離の計算を実行するさらに複雑なクエリについて説明する。

[[GreatCircle]]
==== math ステップを使って大圏距離を計算する

地球上の2か所の緯度と経度が分かっている場合、それらの間のおおよその距離は、半正矢関数の公式を使って計算できる。この式には'math'ステップを使って Gremlin で実行できる三角測量計算がいくつか含まれている。

NOTE: 半正矢関数で使われている数学の理解を深めたい場合は、 https://en.wikipedia.org/wiki/Haversine_formula[ここ] に詳しい説明がある。


本セクションには、2つのクエリを含めた。1つ目は、幾分か柔軟性にかけるアプローチを使ってオースティンとダラスフォートワースの間の距離を計算する。これは私が最初に大圏距離をすべて Gremlin で計算するクエリを作成しようとしたのが反映されている。空港コードはクエリに埋め込まれている。それが動くようになったので、より一般的なクエリの方がよいことがわかった。2つ目の例は、任意の出発地と宛先が指定できる。

クエリを見てみよう。まず、使われているステップの数が少し気が遠くなるように思えるかもしれないが、セクションごとに順を追って作業を進めていくと、実際にはかなり簡単だ。半正矢関数の公式には、いくつかの定数値が必要だ。これらは'withSideEffect'ステップを使ってクエリに挿入される。1つ目の定数、'rdeg'はラジアンで1度を表す。これは π を180 で割った結果だ。２つめの定数,'gcmiles'は地球の平均半径をマイルで表す。これにより、極に近づくにつれて半径が変化する地球の不完全な球形が許容されるようになる。

クエリを作成する最初の試みでは、私は'has'ステップを使って、AUS空港と DFW 空港を見つけ、次に空港コードをキーとして緯度と経度の予測を値としてグルーピングを行った。クエリのその部分だけを取り出して実行すると、これが返ってくる。

[source,groovy]
----
g.withSideEffect("rdeg", 0.017453293).
  withSideEffect("gcmiles",3956).  
  V().
  has('code',within('AUS','DFW')).
  group().
    by('code').
    by(project('lat','lon').
      by('lat').
      by('lon'))

[DFW:[lat:32.896800994873,lon:-97.0380020141602],
 AUS:[lat:30.1944999694824,lon:-97.6698989868164]] 
----

半正矢関数の公式では、2つの座標の緯度と経度の差を計算する必要がある。クエリの次の部分はそれを行っている。project ステップ、'project('ladiff, lgdiff, lat1, lon1, lat2, lon2')'を使って必要な値をすべて集める。

[source,groovy]
----
g.withSideEffect("rdeg", 0.017453293).
  withSideEffect("gcmiles",3956).  
  V().
  has('code',within('AUS','DFW')).
  group().
    by('code').
    by(project('lat','lon').
      by('lat').
      by('lon')).
  as('grp').
  project('ladiff','lgdiff','lat1','lon1','lat2','lon2').
    by(project('la1','la2').
         by(select('AUS').select('lat')).
         by(select('DFW').select('lat')).
       math('(la2 - la1) * rdeg')).
    by(project('lg1','lg2').
         by(select('AUS').select('lon')).
         by(select('DFW').select('lon')).
       math('(lg2 - lg1) * rdeg')).
    by(select('grp').select('AUS').select('lat')).
    by(select('grp').select('AUS').select('lon')).
    by(select('grp').select('DFW').select('lat')).
    by(select('grp').select('DFW').select('lon'))
----

これが、その結果だ。元の座標と合わせて差異を含むマップが生成されている。

[source,groovy]
----
[ladiff:0.04716405157034253,
 lgdiff:0.011028683009581777,
 lat1:30.1944999694824,
 lon1:-97.6698989868164,
 lat2:32.896800994873,
 lon2:-97.0380020141602]  
----

このような値を収集する目的は、値を'math'ステップに入力して計算を完了できるようにすることだ。この例から重要なポイントの1つは、'math'ステップに前の'project'ステップから値を入力する方法だ。最終的な計算では、半正矢関数の公式で必要とされる三角法を実行する。これが、Gremlin でこの問題を解決するための私の最初の試みの完全版である。

[source,groovy]
----
g.withSideEffect("rdeg", 0.017453293).
  withSideEffect("gcmiles",3956).
  V().
  has('code',within('AUS','DFW')).
  group().
    by('code').
    by(project('lat','lon').
      by('lat').
      by('lon')).
  as('grp').
  project('ladiff','lgdiff','lat1','lon1','lat2','lon2').
    by(project('la1','la2').
         by(select('AUS').select('lat')).
         by(select('DFW').select('lat')).
       math('(la2 - la1) * rdeg')).
    by(project('lg1','lg2').
         by(select('AUS').select('lon')).
         by(select('DFW').select('lon')).
       math('(lg2 - lg1) * rdeg')).
    by(select('grp').select('AUS').select('lat')).
    by(select('grp').select('AUS').select('lon')).
    by(select('grp').select('DFW').select('lat')).
    by(select('grp').select('DFW').select('lon')).
  math('(sin(ladiff/2))^2 + cos(lat1*rdeg) * cos(lat2*rdeg) * (sin(lgdiff/2))^2').
  math('gcmiles * (2 * asin(sqrt(_)))')       
----

オースティンからダラスフォートワースまでの距離は約 190 マイルであることがわかる。

[source,groovy]
----
190.2483140396514   
----

クエリをもう少し柔軟にするには、いくつかの調整を必要とする。私は、最初に2つの空港コードを入力するだけのクエリが欲しかった。これにより、コードを扱う際にクエリをパラメータ化するのが簡単になる。私の最初の試みとの主な違いは、出発地と目的地の空港が最初にあり、個別にラベル付けされている点だ。group ステップは select ステップに置き換えられ、"grp" というラベルが付与される。クエリの残りの部分は、必要に応じて、"grp" を参照する。

[source,groovy]
----
g.withSideEffect("rdeg", 0.017453293).
  withSideEffect("gcmiles",3956).
  V().has('code','AUS').as('src').
  V().has('code','DFW').as('dst').
  select('src','dst').
    by(project('lat','lon').
         by('lat').
         by('lon')).
  as('grp').
  project('ladiff','lgdiff','lat1','lon1','lat2','lon2').
    by(project('la1','la2').
         by(select('grp').select('src').select('lat')).
         by(select('grp').select('dst').select('lat')).
       math('(la2 - la1) * rdeg')).
    by(project('lg1','lg2').
         by(select('grp').select('src').select('lon')).
         by(select('grp').select('dst').select('lon')).
       math('(lg2 - lg1) * rdeg')).
    by(select('grp').select('src').select('lat')).
    by(select('grp').select('src').select('lon')).
    by(select('grp').select('dst').select('lat')).
    by(select('grp').select('dst').select('lon')).
  math('(sin(ladiff/2))^2 + cos(lat1*rdeg) * cos(lat2*rdeg) * (sin(lgdiff/2))^2').
  math('gcmiles * (2 * asin(sqrt(_)))')              
----

より汎用的なバージョンのクエリの結果は前のと同じだ。

[source,groovy]
----
190.2483140396514  
----

NOTE: このクエリのコードは、 https://github.com/krlawrence/graph/blob/main/sample-code/great-circle.groovy のsample-codeフォルダーにある。

さらに一歩進んで、クエリをパラメータ化することができる。下記に示す全ては、Gremlin コンソールを使って実行することができるが、アプリケーション内でこのクエリを実行する方法も表している。今回は、サンフランシスコと東京成田を出発地、目的地として使っている。

[source,groovy]
----
start = 'SFO'
stop = 'NRT'

g.withSideEffect("rdeg", 0.017453293).
  withSideEffect("gcmiles",3956).
  V().has('code',start).as('src').
  V().has('code',stop).as('dst').
  select('src','dst').
    by(project('lat','lon').
         by('lat').
         by('lon')).
  as('grp').
  project('ladiff','lgdiff','lat1','lon1','lat2','lon2').
    by(project('la1','la2').
         by(select('grp').select('src').select('lat')).
         by(select('grp').select('dst').select('lat')).
       math('(la2 - la1) * rdeg')).
    by(project('lg1','lg2').
         by(select('grp').select('src').select('lon')).
         by(select('grp').select('dst').select('lon')).
       math('(lg2 - lg1) * rdeg')).
    by(select('grp').select('src').select('lat')).
    by(select('grp').select('src').select('lon')).
    by(select('grp').select('dst').select('lat')).
    by(select('grp').select('dst').select('lon')).
  math('(sin(ladiff/2))^2 + cos(lat1*rdeg) * cos(lat2*rdeg) * (sin(lgdiff/2))^2').
  math('gcmiles * (2 * asin(sqrt(_)))')       

5108.80166113392 
----

JanusGraph が提供するいくつかの追加機能について説明している"<<janusgeo>>"のセクションで、地理空間クエリの実行に関するトピックについて再検討するつもりだ。

[[via]]
=== 特定の空港を経由する経路を見つける

'has'ステップを使って経路をフィルタリングする例をいくつか見てきた。下記のクエリは、オースティン(AUS)を出発してダラス(DFW) を経由する5件の経路を見つける。

[source,groovy]
----
g.V().has('code','AUS').
      out().has('code','DFW').
      out().
      limit(5).
      path().by('code')
----

クエリを実行すると、期待どおり、AUSを出発して、途中でDFWで停止する5つの経路が見つかる。

[source,groovy]
----
[AUS,DFW,ATL]
[AUS,DFW,ANC]
[AUS,DFW,AUS]
[AUS,DFW,BNA]
[AUS,DFW,BOS]
----

この手法は、DFWでどの停泊地にしたいかがわかっている場合には有効だ。しかしながら、旅程途中のどこか特定の空港に行く結果だけを返すクエリを書きたいこともあるだろう。2段階で例を作ってみよう。まず、下記のクエリを見て欲しい。これは、オースティンを出発してエジンバラまでの、途中の米国あるいは英国の空港を経由する10件の経路を探す。

[source,groovy]
----
g.V().
  has('code','AUS').
  repeat(out().simplePath().has('country',within('US','UK'))).
    until(has('code','EDI')).
  path().by('code').
  limit(10)
----

実行すると、次の結果が得られる。

[source,groovy]
----
[AUS,LHR,EDI]
[AUS,JFK,EDI]
[AUS,EWR,EDI]
[AUS,LHR,MAN,EDI]
[AUS,LHR,BHD,EDI]
[AUS,LHR,INV,EDI]
[AUS,LHR,JFK,EDI]
[AUS,LHR,EWR,EDI]
[AUS,PIT,JFK,EDI]
[AUS,PIT,EWR,EDI]
----

しかしながら、例をもっと面白くするために、マンチェスター（MAN)を経由する経路のみを取得したいとしよう。これを行うには、前のクエリを調整して、グラフをトラバースする際に、"MAN" を探して、途中でマンチェスタに遭遇するパスをsackを使って追跡する。EDI に到着したら、'where'ステップを使って、sack の値が「1」以外の経路を除外する。「1」の値は、途中でマンチェスターに遭遇したことを意味する。

[source,groovy]
----
g.withSack(0).V().
  has('code','AUS').
  repeat(out().simplePath().has('country',within('US','UK')).
         choose(has('code','MAN'),sack(sum).by(constant(1)))).
    until(has('code','EDI')).
  where(sack().is(1)).
  path().by('code').
  limit(10)
----

変更されたクエリが実行されると、各結果のパスにMAN が含まれる。

[source,groovy]
----
[AUS,LHR,MAN,EDI]
[AUS,ATL,MAN,EDI]
[AUS,BOS,MAN,EDI]
[AUS,IAD,MAN,EDI]
[AUS,IAH,MAN,EDI]
[AUS,JFK,MAN,EDI]
[AUS,LAX,MAN,EDI]
[AUS,MCO,MAN,EDI]
[AUS,MIA,MAN,EDI]
[AUS,ORD,MAN,EDI]
----

30などの値を使うようにlimit ステップを増やすと、MANがパスの任意の位置に表示されるようになることがわかる。

[source,groovy]
----
[AUS,LHR,GLA,MAN,EDI]
[AUS,LHR,ABZ,MAN,EDI]
[AUS,LHR,BHD,MAN,EDI]
[AUS,LHR,INV,MAN,EDI]
----

[[storesideeffect]]
=== store と sideEffect を使って一意の値のセットを作成する

下記のクエリを見て欲しい。これはIDが1から200（両端含む）の空港の都市名を返すだけだ。リストはアルファベット順にソートされている。

[source,groovy]
----
g.V().hasId(between(1,201)).values('city').order().fold()
----

そして、ここに返される名前がある。リストをよく見ると'Dallas'や、'London'などの都市名を複数回表示されていることがわかる。

[source,groovy]
----
[Abu Dhabi, Addis Ababa, Albuquerque, Alicante, Alice Springs, Amsterdam, Anchorage, Athens, Atlanta, Auckland, Austin, Ayers Rock, Baltimore, Bankok, Barcelona, Beijing, Belgrade, Bengaluru, Berlin, Bilbao, Bologna, Boston, Brisbane, Brussels, Budapest, Buenos Aires, Cairns, Cairo, Calgary, Calicut, Canberra, Cancun, Cape Town, Cedar Rapids, Charlotte, Chennai, Chicago, Chicago, Christchurch, Cincinnati, Cleveland, Cologne, Copenhagen, Dallas, Dallas, Denver, Detroit, Doha, Dubai, Dublin, Durban, Dusseldorf, Edinburgh, Edmonton, El Paso, Fairbanks, Fort Lauderdale, Fort Myers, Frankfurt, Geneva, Genoa, Glasgow, Gold Coast, Gothenburg, Hagta, Halifax, Hamburg, Harrison, Helsinki, Ho Chi Minh City, Hong Kong, Honolulu, Houston, Houston, Hyderabad, Ibiza, Indianapolis, Istanbul, Johannesburg, Kahului, Kansas City, Kingston, Kolkata, Kuala Lumpur, Kuwait, Larnaca, Las Vegas, Lima, Liverpool, London, London, London, London, Long Beach, Los Angeles, Luqa, Luxembourg, Madrid, Manama, Manchester, Manila, Maroochydore, Melbourne, Memphis, Menorca, Mexico City, Miami, Milan, Milwaukee, Minneapolis, Mombasa, Montevideo, Montreal, Moscow, Moscow, Mumbai, Munich, Nairobi, Nantes, Naples, Nashville, New Delhi, New Orleans, New York, New York, Newark, Nice, Nottingham, Oaklahoma City, Oakland, Omaha, Ontario, Orlando, Osaka, Oslo, Ottawa, Palm Springs, Paris, Paris, Perth, Philadelphia, Phnom Penh, Phoenix, Pisa, Pittsburgh, Portland, Portland, Prague, Puerto Vallarta, Raleigh, Rio de Janeiro, Rochester, Rochester, Rome, Salina, Salt Lake City, San Antonio, San Diego, San Francisco, San Jose, San Juan, Santa Ana, Santa Fe, Santiago, Sao Paulo, Seattle, Seoul, Shanghai, Shannon, Singapore, Sofia, St Louis, St. Johns, Stockholm, Stuttgart, Sydney, Tallahassee, Tampa, Tel Aviv, Tenerife, Tokyo, Tokyo, Toronto, Tucson, Tulsa, Turin, Vancouver, Venice, Venice, Verona, Vienna, Warsaw, Washington D.C., Washington D.C., Wellington, West Palm Beach, White Plains, Winnipeg, Zagreb, Zurich] 
----

念の為、返ってきた都市名の数を数えることができる。

[source,groovy]
----
g.V().hasId(between(1,201)).values('city').order().count()

200
----

重複する名前が、1回だけ表示されるようになると便利だ。'dedup'を使うなど、このクエリを書く方法は他にもあるが、これより複雑なシナリオで役に立つ機能を非常によく示していると思うので、'store'と'Set'を使って書き直してみよう。'withSideEffect'を使ってクエリを始めることで、名前付きの場所を設定して、クエリの後半で'store'することができ、そのstore にタイプを指定することもできる。この場合、私は'Set'を使うことを選んだ。このクエリがやっていることは、グラフの最初の200個の頂点の都市名をSetに格納し、それを表示することだ。最初の試みからわかるように、ダラスのような都市名は複数回表示される。しかしながら、修正したクエリから返されるSet を見れば、（デフォルトでは、Setには重複を保存しないので）ダラスやロンドンの名前は1回しか出てこない。

[source,groovy]
----

g.withSideEffect("x", [] as Set).V().hasId(between(1,201)).
  values('city').store('x').cap('x').unfold().order().fold()
----

これが、修正したクエリを実行した後に返される都市名だ。重複する名前が全てなくなっていることに気づくと思う。

[source,groovy]
----
[Abu Dhabi, Addis Ababa, Albuquerque, Alicante, Alice Springs, Amsterdam, Anchorage, Athens, Atlanta, Auckland, Austin, Ayers Rock, Baltimore, Bankok, Barcelona, Beijing, Belgrade, Bengaluru, Berlin, Bilbao, Bologna, Boston, Brisbane, Brussels, Budapest, Buenos Aires, Cairns, Cairo, Calgary, Calicut, Canberra, Cancun, Cape Town, Cedar Rapids, Charlotte, Chennai, Chicago, Christchurch, Cincinnati, Cleveland, Cologne, Copenhagen, Dallas, Denver, Detroit, Doha, Dubai, Dublin, Durban, Dusseldorf, Edinburgh, Edmonton, El Paso, Fairbanks, Fort Lauderdale, Fort Myers, Frankfurt, Geneva, Genoa, Glasgow, Gold Coast, Gothenburg, Hagta, Halifax, Hamburg, Harrison, Helsinki, Ho Chi Minh City, Hong Kong, Honolulu, Houston, Hyderabad, Ibiza, Indianapolis, Istanbul, Johannesburg, Kahului, Kansas City, Kingston, Kolkata, Kuala Lumpur, Kuwait, Larnaca, Las Vegas, Lima, Liverpool, London, Long Beach, Los Angeles, Luqa, Luxembourg, Madrid, Manama, Manchester, Manila, Maroochydore, Melbourne, Memphis, Menorca, Mexico City, Miami, Milan, Milwaukee, Minneapolis, Mombasa, Montevideo, Montreal, Moscow, Mumbai, Munich, Nairobi, Nantes, Naples, Nashville, New Delhi, New Orleans, New York, Newark, Nice, Nottingham, Oaklahoma City, Oakland, Omaha, Ontario, Orlando, Osaka, Oslo, Ottawa, Palm Springs, Paris, Perth, Philadelphia, Phnom Penh, Phoenix, Pisa, Pittsburgh, Portland, Prague, Puerto Vallarta, Raleigh, Rio de Janeiro, Rochester, Rome, Salina, Salt Lake City, San Antonio, San Diego, San Francisco, San Jose, San Juan, Santa Ana, Santa Fe, Santiago, Sao Paulo, Seattle, Seoul, Shanghai, Shannon, Singapore, Sofia, St Louis, St. Johns, Stockholm, Stuttgart, Sydney, Tallahassee, Tampa, Tel Aviv, Tenerife, Tokyo, Toronto, Tucson, Tulsa, Turin, Vancouver, Venice, Verona, Vienna, Warsaw, Washington D.C., Wellington, West Palm Beach, White Plains, Winnipeg, Zagreb, Zurich]  
----

今回は名前が少なくなったことを確認するために、再度数えよう。

[source,groovy]
----
g.withSideEffect("x", [] as Set).V().hasId(between(1,201)).
  values('city').store('x').cap('x').unfold().count()

186
----

本セクションの冒頭で述べたように、この結果は別の方法で得ることができる。例えば、これは、'store'の代わりに'dedup'を使ったバージョンのクエリだ。

[source,groovy]
----
g.V().hasId(between(1,201)).values('city').dedup().count()  

186
----

この場合、これは、明らかに単純なクエリだが、'withSideEffect'と'store'を使う例が非常に役立つ場合がある。特に、出発空港から複数ホップにまたがるすべての一意の都市名見つけてカウントする下記のような、トラバーサルの複数の部分からSetあるいはList に何かを格納したい場合だ。

[source,groovy]
----
g.withSideEffect("x", [] as Set).V().hasId(3).as('a').values('city').store('x').
   select('a').out().as('b').values('city').store('x').
   select('b').out().values('city').store('x').cap('x').unfold().count()

804
----

最後に、このトピックについて、もう一つ興味深いユースケースを見てみよう。頂点とエッジのコレクションをクエリから取得したいのは非常に一般的だ。これは多くの場合、頂点とエッジの両方のプロパティを調べたいからだ。下記の関連をもつ小さいグラフを想像してみてほしい。

(A->B),
(A->C),
(A->D),
(C->D),
(C->E),
(D->F)

下記のコードは、Gremlin コンソールと TinkerGraph を使ってこのグラフを生成するのに使うことができる。

[source,groovy]
----
graph=TinkerGraph.open()
g=graph.traversal()

g.addV("A").as("a").
  addV("B").as("b").
  addV("C").as("c").
  addV("D").as("d").
  addV("E").as("e").
  addV("F").as("f").
  addE("knows").from("a").to("b").
  addE("knows").from("a").to("c").
  addE("knows").from("a").to("d").
  addE("knows").from("c").to("d").
  addE("knows").from("c").to("e").
  addE("knows").from("d").to("f")
----

'valueMap'を見ると、各頂点に割り当てられたIDを確認できる。

[source,groovy]
----
g.V().valueMap(true)

[id:0,label:A]
[id:1,label:B]
[id:2,label:C]
[id:3,label:D]
[id:4,label:E]
[id:5,label:F]
----

同様に、エッジを見て、各エッジにどのIDが付与さえているかを確認できる。

[source,groovy]
----
g.E()

e[6][0-knows->1]
e[7][0-knows->2]
e[8][0-knows->3]
e[9][2-knows->3]
e[10][2-knows->4]
e[11][3-knows->5]
----

これでテストグラフを作成したので、開発する必要のあるクエリを見てみよう。解決したい問題は、頂点Aからスタートして、頂点Aから出ていくエッジをすべて見つけ、それらのエッジの反対側にある頂点をすべて見つけることだ。最後に、Aにも接続されている頂点間のエッジも見つけるが、Aに接続されていない頂点に接続されているエッジを無視したい。簡単に言うと、A はEあるいはFには接続されていないので、(C->E) と (D-F)を除くすべての関連を返したい。 

本セクションの前半で使ったwithSideEffect パターンを使って、再度関心のある頂点とエッジを収集するクエリを開発するとよい。何が起こっているのかを簡単に説明できるように行番号をつけたが、これらはクエリ自体の一部じゃないことに注意してほしい。

[source,groovy]
----
1: g.withSideEffect('x', [] as Set).
2:     V(0L).store('x').
3:     bothE().store('x').
4:     otherV().store('x').
5:     aggregate('tgtlist').
6:     bothE().as('ref').otherV().where(within('tgtlist')).
7:     select('ref').store('x').cap('x').unfold()    
----

上記のクエリを1行ずつ見ていこう。

//[%hardbreaks]
----
1: クエリを開始し、初期値は空のSet 'x' を定義する。 
2: 頂点 0 からスタートして、セット 'x' に 'store' する。 
3: 'V(0)' に接続されているエッジをすべて セットに格納する
4: 'V(0)' に接続されている頂点をセットに格納する。
5: これらのターゲット頂点をすべて、'tgtlist' に収集する。
6: さらにエッジを見つけるが、'V(0)' に接続されているほかの頂点に接続していれば、覚えるだけ。 
7: 見つけたエッジを 'x' に格納し、最後にセットをクエリ全体の結果として返す。'unfold' は出力読みやすくするだけだ。
----

これは、クエリを実行して得られた出力である。ごらんのとおり、関心のない頂点とエッジは正しく結果セットから除外されている。

[source,groovy]
----
v[0]
e[5][0-knows->1]
v[1]
e[6][0-knows->2]
v[2]
e[7][0-knows->3]
v[3]
e[8][2-knows->3]
----

グラフの操作を開始し、より複雑なクエリを実行し始めると、'withSideEffect'に基づくこのクエリのパターンは、覚えておくと非常に便利だ。

[[dfwcopy]]
=== DFW 頂点のコピーを作成する

1つまたは複数の既存の頂点のラベルとプロパティを使って新しい頂点を作成できると便利な場合がある。本セクションでは、ダラスフォートワース(DFW) 空港頂点のコピーを作成できるクエリの作成について調査した方法を示す小さなケーススタディを紹介する。

他の頂点のラベルを使って頂点を作成するのは非常に簡単だ。下記に示す2つのクエリは、新しい頂点のラベルとしてDFW空港頂点のラベルを使う。

私の最初の考えは、これを下記のようにすることだった。

[source,groovy]
----
g.addV().property(label,V().has('code','DFW').label())
----

上記のクエリは機能するが、少し面倒に感じ、また、DFW頂点を複数回参照する必要があることに気づいたので、下記のようにクエリを変更して実行した。

[source,groovy]
----
g.V().has('code','DFW').as('dfw').
      addV().property(label, select('dfw').label())

v[57525]
----

新しい頂点を調べると、実際に正しくラベルがついていることがわかる。

[source,groovy]
----
g.V(57525).valueMap(true)

[label:airport,id:57525]
----

次に、クエリを拡張して、プロパティキー名とその値をDFW頂点から新しい頂点へコピーする必要がある。本書の前半で、'select'ステップを'keys'や'valuesキーワードと組み合わせて、マップから値を選択する方法について説明した。ここでも同じ手法が使える。

まず、DFW空港のプロパティについて思い出してみよう。

[source,groovy]
----
g.V().has('code','DFW').properties()

vp[country->US]
vp[code->DFW]
vp[longest->13401]
vp[city->Dallas]
vp[elev->607]
vp[icao->KDFW]
vp[lon->-97.0380020141602]
vp[type->airport]
vp[region->US-TX]
vp[runways->7]
vp[lat->32.896800994873]
vp[desc->Dallas/Fort Worth...]
----

上記にリストアップされているプロパティの数も数えよう。

[source,groovy]
----
g.V().has('code','DFW').properties().count()

12
----

よって、12個のキーと値をDFW頂点に属するこの12個のプロパティから新しい頂点にコピーするいくつかのステップをクエリに追加する必要がある。

下記はこれを行う方法を考えたときに私が試した最初のクエリである。クエリの目的は最初にDFW空港からプロパティをキャプチャし、次にそれらを作成した新しい頂点に追加することだ。

[source,groovy]
----
g.V().has('code','DFW').as('dfw').
      addV().property(label, select('dfw').label()).as('new').
             property(select('dfw').properties().key(),
                      select('dfw').properties().value()) 
----

これを実行すると、新しい頂点が明らかに作成されたので、勇気づけられるように見えるこの結果が得られた。

[source,groovy]
----
v[53767]
----

しかしながら、新しい頂点を調べたところ、12個のプロパティのうち1つしかコピーされていなかったことがわかった。なので、その頂点を削除して、少し再考するときがきた。

[source,groovy]
----
g.V(53767).valueMap(true).unfold()

country=[US]
label=airport
id=53767

g.V(53767).drop()
----

私がわかったことは、プロパティをコピーする最初の試みは、基本的に私が要求した、1つのプロパティをコピーすることだった。これが当てはまることが明らかでなければ、本セクションで後述するプロファイルステップの結果を見れば明らかになることを期待する。私は、すべきことは最初にDFWのプロパティをすべて取得して、次にそれらを新しい頂点に追加することであることがわかった。なので、クエリを書きに示すように変更した。

[source,groovy]
----
g.V().has('code','DFW').as('dfw').
      addV().property(label, select('dfw').label()).as('new').
      select('dfw').properties().as('dfwprops').
      select('new').property(select('dfwprops').key(), 
                             select('dfwprops').value())          
----

実行すると、これは私がGremlin コンソールで見たものだ。これはクエリから取得したかったものよりも出力が多いが、今回は明らかに多くの処理を行った。下記の行数を数えると、合計12行になることがわかる。なので、今回はプロパティごとに1つの結果が表示されている。

[source,groovy]
----
[53768]
[53768]
[53768]
[53768]
[53768]
[53768]
[53768]
[53768]
[53768]
[53768]
[53768]
[53768]
----

すぐに、不要な出力を除去する方法を調査するが、最初に新しい頂点の内容を調べてみよう。

[source,groovy]
----
g.V(53768).valueMap(true).unfold()

country=[US]
code=[DFW]
longest=[13401]
city=[Dallas]
lon=[-97.0380020141602]
type=[airport]
elev=[607]
label=airport
icao=[KDFW]
id=53768
region=[US-TX]
runways=[7]
lat=[32.896800994873]
desc=[Dallas/Fort Worth International Airport]
----

なので、私の当初の目的の大部分は達成された。元のDFW頂点の、IDの値を除くすべてがコピーである頂点が作成された。では、クエリの結果として返された不要な頂点のリストについて何ができるか。

まず、'profile'ステップからこのクエリについて何がわかるか見てみよう。私はこのクエリを実行する前に、新しい頂点を'drop'ステップを使って削除したので、新旧両方のDFW 頂点をピックアップしなかった点に注意してほしい。

[source,groovy]
----
g.V(53768).drop()

g.V().has('code','DFW').as('dfw').
      addV().property(label, select('dfw').label()).as('new').
      select('dfw').properties().as('dfwprops').
      select('new').property(select('dfwprops').key(), 
                             select('dfwprops').value()).profile()

----

下記の結果を見ると、各プロパティのキー／値のペアごとに、トラバーサーが生成されたことがわかる。これは、なぜ12個の結果が返されたかを説明している。これは、このクエリを書く最初の試みが失敗したことも説明している。そのクエリをプロファイリングすると、処理が成功するために必要な12個ではなく1個のトラバーサーしか生成されないことがわかる。

[source,console]
----
Traversal Metrics      Step                      Count Traver-  Time   %Dur
                                                       sers      (ms)
===================================================================================
TinkerGraphStep(vertex,[code.eq(DFW)])@[dfw]        1     1    1.416    28.85
AddVertexStep({label=[[SelectOneStep(last,dfw),...  1     1    1.840    37.47
  SelectOneStep(last,dfw)                           1     1    0.171
  NoOpBarrierStep(2500)                             1     1    0.092
  LabelStep                                         1     1    0.059
SelectOneStep(last,dfw)                             1     1    0.132     2.70
NoOpBarrierStep(2500)                               1     1    0.032     0.66
PropertiesStep(property)@[dfwprops]                12    12    0.094     1.92
SelectOneStep(last,new)                            12    12    0.127     2.60
NoOpBarrierStep(2500)                              12    12    0.065     1.34
AddPropertyStep({value=[[SelectOneStep(last,dfw... 12    12    1.200    24.45
  SelectOneStep(last,dfwprops)                     12    12    0.168
  NoOpBarrierStep(2500)                            12    12    0.064
  PropertyKeyStep                                  12    12    0.066
  SelectOneStep(last,dfwprops)                     12    12    0.134
  NoOpBarrierStep(2500)                            12    12    0.070
  PropertyValueStep                                12    12    0.043
                                            >TOTAL  -     -    4.911                               

----

第4章の前半の'addV'と'property'ステップの説明から思い出していただきたいのだが、'property'ステップは新しいプロパティ時代ではなく、プロパティが追加された頂点を返す。これにより、複数の'addV'と'property'ステップを連鎖させることができる。

なので、新しいプロパティを生成する方法が必要だが、12個のトラバーサーが結果を返さないようにする必要がある。うまくいけば、これに対するリアクションは 「これがクエリに'sideEffect'ステップを導入するのに適した場所のように思われる。」のようなものだ。それがあなたのリアクションであれば、あなたは正しい。

新しいクエリを実行する前に、前のクエリで実行された作業をクリーンアップする必要がある。

[source,groovy]
----
g.V().has('code','DFW')

[8]
[53767]

g.V(53767).drop()
----

では、プロパティの生成を'sideEffect'ステップにラップして不要な結果が返されないようにする。修正されたバージョンのクエリを下記に示す。

[source,groovy]
----
g.V().has('code','DFW').as('dfw').
      addV().property(label, select('dfw').label()).as('new').
      sideEffect(select('dfw').properties().as('dfwprops').
                 select('new').property(select('dfwprops').key(), 
                                        select('dfwprops').value()))
----

変更されたバージョンのクエリを実行すると、これが返される。

[source,groovy]
----
[53780]
----

結果として新しい頂点を1回だけ取得したので、これははるかによい。クエリが意図したとおりに動作したことを再確認しよう。

[source,groovy]
----
g.V(53780).valueMap(true).unfold()

country=[US]
code=[DFW]
longest=[13401]
city=[Dallas]
lon=[-97.0380020141602]
type=[airport]
elev=[607]
label=airport
icao=[KDFW]
id=53780
region=[US-TX]
runways=[7]
lat=[32.896800994873]
desc=[Dallas/Fort Worth International Airport]
----

この小さなケーススタディでは、どのようにクエリを段階的に進化させることができるか、またその過程で予期ない結果に適用する方法を示そうとした。必要に応じて、本セクションに示されているのと基本的に同じ手法を使って1つあるいは複数のエッジをコピーすることもできる。

[[btree]]
=== 順序付き二分木をグラフとしてモデル化する

もちろんツリー構造をグラフとしてモデル化することができる。次のコードは順序づけられた二分木を含む新しいグラフを生成する。このようなグラフは、グラフに閉域がないので、'接続された非巡回グラフ'と呼ばれることがある。これは、ノードを離れると、そこへ再び到達できるような他のパスがないことを意味する。対照的に、air-routes グラフは、明らかに頂点に再訪する方法は多数あるので、巡回グラフの例だ。

[source,groovy]
----
// Builds a small ordered Binary (BST) Tree
graph=TinkerGraph.open()
g=graph.traversal()
g.addV('root').property('data',9).as('root').  
  addV('node').property('data',5).as('b').  
  addV('node').property('data',2).as('c').  
  addV('node').property('data',11).as('d').  
  addV('node').property('data',15).as('e').  
  addV('node').property('data',10).as('f').  
  addV('node').property('data',1).as('g').  
  addV('node').property('data',8).as('h').  
  addV('node').property('data',22).as('i').  
  addV('node').property('data',16).as('j').  
  addE('left').from('root').to('b').
  addE('left').from('b').to('c').
  addE('right').from('root').to('d').
  addE('right').from('d').to('e').
  addE('right').from('e').to('i').
  addE('left').from('i').to('j').
  addE('left').from('d').to('f').
  addE('right').from('b').to('h').
  addE('left').from('c').to('g')
----

もちろん、'max'と'min'ステップを使ってグラフ内の最大値と最小値を見つけることができる。しかしながら、下記のクエリは順序づけられた二分木のセマンティクスを使ってこれを行う方法を示す。

[source,groovy]
----
// Find the largest value in the graph
g.V().hasLabel('root').repeat(out('right')).
                       until(out('right').count().is(0)).values('data')

22

// Find the smallest value in the graph
g.V().hasLabel('root').repeat(out('left')).
                       until(out('left').count().is(0)).values('data')

1
----

ちなみに、これは'count'の代わりに'not'を使ってクエリを書いた別の方法だ。'not'はGroovy の予約語なので、"<<rword>>" のセクションで説明したように、プレフィクスとして'.'表記をつける必要がある。

[source,groovy]
----
g.V().hasLabel('root').repeat(out('left')).
                       until(__.not(out('left'))).values('data')
----

ツリーをトラバースする際に'repeat'が遭遇する値を確認したい場合は、'emit'ステップを追加して、'repeat'がアクセスする各ノードの値を取得するとよい。これにはルートノードからの値は含まれない点に注意してほしい。

[source,groovy]
----
g.V().hasLabel('root').repeat(out('left')).emit().values('data')

5
2
1
----

おそらく、ツリーをトラバースする際に遭遇したすべての値を確認するよりよい方法は、下記のように'path'を使うことだ。これにはルートノードの値が含まれる点に注意してほしい。 

[source,groovy]
----
g.V().hasLabel('root').repeat(out('left')).
                       until(__.not(out('left'))).path().by('data')

[9,5,2,1]
----

下記のクエリを実行すると、ツリー内のすべての可能なパスを確認できる。

[source,groovy]
----
g.V().hasLabel('root').repeat(out()).times(4).emit().path().by('data')

[9,5]
[9,11]
[9,5,2]
[9,5,8]
[9,11,10]
[9,11,15]
[9,5,2,1]
[9,11,15,22]
[9,11,15,22,16]
----

https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#tre[グラフをツリーに変換する]のセクションで、TinkerPop Tree API について簡単に説明した。そこで説明したことを使って下記のように、二分木グラフからTreeオブジェクトを生成することができる。

[source,groovy]
----
t=g.V().hasLabel('root').repeat(out()).emit().tree().by('data').next()
----

作成したオブジェクトの種類を照会できることを確認してほしい。

[source,groovy]
----
t.getClass()

class org.apache.tinkerpop.gremlin.process.traversal.step.util.Tree
----

ツリーを出力すると、元のグラフからどのように作成されたかが確認できる。ネストを詳しく調べると、グラフを作成するのに使った元の二分木データを実際に表していることがわかる。

[source,groovy]
----
println t

[9:[5:[2:[1:[:]], 8:[:]], 11:[10:[:], 15:[22:[16:[:]]]]]]
----

'getObjectAtDepth'メソッドを使うと、ツリー構造をさらに調べることができる。

[source,groovy]
----
t.getObjectsAtDepth(1)

9

t.getObjectsAtDepth(2)

5
11

t.getObjectsAtDepth(3)

2
8
10
15

t.getObjectsAtDepth(4)

1
22

t.getObjectsAtDepth(5)

16
----

[[mapstr]]
=== map を使って連結された結果文字列を生成する

下記の例では、'map'を使って、イングランドの空港の、空港がある都市と連結された空港コードを含む文字列を構築する

[source,groovy]
----
g.V().has('airport','region','GB-ENG').limit(10).
  map{it.get().value('code')+" "+it.get().value('city')}
----

これは、クエリを実行した結果だ。

[source,groovy]
----
LHR London
LGW London
MAN Manchester
LCY London
STN London
EMA Nottingham
LPL Liverpool
LTN London
SOU Southampton
LBA Leeds
----


[[randwalk]]
=== グラフをランダムウォークする

グラフの分析を行うとき、ランダムにトラバースまたは、'ウォーク'したいことがある。下記の例は、オースティン(AUS) 頂点をスタートして、そこからランダムに5つの接続された頂点に移動するクエリを示している。'random walk'は、現在の頂点に接続されているエッジの1つを選択し、エッジのdistance プロパティを使ってサンプリングして、そのエッジの反対側の頂点に移動することによって実現される。

[source,groovy]
----
// Random walk with five hops
g.V().has('code','AUS').
      repeat(bothE('route').
         sample(1).by('dist').otherV()).
      times(5).
      path().by('code').by('dist')
----

下記は、クエリを5回実行した結果だ。各グラフウォークはAUSでスタートし、そこから5か所に進むことを確認できる。表示されるパスには、他の空港の名前とそれらの間の距離が表示されている。

[source,groovy]
----
[AUS,992,SFB,828,MDT,592,ORD,234,DTW,500,LGA]

[AUS,957,CVG,374,ATL,1890,SAN,2276,DCA,204,PIT]

[AUS,1209,PIT,1399,CUN,941,BJX,729,IAH,1384,BZN]

[AUS,748,MEX,1252,PHX,5255,LHR,2487,LXR,492,JED]

[AUS,722,STL,717,DCA,893,RSW,1103,HPN,563,CLT]
----

前の例では、すべてのランダムウォークが同じ場所から始まっている。しかしながら、毎回異なる空港からスタートして、よりランダムにウォークしたいのであれば、代わりに クエリの開始時に'sample'ステップを使って、'airport'ラベルがついたすべての頂点のセットからランダムに空港を選ぶとよい。

[source,groovy]
----
// Random walk with five hops
g.V().hasLabel('airport').sample(1).
      repeat(bothE('route').
        sample(1).by('dist').otherV()).
      times(5).
      path().by('code').by('dist')
----

下記に示すように、5回実行すると、各ウォークは異なる空港からスタートする。

[source,groovy]
----
[OMA,1144,LGA,584,CVG,750,BOS,6682,NRT,5951,VCE]

[CLE,244,ROC,263,JFK,8054,HKG,7952,BOS,7288,PVG]

[EMA,1126,AGP,969,PMO,708,VIE,5684,NRT,5152,DOH]

[SNN,387,LGW,1349,KBP,264,KHE,434,IST,2831,DEL]

[ARN,1814,LEI,1232,PRG,433,BRU,1384,SVO,3598,PEK]
----

クエリを書く他の方法には、'local'ステップの導入がある。この場合、'repeat'ステップはトラバーサルの現在のローカル状態に対して適用される。この方法では、複数のランダムウォークを得ることができる。クエリの最後にある'limit(5)'は返されるランダムウォークの数を5件に制限する。'local'ステップが削除されると、1つのウォークしか発生しないことに注意してほしい。

[source,groovy]
----
// Five random walks each of five hops
g.V().hasLabel('airport').
      repeat(local(bothE('route').
        sample(1).by('dist').otherV())).
      times(5).
      path().by('code').by('dist').limit(5) 
----

実行すると、下記に示すような5件の結果が返される。

[source,groovy]
----
[ATL,1301,ASE,845,SFO,2580,MIA,596,ATL,546,PBI]
[ANC,2547,PHX,1999,BWI,368,BOS,3576,CGN,4745,MIA]
[AUS,922,CUN,931,SAT,248,DAL,1378,LGA,736,MKE]
[BNA,630,DFW,1430,SJC,2110,ATL,2180,SEA,4868,AMS]
[BOS,3838,MUC,4024,JFK,8054,HKG,858,YNZ,901,HRB]
----

[[sevendegrees]]
=== 7次の隔たり！

いや、見出しの７という単語は毎違いではないので、読んでほしい。ほとんどの人はきっと有名な”6次の隔たり”理論について聞いたことがあることだろう。この理論は本質的に、実在する人にとって、「友達の友達」スタイルのつながりを使って、他の誰からも6つの友人関係よりも遠く離れている人はいないとする。

NOTE: ウィキペディアでの6次の隔たり理論に関しては、 https://en.wikipedia.org/wiki/Six_degrees_of_separation を参照してほしい。

air-routes データセットを使って実験を実行して、基地の孤立した頂点ではない空港が主要なハブ空港からどれだけ離れているかを調べるのはとても楽しい。この実験では、ロンドンヒースロー(LHR) 空港をターゲットとして使うことにした。

これを行うために、私は下記のクエリをひねり出した。最初にしたかったことはは、探している接続の数を確立することだった。

まず、グラフにある空港の数を再確認した。

[source,groovy]
----
g.V().hasLabel('airport').count()

3374
----

次に、経路がない孤立した空港がいくつかあるので、それを除外する必要があることを思い出した。これは、"<<noroutes>>" のセクションで説明したのと同じ手法を使って行うことができる。

[source,groovy]
----
g.V().hasLabel('airport').not(outE('route')).count()

16
----

なので、この実験で無視すべき空港が16件あることがわかる。我々が気にかける3358件の空港を残すが、そのうちの1つはLHRなので、巡回パスを探していないので、この空港もカウントに入れないようにする必要がある。したがって、残りの3357件の空港すべてとロンドンヒースローとの間に経路があることを証明するクエリが必要だが、孤立した空港とヒースロー自体を出発点として無視する。

クエリのコア部分を下記に示す。私はテスト目的で、1ホップだけを使うことから始めた。クエリはLHR と孤立したノードを無視することによって始まる。次に'local'スコープで'union'ステップを使って、出発空港からLHRの間の1ホップで単一のパスを見つけようとする。その結果、各開始空港について、開始空港からLHRへのすべての空港のコードを含んだパスになるか、あるいは、LHRに到達しなかった場合、パスには開始空港のみが含まれる。クエリのこの部分をテストするために、私はホップカウント１を使い、結果を10に制限した。

[source,groovy]
----
g.V().has('airport','code',neq('LHR')).
       filter(out('route').count().is(neq(0))).
       local(union(
              identity().values('code'),
              local(repeat(out().simplePath()).
                      emit().times(1).
                      has('code','LHR').
                      limit(1)).
              path().by('code')).
              fold()).
        limit(10)

----

ご覧の通り、これまでのクエリは機能しているようだ。開始空港とパスが返るか、経路が見つからなかった場合に開始空港だけが返る。これは'union'ステップを使って、少なくとも出発空港が返されることを保証しているからだ。'local'スコープは各開始空港ごとの結果を個別のリストに入れたいので、使われる。

[source,groovy]
----
[ATL,[ATL,LHR]]
[ANC]
[AUS,[AUS,LHR]]
[BNA]
[BOS,[BOS,LHR]]
[BWI,[BWI,LHR]]
[DCA]
[DFW,[DFW,LHR]]
[FLL]
[IAD,[IAD,LHR]]

----

クエリから欠落している最後の部分は、LHRに到達したかどうかを判断し、到達に成功した回数をカウントする方法だ。これは、返される結果の長さに複数の項目が含まれているかを確認することによって行われる。言い換えると、開始空港のコード以上のものが返ったか、である。これを行うために、'where'ステップは指定されたステップ数でLHRに到達しなかったパスを除外する。最後に、テストで行ったようにパスを表示するのではなく、開始空港のうち、LHRに到達できた数をカウントする。私の最初のテストでは、5ホップでLHRに到達できた空港の数を確認することにした。

[source,groovy]
----
g.V().has('airport','code',neq('LHR')).
      filter(out('route').count().is(neq(0))).
      local(union(
             identity().values('code'),
             local(repeat(out().simplePath()).
                     emit().times(5).
                     has('code','LHR').
                     limit(1)).
             path().by('code')).
             fold().
             where(count(local).is(gt(1)))).
      count()

3345
----

ご覧の通り、テスト中の、3357空港のうち33455空港から５ホップでLHRに到達できた。次に、クエリを再度実行したが、6ホップ使った。

[source,groovy]
----
g.V().has('airport','code',neq('LHR')).
      filter(out('route').count().is(neq(0))).
      local(union(
             identity().values('code'),
             local(repeat(out().simplePath()).
                     emit().times(6).
                     has('code','LHR').
                     limit(1)).
             path().by('code')).
             fold().
             where(count(local).is(gt(1)))).
      count()  

3354
----

したがって、6ホップで、3357の空港のうち、3354がLHRに到達することができた。次に、7ホップを試したところ、2つを除くすべての空港がLHRに到達できたことがわかった。

[source,groovy]
----
g.V().has('airport','code',neq('LHR')).
      filter(out('route').count().is(neq(0))).
      local(union(
             identity().values('code'),
             local(repeat(out().simplePath()).
                     emit().times(7).
                     has('code','LHR').
                     limit(1)).
             path().by('code')).
             fold().
             where(count(local).is(gt(1)))).
      count() 

3355
----

これは私の興味を引いた。私は孤立した空港でない限り、グラフ中に7ホップでLHRに到達できない空港はないとかなり確信していたが、すでにクエリの一部として除外していた。なので、念のため、30ホップで行くことにした。しかしながら、まだ3355の答えが返ってきた。

[source,groovy]
----
g.V().has('airport','code',neq('LHR')).
      filter(out('route').count().is(neq(0))).
      local(union(
             identity().values('code'),
             local(repeat(out().simplePath()).
                     emit().times(30).
                     has('code','LHR').
                     limit(1)).
             path().by('code')).
             fold().
             where(count(local).is(gt(1)))).
      count()

3355
----

これは私にとって興味深い結論を残した。グラフには孤立していない２つの空港がないといけない。つまり、経路がいくつかあるが、主要のネットワークから分離されている。なので、次のセクションの主題である、それらを見つけるクエリが必要だった。本セクションのクエリが証明したことは、グラフ内の任意の空港からさらに調査する必要のある２つのケースを除いて、ロンドンLHR に7ホップ以下で到達できることだ。したがって、本セクションのタイトルは、「6次の隔たり」ではなく、「7次の隔たり」になっているのだ。

[[mininetworks]]
==== 孤立したサブネットワークを見つける

上記で説明したように、前のセクションのクエリに取り組んでいる際に、グラフに2つの空港があり、それらは相互に経路を持っているが、それ自体メインの経路ネットワークに接続されていない小さなネットワークの一部なので、それらは真の孤立ではないことがわかった。言い換えると、そのネットワークはメイングラフ内の分離されたミニネットワークであり、どちらからもロンドンに到達することはできない。さらに分析した結果、これは実際には後続の更新で修正したデータセットのエラーが原因であることがわかったが、バージョン 0.77レベルの air-routes を使っているのであれば、下記のクエリは示した結果が得られる。

空港が欠けているパズルを解くために、私は7次の隔たりのクエリを若干変更するだけで済んだ。最新のバージョンのair-routes データセットを使っているのであれば、この特定のエラーは修正されるが、既存のメイングラフに他の孤立したネットワークがが見つかるので注意してほしい。しかしながら、これらはエラーによるものではなく、ポルトガルにはコミューター航空会社を介して相互接続された一連の空港があるが、それらのいずれかから主要な世界的な経路ネットワークに到達する方法がないからだ。

したがって、これが、修正されたクエリの形式だ。

[source,groovy]
----
g.V().has('airport','code',neq('LHR')).
      filter(out('route').count().is(neq(0))).
      local(union(
             identity().values('code'),
             local(repeat(out().simplePath()).
                     emit().times(7).
                     has('code','LHR').
                     limit(1)).
             path().by('code')).
             fold().
             where(count(local).is(1))).
       unfold()   
----

前のセクションで使ったクエリからこのクエリに加えられた唯一の変更は、'where'ステップが、'where(count(local).is(1)))'に変更され、長さが1のパスを検索するようになったことだ。これらは、LHR への経路が見つからなかった空港を表している。次に'count'ではなく、'unfold'を使って経路がなかった空港のコードを返す。

クエリを実行すると、ロンドンへの経路がなかった空港のコードが表示される。これらの空港は真に相互に接続されているが、メイン経路ネットワークからは分離されている。

[source,groovy]
----
HPB
VAK
----

調査したことを確認するために、いくつかのクエリを実行して、これらの各空港からの経路を再確認した。ご覧の通り、それらは相互に接続されているだけだっだ。

[source,groovy]
----
g.V().has('code','HPB').out().path().by('code')
[HPB,VAK]

g.V().has('code','VAK').out().path().by('code')
[VAK,HPB]
----

この演習が、面白くてかつ役に立つことが示され、エラーチェックをすり抜けたエラーがグラフにあることが明らかになった。

[[longestroutes]]
=== 最も多くの経由が必要な旅を探す

”指定された空港からスタートして、最も行くのが難しい場所はどこか？”のような質問を熟考するのは興味深い場合がある。この例のために、「行くのが難しい」を「最も多くのホップ数を必要とする」という意味として定義しょう。前のセクションのクエリを修正することにより、最長経路のいくつかを検出する方法を思いつくことができる。セクションの最後に、同じ結果を生成する他の方法を示す例も含めた。

下記に示すクエリは、オースティン(AUS) ではなく、出経路があるすべての空港を見つける。見つかった各空港ごとに、オースティンへ行くのに、10ホップ以下でたどり着けるかどうかを試みる。各空港ごとに試みは1回だけ行われる。10の値を使うことにしたのは、それ以上経由地はないだろうと、すでにかなり確信していたからだ。しかしながら、実際には、十分な大きさである限り、なんの値を使っても構わない。AUSに到達するやいなや、'emit'ステップが結果を返すことを考慮すると、100の値はクエリに悪影響を及ぼさない。　クエリは各開始空港からAUSへの単一のパスを見つける。クエリの最後の行の'where'ステップは、8ホップ以上の長さをもつパスを保持するだけだ。なので、本質的に、AUSとしてオースティンへ行くのに少なくとも7ホップかかる経路のみを見つけると言える。

[source,groovy]
----
g.V().has('airport','code',neq('AUS')).
      filter(out('route').count().is(neq(0))).
      local(repeat(out().simplePath()).
              emit(has('code','AUS')).
              times(10).limit(1)).
      path().by('code').
      where(count(local).is(gte(8))) 
----

実行すると、クエリが完了するのに数秒かかることがあるが、一般的なラップトップやデスクトップの場合よりも長くかかることはない。これがクエリを実行した結果だ。

[source,groovy]
----
[YPO,YAT,ZKE,YFA,YMO,YTS,YYZ,AUS]
[YZG,YIK,AKV,YPX,YGL,YUL,ATL,AUS]
[THU,NAQ,JUV,JAV,GOH,KEF,PIT,AUS]
----

クエリは、下記に示すように、'repeat'と、'until'ステップを使って書くこともできる。

[source,groovy]
----
g.V().has('airport','code',neq('AUS')).
      filter(out('route').count().is(neq(0))).
      local(repeat(out().simplePath()).
        until(has('code','AUS').or().loops().is(8)).
        has('code','AUS').limit(1)).
      path().by('code').
      where(count(local).is(gte(8)))
----

前と同様、同じ3つのパスが見つかった。

[source,groovy]
----
[YPO,YAT,ZKE,YFA,YMO,YTS,YYZ,AUS]
[YZG,YIK,AKV,YPX,YGL,YUL,ATL,AUS]
[THU,NAQ,JUV,JAV,GOH,KEF,PIT,AUS]
----

[[quicklyfindhardest]]
==== 空港に行くのが最も困難な場所を素早く見つける

「行きづらい」空港を見つけるクエリを書く方法は、他にもある。下記に示した手法は、本質的に、空港にアクセスするのを1回だけにするために重複排除戦略を使っていることに依存する。これは、'sideEffect'ステップが機能する方法とは異なることに注意してほしい。このステップにより、クエリはファンアウトして同じ頂点に多くの場所からアクセスする、多対１のタイプのパターンであるが、トラバーサルがそれ自体にループバックすることはできない。重複排除アプローチを使うことにより、頂点に正確に1回しかアクセスせず、クエリの進行中にその頂点の他のすべてのインスタンスを削除する。これにより、クエリプロセッサの処理量が大幅に軽減され、結果としてクエリの実行はより効率的になる。下記のクエリは、上記よりも、少しフィルタリングが少ないが、指定されたスタート地点から少なくとも到達するのに指定されたホップ数を必要とする宛先だけを探している場合は、うまく機能する。

今回は、オースティン(AUS) からスタートし、７ホップでしか行くことができない空港を探すことにした。途中で重複を削除しているという事実は、見つかった宛先へのより短い経路がないことを保証する。読み返しが得意なのであれば、結果が上記の結果とマッチするが、順序が逆になっていることがわかるだろう。

最初の例は、'store'ステップを使っていた場所を追跡し、7ホップが完了するまで、以前にアクセスしていない場所の場合のみ続行する

[source,groovy]
----
g.V().has('code','AUS').
      repeat(out().where(without('a')).store('a')).
        times(7).
      path().
        by('code')
----

御覧のとおり、結果は見覚えがある。

[source,groovy]
----
[AUS,YYZ,YUL,YGL,YPX,AKV,YIK,YZG]
[AUS,YYZ,CPH,SFJ,JAV,JUV,NAQ,THU]
[AUS,YYZ,YTS,YMO,YFA,ZKE,YAT,YPO]
----

これの別のバージョンのクエリは、'dedup'ステップを使って同じ結果を得る。ほとんどの Gremlin クエリエンジンでは、これは、少なくとも指定されたホップ数で到達可能なターゲットのみを探す効率的な方法だ。このクエリは"<<doesanyrouteexist>>"のセクションで使ったものに似ている。

[source,groovy]
----
g.V().has('code','AUS').
      repeat(out().dedup()).
        times(7).
      path().
        by('code')
----

再度、同じ結果が生成される。

[source,groovy]
----
[AUS,YYZ,YUL,YGL,YPX,AKV,YIK,YZG]
[AUS,YYZ,CPH,SFJ,JAV,JUV,NAQ,THU]
[AUS,YYZ,YTS,YMO,YFA,ZKE,YAT,YPO]     
----

グラフで最長の経路を探す場合、特に密に接続されている経路であれば、注意が必要だ。検索するのに、特別なターゲット、あるいは特定のホップ数をどのように選択するか注目してほしい。

NOTE: クエリの実行に非常に長時間かかる可能性があるので、最長のパスを探す場合は、慎重にすべきだ。

2つの空港間の最長の経路を任意に探すクエリを書こうとしている場合、非常に長時間実行されるクエリを書くリスクがある。多くの点で、「最長パス」の概念は、アンチパターンとみなすことができる。これは例えばair-routes のような、密に接続されているグラフで特に当てはまる。

[[unwantededges]]
=== 不要な並列エッジを見つける

一般的に言って、グラフには、同じ2つの頂点間に、同じ方向に複数のエッジが存在する理由はたくさんある。ほとんどのプロパティグラフシステムではこれを許容し、多くのデータモデルはこの機能を利用する。これらを並列エッジと呼ぶ。しかしながら、'air-routes'グラフでは、空港Aから空港Bへの単一のエッジを使って、経路の存在をモデル化している。同じ2つの空港間に複数のエッジが同じ方向にあれば、ここでは、エラーとみなされる。これには反対方法（BからA）に向かうエッジは含まれないことに注意してほしい。

'air-routes'グラフを開発しているさなかに、まだデータのクリーンアップをしているとき、誤って並列エッジがグラフに含まれるという問題に頻繁に遭遇した。私は、Gremlin を使えば、これらのエラーケースを検出できることに気づいた。

最初は、非常に基本的なことを試したが、それでも出力をかなり読み込む必要があった。次のクエリを使って、指定された空港に、他の空港への複数の発エッジがあるかどうかを確認した。これは私にとってどの空港頂点に問題があるかを事前に当たりをつけておくのに必要だった。グラフに3,300 を超える空港頂点がある場合、理想からは程遠い。

[source,groovy]
----
g.V().has('code','LHR').out().groupCount().by('code').
  order(local).by(values,desc).next().values().max()  
----

返ってきた答えが、1より大きい場合は、次のクエリを実行し、それぞれの結果を目視して、重複するエッジがどこにあるかを確認した。

[source,groovy]
----
g.V().has('code','LHR').out().groupCount().by('code').order(local).by(values,desc)
----

言ったように、これは非常に労力と時間を要する手順だった。明らかにもっと良いクエリが必要だった。'groupCount'について知っていることを踏まえると、すべての単一経路が何回存在するかを調べる任意のクエリを書くことができることがわかった。しかしながら、43,000 を超える経路があるので、手でそれをチェックすることはできなかった。なので、Gremlin でよくあることだが、クエリを段階的に作成した。まず、全ての経路がができるのをカウントするクエリを書いた。数10ページあるので、このクエリからの出力すべてを示していないが、示したものからお分かりだと思うが、この結果はまだすべての結果を調べるのに人の労力を必要とする。理想からは程遠いのだ。

[source,groovy]
----
g.V().as("a").out().as("b").groupCount().by(select("a","b"))

[[a:v[1],b:v[3]]:1,[a:v[1],b:v[6]]:1,[a:v[1],b:v[7]]:1 ...
----

次に、複数回発生する経路だけを選択するためにフィルタを追加した。マップをフィルタリングしい値のストリームに戻すために'filter'を適用する前に'unfold'を使う必要があった点に注意してほしい。

[source,groovy]
----
g.V().as("a").out().as("b").groupCount().by(select("a","b")).unfold().
                            filter(select(values).is(gt(1)))
----

次に、どの経路がエラーに含まれているかを把握するために、さらにステップを1つ追加した。

[source,groovy]
----
g.V().as("a").out().as("b").groupCount().by(select("a","b")).unfold().
                            filter(select(values).is(gt(1))).select(keys)
----

私が遭遇したエラーの1つは、LHR から JFK への経路を2回グラフに間違って追加してしまったことだ。LHR のID は49で、JFK のIDは12だ。上記のクエリを実行する際に、次の出力が返り、どの経路を修正する必要があるかが正確にわかった。これは明らかに前のに比べて非常に便利なクエリだ。この時点で停止できていたらうれしいが、クエリをさらに改善できるかを確認したかった。

[source,groovy]
----
[a:v[49],b:v[12]]
----

本当は空港コードを返したかったので、クエリに、全体的には満足いくものではなかった。なので、空港コードを使って、'groupCount'を実行するためにいくつかの調整を追加した。また、ステップが実行される前に何が返されるかがわかると理解の助けになると考え、このクエリの最後に'select(keys)'も残した。

[source,groovy]
----
g.V().as("a").out().as("b").select('a','b').by('code').groupCount().unfold()
                           .filter(select(values).is(gt(1)))
----

したがって、クエリを実行した際に返されるものは、空港コードと、並列エッジによって相互に接続されているように見える回数だ。これは実際には、'{}'の内容がキーで、=2 の部分が値である、キー/値のペアだ。グラフの間違いを修正するにはこれで十分である、と理にかなった主張が可能だ。しかしながら、他の状況で、役に立つとわかる可能性がある他に可能な改良点を示すために、2，3のステップをさらに追加したい。

[source,groovy]                                
----
{a=LHR, b=JFK}=2
----

'= 2'の部分を返したくないのであれば、キーの部分を選択するだけでよい。

[source,groovy]
----
g.V().as("a").out().as("b").select('a','b').by('code').groupCount().unfold()
                           .filter(select(values).is(gt(1))).select(keys)
----

これが、今返されるものだ。キー自体は、'as'ステップの'a and b'用語を使って、マップに返される点に注意してほしい。

[source,groovy]
----
[a:LHR,b:JFK]
----

これは、ほぼ正確に私が求めたことではあるが、返されるマップから値を選択するだけで出力をクリーンアップするために小さなステップをさらにもう1つ追加することができる。

[source,groovy]
----
g.V().as("a").out().as("b").select('a','b').by('code').groupCount().unfold()
                           .filter(select(values).is(gt(1))).select(keys).select(values)
----

したがって、これが修正が必要な並列エッジがある空港のコードだけの最終的な出力だ。

[source,groovy]
----
[LHR,JFK]
----

TIP: この問題を解くために、私がGremlin クエリを段階的に構築したやり方に注意してほしい。私は、作成する必要があるかもしれない最も基本的なクエリを除くすべてにアプローチする賢明な方法としてこれをお勧めする。このようにすると、さらなる部分をクエリに追加する前に、クエリの各部分が意図した方法で機能していることををチェックすることもできる利点がある。

[[groupcountpath]]
==== パスで groupCount を使って重複するエッジを見つける

前の例では、'select'と'groupCount'ステップを使って作成したマップを使って重複するエッジを見つけた。'groupCount'ステップの内側で'path'ステップを使って、同じ結果を得ることも可能だ。

まず、オースティン (AUS) とカンクン(CUN) の間に重複するエッジを作成しよう。

[source,groovy]
----
g.V().has('code','AUS').addE('route').to(V().has('code','CUN'))

e[53791][3-route->180]
----

これで'path'ステップを内包する'groupCount'ステップを使ってオースティンにある重複するエッジを探すことができるようになった。出力の量を少し減らすためだけに'limit'ステップを使った。

[source,groovy]
----
g.V().has('code','AUS').out().
      groupCount().by(path().by('code')).limit(local,5)
----

下記の結果からわかるように、AUS と CUN の間の経路には2つのカウントが関連づけられている。

[source,groovy]
----
[[AUS,CUN]:2,[AUS,MDW]:1,[AUS,MIA]:1,[AUS,DFW]:1,[AUS,BWI]:1]
----

この手法は前のセクションで示したクエリ全体を置き換えるものではない点に注意してほしい。'path'ステップを'groupCount'ステップ内に配置して、有用な結果をいくつか得られることを示すことを目的としている。

[[flr]]
=== グラフ内で隣接する2つの空港間で最長の飛行経路を見つける

本セクションでは、ある意味、Gremlin クエリ言語の長所、短所に関するケーススタディである。ここでは、単一のGremlin クエリとして表現されたとても単純な質問であると私が考えたものを取得するために行ってきた学習手順をドキュメント化した。このドキュメントはGremlin を使う際のよい面、悪い面、そして時には酷い側面が反映されている。良い面として、強力で、簡単であるべきことは簡単である。悪い面として、簡単に見えるものの中には、実際には正しく理解するのが非常に難しいものがある。特に、一連の小さなプログラムステップに分割するのではなく、単一のクエリを構築して、あるジョブを実行したい場合はなおさらだ。実際のクエリを使って、この例を見てみよう。

構築したいクエリはグラフ内で任意の2つの空港間の最長の経路を見つけることだ。最長の経路が複数ありうるケース（この例では異なる経路として同じ2つの空港間の戻りのフライトはカウントされない）を処理したい場合は、この単純に見えるクエリを正しく実行するために多くの処理を必要とすることがわかる。

下記に示すように、'max'ステップを使っている際、必要なことを実行するのが明らかで簡単に思えるかもしれないが、'max'の実装方法が原因でおそらく機能しないだろう。現在、'max'と'min'ステップにより、トラバーサル中に所得される前のパスは失われる。これにはTinkerPopに未解決の問題があるが、その問題が解決されるまで、求める結果が得られる他の方法を調査する必要がある。

[source,groovy]
----
g.E().hasLabel('route').as('e').values('dist').max().select('e')
----

まず、これを行うことができる（下記）。このアプローチの欠点は両方のクエリが、たくさんのエッジを見る必要があり、処理に多くのメモリとCPUを使う可能性があることだ。

[source,groovy]
----
r=g.E().hasLabel('route').values('dist').max().next()
g.E().has('dist',r).bothV().values('code')
----

ID を使うと、エッジは1回しか参照されないので、この次のクエリは、より効率的だが、このアプローチは複数の経路が同じ(最大）の長さであり、成功基準を満たさない場合に見逃す。

[source,groovy]
----
r=g.E().hasLabel('route').as('e').order().by('dist', desc).limit(1).select('e').id().next()
g.E(r).dist
g.E(r).bothV().values('code')
----

このクエリは、TinkerPop チームの Daniel Kuppitz がメーリングリストでこれを議論した後で推奨したものであり、実際には機能するが、このクエリを構築するための実験をどこから始めたのか、は些細なことではない。

[source,groovy]
----
g.E().hasLabel("route").order().by("dist", desc).store("d").by("dist").
  filter(values("dist").as("cd").select("d").by(limit(local, 1)).as("md").where("cd",eq("md"))).
  project("from","to","dist").by(outV()).by(inV()).by("dist")        
----

最後に、頂点だけでなく、空港コードを出力するために、下記のようにクエリを再度微調整するとよい。

[source,groovy]
----
g.E().hasLabel("route").order().by("dist",desc).store("d").by("dist").\
  filter(values("dist").as("cd").select("d").by(limit(local, 1)).as("md").where("cd",eq("md"))).\
  project("from","to","dist").by(outV().values('code')).by(inV().values('code')).by("dist") 
----

これで、クエリを実行する準備が整った。これはそれからの出力である。両方の経路が同じ都市ペア間にあることに注目してほしい。クエリをさらに詳細化して、このような組み合わせを1回しか表示しないようにすることもできるが、読者の練習問題として残しておく。

[source,groovy]
----
[from:DXB,to:AKL,dist:8818]
[from:AKL,to:DXB,dist:8818]
----

[[miscq]]
=== その他のクエリ

本セクションにおける例は、まだ検討する機会がないいくつかのその他の機能とクエリを示している。時間の経過とともに、これらのクエリはおそらく本書の他のセクションに移す必要があるだろう。

==== is ステップ内で計算を使う

'is'ステップ内で数式を使うことができる。これは非常に便利なことがある。下記の例は、テストの一部として、単に500 を 2で除算するだけだ。明らかに通常は、250と入力するだけだが、これは機能を示している。

[source,groovy]
----
g.V().hasLabel('airport').where(out().count().is(gt(500/2))).values('code')

CDG
FRA
AMS
IST
----

この機能は、変数と組み合わせて使うと、より面白くなる。

[source,groovy]
----
a = 500

g.V().hasLabel('airport').where(out().count().is(gt(a/2))).values('code')

CDG
FRA
AMS
IST
----

これは、変数'a'を任意の空港からの経路数の最大値を表す値に設定するところから始まるもう1つの例だ。クエリを使って、少なくとも、値'a'よりも50少ない発経路を持つすべての空港を見つける。

[source,groovy]
----
a = g.V().local(out('route').count()).max().next()

g.V().hasLabel('airport').where(out().count().is(gt(a-50))).
      project('apt','routes').by('code').by(out().count())

[apt:ATL,routes:232]
[apt:ORD,routes:232]
[apt:CDG,routes:262]
[apt:FRA,routes:272]
[apt:DXB,routes:230]
[apt:PEK,routes:234]
[apt:AMS,routes:269]
[apt:MUC,routes:237]
[apt:IST,routes:270]
----


[[beyond]]
== コンソールとTinkerGraph を超えて移動する

これまで見てきたほとんどの例は、Gremlin コンソール と TinkerGraph のインメモリグラフをすべて1台のマシンで実行して作成したものだ。しかしながら、Gremlin とオプションの Gremlin コンソールを使いながらも、デプロイして、グラフとやり取りをする方法はたくさんあり、それらの多くは、単一のマシンですべてを実行するだけではない。例えば、Apache TinkerPop パッケージには、Gremlin サーバと呼ばれるコンポーネントが含まれている。Gremlin サーバを使えば、グラフデータベースをローカルに、あるいはリモートにホストすることができ、HTTPや WebSockets を介して通信することができる。Gremlin コンソールはローカル、リモート両方のグラフへのアクセスサポートする。また、独自のコードや他のツール、あるいは'curl'などのようなコマンドラインユーティリティを使ってグラフにアクセスできる。

本番環境では、バックエンドにHBase や Cassandra などを使ったJanusGraph のようなテクノロジと、Solr やElasticsearch のようなインデックス技術を使うことが多い。このような場合、グラフを操作および管理する方法と、クエリ結果が返される方法は別物だ。

返されるデータが他のものに埋め込まれたGraphSON (JSON) 形式のこともあれば、プログラムの変数として返されることもある。Python Notebook から Gremlin を使ってグラフを操作する方法もある。独自のオンプレミスグラフシステムを構築することも、ホストされたサービスを使ってもよい。Gremlin コンソール を介してGremlin サーバを使ってリモートグラフに接続することもできるが、'curl'やその他の HTTP/REST タイプのテクノロジを使うこともできる。以上、基本的なことからシステムを本番運用に移すまで、様々な選択肢を検討する必要があることを説明した。

本セクションでは、これらのより洗練された環境から例の選択を見つける。本書のこれまでの焦点は、学習環境として、Gremlin コンソールと TinkerGraph を使ってGremlin クエリとトラバーサル言語を教えることだった。しかしながら、少なくとも他の環境について、設定する方法やなぜそれを使うのかについて触れることなく、議論を終えることはできない。続くセクションは、Gremlin コンソールを超えてグラフアプリケーションプログラミングの世界へ移行し、グラフシステムをデプロイする意欲を掻き立てる試みである。

[[javatinker]]
=== Java アプリケーションから TinkerGraph を操作する

本書のこれまでのところ、Gremlin コンソールから TinkerGraph を操作する数多くの方法を見てきた。より洗練されたアプリケーションを作成し始めると、Gremlin コンソールはツールボックスに用意しておきべきツールの1つにしか過ぎないことがわかる。確かではないかもしれないが、グラフを操作することができるスタンドアロンのアプリケーションを書きたくなるだろう。現在 TinkerPop 3 で利用可能な様々な言語バインディングがある。最も広く使われているものの1つが、Java API だ。Apache TinkerPop 自体Java でコーディングされている。

NOTE: 本書に関するGitHub リポジトリに、いくつかのJava のサンプルがある。
https://github.com/krlawrence/graph

すでに簡単に説明したように、商用アプリケーションを構築する場合、ACID トランザクションのような機能が必要となることがあり、その場合、グラフデータベースとしてTinkerGraph は使わないだろう。しかしながら、TinkerGraph が必要としているものに合致する場合もある。1つの例は、ラップトップのメモリ上に収まる静的なグラフで分析を行う場合だ。'air-routes'グラフはそのようなグラフの良い例だ。様々なデータベースバックエンドを使うスタンドアローンアプリケーションを書く上での最初のステップとして、Gremlin と TinkerGraph を使う Java アプリケーションの作成方法のいくつかの例を見てみよう。

[[tpinterfaces]]
==== Apache TinkerPop インタフェースとクラス

Apache TinkerPop プロジェクトで定義された Java インタフェースやクラスは多くあり、それらに精通したいだろうと思う。最新の JavaDoc 形式の API ドキュメントは常に、 http://tinkerpop.apache.org/javadocs/current/full にある。

TinkerPop JavaDoc は英語の散文としてやや説明不足な面があるが、それでも、メソッド、パラメータ、型に関してリファレンス情報の有用なソースだ。いくつかのテストプログラムを書いてテストを実行すると、きっと進捗がはかどるはずだ。そのため、私は本書に盛り込んだサンプルコードを参照することをお勧めする。

Gremlin コンソールを使う場合は、環境はあらかじめ設定されているので、クラスやインタフェースをインポートする必要はない。しかしながら、スタンドアローン Java アプリ家s－本のドメインに移るやいなや、構築しているアプリケーションに関連するクラスのインポートを始め、Gremlin コンソールがあなたに代わって実行していたことに気づいていなかった可能性のある他のいくつかのことを実行する方法を学ぶ必要になるだろう。

理にかなったスタート方法として、これは多数のGremlin タスクをJava アプリケーションから実行できるようにするためのいくつかのインポートだ。アプリケーションに機能を追加する際には、もちろん、さらに適切なインポート文を追加する必要がある。

2行目の、"\_\_" (アンダースコア、アンダースコア）というかなり奇妙なクラスのインポートに特に注意してほしい。これは、('repeat'ステップ内など) "ドット" でアタッチする、先のステップがないトラバーサルで'in()'や'out()'などのようなメソッドを呼べるようにするために必要になる。コードで明示的に、".\_\_"を使えるようにする"\_\_" クラスを静的にインポートできるのを好む場合は、本書の前の方で説明したように、予約語の競合に直面した場合を除いて不要だ。

[source,java]
----
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__;
import org.apache.tinkerpop.gremlin.process.traversal.Path;
import org.apache.tinkerpop.gremlin.process.traversal.*;
import org.apache.tinkerpop.gremlin.structure.Edge;
import org.apache.tinkerpop.gremlin.structure.Vertex;
import org.apache.tinkerpop.gremlin.structure.io.IoCore;
import org.apache.tinkerpop.gremlin.tinkergraph.structure.*;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.Set; 
----

[[javatp1]]
==== 最初のTinkerPop Javaプログラムを書く

これで、いくつかのインポートが完了したので、Java アプリケーションの基本的なアウトラインの作成を始めることができる。下記のコードは、'TinkerGraphTest'というクラスを定義し、メモリ内にTinkerGraph を作成し、'main'メソッドを定義し、air routes GraphML データをロードする。今はJavaプログラムとして実行しようとしているので、例外をキャッチする必要があることに注意してほしい。これはGremlin コンソールで作業している際には隠蔽されている別のものだ。

TIP: TinkerGraphTest.java のソースコードは、 https://github.com/krlawrence/graph/tree/main/sample-code にあるsample-code フォルダに置いてある。

最後に、この初期クラスの定義で GraphTraversalSource を作成し、Gremlin クエリを作成してオースティン空港頂点のプロパティ valueMap  を取得して出力する。'Map'に用意されている'toString'メソッドにより、有用な出力がもたらされるはずだ。next() の呼び出しには注意してほしい。これによりグラフトラバーサルが終了し、結果が返される。この呼び出しをなくすと、期待したものが返らなくなる。

[source,java]
----
public class TinkerGraphTest 
{
  public static void main(String[] args) 
  {
    TinkerGraph tg = TinkerGraph.open() ;

    try
    {
      tg.io(IoCore.graphml()).readGraph("./air-routes.graphml");
    }
    catch( IOException e )
    {
      System.out.println("File not found");
      System.exit(1);
    }
    GraphTraversalSource g = tg.traversal();
    Map<String,?> aus = g.V().has("code","AUS").valueMap().next();
    System.out.println(aus);
  }
}
----

[[javacompile]]
==== コードをコンパイルする

プログラムをテストする前に、もちろんコンパイルする必要がある。実験中にこれを行う最も簡単な方法は、Java 'classpath'に TinkerPop JAR ファイルが含まれるように、セットアップすることだ。より大きなソリューションの作成に取り掛かると、Apache Maven のようなツールを使ってビルドを制御することになるだろう。ここでの実験では、'classpath'を簡単に使うだけで十分だ。

次の Bash シェルスクリプトの行は、小さなテストプログラムのビルドと実行の両方に必要なものをセットアップしている。GREMLIN 変数はTinkerPop JAR ファイルが置かれている場所のルートディレクトリを指す用に設定する必要があることに注意してほしい。後ほど、JanusGraph を使い始める際に、TinkerGraph ではなくJanusGraph JAR ファイルを指すようにこれらの設定を調整する必要があることがわかる。

----
# Root directory for Gremlin Console install
GREMLIN=...

# Path to Gremlin core JARs
LIBPATH=$GREMLIN/lib/*

# Path to TinkerGraph JARs
EXTPATH=$GREMLIN/ext/*

#Path to additional JARs
ADDL=$GREMLIN/ext/tinkergraph-gremlin/lib/*

# Classpath
export CP=$CLASSPATH:$LIBPATH:$EXTPATH:$ADDL 


# Compile
javac -cp $CP TinkerGraphTest.java
----

これまでにコーディングしたものがすべて正常にコンパイルされたと仮定すると、以前に作成したものと同じ'classpath'を使って実行できる。

----
# Run
java -cp $CP TinkerGraphTest
----

返される出力は次のようになる。もしそうであれば、初めてのTinkerPop 対応 Java アプリを正しく構築して実行できたので、お祝いに30秒間、お祝いしよう。

[source,java]
----
{country=[US], code=[AUS], longest=[12250], city=[Austin], elev=[542], icao=[KAUS], lon=[-97.6698989868164], type=[airport], region=[US-TX], runways=[2], lat=[30.1944999694824], desc=[Austin Bergstrom International Airport]}
----

[[javaadd]]
==== Javaプログラムに追加する

これで、コンパイルして実行する基本的なスケルトンアプリケーションができたので、さらに実験を追加し始めることができる。下記の2行を追加すると、生成した値のマップから都市名を抽出することができる。これより、プログラムに追加するとき、追加する行と、それらの新しい行が生成する追加の出力を表示する。

[source,java]
----
List city = (List)(aus.get("city"));
System.out.println("The AUS airport is in " + city.get(0));  
----

なので、コンパイルして再度実行するときは、この追加の出力行を参照すること。

[source,console]
----
The AUS airport is in Austin
----

値のマップで返されたすべての値をきれいに出力したいのであれば、次のようにするとよい。

[source,java]
----
aus.forEach( (k,v) -> System.out.println("Key: " + k + ": Value: " + v));
----

これにより、この出力が生成される。

[source,java]
----
Key: country: Value: [US]
Key: code: Value: [AUS]
Key: longest: Value: [12250]
Key: city: Value: [Austin]
Key: elev: Value: [542]
Key: icao: Value: [KAUS]
Key: lon: Value: [-97.6698989868164]
Key: type: Value: [airport]
Key: region: Value: [US-TX]
Key: runways: Value: [2]
Key: lat: Value: [30.1944999694824]
Key: desc: Value: [Austin Bergstrom International Airport]
----

これで、頂点からプロパティ値を取得して操作する方法の１つがわかった。それでは、プログラムにもう少し面白いものを追加しよう。次の2行は、ダラスフォートワース(DFW) から経由地なしで飛ぶことができる空港の数をカウントし、その結果を出力する。

[source,java]
----
Long n = g.V().has("code","DFW").out().count().next();
System.out.println("There are " + n + " routes from Dallas");
----

[source,console]
----
There are 221 routes from Dallas
----

次に、DFWから直行便で飛ぶことができるこれらの221 の空港のIATAコードを取得するためのコードを追加しよう。今回は、'toList()'メソッドの呼び出してクエリを終了した点に注意してほしい。これによりトラバーサルが終了し、名前が示すように、結果がリストで返される。'order'ステップはトラバーサルで使われ、空港コードが昇順で返される。

[source,java]
----
List fromDfw = g.V().has("code","DFW").out().
                     order().by("code").values("code").toList();

System.out.println(fromDfw);
----

返される新しい出力は次のようになる。

[source,java]
----
[ABI, ABQ, ACT, AEX, AGU, AMA, AMS, ANC, ASE, ATL, AUH, AUS, BDL, BHM, BIL, BIS, BJX, BKG, BMI, BNA, BOG, BOI, BOS, BPT, BRO, BTR, BWI, BZE, BZN, CAE, CCS, CDG, CHA, CHS, CID, CLE, CLL, CLT, CMH, CMI, CNM, COS, COU, CRP, CUN, CUU, CVG, CVN, CZM, DAY, DCA, DEN, DOH, DRO, DSM, DTW, DUS, DXB, EGE, ELP, EVV, EWR, EZE, FAR, FAT, FCO, FLL, FRA, FSD, FSM, FWA, GCK, GCM, GDL, GEG, GGG, GIG, GJT, GLH, GPT, GRI, GRK, GRR, GRU, GSO, GSP, GUA, GUC, HDN, HKG, HNL, HOU, HSV, IAD, IAH, ICN, ICT, IND, JAC, JAN, JAX, JFK, JLN, KOA, LAS, LAW, LAX, LBB, LCH, LEX, LFT, LGA, LHR, LIM, LIR, LIT, LRD, MAD, MAF, MBJ, MCI, MCO, MEI, MEM, MEX, MFE, MGA, MGM, MHK, MIA, MID, MKE, MLI, MLM, MLU, MOB, MSN, MSP, MSY, MTJ, MTY, MYR, MZT, NAS, NRT, OAK, OGG, OKC, OMA, ONT, ORD, ORF, PBC, PBI, PDX, PEK, PHL, PHX, PIA, PIB, PIT, PLS, PNS, PSP, PTY, PUJ, PVG, PVR, QRO, RAP, RDU, RIC, RNO, ROW, RSW, RTB, SAF, SAL, SAN, SAT, SAV, SBA, SCL, SDF, SEA, SFO, SGF, SHV, SJC, SJD, SJO, SJT, SJU, SLC, SLP, SMF, SNA, SPI, SPS, STL, SUX, SWO, SYD, TLH, TPA, TRC, TUL, TUS, TVC, TXK, TYR, TYS, UIO, VPS, XNA, YEG, YUL, YVR, YYC, YYZ, ZCL]
----

次の行は、ロンドンヒースローから米国内の任意の空港までのすべての経路を見つける。各パスには、空港コードとそれらの間の距離が含まれているパスのリストが返される。

[source,java]
----
List <Path> lhrToUsa = g.V().has("code","LHR").outE().inV().
                             has("country","US").
                             path().by("code").by("dist").toList();

lhrToUsa.forEach((k) -> System.out.println(k));   
----

出力はこのようになる。読みやすくするために結果をカラムに配置した。

[source,java]
----
[LHR, 4896, PDX]     [LHR, 4820, IAH]    [LHR, 3665, IAD]
[LHR, 3980, CLT]     [LHR, 4414, MIA]    [LHR, 3860, RDU]
[LHR, 3254, BOS]     [LHR, 4001, MSP]    [LHR, 4783, SEA]
[LHR, 3622, BWI]     [LHR, 3440, JFK]    [LHR, 3939, ORD]
[LHR, 4198, ATL]     [LHR, 5439, LAX]    [LHR, 5255, PHX]
[LHR, 4901, AUS]     [LHR, 5469, SAN]    [LHR, 5350, SFO]
[LHR, 4736, DFW]     [LHR, 4850, SLC]    [LHR, 3753, DTW]
[LHR, 5352, SJC]     [LHR, 3453, EWR]    [LHR, 4655, DEN]
[LHR, 4616, MSY]     [LHR, 5213, LAS]    [LHR, 3533, PHL]
----

最初のJava プログラムの最後の部分は、単純な'repeat'操作を実行する方法を示している。下記のコードはオースティンから途中経由1回で行くことができる英国内の都市を探す。ここで注意すべき重要な点は、out() の呼び出しの前に、TinkerPop でのJava の使用に関する議論の冒頭で述べた奇妙な名前のクラス"\_\_." をつける必要がある、ということだ。"\_\_." のプレフィクスを付けなかったら、コンパイラが、'out'ステップがどこからなのかわからないので、コンパイルエラーが発生するだろう。

[source,java]
----
List <Object> eng = 
      g.V().has("code","AUS").repeat(__.out()).times(2).
            has("region","GB-ENG").values("city").dedup().toList();

System.out.println("\nPlaces in England I can get to with one stop from AUS.\n");
eng.forEach( (p) -> System.out.print(p + " ")); 
----

追加したことは次のような出力を生成するはずだ。

[source,console]
----
Places in England I can get to with one stop from AUS.

Birmingham Bristol London Manchester Leeds Newcastle
----

[[javastatics]]
==== 知っておくべき重要なクラスと列挙型

すでに述べたように、Gremlin コンソールを使っている場合、スタンドアロンのJava コードを書くときに自分で気にする必要があるいくつかが行われる。コンソールから Java へジャンプする人々が混乱していることに気づいた重要な領域は、どのクラスや列挙子が「舞台裏で」静的にインポートされているのか、Javaからそれらの同じ機能へどのようにアクセスされるのかを理解することだ。下記で説明するすべてのクラスや列挙子のより詳しい説明を見つけることができるので、TinkerPop javadoc のページもブックマークしておくべきだろう。最新のjavadoc は常に、 http://tinkerpop.apache.org/javadocs/current/full/ にある。

TIP: TestImports.java というサンプルプログラムが、 https://github.com/krlawrence/graph/tree/main/sample-code にある sample-code フォルダにあり、これらの構成が使われていることが示されている。

下記の表は、左側のカラムに、一般的に使われるGremlin キーワードを示す。2つ目のカラムにはJava プログラムからこれらの同じキーワードを明示的に参照する方法を示している。3つ目のカラムは、Javaプログラムで使われる可能性のあるコンテキストの例を示している。これらのクラスの一部をコードへ静的にインポートする選択することができる。私は明示的なプレフィクスを使うのを好むが、多くの場合、それは個人的な好みの問題である。使用可能なすべての述部の表が "<<tranges>>"のセクションにある。特別な +++".__"+++ クラスについては、いくつかの例を示した。一般に、このプレフィクスを使うのは、”ドットチェイン" できるクエリの前に何もない場合だ。

頂点に追加される際に、プロパティの値がどのように扱われるべきかを指定する必要があるのであれば、VertexPropertry インタフェースの一部である Cardinality 列挙子 の一部として定義されているキーワードの1つを使うとよい。

.カーディナリティ
[cols="1,1,3"]
|==============================================================================
|single  | Cardinality.local | property(Cardinality.single,"mykey","ABC")
|list    | Cardinality.list  | property(Cardinality.list,"mykey","ABC")
|set     | Cardinality.set   | property(Cardinality.set,"mykey","ABC") 
|==============================================================================

ソート順方向のパラメータとしてローカルスコープを指定する必要がある場合、'Scope'や'Order'列挙子で定義されたスタティクスを使うことができる。

NOTE: Order.incr や Order.decr の列挙子は TinkerPop 3.3.4 リリースで廃止され、Order.asc や Order.desc が採用され、キーワードを他の一般的に使われるクエリ言語とより一致させるようになった。TinkerPop 3.5.0 の時点で、incrと decr はGremlin クエリ言語から完全に削除された。

.スコープと順序付け
[cols="1,1,3"]
|==============================================================================
|local   | Scope.local    | order(Scope.local)
|global  | Scope.global   | order(Scope.global)
|desc    | Order.desc     | order().by(Order.desc)
|decr    | Order.decr     | order().by(Order.decr)  [Deprecated since 3.3.4, removed
in 3.5.0]
|asc     | Order.asc      | order().by(Order.asc)
|incr    | Order.incr     | order().by(Order.incr)  [Deprecated since 3.3.4, removed
in 3.5.0]
|shuffle | Order.shuffle  | order().by(Order.shuffle)
|==============================================================================

マップデータ構造からキーや値にアクセスする必要がある場合、'Column'列挙型で定義されたスタティックを使うことができる。

.キーと値
[cols="1,1,3"]
|==============================================================================
|keys    | Column.keys    | order().by(Column.keys)
|values  | Column.values  | order().by(Column.values)
|==============================================================================

'valueMap'から'id'と'label'の値にアクセスするときは、'T'列挙子て定義されたスタティックを使う必要がある。一連のプロパティからキーと値にアクセスする場合も同様。

.ラベルとID
[cols="1,1,3"]
|==============================================================================
|label   | T.label        | valueMap(true).next().get(T.label)
|id      | T.id           | valueMap(true).next().get(T.id)
|key     | T.key          | properties().order().by(T.key)
|value   | T.value        | properties().order().by(T.value)
|==============================================================================

"ドットチェイン"への前のステップがない場合は、プレフィクスとして ".\_\_" クラスを使うことができる。このクラスの javadoc を見ると、下記に示すような場合に、Gremlin 機能を呼び出すために使うことができる静的メソッドが定義されていることがわかる。

.匿名参照
[cols="1,1,3"]
|==============================================================================
|out     | +++__+++.out         | repeat(+++__+++.out())
|in      | +++__+++.in          | order().by(+++__+++.in("contains"))
|constant| +++__+++.constant    | union(+++__+++.constant("b"),+++__+++.constant("a"))
|==============================================================================

テストを実行するために述部を使う必要がある場合はいつでも、'P'クラスで定義された静的メソッドを使うとよい。定義されているすべてのメソッドが下記に示されているわけではない。

.述部
[cols="1,1,3"]
|==============================================================================
|gt      | P.gt           | has("runways",P.gt(3))
|gte     | P.gte          | has("runways",P.gte(5))
|lt      | P.lt           | has("runways",P.lt(2))
|lte     | P.lte          | has("runways",P.lte(2))
|eq      | P.eq           | has("city",P.eq("Dallas"))
|neq     | P.neq          | has("city",P.neq("Dallas"))
|within  | P.within       | has("city",P.within("Dallas","Austin"))
|without | P.without      | has("city",P.without("Dallas"))
|inside  | P.inside       | has("runways",P.inside(3,5))
|outside | P.outside      | has("runways",P.outside(2,5))
|between | P.between      | has("runways",P.between(2,5))
|==============================================================================

Apache TinkerPop リリース 3.4 では、いくつかの新しいテキスト述部と新しい TextP クラスが導入された。

.テキスト述部
[cols="1,1,3"]
|==============================================================================
|startingWith    | TextP.startingWith     | has("city",TextP.startingWith("Dal"))
|endingWith      | TextP.endingWith       | has("city",TextP.endingWith("as"))
|containing      | TextP.containing       | has("city",TextP.containing("all"))
|notStartingWith | TextP.notStartingWith  | has("city",TextP.notStartingWith("Dal")) 
|notEndingWith   | TextP.notEndingWith    | has("city",TextP.notEndingWith("as"))    
|notContaining   | TextP.notContaining    | has("city",TextP.notContaining("all"))   
|==============================================================================

トラバーサルパスに、"'x'"などの単一のラベルに関連づけられた複数の値がある場合、'Pop'列挙子の一部として定義されている'first'、'last'、'all'、'mixed'のスタティックを使うことができる。名前が示す通り、'first'はコレクションの最初の項目を返す。'last'を指定すると最後の項目が返され、'all'はコレクションの全要素が返される。'mixed'を指定すると、コレクションに複数の項目があれば、'List'が返される。そうでなければ、'Object'が返される。

.First, last, all、そして mixed
[cols="1,1,3"]
|==============================================================================
|first   | Pop.first      | select(Pop.first,"x")
|last    | Pop.last       | select(Pop.last,"x")
|all     | Pop.all        | select(Pop.all,"x")
|mixed   | Pop.mixed      | select(Pop.mixed,"x")
|==============================================================================

'sack'を操作する場合、'sum'や'assign'などの演算子は'Operator'列挙子で定義される。

.演算子
[cols="1,1,3"]
|==============================================================================
|sum     | Operator.sum   |sack(Operator.sum)
|minus   | Operator.minus |sack(Operator.minus)
|mult    | Operator.mult  |sack(Operator.mult)
|div     | Operator.div   |sack(Operator.div)
|assign  | Operator.assign|sack(Operator.assign).by(constant(0))
|min     | Operator.min   |sack(Operator.min)
|max     | Operator.max   |sack(Operator.max)
|addAll  | Operator.addAll|sack(Operator.addAll)
|and     | Operator.and   |sack(Operator.and)
|or      | Operator.or    |sack(Operator.or)
|==============================================================================

'Direction'列挙子は、エッジの方向に関連して使われる定数を定義する

.方向
[cols="1,1,3"]
|==============================================================================
|IN      | Direction.IN   | myEdge.vertices(Direction.IN)
|OUT     | Direction.OUT  | myEdge.vertices(Direction.OUT)
|BOTH    | Direction.BOTH | myEdge.vertices(Direction.BOTH)
|==============================================================================

'Pick'列挙子は'branch'、'choose'、'option'ステップに関連して使われる定数を定義する。

.Pick
[cols="1,1,3"]
|==============================================================================
|none    | Pick.none      | option(none,constant('no match'))
|any     | Pick.any       | option(any,constant('any picked'))  
|==============================================================================

Gremlin ユーザメーリングリストで共有された他の便利なヒントは、コマンド':show imports'を使って「舞台裏で」インポートされたすべてのリストを表示するように Gremlin コンソールに要求できることだ。通常返される可能性のあるものはを下記に示す。出力にバージョンチェックを含めたので、将来これが変更された場合に備えて、クエリした Gremlin のバージョンを確認できる。

[source,groovy]
----
gremlin> Gremlin.version
==>3.4.10
----

これは、Gremlin コンソールが開始時に静かにセットアップしてくれたインポートのリストである。'static'インポートであるものは、上記で説明した定義を含むものなので、特に注意してほしい。

[source,groovy]
----
gremlin> :show imports
Custom imports:
  org.apache.tinkerpop.gremlin.structure.*
  org.apache.tinkerpop.gremlin.structure.util.*
  org.apache.tinkerpop.gremlin.structure.util.reference.*
  org.apache.tinkerpop.gremlin.process.traversal.*
  org.apache.tinkerpop.gremlin.process.traversal.step.*
  org.apache.tinkerpop.gremlin.process.traversal.step.util.*
  org.apache.tinkerpop.gremlin.process.remote.*
  org.apache.tinkerpop.gremlin.structure.util.empty.*
  org.apache.tinkerpop.gremlin.structure.io.*
  org.apache.tinkerpop.gremlin.structure.io.graphml.*
  org.apache.tinkerpop.gremlin.structure.io.graphson.*
  org.apache.tinkerpop.gremlin.structure.io.gryo.*
  org.apache.commons.configuration.*
  org.apache.tinkerpop.gremlin.process.traversal.strategy.decoration.*
  org.apache.tinkerpop.gremlin.process.traversal.strategy.optimization.*
  org.apache.tinkerpop.gremlin.process.traversal.strategy.finalization.*
  org.apache.tinkerpop.gremlin.process.traversal.strategy.verification.*
  org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.*
  org.apache.tinkerpop.gremlin.process.traversal.util.*
  org.apache.tinkerpop.gremlin.process.computer.*
  org.apache.tinkerpop.gremlin.process.computer.traversal.step.map.*
  org.apache.tinkerpop.gremlin.process.computer.clustering.connected.*
  org.apache.tinkerpop.gremlin.process.computer.clone.*
  org.apache.tinkerpop.gremlin.process.computer.bulkdumping.*
  org.apache.tinkerpop.gremlin.process.computer.bulkloading.*
  org.apache.tinkerpop.gremlin.process.computer.clustering.peerpressure.*
  org.apache.tinkerpop.gremlin.process.computer.traversal.*
  org.apache.tinkerpop.gremlin.process.computer.ranking.pagerank.*
  org.apache.tinkerpop.gremlin.process.computer.search.path.*
  org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.optimization.*
  org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.decoration.*
  org.apache.tinkerpop.gremlin.util.*
  org.apache.tinkerpop.gremlin.util.iterator.*
  org.apache.tinkerpop.gremlin.util.function.*
  java.util.*
  java.sql.*
  static org.apache.tinkerpop.gremlin.structure.io.IoCore.*
  static org.apache.tinkerpop.gremlin.process.traversal.P.*
  static org.apache.tinkerpop.gremlin.process.traversal.AnonymousTraversalSource.*
  static org.apache.tinkerpop.gremlin.process.traversal.TextP.*
  static org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__.*
  static org.apache.tinkerpop.gremlin.process.computer.Computer.*
  static org.apache.tinkerpop.gremlin.util.TimeUtil.*
  static org.apache.tinkerpop.gremlin.util.function.Lambda.*
  static org.apache.tinkerpop.gremlin.process.traversal.SackFunctions.Barrier.*
  static org.apache.tinkerpop.gremlin.structure.VertexProperty.Cardinality.*
  static org.apache.tinkerpop.gremlin.structure.Column.*
  static org.apache.tinkerpop.gremlin.structure.Direction.*
  static org.apache.tinkerpop.gremlin.process.traversal.Operator.*
  static org.apache.tinkerpop.gremlin.process.traversal.Order.*
  static org.apache.tinkerpop.gremlin.process.traversal.Pop.*
  static org.apache.tinkerpop.gremlin.process.traversal.Scope.*
  static org.apache.tinkerpop.gremlin.structure.T.*
  static org.apache.tinkerpop.gremlin.process.traversal.step.TraversalOptionParent.Pick.*
  org.apache.tinkerpop.gremlin.driver.*
  org.apache.tinkerpop.gremlin.driver.exception.*
  org.apache.tinkerpop.gremlin.driver.message.*
  org.apache.tinkerpop.gremlin.driver.ser.*
  org.apache.tinkerpop.gremlin.driver.remote.*
  org.apache.tinkerpop.gremlin.tinkergraph.structure.*
  org.apache.tinkerpop.gremlin.tinkergraph.process.computer.*
----

前に説明したように、Gremlin コンソールを使っている際は、いつでも'getClass'メソッドを使うか、単に'.class'を使って、多くの場合、何かが定義されている場所を見つけることができる。本セクションの前の例でみたように、'values'、'id'、'local'などの多数のキーワードは列挙子として定義されているので、'getClass'を直接つかうことができる。いくつかの例を下記に示す。

[source,groovy]
----
gremlin> label.getClass()
==>class org.apache.tinkerpop.gremlin.structure.T$1
gremlin> key.getClass()
==>class org.apache.tinkerpop.gremlin.structure.T$3
gremlin> keys.getClass()
==>class org.apache.tinkerpop.gremlin.structure.Column$1
gremlin> values.getClass()
==>class org.apache.tinkerpop.gremlin.structure.Column$2
gremlin> local.getClass()
==>class org.apache.tinkerpop.gremlin.process.traversal.Scope
gremlin> Order.class
==>class org.apache.tinkerpop.gremlin.process.traversal.Order
gremlin> Column.class
==>class org.apache.tinkerpop.gremlin.structure.Column
----

この出力を上記の表と比較すると、例えば、'label'と'key'が'T'列挙型で定義されていることわかる。また、'keys'と'values'が実際には'Column'列挙型で定義されていることもわかる。最後に、'local'は、予想どおり、'Scope'列挙型で定義されていることがわかる。

[[javapredicates]]
==== Java アプリケーションで Gramlin 述部を使う

前のセクションで説明したように、Javaプログラムから'eq'や'neq'のようなGremlin 述部を使う場合は、プレフィクス "'P.'" を付ける必要がある。これは、同じ名前のTinkerPop クラス参照であり、Gremlin 述部を表す一連の静的メソッドが定義されている。

TIP: 本セクションで使われているコードを含むGraphRegion.java というサンプルプログラムが、 https://github.com/krlawrence/graph/tree/main/sample-code にあるサンプルファイルディレクトリにある。

下記のコードを見ていただきたい。'findByRegion'というメソッドが定義されていて、3文字の空港IATAコードを表す文字列を入力として受け取る。次にこのメソッドは、Gremlin クエリを使って、指定された空港がどの地理的地域にあるかを把握し、次に、その地域にあるすべての空港を返す。'where'ステップの一部として'P.eq'を使っていることに注意してほしい。これは、Gremlin コンソール内で実行されていないので、より厳密に指定する必要がある別のケースだ。

[source,java]
----
// Find all airports in the region of the specified airport
public void findByRegion(String iata)
{
  System.out.println("\nRegion code lookup for " + iata );

  List<List<Object>> list =  
  g.V().has("code",iata).values("region").as("r").
    V().hasLabel("airport").as("a").values("region").
        where(P.eq("r")).by().
        local(__.select("a").values("city","code","region").fold()).toList();               
    
  for(List t : list)
  {
    System.out.println(t);
  }
}                                
----

コロラド州デンバーの空港を表す DEN のパラメータを渡して'findByRegion'メソッドを呼び出すと、次の出力が返される。

[source,console]
----
Region code lookup for DEN
[COS, Colorado Springs, US-CO]
[DEN, Denver, US-CO]
[DRO, Durango, US-CO]
[GJT, Grand Junction, US-CO]
[EGE, Eagle, US-CO]
[HDN, Hayden, US-CO]
[APA, Denver, US-CO]
[TEX, Telluride, US-CO]
[ASE, Aspen, US-CO]
[ALS, Alamosa, US-CO]
[CEZ, Cortez, US-CO]
[GUC, Gunnison, US-CO]
[MTJ, Montrose, US-CO]
[PUB, Pueblo, US-CO]
----


[[javacheck]]
==== クエリが結果を返したかどうかを確認する

これらの厄介な Java の NullPointerException を回避するために、参照する前にクエリ結果を返したかどうかを知ることが重要なことがよくある。Java について心配することなく、下記のクエリを純粋にGremlin の観点から検討してみてほしい。

[source,groovy]
----
g.V().has("code","AUS").outE().as("edge").inV().has("code","SYD").
                        select("edge").by("dist")
----

クエリは、オースティン(AUS) 空港を見つけ、次にオースティンとシドニー(SYD) を接続する発エッジを探し、そのエッジから距離を返す。ここでの問題は、オースティンとシドニー間に直接の経路がないので、距離を取得するためのエッジがないことだ。言い換えると、このクエリは結果を返さない。では、Gremlin コンソールでは、これは問題ではない。何も返ってこないで、そのまま続くからだ。しかしながら、下記のコードを見てほしい。これは、クエリを Java のコードに移す最初の試みだ。

[source,java]
----
Long result = 
      g.V().has("code","AUS").outE().as("edge").inV().has("code","SYD").
            select("edge").by("dist").next(); 
----

表面的には、これは問題ないように見える。しかしながら、このコードを実行すると、'next'を呼び出そうとして、オースティンとシドニー間にエッジがなく、処理する距離の値がないので、処理する結果がないため、NullPointerException が発生する。

TIP: 本セクションで使われているコードを含む、GraphSearch2.java というサンプルプログラムが、 https://github.com/krlawrence/graph/tree/main/sample-code にあるsample-code ディレクトリにある。

したがって、有効な結果が得られているかをチェックする方法が必要だ。そのような方法の1つに、クエリの結果をリストに保存するというものがある。そうすると、最悪の場合、結果が見つからない場合は、空のリストが返される。なので、クエリを次のように書き換えることができる。

[source,java]
----
List result = 
      g.V().has("code","AUS").outE().as("edge").inV().has("code","SYD").
            select("edge").by("dist").toList();
----

これで、結果がリストに追加されたので、結果が得られたかどうかを安全に確認できる。

[source,java]
----
if (result.isEmpty())
{
  System.out.println("No results were found");
}
else
{
  System.out.println("The distance is " + result.get(0));
}
----

リストを使わず、後処理を行わず、”純粋なGremlin " なソリューションが欲しいのであれば、'coalesce'ステップを使って、特別な定数値、この場合は -1、を返し、結果が見つからなかったことを示すことだ。

[source,java]
----
Integer d = (Integer) 
    g.V().has("code","AUS").outE().as("edge").inV().has("code","SYD").
          select("edge").by("dist").fold().
          coalesce(__.unfold(),__.constant(-1)).next(); 
----

ルートが存在する場合は、距離が見つかって返される。さもなければ、'"-1"'の値が返される。これは実際にはこの場合はクエリ自体で'fold'ステップを使ってリストを生成していることを除き、'toList'の例と同じ概念を使っている。リストが空でない場合、'unfold'は結果を返す。さもなければ、'coalesce'が最初に結果を返す際に定数値が返される。

もちろん、この問題を解決するために思いつく方法は他にも多数あるが、リストを使うと、かなり使いやすい解決策が得られることがよくある。

[[javacreate]]
==== Java アプリケーションから新しいグラフを作成する

下記のコードは、新しい ( 空の ) TinkerGraph インスタンスを生成し、グラフトラバーサルソースオブジェクトを生成してから、トラバーサルを使って、小さなグラフを作成する。

TIP: このサンプルの完全なソースコードは https://github.com/krlawrence/graph/tree/main/sample-code に置いてある、CreateGraph.java のファイルにある。

トラバーサルの最後で、'iterate()'が呼び出されていることに注意してほしい。スタンドアローンアプリケーションとして実行する際、これが必要になる。これは、Gremlinコンソールがあなたにわからない形で実行する別のささいなことであり、コンソール内で実行するのではない場合に、自分で実行すべきことを覚えておくべきことだ。

[source,java]
----
// Create a new (empty) TinkerGrap
TinkerGraph tg = TinkerGraph.open() ;

// Create a Traversal source object
GraphTraversalSource g = tg.traversal();
               
// Add some nodes and vertices - Note the use of "iterate".
g.addV("airport").property("code","AUS").as("aus").
  addV("airport").property("code","DFW").as("dfw").
  addV("airport").property("code","LAX").as("lax").
  addV("airport").property("code","JFK").as("jfk").
  addV("airport").property("code","ATL").as("atl").
  addE("route").from("aus").to("dfw").
  addE("route").from("aus").to("atl").
  addE("route").from("atl").to("dfw").
  addE("route").from("atl").to("jfk").
  addE("route").from("dfw").to("jfk").
  addE("route").from("dfw").to("lax").
  addE("route").from("lax").to("jfk").
  addE("route").from("lax").to("aus").
  addE("route").from("lax").to("dfw").iterate();
----

新しいグラフを作成したら、いくつかのクエリを実行して正しく見えることを確認するとよい。まず、頂点が作成されたことをチェックし、その頂点に割り当てられたＩＤを確認しよう。前の例と同様、パラメータに'true'を指定して'valueMap'を呼び出すと、必要なものが返される。このコードから返されるものは、マップのリストであり、各マップにはキーとして、空港コード、頂点ID と頂点ラベルが含まれている。 

[source,java]
----
List<Map<Object,Object>> vm = new ArrayList<Map<Object,Object>>() ;
    
vm = g.V().valueMap(true).toList();
----

マップのリストが取得できたら、それらを処理できる。'id'や'label'の値をマップから取得するには、キー名に、'"T."'のプレフィクスを付ける必要があることに注意してほしい。ほとんどのプロパティキーが文字列であるのに対し、ID やラベルは特殊なケースだからだ。 TinkerPop のドキュメントを見ると、T は、'T.id'、'T.label'、'T.value'及び'T.key'の定義を含むJava の列挙子であることがわかる。Java で Gremlin を使う場合、Gremlin コンソールを使う際には必要なかった'"T."'プレフィクスを使う必要があることを覚えておくことは重要だ。

[source,java]
----
// Dislpay the code property as well as the label and id.
for( Map m : vm)
{
  System.out.println(((List)(m.get("code"))).get(0) + " " + 
                             m.get(T.id) + " " + m.get(T.label));
}                     
----

グラフの作成が万事うまくいったら、各頂点に割り当てられたIDを表示する下記のようなリストを取得する必要がある。

[source,java]
----
AUS 0 airport
DFW 2 airport
LAX 4 airport
JFK 6 airport
ATL 8 airport
----

最後に、エッジが正しく作成されているか、新しいグラフにある頂点間のすべてのパスを表示してチェックしよう。

[source,java]
----
// Display the routes in the graph we just created

List<Path> paths = new ArrayList<Path>();

paths = g.V().out().path().by("code").toList();

for (Path p : paths)
{
  System.out.println(p.toString());
}
----

繰り返すが、すべてが期待どおりにうまくいったのであれば、このように返ってくるはずだ。

[source,java]
----
[AUS, DFW]
[AUS, ATL]
[DFW, JFK]
[DFW, LAX]
[LAX, JFK]
[LAX, AUS]
[LAX, DFW]
[ATL, DFW]
[ATL, JFK]
----

[[javasave]]
==== Javaアプリケーションからグラフを保存する

新しいグラフを作成したら、それを保存したくなると思う。下記のコードは、グラフをGraphSON( TinkerPop の JSON フォーマット）かあるいは GraphML (XML) で保存する方法を示している。これは Gremlin コンソール内ではなく、スタンドアローンプログラムで実行しているので、もう少し作業が必要になる別の例だ。データを保存するという我々の試みは、発生する可能性のある例外をキャッチする必要がある。このコードは、CreateGraph.java サンプルプログラムの一部としても含まれている。

[source,java]
----
// Save the graph we just created as GraphML (XML) or GraphSON (JSON)
try
{
  // If you want to save the graph as GraphML uncomment the next line
  tg.io(IoCore.graphml()).writeGraph("mygraph.graphml");
  
  // If you want to save the graph as JSON uncomment the next line
  tg.io(IoCore.graphson()).writeGraph("mygraph.json");
}
catch (IOException ioe)
{
  System.out.println("Graph failed to save");
}
----

[[groovyapp]]
=== Groovy アプリケーションから TinkerGraph を操作する

本書の初めの方の、"<<grv>>" のセクションで、Gremin コンソールで Groovy コードを使う方法について説明した。しかしながら、スタンドアロンの Groovy アプリケーションを使って TinkerGraph を操作する方法をまだ見ていない。

NOTE: いくつかの Groovy のサンプルが 本書に関連する GitHub リポジトリ、 https://github.com/krlawrence/graph にある。

本セクションでは、以前にJava でコーディングしたテストアプリケーションの一部を Groovy で書き直す。”<<javatinker>>" のセクションで取り上げた内容の多くはここでも同様に関連しているが、中身は重複していない。なので、Groovy アプリケーションをすでに書いていたとしても、このセクションを読んでいただきたい。

TIP: 本セクションの例は、 https://github.com/krlawrence/graph/tree/main/sample-code にあるサンプルコードフォルダに置いてある、TinkerGraphTest.groovy というサンプルプログラムから抜粋したものだ。

すでに、ご自身の環境にGroovy をダウンロード、インストールして、Groovy バイナリが配置されている場所を指すように、PATH を設定済みであることを前提としている。Java の例と同様、最初にすべきことは、プログラムで使っているすべての TinkerPop 3 のクラスを'import'経由で取り込むことだ。

[source,groovy]
----
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__;
import org.apache.tinkerpop.gremlin.process.traversal.Path;
import org.apache.tinkerpop.gremlin.process.traversal.*;
import org.apache.tinkerpop.gremlin.structure.Edge;
import org.apache.tinkerpop.gremlin.structure.Vertex;
import org.apache.tinkerpop.gremlin.structure.io.IoCore;
import org.apache.tinkerpop.gremlin.tinkergraph.structure.*;
import org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph;
import org.apache.tinkerpop.gremlin.util.Gremlin;
import java.io.IOException;
----

必要なクラスのインポートが済んだら、アプリケーションを開始することができる。最初に、使っているTinkerPop のバージョンを表示する。

[source,groovy]
----
println "The Gremlin version is ${Gremlin.version()}"

def tg = TinkerGraph.open() 
----

これで、新しい TinkerGraph インスタンスを生成し、air routes グラフをロードする準備が整った。これは、Java の例でやったように、Groovy で行うことができる。しかしながら、Java と異なり、Groovy はスローされる可能性のある例外をキャッチする必要はないが、例外が発生した際に、特別なアクションを実行する必要がある場合には、ベストプラクティスとして、おそらくキャッチするのはよい考えだ。

[source,groovy]
----
println "Loading the air-routes graph...\n"

// Load the air-routes graph
try
{
  tg.io(IoCore.graphml()).readGraph("air-routes.graphml");
} 
catch (IOException e)
{
  println "Could not load the graph file"
  System.exit(0);
}
----

例外が発生しなかったと仮定すると、先に進んでグラフトラバーサルオブジェクトを作成するとよい。

[source,groovy]
----
// Create a graph traversal source object and find the Austin airport vertex
def g = tg.traversal()
----

まず、単純なクエリを実行して、AUS 空港を表す頂点を見つけ、'println'を使ってそれに関する情報を表示する。

[source,groovy]
----
def aus = g.V().has('code','AUS').valueMap().next()

println aus
----

NOTE: Javaアプリケーションの構築を検討していたときと同様、期待している結果が確実に返されるように、next、toList、fillなどのステップでクエリを終了する必要がある。

これで、アプリケーションを始めることができ、コンパイルできるかを確認するときだ。次のセクションで示されているように、TinkerPop 特有の JAR ファイルを確実に取得する必要がある。

[[groovyc]]
==== Groovy アプリケーションをコンパイルする

Javaの例では、'--cp'フラグを使って javac 呼び出しにCLASSPATHを指定した。これはGroovy を使う場合にも実行できるが、しかしながら、ビルド環境として Microsoft Windows を使っている場合は、'-cp'を使うと予期しないエラーが発生することがある。したがって、Groovy コンパイラを実行する前に、使っている環境で、CLASSPATH 変数を定義することをお勧めする。

下記のコマンドは、Bash シェルで機能するが、他の環境に簡単に移植できる。GREMLIN 変数はGremlin コンソールをダウンロードしてインストール、解凍した場所を指している必要がある。

----
# Root directory for Gremlin Console install
GREMLIN=...

# Path to Gremlin core JARs
LIBPATH=$GREMLIN/lib/*

# Path to TinkerGraph JARs
EXTPATH=$GREMLIN/ext/*

#Path to additional JARs
ADDL=$GREMLIN/ext/tinkergraph-gremlin/lib/*

# Classpath
export CLASSPATH=$CLASSPATH:$LIBPATH:$EXTPATH:$ADDL 

# Compile
groovyc TinkerGraphTest.groovy
----

==== Groovy アプリケーションを実行する

すべて正常部コンパイルできたと仮定して、これでGroovy アプリケーションが実行できる。

[source,groovy]
----
groovy TinkerGraphTest
----

そして、これが、我々が得るべき出力の類だ。

[source,groovy]
----
Gremlin version is 3.3.1
Loading the air-routes graph...

[country:[US], code:[AUS], longest:[12250], city:[Austin], elev:[542], icao:[KAUS], lon:[-97.6698989868164], type:[airport], region:[US-TX], runways:[2], lat:[30.1944999694824], desc:[Austin Bergstrom International Airport]]
----

これでテストプログラムの小さなスケルトンを実行できたので、さらにいくつか興味深い機能の追加を始めることができる。

==== Groovy アプリケーションに追加する

下記のコードは、プログラムで数行前に実行したオースティン頂点の'valueMap'を操作する方法を示している。

[source,groovy]
----
// Retieve the city name property and display it
def city = aus['city']
println "\nThe AUS airport is in ${city[0]}\n"

// Iterate through the keys we got back and print them along with their values
aus.each {println "${it.key} : ${it.value[0]}"}
----

ここで、プログラムを再コンパイルして実行すると、追加した行により下記の出力が生成される。

[source,groovy]
----
The AUS airport is in Austin

country : US
code : AUS
longest : 12250
city : Austin
elev : 542
icao : KAUS
lon : -97.6698989868164
type : airport
region : US-TX
runways : 2
lat : 30.1944999694824
desc : Austin Bergstrom International Airport
----

以前、Java プログラムで行ったように、クエリを追加して、DFW 空港を起点とする経路がいくつあるかを確認することができる。

[source,groovy]
----
def n = g.V().has("code","DFW").out().count().next() 
println "\nThere are  ${n} routes from Dallas"

There are  221 routes from Dallas
----

次に、いくつかのコードを追加して、DFWから飛ぶことができる場所を表すIATAコードを見つけることができる。

[source,groovy]
----
// Where can I fly to from DFW?
def fromDfw = g.V().has("code","DFW").out().values("code").toList()
println "\nHere are the places you can fly to from DFW\n"
println fromDfw  
----

コードを実行すると、下記のような結果が返されるはずだ。

[source,groovy]
----
Here are the places you can fly to from DFW

[CID, HNL, HOU, SAN, SNA, SLC, LAS, DEN, SAT, MSY, EWR, DTW, ELP, SJU, CLE, OAK, TUS, SAF, PHL, GEG, BZN, JAC, GCM, MEI, PIB, KOA, SUX, SBA, ASE, CVN, BKG, BIS, GUC, MTJ, TVC, CNM, GLH, SWO, BIL, MAF, BDL, RAP, SDF, SHV, BOI, LBB, RNO, CMH, ICT, ACT, CLL, ABI, SGF, RIC, CCS, TXK, PIA, LEX, GUA, CRP, MTY, AMA, BJX, BMI, BOG, BPT, DSM, MYR, AEX, CZM, AGU, COU, DAY, CUU, DRO, BRO, BTR, BZE, CAE, CHA, CHS, CMI, GCK, GDL, GGG, GJT, GPT, EVV, FAR, FAT, FSD, FSM, FWA, JAN, JLN, YYZ, LAW, YVR, LCH, LHR, LFT, CDG, LIR, GRI, GRK, GRR, GSO, GSP, MLI, PEK, MLM, PVG, MLU, FCO, MOB, AMS, MSN, MAD, MZT, RSW, PBC, FRA, LRD, NRT, MFE, SYD, MGM, DXB, MHK, HKG, QRO, ICN, ROW, GIG, SAL, GRU, SAV, EZE, SJD, LIM, SJT, SCL, SLP, MEX, SPI, YUL, PLS, YEG, PNS, YYC, PTY, DOH, OKC, TYS, ONT, VPS, AUH, XNA, CLT, ZCL, CUN, EGE, PSP, HDN, MEM, UIO, CVG, MID, TYR, ATL, ANC, TLH, SPS, PIT, TRC, PDX, ABQ, MKE, OMA, TUL, PVR, OGG, DUS, LGA, NAS, STL, JFK, LAX, AUS, IND, MGA, BNA, MCI, BOS, BWI, DCA, FLL, IAD, IAH, JAX, PUJ, SJO, SMF, RTB, COS, SJC, HSV, TPA, BHM, LIT, ORF, SFO, MCO, MBJ, MIA, MSP, ORD, PBI, PHX, RDU, SEA]
----

下記のコードは、ロンドンのヒースロー空港(LHR) から飛ぶことができる米国内のすべての空港を検出する。'limit'ステップを使って、最初の10件のみが選択されている。'path'ステップは空港のペアとそれらの間の距離を適切に返すために使われている。返されるものは、パスのリストなので、単純なGroovyの'each'ループを使って結果を出力できる。

[source,groovy]
----
def lhrToUsa = g.V().has("code","LHR").outE().inV().
                     has("country","US").limit(10).
                     path().by("code").by("dist").toList()

println "\nFrom LHR to airports in the USA (only 10 shown)\n"

lhrToUsa.each {println it}
----

これは、この新しいクエリを追加してコードを実行したときに返された10件の経路である。

[source,groovy]
----
From LHR to airports in the USA (only 10 shown)

[LHR, 4896, PDX]
[LHR, 3980, CLT]
[LHR, 4198, ATL]
[LHR, 4901, AUS]
[LHR, 3254, BOS]
[LHR, 3622, BWI]
[LHR, 4736, DFW]
[LHR, 3665, IAD]
[LHR, 4820, IAH]
[LHR, 3440, JFK]
----

最後に、オースティンから経由1回以内でアクセスできるイングランドの空港を見つけるコードを書いてみよう。

[source,groovy]
----
def eng = g.V().has("code","AUS").repeat(__.out()).emit().times(2).
                has("region","GB-ENG").dedup().values("code").toList();

println "\nAirports in England reachable with no more than one stop from AUS"
println "\n${eng}\n"  
----

結果はこのとおり。途中で1回しか経由しない場合、合計9つの異なる空港にアクセスできるような。

[source,groovy]
----
Airports in England reachable with no more than one stop from AUS

[LHR, BRS, LGW, STN, MAN, BHX, LBA, NCL, LCY]
----

これで、幾分興味深い Groovy アプリケーションが起動できたので、必要に応じて、この基盤の上に、"<<javatinker>>" のセクションで行ったように、構築することができる。

[[groovypredicates]]
==== Groovy アプリケーションで Gremlin 述部を使う

スタンドアローンの Java アプリケーションを書く際に行ったのと同じように、Groovy  プログラムから'eq'や'neq'のような Gremlin 述部を使う場合は、Gremlin 述部を表す一連の静的メソッドが定義されている同じ名前の TinkerPop クラスを参照する'"P."'プレフィクスを付ける必要がある。

TIP: 本セクションで使ったコードを含むGraphRegion.groovyというサンプルプログラムは、 https://github.com/krlawrence/graph/tree/main/sample-code にあるサンプルファイルのディレクトリに置いてある。

下記のコードでは、以前にJavaで書いた'findByRegion'メソッドが Groovy に移植されている。前と同様、3文字の空港 IATA コードを表す文字列が入力として期待されている。このメソッドは、Gremlin クエリを使ってどの地理的地域に指定された空港があるかを把握し、その地域の他のすべての空港を返す。再度、'where'ステップの一部として'P.eq'を使っていることに注意してほしい。

[source,groovy]
----
def findByRegion(iata)
{
  println("\nRegion code lookup for " + iata )

  def list =  
    g.V().has("code",iata).values("region").as("r").
      V().hasLabel("airport").as("a").values("region").
          where(P.eq("r")).by().
          local(__.select("a").values("city","code","region").fold()).toList()               
  
  list.each {println it}
}
----

[[janusintro]]
=== JanusGraph を導入する

これまで、例では、Apache TinkerPop に含まれている TinkerGraph のグラフを使ってきた。Gremlin とその関連テクノロジについて学び、本番環境へのデプロイに移行すると、信頼性の高い永続性、スキーマを定義できる機能、ACID トランザクションのサポートなどの機能が用意されたグラフストアが必要になる。著名な Titan グラフデータベースのオープンソースフォークとして2016 年に始まった JanusGraph プロジェクトは、Linux Foundation によってホストされ、これらの高度な機能が用意されている。

本書では、理にかなった量の JanusGraph カバレッジを提供しようと試みてきたが、 それでも、高度なトピックとその詳しい説明と、それに合わせて操作できる数多くの設定に関する説明がある JanusGraph の公式ドキュメントに慣れ親しむことをお勧めする。

JanusGraph はラップトップ上で実行できるので、学習や実験するのに便利だが、分散クラスタに保存されている非常に大きなグラフを扱うように設計されている。数十億の頂点やエッジを含んだグラフを扱うことができる。これから説明するように、JanusGraph は、Apache Cassandra や、Apache HBase などの様々な永続ストレージオプションや、Apache Solr や Elasticsearch などのインデックステクノロジで動作するように設計されている

.ここに便利な JanusGraph に関するリソースがある。
ランタイムダウンロード( JAR ファイル他)::
http://janusgraph.org/
Documentation::
http://docs.janusgraph.org/latest/.
API Documentation::
http://docs.janusgraph.org/latest/javadoc.html
http://javadoc.io/doc/org.janusgraph/janusgraph-core/0.2.0

次のセクションでは、JanusGraph と、それと組み合わせると非常にスケーラブルなグラフデータベースソリューションを構築してデプロイする方法が得られるその他のテクノロジについて詳しく見ていく。まず、JanusGraphをインストールして、Gremlin コンソールからアクセスする方法を簡単に見てから、スキーマとインデックスの両方を作成して管理する方法や、JanusGraph で用意されているトランザクション機能を使う方法などを含むより高度なトピックに進む。

また、下記に示すものを読むのと合わせて、JanusGraph の公式ドキュメントを読んで理解を深めることをお勧めする。

[[janusinstall]]
==== JanusGraph をインストールする

JanusGraph 自体は非常に簡単にインストールできる。ZIPファイルをダウンロードして、適当な場所に解凍するだけだ。下記の "<<janusinmemory>>" のセクションでさらに説明しているインメモリオプション使うのであれば、これを行ったら、すぐにこれを使って実験を始めることができる。しかしながら、商用デプロイではおそらく、ある種の永続ストレージやインデックスサービス、追加でインストールする必要のあるその他コンポーネントと組み合わせて使うものと思われる。これについては、後で少し説明する。ダウンロードページには、JanusGraph がテストされた Apache Cassandra や、Apache Solr のような関連テクノロジのバージョンに関する情報が載っている。

NOTE: JanusGraph には独自のプロセスがなく、実行するサービスとして提供されるのでもなく、独自コードからあるいは、Gremlinサーバのようなものを使ってホストされているGremlin コンソールを使って起動されるJava クラスのセットである覚えておくことは重要だ。

JanusGraph のインストールパッケージは、 http://janusgraph.org/ にあり、単一のZIPファイルである。ダウンロードして解凍したら Gremlin コンソールを使って実験する準備が整う。下記で説明するように、JanusGraph で操作する際には、JanusGraph のダウンロードの一部としてパッケージ化されているバージョンのGremlin コンソールを使う必要がある。

[[janusconsole]]
==== Gremlin コンソールから JanusGraph を使う

Gremlin コンソールのバージョンは、JanusGraph ダウンロードの一部として含まれている。このバージョンのコンソールと、標準のApache TinkerPop ダウンロードの一部として入手するバージョンとの主な違いは、コンソールがあらかじめ、JanusGraph 特有のクラスを認識し、見つけるように設定されていることだ。そのようなクラスの良い例は、コンソールから新しいJanusGraph インスタンスを生成ｓるうのに使われる'JanusGraphFactory'だ。

NOTE: JanusGraph を使う場合は、JanusGraph ダウンロードの一部としてパッケージ化されているバージョンの Gremlin コンソールを使う必要がある。

上述したように、JanusGraph はスタンドアロンサービスではなく、呼び出しプロセスによって起動される必要がある Java クラスのセットである。Gremlin コンソールはその役割を果たすことができる。JanusGraph を解凍すると、JanusGraph 親ディレクトリ配下の bin ディレクトリにgremlin.sh と gremlin.bat のスクリプトがある。Gremlin コンソールを起動すると、以降のいくつかのセクションで説明するように、バックエンドストアとインデックスの観点から操作する環境についてJanusGraph に指示することができる。

[[janusinmemory]]
==== インメモリオプション付きで JanusGraph を使う

ほとんどすべての本番ユースケースでは、JanusGraph は、Apache Cassandra や、Apache HBase のような永続バックエンドストアと一緒に使う。しかしながら、JanusGraph で実験をしているうちは、すべてのバックエンドストレージコンポーネントの構成について心配せずに素早く起動して実行できると信じられないほど便利だ。これは、JanusGraph で用意されている'inmemory'オプションにより、可能になる。これにより、基本的に、JanusGraphを コンピュータのメモリに格納されたすべてのグラフデータでTinkerGraph を使っていたのと同じ方法で使えるようになる。しかしながら、大きな違いの1つは、JanusGraphを使うと、'inmmeory'ストレージモデルを使っていても、スキーマやトランザクションのようなTinkerGraph に用意されていない機能を実験することができることだ。これらのトピックについては、後で少し触れる。まずは、'inmmeory'ストレージモデルを使う Gremlin コンソールからJanusGraph のインスタンスを作ってみよう。

JanusGraph インスタンスを作成するのは、本書の前の方で TinkerGraph インスタンスを作ったのと非常によく似ている。唯一の違いは、'JanusGraphFactory'を使ってグラフを作ることであり、この場合、JanusGraph に、すべてをインメモリストレージモデルで使いたいことを伝える唯一のパラメータとして'inmemory'を指定する。グラフトラバーサルオブジェクト'g'は前と全く同じ方法で作成する。

[source,groovy]
----
graph = JanusGraphFactory.open('inmemory')
g = graph.traversal()
----

上述の'open'コマンドは下記に示すコマンドの省略形である点に注意してほしい。

[source,groovy]
----
graph = JanusGraphFactory.build().set("storage.backend","inmemory").open()
g = graph.traversal()
----

これで、TinkerGraph の場合と同様に、グラフインスタンスが生成できたので、グラフがサポートする機能を照会することができる。本書の前の方の、https://kelvinlawrence.net/book/Gremlin-Graph-Guide.html#tgintro[TinkerGraph を導入する] セクションで、TinkerGraph で用意されている機能について説明した。これらの機能をJanusGraph で用意されているものを比較すると、いくつかの重要な違いを見つけることができる。

下記に示すように、'features'メソッドを呼び出すことにより、機能セットを得ることができる。最初に目につくのは、トランザクションに関連する様々な機能が'true'に設定されていて、JanusGraph がトランザクションをサポートしていることを示していることだ。次のセクションでは、これらのトランザクション機能の使い方を見ていく。'inmemory'モードで使っているので、'Persistence'は'false'として表示されていることに注意してほしい。注意すべき他のものは、TinkerGraph と異なり、'UserSuppliedIds'が'false'に設定されていて、JanusGraph は独自のID値を生成し、こちらで用意したものは無視することだ。リストは読みやすくするために２カラムでフォーマットされている。

.JanusGraph の機能
----
graph.features()

> GraphFeatures                            > VertexPropertyFeatures                    
>-- Transactions: true                     >-- AddProperty: true                       
>-- Computer: true                         >-- RemoveProperty: true                    
>-- ConcurrentAccess: true                 >-- NumericIds: false                       
>-- ThreadedTransactions: true             >-- StringIds: true                         
>-- Persistence: false                     >-- UuidIds: false                          
> VariableFeatures                         >-- CustomIds: true                         
>-- Variables: true                        >-- AnyIds: false                           
>-- LongValues: true                       >-- UserSuppliedIds: false                  
>-- BooleanArrayValues: true               >-- Properties: true                        
>-- ByteArrayValues: true                  >-- LongValues: true                        
>-- DoubleArrayValues: true                >-- BooleanArrayValues: true                
>-- FloatArrayValues: true                 >-- ByteArrayValues: true                   
>-- IntegerArrayValues: true               >-- DoubleArrayValues: true                 
>-- StringArrayValues: true                >-- FloatArrayValues: true                  
>-- LongArrayValues: true                  >-- IntegerArrayValues: true                
>-- StringValues: true                     >-- StringArrayValues: true                 
>-- MapValues: true                        >-- LongArrayValues: true                   
>-- MixedListValues: false                 >-- StringValues: true                      
>-- SerializableValues: false              >-- MapValues: true                         
>-- UniformListValues: false               >-- MixedListValues: false                  
>-- BooleanValues: true                    >-- SerializableValues: false               
>-- ByteValues: true                       >-- UniformListValues: false                
>-- DoubleValues: true                     >-- BooleanValues: true                     
>-- FloatValues: true                      >-- ByteValues: true                        
>-- IntegerValues: true                    >-- DoubleValues: true                      
> VertexFeatures                           >-- FloatValues: true                       
>-- MetaProperties: true                   >-- IntegerValues: true                     
>-- AddVertices: true                      > EdgePropertyFeatures                    
>-- RemoveVertices: true                   >-- Properties: true                      
>-- MultiProperties: true                  >-- LongValues: true                      
>-- AddProperty: true                      >-- BooleanArrayValues: true              
>-- RemoveProperty: true                   >-- ByteArrayValues: true                 
>-- NumericIds: true                       >-- DoubleArrayValues: true               
>-- StringIds: false                       >-- FloatArrayValues: true                
>-- UuidIds: false                         >-- IntegerArrayValues: true              
>-- CustomIds: false                       >-- StringArrayValues: true               
>-- AnyIds: false                          >-- LongArrayValues: true                 
>-- UserSuppliedIds: false                 >-- StringValues: true                    
> EdgeFeatures                             >-- MapValues: true                                                          
>-- RemoveEdges: true                      >-- MixedListValues: false                                                   
>-- AddEdges: true                         >-- SerializableValues: false                                                
>-- AddProperty: true                      >-- UniformListValues: false                                                 
>-- RemoveProperty: true                   >-- BooleanValues: true                                                      
>-- NumericIds: false                      >-- ByteValues: true                                                         
>-- StringIds: false                       >-- DoubleValues: true                                                       
>-- UuidIds: false                         >-- FloatValues: true                                                        
>-- CustomIds: true                        >-- IntegerValues: true                                                      
>-- AnyIds: false                                                                        
>-- UserSuppliedIds: false                                                               
----

これで、'inmemory' JanusGraphの空のインスタンスができたので、前の例でTinkerGraph でやったのと同じようにこれを Gremlin コンソールから使うことができる。JanusGraph が生成するID値は、TinkerGraphから期待されたものとはかなり異なって見えることに注目してほしい（ゼロから始まらないので）。

[source,groovy]
----
g.addV('person').property('name','Kelvin')
v[4232]

g.V().has('name','Kelvin')
v[4232]

g.V().has('name','Kelvin').id()
4232
----

JanusGraphでさらに実験をする前に、議論すべき重要な主題が3つある。１つはトランザクション。もう1つは頂点やエッジ、プロパティのスキーマやインデックスを定義すること、3つ目は、JanusGraph 管理 API だ。これらの主題については、以降のセクションで扱う。

[[janustrans]]
==== JanusGraph トランザクション

これまで、主に TinkerGraph を使って実験を行ってきた。TinkerGraph はトランザクションをサポートしない。公平を期すために、TinkerGraph が良いソリューションであるタイプのユースケースでは、これは実際には問題にならない。しかしながら、JanusGraph の典型的なユースケースは、バックエンドストアによって永続化された非常に大きなグラフの保存と変更（更新）だ。そのような環境では、トランザクションのサポートがはるかに重要になる。トランザクションのサポートを提供する他のデータベースを使っているのであれば、またJanusGraphのドキュメントで指摘されているように、JanusGraph トランザクションの完全なアトミック性、一貫性、独立性、永続性に依存すべきでない。ACIDサポートの規模は使われているバックエンドストアに依存する。"<<janusstorage>>" のセクションで、いくつかのバックエンドストレージオプションを見ていく。

NOTE: JanusGraph の公式ドキュメントには、トランザクションの処理方法と様々な使用シナリオに基づいて使われる手法の詳細が含まれている。最新バージョンは常に、 http://docs.janusgraph.org/latest/tx.html にある。

多くの場合、JanusGraph を使う際は、明示的に新しいトランザクションをオープンする必要ない。代わりに、必要に応じてオープンされる。下記の例を見てみよう。トランザクションは'addVertx'が呼ばれたときにオープンされ、'commit'が呼ばれるまでオープンのままになる。JanusGraph トランザクション機能にアクセスするには、'graph'インスタンスに関連づけられている'tx'メソッドを使う点にも注意してほしい。下記の例では、JanusGraph インスタンスに接続されている Gremlin コンソールがあるものとみなす。前に作成した'inmemory' JanusGraph は、トランザクションは'inmemory' JanusGraph インスタンスでもサポートされるので、これらの例ではうまく機能する。JanusGraph が表示する警告メッセージを示していないことに注意してほしい。これは新しいプロパティのまだ作成していないことを示している。"<<jaindexintro>>" のセクションにて、インデックスの作成方法について説明する

[source,groovy]
----
// Start a new transaction
xyz = graph.addVertex()

v[4344]

// Add a property
xyz.property('name', 'XYZ')

// Commit the transaction
graph.tx().commit()

// Check to make sure our new vertex was created
g.V().has('name','XYZ')

v[4344]
----

上記の例では、'graph'オブジェクトを使って頂点を追加した。本書の前の方で説明したように、TinkerPop ドキュメントでは、これを推奨していない。代わりに、下記に示すように、トラバーサルの一部として頂点を追加することを推奨している。'graph'オブジェクトは トランザクションを'commit'するのに引き続き使われる点に注意してほしい。

[source,groovy]
----
// Start a new transaction
g.addV().property('name','XYZ')

v[4216]

// Commit the transaction
graph.tx().commit()

// Check to make sure our new vertex was created
g.V().has('name','XYZ')

v[4216]
----

場合によっては、トランザクションを継続して、'commit'するのではなく、実行したことを 元に戻したり、'rollback'する必要があることもある。これは下記に示すように、'rollback'メソッドを呼び出すことで実現できる。

[source,groovy]
----
// Start a new transaction
g.addV().property('name','ABC')

// Rollback the transaction
graph.tx().rollback()

// Nothing will be returned
g.V().has('code','ABC')
----

次のセクションの主題である JanusGraph 管理システムには、スキーマエントリの作成やあるいはグラフを構成するのに使われる独自のトランザクションシステムがある点に注意してほしい。

[[janusmgmt]]
==== JanusGraph 管理 API

JanusGraph には、ManagementSystem クラスを介して 利用できるようにする管理 API が含まれている。グラフに関するメタデータのクエリ、エッジや頂点、プロパティスキーマタイプの定義、インデックスの作成、更新など、様々な重要な機能を実行するのに管理APIを使うことができる。

下記に示すように、'openManagement'メソッド呼び出しを使ってManagementSystem オブジェクトのインスタンスを作成することができる

[source,groovy]
----
mgmt = graph.openManagement()
----

次のセクションでは、管理 API を使って、'air-routes'グラフのスキーマとインデックスの両方を作成し、それをロードする方法を示す。その前に、JanusGraph 管理APIを導入するのに数分かかると思われる。とりあえず、インメモリにJanusGraph インスタンスを作成して air-routes グラフをそこへロードしたが、インデックスやスキーマをまだ定義していないこととしよう。この状況では、スキーマタイプのグラフをロードする際に、JanusGraph は可能な限りベストなデフォルトを提供する。

下記の例では、管理APIを使って、グラフで現在定義されているすべての頂点ラベルのリストを取得する

[source,groovy]
----
mgmt.getVertexLabels()

version
airport
country
continent
----

このクエリは同様に、現在定義されているすべてのエッジラベルを見つける。

[source,groovy]
----
mgmt.getRelationTypes(EdgeLabel.class)

route
contains
----

このクエリは現在定義されているすべてのプロパティキーを見つける。このリストには、頂点とエッジの両方のプロパティキー名が含まれている点に注意してほしい。

[source,groovy]
----
mgmt.getRelationTypes(PropertyKey.class)

dist
code
type
desc
country
longest
city
elev
icao
lon
region
runways
lat
----

プロパティのカーディナリティを照会できる。

[source,groovy]
----
mgmt.getPropertyKey('code').cardinality()

SINGLE
----

これまでのところ、'air-routes'グラフにスキーマが定義されていない点に注意してほしい。すでにロードされているプロパティのいづれかのdataType を照会すると、'Object.class'が返され、デフォルトでは、スキーマがまだ定義されていない場合にJanusGraph が使う。

[source,groovy]
----
mgmt.getPropertyKey('code').dataType()

Object.class
----

グラフにラベル定義が存在するかどうかをテストすることもできる。

[source,groovy]
----
mgmt.containsEdgeLabel('route')

true

mgmt.containsEdgeLabel('travels')

false
----

[[cardlist]]
==== カーディナリティ LIST のプロパティを生成する

JanusGraph 管理 API を使うと、プロパティが値のリストとして受け入れることができるように指定できるようになる。これは、プロパティキーが作成されるときに'LIST'のカーディナリティを指定することで実行できる。明示的にこれを行わない限り、プロパティが作成されるたびに、カーディナリティはデフォルトの'SINGLE'になる。下記のコードは、JanusGraph インスタンスに接続されたGremlin コンソールから実行できる。'String'値を受け入れることができる'mylist'というプロパティキーが作成される。キーが作成される前に、そのカーディナリティは'LIST'として指定される。変更が完了したら、常に管理トランザクションを'commit'するのを忘れないでほしい。

[source,groovy]
----
mgmt = graph.openManagement()
maker = mgmt.makePropertyKey('mylist')
maker.dataType(String.class)
maker.cardinality(LIST)
maker.make()
mgmt.commit()
----

下記に示すように、前のステップを連鎖させることができる点に注意してほしい。

[source,groovy]
----
mgmt = graph.openManagement()
mgmt.makePropertyKey('mylist').dataType(String.class).cardinality(LIST).make()
mgmt.commit()
----

これで、新しいキーを作成できたので、管理APIを使えば、そのカーディナリティが実際に'LIST'に設定されていることを確認することができる。いつものように、APIを使い終わったら、'commit'を呼び出してトランザクションを閉じること。

[source,groovy]
----
mgmt = graph.openManagement()
mgmt.getPropertyKey('mylist').cardinality()

LIST

mgmt.commit()
----

これで、新しい頂点を作成し、新しい'mylist'プロパティを使っていくつかの値を追加できる。カーディナリティは'LIST'であって、'SET'ではないので、新しいプロパティに重複した値を関連づけることができる点に注意してほしい。

[source,groovy]
----
n = g.addV().property('mylist','one').property('mylist','two').next()

v[3043568]

g.V(n).property(list,'mylist','one')
g.V(n).valueMap()

// Duplicates allowed
[mylist:[one,one,two]]

graph.tx().commit()
----

[[cardset]]
==== カーディナリティ SET のプロパティを生成する

JanusGrpah 管理 API を使って、プロパティに'SET'の値を含めることができるように指定することもできる。カーディナリティ'SET'と、カーディナリティ'LIST'の違いは、セットには重複する値が許容されない、ということだ。

整数値のセットを受け入れる'numbers'という新しいプロパティキーを作成してみよう。

[source,groovy]
----
mgmt = graph.openManagement()
mgmt.makePropertyKey('numbers').dataType(Integer.class).cardinality(SET).make()
----

前と同様、新しいプロパティのカーディナリティを再確認できる。

[source,groovy]
----
mgmt.getPropertyKey('numbers').cardinality()

SET
----

また、前と同様、変更が完了したら、管理トランザクションをコミットする必要がある。

[source,groovy]
----
mgmt.commit()
----

次に、新しい頂点を作成し、いくつかのテストを実行して、JanusGraph がセットに期待するルールを適用することを確認しよう。まず、新しい頂点を作成し、値 1, 2 および 3 をプロパティに入れる。これは、期待通りに動く。

[source,groovy]
----
n = g.addV().property('numbers',1).property('numbers',2).property('numbers',3).next()

v[2846792]

g.V(n).valueMap()

[numbers:[1,2,3]]
----

次に、2番目の値 2 を追加して、何が起こるか見てみよう。御覧の通り、すでに2が存在するので、2番目の２はセットに追加されなかった。

[source,groovy]
----
g.V(n).property(set,'numbers',2)
g.V(n).valueMap()

// Duplicates not allowed
[numbers:[1,2,3]]
----

代わりに4を追加してみよう。セットに既存の4 の値が存在しないので、これはちゃんと動く

[source,groovy]
----
g.V(n).property(set,'numbers',4)
g.V(n).valueMap()

[numbers:[1,2,3,4]]
----

最後に、プロパティの作成がすべて完了したので、グラフトランザクションをコミットする。

[source,groovy]
----
graph.tx().commit()
----

[[janusschema]]
=== air-routes グラフ用の JanusGraph スキーマを定義する

エッジ、頂点、プロパティのタイプやラベルをあらかじめ定義しておく必要はないが、定義することを強くお勧めする。何も定義せずに、たとえば航空路データをロードすると、正常に機能するが、JanusGraph は様々なことを想定する。その1つは、すべてのプロパティキーのデフォルトタイプを Java の'Object.class'に設定する。これはグラフでより厳密な型チェックを実施できるようにするには理想的ではない。また、スキーマが定義されていないと、JanusGraph はすべてのエッジの使用制約あるいは'multiplicity'設定を'MULTI'に設定する。これが何を意味するかは、すぐに説明するつもりだが、本質的には、同じラベルがついたエッジが何本2つの頂点間に存在できるかにデフォルトで制限がないことを意味する。

管理APIを使ってスキーマを定義できる。プロパティタイプはいつでも追加することができるが、一度定義するとそのタイプを変更することはできない。キーを作成した後で実行できることは、キーの名前を変更することだけだ。

JanusGraph を使う際のベストプラクティスは、データをグラフにロードする前にラベルとプロパティタイプを定義することだ。グラフが大きくなるにつれ、追加のプロパティタイプやラベルを追加する必要が出てきたら、それを行うことができる。

管理APIを使って、頂点やエッジによって使われるラベルを定義することができる。これらの値はグラフ全体で一意でなければならない。また各プロパティキーのタイプやカーディナリティ('SINGLE'、'LIST'あるいは'SET') を定義することや、エッジについて任意のラベル('MULTI'、'MANY2ONE'、'ONE2MANY'、'ONE2ONE'あるいは'SIMPLE') のエッジの許容される使い方を指定することもできる。プロパティキー名もグラフ全チアを通して一意である必要がある。

エッジラベルのスキーマを定義する前に、各オプションで許容されるものを理解し、各エッジタイプに最適なものを決定する必要がある。

.多重度のオプションには、次の制約がある。
MULTI::
- これは、特定のラベルを持つエッジに多重度が定義されていない場合のデフォルトのオプションである。この設定により、頂点のペア間で同じラベルの複数のエッジが許容される。航空路グラフは、空港間の routes エッジにMULTI の多重度を使う。
  
SIMPLE::
- この設定では、頂点の任意のペア間に特定のラベルのエッジが最大1本だけ許容される。air-routes グラフでは、空港は複数の大陸に存在できないので、この設定は、大陸と空港間のエッジに使われる。同じものが、空港と国の間のエッジにも使われる。

MANY2ONE::
- この設定はグラフの任意の頂点からの特定のラベル名の最大1つの発エッジが許容されるが、このラベルを持つ着エッジの数に制限はない。

ONE2MANY::
- この設定ではグラフ内の任意の頂点への特定のラベルで最大で1つの入りエッジが許容されるが出エッジの数に制約はない。

ONE2ONE::
- この設定では、グラフ内の任意の頂点での指定されたラベル最大1つの入りエッジと1つの出エッジが許容される。

==== エッジラベルと用途を定義する

JanusGraph Management API を使って、'air-routes'グラフで使われる'route'エッジと'contains'エッジの多重度を指定する方法を見てみよう。

[source,groovy]
----
// Define edge labels and usage
mgmt = graph.openManagement()
mgmt.makeEdgeLabel('route').multiplicity(MULTI).make()
mgmt.makeEdgeLabel('contains').multiplicity(SIMPLE).make()
mgmt.commit()
----

==== 頂点ラベルを定義する

次に、JanusGraph に 使う頂点ラベルについて伝える。'air-routes'グラフには4つの異なる頂点タイプ、つまり、'version'、'airport'、'country'、'continent'があるので、それぞれにラベルを作成する。

[source,groovy]
----
// Define vertex labels
mgmt = graph.openManagement()
mgmt.makeVertexLabel('version').make()
mgmt.makeVertexLabel('airport').make()
mgmt.makeVertexLabel('country').make()
mgmt.makeVertexLabel('continent').make()
mgmt.commit()
----

==== 頂点プロパティキーを定義する

次に、頂点が使う、プロパティキーと、データタイプを定義する必要がある。'air-routes'グラフでは、カーディナリティが'SINGLE'のプロパティのみを使う。

[source,groovy]
----
// Define vertex property keys
mgmt = graph.openManagement()
mgmt.makePropertyKey('code').dataType(String.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('icao').dataType(String.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('type').dataType(String.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('city').dataType(String.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('country').dataType(String.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('region').dataType(String.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('desc').dataType(String.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('runways').dataType(Integer.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('elev').dataType(Integer.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('lat').dataType(Double.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('lon').dataType(Double.class).cardinality(Cardinality.SINGLE).make()
mgmt.commit()
----

==== エッジプロパティキーを定義する

また、エッジで使われるプロパティキーとデータ型を定義する必要もある。現在、'air-routes'グラフには1つのエッジプロパティ、2つの空港間の距離を格納するのに使われる'dist'しかない。

[source,groovy]
----
// Define edge property keys
mgmt = graph.openManagement()
mgmt.makePropertyKey('dist').dataType(Integer.class).cardinality(Cardinality.SINGLE).make()
mgmt.commit()
----

これで、スキーマを定義したので、管理APIを使って実行したすべてが正しく見えることを再確認できる。下記のコードスニペットは Gremlin コンソールで実行でき、データ型とカーディナリティ設定と合わせてプロパティキーを表示する。

[source,groovy]
----
// Look at the properties
mgmt = graph.openManagement()
types = mgmt.getRelationTypes(PropertyKey.class) 
types.each{println "$it\t: " + 
                    mgmt.getPropertyKey("$it").dataType() + 
                    " " + mgmt.getPropertyKey("$it").cardinality()}

mgmt.commit()
----

これが、スキーマ作成がうまくいった場合に返されるはずの出力である。エッジと頂点両方のプロパティキーが表示されていることに注意してほしい。

[source,groovy]
----
lat     : class java.lang.Double SINGLE
lon     : class java.lang.Double SINGLE
dist    : class java.lang.Integer SINGLE
longest : class java.lang.Object SINGLE
code    : class java.lang.String SINGLE
icao    : class java.lang.String SINGLE
type    : class java.lang.String SINGLE
city    : class java.lang.String SINGLE
country : class java.lang.String SINGLE
region  : class java.lang.String SINGLE
desc    : class java.lang.String SINGLE
runways : class java.lang.Integer SINGLE
elev    : class java.lang.Integer SINGLE
----

[[janusload]]
==== air-routes を JanusGraph インスタンスへロードする

これで、'air-routes'グラフのスキーマとインデックスの作成方法がわかったので、TinkerGraph で使ったのと同じ基本的な手順を使って、JanusGraph インスタンスにロードできる。グラフをXMLファイルからロードしたあと、'commit'を呼び出してトランザクションを終了するのを忘れないように。

[source,groovy]
----
graph.io(graphml()).readGraph('air-routes.graphml')
graph.tx().commit()
----

'air-routes'グラフをロードする前に、まだスキーマを定義していなかった場合、JanusGraph は頂点、エッジ、プロパティを作成はするが、デフォルトの型と設定を使って作成される点に注意してほしい。少し後で、'air-routes'グラフのインデックスの作成についても見ていく。データをロードする前に、スキーマも同様に、インデックスを作成するのを強くお勧めするが、その方法について説明する前に、もう少し調べてみよう。

TinkerGraph とは異なり、JanusGraph はデフォルトでは、ユーザが投入した頂点とエッジのIDの値を尊重することを保証しない。代わりに、グラフに頂点やエッジが追加されるたびに独自の ID 値を生成する。本書の前の方で、あるいは air-routes.graphml ファイルの中身を覗いて気づいたかもしれない。GraphMLのマークアップではオースティンのIDは3に指定されている。しかしながら、JanusGraphに'air-routes'がロードされていて、オースティン頂点のIDを照会すると、3ではなくなったことがわかる。JanusGraph にユーザ指定のID値を尊重させるように変更する設定はあるが、これは他の便利な JanusGraph の機能を無効にするので、これを使うことはお勧めしない。このオプションについて詳しく学びたいのであれば、JanusGraph のドキュメントを参照いただきたい。

[source,groovy]
----
g.V().has('code','AUS').id()

4240
----

グラフシステムに独自のID値を割り当てさせることは、グラフにクエリを実行すればIDを取得できるので、大きな問題にはならないが、グラフを扱う際に、ユーザが用意したID値に頼る習慣を身に付けてはいけないことに注意してほしい。

前に説明したように、必要に応じて重要なID値を後で使えるように、いつでも変数に格納することができる。

[source,groovy]
----
ausid = g.V().has('code','AUS').id().next()

g.V(ausid).values('city','desc','region').join(', ')

Austin Bergstrom International Airport, Austin, US-TX
----

プロパティ値は必ずしも指定した順序で返されるとは限らない点に注意してほしい。これは、上記の例を見ればわかる。'values'ステップでは最初は、'city'だったが、実際には'desc'プロパティ値が最初に返された。Gremlin はあなたが要求した特定の順序でアイテムが返されることを保証しない。それらは、トラバーサル中に見つかった順番に返される。返される順序への依存関係をクエリに組み込むべきではない。特定の順序が必要なのであれば、ソートすべきであり、さもなければ、返されたクエリの結果をニーズに合わせるように操作すべきである。

[[jaindexintro]]
=== JanusGraph インデックス

JanusGraph は、それぞれ'graph indexes'と'vertex centric indexes'として知られる、2つの異なるタイプのインデックス作成をサポートする。JanusGraph は、外部インデックステクノロジと合わせて、'composite'インデックス、'mixed'インデックスもサポートする。これらの概念はすべて、以降のセクションで議論され、説明されている。インデックスを使うと、グラフクエリのパフォーマンスが大きく改善されるので、作成、管理しているグラフにインデックスを使うことに慣れ親しむべきだ。多くの場合、インデックスを使うことはデフォルトではオプションだが、必須であるとみなすことを強くお勧めする。JanusGraph ドキュメントはインデクシングについてかなり詳しく説明しており、下記URLにアクセスして読むことができる：
http://docs.janusgraph.org/latest/indexes.html

[[graphindexes]]
==== グラフインデックス

リレーショナルデータベースなどの他のタイプのデータベースを使ったことがあるのであれば、インデックスを使ってデータベース全体へのランダムアクセスを高速化するという概念にはすでに慣れ親しんでいることだと思う。JanusGraph を使う際は、それは'graph index'が果たす役割として、だ。'graph index'の主な仕事は、最初にグラフ全体を検索して探している頂点やエッジを見つけることなく、クエリの開始点を可能な限り効率的に取得することだ。

JanusGraph を操作する際には、常にプロパティキー、あるいはキーの組み合わせに対して'graph index'を作成するべきだ。状況によっては、次に説明する'vertex centric indexes'を作成する必要もあるが、ほとんどの場合、これは、最初からではなく、グラフのパフォーマンスチューニングの一部だ。逆に、最初のグラフスキーマで'graph indexes'を作成することも検討すべきだ。最も単純な'graph index'は、複合インデックスで、このあとすぐに作成方法と使い方について説明する。

[[vciintro]]
==== 頂点セントリックインデックス

頂点セントリックインデックスは、その名前が示すように、頂点に関連づけられたインデックスである。これらは通常、特定の頂点の入射エッジの数が大幅に増えてパフォーマンスに影響を及ぼすようなときに使われる。上述したように、最初にグラフとグラフスキーマを作成するときは、'graph index'のセットのみを作成し、必要に応じて頂点セントリックインデックスを作成することになると思われる。

[[compositeintro]]
==== 複合インデックスを導入する

複合インデックスを使うと、指定されたプロパティキーで値との完全一致クエリを十分に高速化することができる。例えば、下記のクエリは、'city'キーに関連付けられた値が、値'Paris'に完全一致するものを探しているので、複合インデックスを利用することができる。

[source,groovy]
----
g.V().has('city','Paris')
----

複合インデックスは複数のキーを使うクエリをサポートするように定義できる。例えば、'city'や'country'プロパティキーを参照するクエリに使うことができるインデックスを作成して、下記のように、英国のロンドンにある空港ではなく、カナダオンタリオ州ロンドン市にある空港の頂点を見つけるクエリに役立てることができる。

[source,groovy]
----
g.V().has('city','London').has('country','CA')
----

より洗練された部分一致検索や、'equal to'以外の述部を使ったり、クエリで正規表現使ったりする場合には、複合インデックスは役に立たない。そこで'mixed index'が登場する。なので、たとえば、複合インデックスは、'air-routes'グラフで5本を超える滑走路がある空港を探す次のクエリには役に立たない。

[source,groovy]
----
g.V().has('runways',gt(5))
----

[[mixedintro]]
==== 混合インデックスを導入する

上述したように、書こうとしているクエリが単純な同等性のテスト以上のものを必要とするのであれば、混合インデックスと呼ばれるものの作成が必要になるだろう。混合インデックスを作成することにしたら、Apache Solr や Elasticsearch のようなインデックスバックエンドも設定する必要がある。混合インデックスの使い方については、"<<extindex>>" のセクションで説明する。

[[compositeindex]]
==== 完全一致検索を速くするために複合インデックスを構築する

クエリで定期的に使うことになると思われるプロパティキーのグラフインデックスを作成するのを強くお勧めする。インデックスがないと、JanusGraph は1つあるいは複数お特定のプロパティを検索するクエリを発行するたびにグラフ全体を毎回検索する必要があるので、インデックスを使うとグラフの検索を大幅に高速化できる。インデックス化されていないプロパティキーを使うクエリを発行すると、クエリはうまく機能するが、警告がオフになっていない限り、JanusGraph は、クエリのパフォーマンスを向上させるために、インデックスの作成を検討すべき旨を通知する。

NOTE: JanusGraph を実行している一部のグラフシステムでは、完全なグラフ検索を実行する機能が無効になっている可能性があるので、クエリで使うプロパティキーのインデックスが必要になる可能性を常に気にしておくべきだ。

下記の例を見てほしい。値'LHR'を含む'code'プロパティ空港を探す単純なクエリを発行する。そのプロパティキーのインデックスをまだ作成していないので、JanusGraph は探している頂点を返す前に警告を出す。使っている JanusGraph システムのシステム管理者が完全なグラフ検索を実行する機能(デフォルトでは on になっているが無効にできる機能) を無効化している場合、下記のクエリはエラーメッセージ出して失敗する。

[source,groovy]
----
g.V().has('code','LHR')

WARN  org.janusgraph.graphdb.transaction.StandardJanusGraphTx  
    - Query requires iterating over all vertices [(code = LHR)]. 
      For better performance, use indexes

v[32904]
----

インデックスが存在する場合、グラフ自体を参照する前に、JanusGraph はインデックスを参照する。検索対象のプロパティキーがインデックスされている場合、グラフ内でそのプロパティキーが出現するたびにインデックスにエントリが現れる。これにより、JanusGraph は、それらの要素を探してグラフ全体を検索することなく、要素を直接フェッチできるようになる。大きなグラフでは、これによりパフォーマンスが大幅に改善する。インデクシングのニーズに応じて、Apache Solr や Elasticsearch のような外部インデックステクノロジも使う必要があったりなかったりする。外部インデックスを使う主題については、後ほど説明する。まずは、外部インデックスの助けを必要とせず、JanusGraph が自前で管理できる作成可能なインデックスのタイプを見てみよう。

JanusGraph を使うと、管理APIを使ってインデックス作成し、操作をすることができる。JanusGraph ドキュメントは、インデックスを作成し始める前に、常に'graph().tx().rollback()'を呼び出して、他のトランザクションが現在アクティブになっていないことを確認することを強く推奨している。

下記の例は管理APIを使って、'air-routes'グラフの空港の'code'プロパティの新しい複合インデックスを作成する方法を示している。

[source,groovy]
----
// Make sure no other transactions are open
graph.tx().rollback()

// Open a new management transaction
mgmt = graph.openManagement()

// Create a composite index for the code key for use with vertices
idx = mgmt.buildIndex('airportIndex',Vertex.class)
iata = mgmt.getPropertyKey('code')
idx.addKey(iata).buildCompositeIndex()

// All done commit our changes to end the transaction
mgmt.commit()
----

インデクスを作成したら、何か他のことをやろうとする前に、そのインデックスが利用可能になるまで待つことが重要だ。これには、JanusGraph 管理 API の一部でもある'awaitGraphIndexStatus'メソッドを呼び出すとよい。

[source,groovy]
----
mgmt.awaitGraphIndexStatus(graph, 'airportIndex').
     status(SchemaStatus.REGISTERED).call()
----

グラフにすでにデータがある場合は、JanusGraph に再インデックスを実行するように伝える必要もある。再度、管理API を使ってこれを行うが、今回は、'updateIndex'メソッドを使う。

[source,groovy]
----
mgmt = graph.openManagement()
mgmt.updateIndex(mgmt.getGraphIndex("airportIndex"), SchemaAction.REINDEX).get()
mgmt.commit()
----

前に使ったのと同じクエリを再実行し、JanusGraph から インデックスを使うことに関する警告を受け取った場合、今回は同じ結果が得られるが、警告は出ない。これは、JanusGraphが作成したばかりのインデックスを使ってクエリを満たすことができたことを示している。

[source,groovy]
----
g.V().has('code','LHR')

v[32904]
----

また、JanusGraph 管理 API を使って、定義したばかりのインデックスに関する情報を照会することもできる。下記に示すように、これまでに1つしかインデックスを作成していないので、返されるのはそれだけだ。

[source,groovy]
----
mgmt = graph.openManagement()

// What indexes are defined?
v_idxes = mgmt.getGraphIndexes(Vertex.class)

airportIndex

// Print the key names they are associated with
v_idxes.each {println it.getFieldKeys()} 

[code]

mgmt.commit()
----

複数のキーを含むクエリをサポートするインデックスを定義することもできる。例えば、基本的に、値がロンドンである'city'プロパティと、'CA'の値をもつ country プロパティをもつ任意の頂点を探すクエリ下記のようなクエリを支援するのに使われるインデックスを作りたくなるだろう。

[source,groovy]
----
g.V().has('city','London').has('country','CA')
----

次のコードを使って、このようなクエリをサポートするインデックスを定義できる。前の例との唯一の違いは、インデックスに1つのキーではなく、2つのキーを追加していることに注意してほしい。'addKey'メソッドは、Gremlin クエリはキーを使うという想定とは逆の順序で、'city'キーの前に'country'キーを使って呼び出される点にも注意してほしい。

[source,groovy]
----
// Make sure no other transactions are active
graph.tx().rollback() 

// Start a new management transaction
mgmt = graph.openManagement()

// Find the property keys that we need to index
city = mgmt.getPropertyKey('city')
country = mgmt.getPropertyKey('country')

// Create a new index and add our keys
index = mgmt.buildIndex('byCityAndCountry', Vertex.class)
index.addKey(country).addKey(city).buildCompositeIndex()

// All done
mgmt.commit()

// Wait for the index to be active
mgmt.awaitGraphIndexStatus(graph, 'byCityAndCountry').call()

// Force a re-index
mgmt = graph.openManagement()
mgmt.updateIndex(mgmt.getGraphIndex("byCityAndCountry"), SchemaAction.REINDEX).get()
mgmt.commit()             
----

Gemlinの'profile'ステップを使って、JanusGraph が実際に新しいインデックスを使っていることを検証することができる。ページに収まるように出力の一部を切り捨てたが、この出力から、クエリが実際に新しいインデックスを使ったことがわかる。

[source,groovy]
----
g.V().has('city','London').has('country','CA').profile()
----

これが、クエリによって返される出力である。

[source,console]
----
Traversal Metrics
Step                                              Traversers  Time (ms)
========================================================================
JanusGraphStep([],[city.eq(London), country.eq(...      1          1.036
    \_condition=(city = London AND country = CA)
    \_isFitted=true
    \_query=multiKSQ[1]@2147483647
    \_index=byCityAndCountry
    \_orders=[]
    \_isOrdered=true
  optimization                                                     0.741
  backend-query                                         1          0.085
    \_query=byCityAndCountry:multiKSQ[1]@2147483647
                                            >TOTAL      -          1.036
----

==== キーマを自動生成、インデクシング、グラフロードするスクリプト

本書のための、私の GitHub プロジェクトのサンプルコードディレクトリには、`janusgraph-inmemory.groovy` という小さな Gremlin (Groovy) スクリプトがファイルにある。このURL にアクセスすれば、ファイルにアクセスできる：
https://github.com/krlawrence/graph/blob/main/sample-code/janus-inmemory.groovy

スクリプトは'inmemoy' JanusGraph インスタンスを作成し、スキーマを定義し、いくつかのインデックスを作成し、 air-routes.graphml ファイルをロードして、Gremlin コンソールを使っていくつかのクエリを試すことができるようにする。JanusGraphのこの説明でこれまで扱ってきた 概念を実験する良い方法があると思う。

[[janpred]]
=== 追加の JanusGraph テキスト検索述部

”<<tranges>>" のセクションで、'neq'、'gte'や'lte'のようなTinkerPop が定義する述部についてすでに見てきた。JanusGraph ではグラフでテキストの特定のパターンを探す際に使うことができる一連の述部が用意されている。

名前に'Contains'という単語が含まれているメソッドは、指定された検索パターンにマッチする単語全体を探す。名前に'Contains'が含まれていないメソッドは、マッチが検出された文字列全体を参照する。

次の表は、JanusGraph で用意されている追加のテキスト検索述部をまとめたものだ。

.Additional JanusGraph text search predicates
[cols="^1,4"]
|==============================================================================
|textContains           | True if a whole word matches the search string provided.
|textContainsPrefix     | True if at least one word starts with the search string provided.
|textContainsRegex      | True if at least one word matches the regular expression provided.
|textContainsFuzzy      | True if a word matches the fuzzy search text provided.
|textPrefix             | True if the string being inspected starts with the search text.
|textRegex              | True if the string being inspected matches the regular expression provided. 
|textFuzzy              | True if the string being inspected matches the fuzzy search text.
|==============================================================================

これらの述部の各々について、それが使われている例と合わせて、それらが提供するものを見てみよう。まず、下記のクエリは、'"Dallas"'という単語が含まれている'desc'(description) のプロパティをもつ任意の頂点を見つける。これは、スペースやスラッシュなどの任意の単語区切り文字が続く'Dallas'にマッチすることに 注意してほしい。

==== テキスト比較述部

最も単純な検索述部では、文字列が単語全体（完全な単語一致) あるいは、検査対象のテキスト全体の一部として存在する必要がある完全一致を指定することができる。これらの検索では、大文字と小文字は区別**されない**。

[source,groovy]
----
g.V().has('desc',textContains("Dallas")).values('desc')
----

これが、クエリが返すものだ。

[source,console]
----
Dallas/Fort Worth International Airport
Dallas Love Field
----

'textContains'を使って検索される単語は、文字列の最初の単語である必要はない。それは単語として存在する必要があるだけだ。下記のクエリは、'desc'プロパティのどこかに表示される "Love" という単語を見つける。

[source,groovy]
----
g.V().has('desc',textContains("Love")).values('desc')
----

これが、クエリが返すものだ。

[source,console]
----
Dallas Love Field
Ernest A. Love Field
----

この例では、'fort'という単語は、スタンドアローンの単語として出現する限り、'city'名のどこにあっても見つかる

[source,groovy]
----
g.V().has('city',textContains("fort")).values('city')
----

下記の結果からわかるように、'VIeux Fort'と、'Fort'で始まる名前のすべての都市が見つかった。

[source,console]
----
Fort Myers           Fort Worth               
Fort-de-France       Fort McMurray            
Fort Lauderdale      Fort Sandeman            
Fort Wayne           Fort Smith               
Fort St.John         Fort Yukon               
Fort Nelson          Fort Albany              
Fort Chipewyan       Fort Hood/Killeen        
Fort Mcpherson       Vieux Fort               
Fort Smith           Fort Good Hope           
Fort Severn          Fort Frances             
Fort Simpson         Fort Hope                
Fort Leonard Wood    Fort Dodge               
----

下記のクエリはグラフのどの説明にある単語全体ともマッチしないので、結果は返されない。

[source,groovy]
----
// Matches no whole word so no results
g.V().has('desc',textContains("Dalla")).values('desc')
----

'textContains'の代わりに'textContainsPrefix'を使うと、検索では、指定されたテキストで始まる単語全体が検索され、いくつかの結果が得られる。次の食えりとそれが生成する結果を見てほしい。

TIP: textContains と textContainsPrefix を使った検索では、大文字と小文字は区別されない。

[source,groovy]
----
g.V().has('desc',textContainsPrefix("dalla")).values('desc')
----

これが、クエリが返すものだ。今回は、'Dallas'が'dalla'の文字で始まるのでいくつかの結果が得られた。繰り返すが、これらは大文字と小文字を区別しないクエリであることを忘れないでいただきたい。

[source,console]
----
Dallas/Fort Worth International Airport
Dallas Love Field
----

'textContains'クエリを使って、description の一部に単語'Regional'がある空港を見つけることができる。このようなクエリの例を下記に示す。マッチした空港の description の最初の５件のみが返される。

[source,groovy]
----
g.V().has('desc',textContains('Regional')).values('desc').limit(5)
----

これが、クエリによって返されたdescriptionである。 

[source,console]
----
Rapid City Regional Airport
Abilene Regional Airport
Grand Junction Regional Airport
San Luis County Regional Airport
Liberal Mid-America Regional Airport
----

少し具体性を下げて、descriptionにある単語の先頭に、'Reg'がある空港を探したい場合は、上記で実行した地域の空港のクエリを調整して、'textContainsPrefix'を使うとよい。

[source,groovy]
----
g.V().has('desc',textContainsPrefix('Reg')).values('desc').limit(5)
----

それでも、同じ５つの結果が返される。

[source,console]
----
Rapid City Regional Airport
Abilene Regional Airport
Grand Junction Regional Airport
San Luis County Regional Airport
Liberal Mid-America Regional Airport
----

'textPrefix'述部は、検査される文字列全体を調べて、それを指定した文字列と比較し、文字列が指定したパターンで始まる場合にのみ結果を返す。なので、この場合、文字列全体の先頭のみを見て、その中の個々の単語は参照しない。下記のクエリは、名前が、'Los'の文字で始まる都市を探す。

[source,groovy]
----
g.V().has('city',textPrefix('Los')).values('city')
----

TIP: textPrefix を使った検索は大文字と小文字を区別する。

これは、クエリから返されるものです。

[source,console]
----
Los Alamos
Los Angeles
Los Mochis
Losuia
----

クエリで、この場合、'Los'が名前の先頭になかったので、'Chapelco/San Martin de los Andes'の都市が見つからなかった点に注目してほしい。その都市も見つかるようにしたいのであれば、下記に示すように、代わりに、'textContainsPrefix'を使うとよい。

[source,groovy]
----
g.V().has('city',textContainsPrefix('Los')).values('city')
----

ご覧通り、今回は、'Chapelco/San Martin de los Ande'も見つかり、返された結果に含まれている。前と同様、検索語の場合は無視される。

[source,console]
----
Los Alamos
Chapelco/San Martin de los Andes
Los Angeles
Los Mochis
Losuia
----

==== 正規表現述部

JanusGraphの正規表現述部は、 https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html に記載されている Java 1.8 Pattern クラスの一部として定義された構文を認識する。Java の正規表現の構文は、これまで使ってたものと違う場合があるので、そのURLのドキュメントを調べるのに少し時間を費やすだけの価値はある。

下記のクエリでは、'textContainsRegex'述部を使って、大文字、小文字を無視して、'for'で始まる都市名を検索する。

[source,groovy]
----
g.V().has('city',textContainsRegex("(?i)for.*")).values('city')
----

'Fort Myers'のような'For'で始まる名前と、後続の単語にテキスト'For'で始まる単語を含む都市名がどのように見つかるかに注目してほしい。例えば'La Fortuna'と'View Fort'も見つかる。

[source,console]
----
Fort Myers                Fort Worth                
La Fortuna/San Carlos     Fort McMurray             
Fort-de-France            Fort Sandeman             
Fort Lauderdale           Fortaleza                 
Fort Wayne                Fort Smith                
Jerez de la Forntera      Fort Yukon                
Fort St.John              Fort Albany               
Fort Nelson               Fort Hood/Killeen         
Fort Chipewyan            Vieux Fort                
Formosa                   Fort Good Hope            
Fort Mcpherson            Grand Forks               
Fort Smith                Fort Frances              
Juiz de Fora              Fort Hope                 
Fort Severn               Fort Dodge                
Fort Simpson              Fort Leonard Wood
----

下記のクエリは大文字、小文字を区別せずにテキスト文字列の先頭に単語'dallas'を見つける他の方法を示している。今回は、とても単純な正規表現を使う。もちろん、実際には、これにより'textContainsPrefix'を使うだけで得られるのと同じ結果が得られる。

[source,groovy]
----
// Matches dallas ignoring case
g.V().has('city',textRegex("(?i)dallas")).valueMap('code','city')
----

ご覧のとおり、クエリは期待通りに機能する。

[source,console]
----
[code:[DFW],city:[Dallas]]
[code:[DAL],city:[Dallas]]

----

検索を少し拡張したい場合は、下記に示すように、正規表現を修正して、文字'dal'で始まる都市名を見つけるとよい。

[source,groovy]
----
// Matches any city that contains dal followed by anything, ignoring case.
g.V().has('city',textRegex('(?i)dal.*')).values('city')
----

今回は、いくつかの追加の都市が返される。

[source,console]
----
Dallas
Dallas
Dalcahue
Dalat
Dalaman
Dalanzadgad
Dalian
----

代わりに、もっと具体的にしたいのであれば、再度正規表現を調整するとよい。今回、任意の３文字で始まり、そのあとに文字'cah'が続き、そのあとに任意の数の文字が続く都市名を探す。

[source,groovy]
----
// Anything that matches 3 characters followed by 'cah' followed by anything.
g.V().has('city',textRegex(".{3}cah.*")).values('city')
----

変更されたより具体的な検索パターンを使うと、パターンにマッチした都市を１つだけ見つける。
 
[source,console]
----
Dalcahue
----

これが、任意の３文字で始まり、そのあとに'cah'もしくは'anz'のいずれかが続き、そのあとに任意の数の文字が続く都市名を探す別の例だ。

[source,groovy]
----
g.V().has('city',textRegex(".{3}(cah|anz).*")).values('city')
----

これが、この正規表現を使って返されたものだ。

[source,console]
----
Dalcahue
Dalanzadgad
----

これは正規表現を使って、文字'US-'で始まり、そのあとに'O'、'R'、あるいは'D'のいずれかが続き、そのあとに任意の数の文字が続く地域コードをもつ空港を見つける別のクエリである。

[source,groovy]
----
g.V().has('region',textRegex("US-[ORD].*")).
      local(values('code','region').fold()).fold()
----

これが、このクエリが返すものだ。

[source,groovy]
----
[[PVD,US-RI],[LMT,US-OR],[SWO,US-OK],[PDX,US-OR],[EUG,US-OR],[MFR,US-OR],[TOL,US-OH],[PDT,US-OR],[CMH,US-OH],[OTH,US-OR],[YNG,US-OH],[OKC,US-OK],[DAY,US-OH],[LAW,US-OK],[LCK,US-OH],[LUK,US-OH],[RDM,US-OR],[DCA,US-DC],[CLE,US-OH],[TUL,US-OK],[CAK,US-OH],[ILG,US-DE],[BID,US-RI]]

----

これは、正規表現を使ったもう少し複雑なクエリです。このパターンは任意の文字で始まり、'al'が続き、オプションで別の'l'が続き、そのあとに、'"s,k,e,i"'のいずれでもない文字が続く単語を含む空港のdescription にマッチする

[source,groovy]
----
g.V().has('desc',textContainsRegex("(?i).all?[^(s|k|e|i)]")).values('desc')
----

これがクエリが返す空港のdescription のリスト

[source,console]
----
Dinard-Pleurtuit-Saint-Malo Airport
Walla Walla Regional Airport
Salt Lake City
Palm Springs International Airport
Eduardo Falla Solano Airport
Palm Beach International Airport
Salt Cay Airport
Melville Hall Airport
Hall Beach Airport
----

==== あいまい検索述部

これらの述語は、
https://en.wikipedia.org/wiki/Levenshtein_distance[レーベンシュタイン距離] メソッドを使って、テキストの一部が検索対象のパターンに十分近いかどうかを判断する。これは、検索対象のテキストを一致させるために、パターンワードで何文字変更する必要があるかの評価に基づいている。たとえば、'pall'は、'palm'、'paul'、'palm'に一致する。

下記のクエリは、ファジーソートを使って単語'pall'に近い単語を検索する。

[source,groovy]
----
g.V().has('desc',textContainsFuzzy("pall")).values('desc')
----

これが、クエリを実行した結果である。'Paul'、'Palm'、'Hall'という単語全体を含む空港のdescription が見つかったことがわかる。

[source,console]
----
Minneapolis-St.Paul International Airport
Palm Beach International Airport
Palm Springs International Airport
John Paul II International Airport Krakow-Balice Airport
Melville Hall Airport
Hall Beach Airport
St Paul Island Airport
----

このクエリは'textFuzzy'を使って、名前がダブリンに近い都市を見つける

[source,groovy]
----
g.V().has('city',textFuzzy('Dublin')).values('city')
----

これはクエリが返すものだ。'fuzzy'検索で使われる手法は、単なる１文字を置き換えるものではないことがわかる。返される都市名のすべてが同じ長さであるとは限らないことに注意してほしい。'fuzzy'検索アルゴリズムをよりよく理解するにはWikipedia の上述のページを参照することをお勧めする。

[source,console]
----
Yulin
Hubli
Dublin
Lublin
Dubois
Dubai
----

[[janusgeo]]
=== JanusGraph GeoSpatial API

以前、"<<latlonmanual>>" のセクションで、'air-routes'グラフにある空港には、プロパティの中に緯度と経度が含まれているという事実を利用する作成する方法のいくつかの例を紹介した。 JanusGraph を使う場合、利用できる追加の組み込み機能がいくつかある。

NOTE: JanusGraph API の公式ドキュメントはGepShape クラスとその関連クラスを調べるのによい。そのドキュメントは、ここでいつでも見つけることができる:
http://docs.janusgraph.org/latest/javadoc.html

下記の例は、GeoSpatial API を使ってロンドンヒースロー(LHR) を中心とした半径100km以内の空港を検索し、見つける１つの方法を示している。気に掛けるべき主要クラスが、'Geoshape'クラスである。これはその領域内にある他の座標をテストする際に使用できる領域を作成するのに使うことができる。

下記のコードには、グラフ内の各空港ごとに、その空港の緯度と経度に基づいて'point'が作成されていることに注目してほしい。次に、その'point'が半径100km以内にあるかどうかを確認するためにテストが実行される。'valueMap'に渡されるのは空港だけだ。'point'作成中にクロージャ内で計算できるようにどのように'map'ステップが使われているかにも注目してほしい

[source,groovy]
----
// Get the lat/lon for LHR
lon = g.V().has('code','LHR').values('lon').next()
lat = g.V().has('code','LHR').values('lat').next()

// Create a 100km radius circle with LHR at the center
boundary = Geoshape.circle(lat,lon,100)

// Find other airports that are within that circle
g.V().hasLabel('airport').
      where(map{a=it.get().value('lat'); 
                b=it.get().value('lon'); 
                Geoshape.point(a,b).within(boundary)}.is(true)).
                valueMap('code','lat','lon')
----

下記は、上記のクエリを実行して返される出力だ。クエリは'air-routes'グラフを含むJanusGraph インスタンスに接続されたGremlin コンソールからそのまま実行できる。

[source,groovy]
----
[code:[LGW],lon:[-0.190277993679047],lat:[51.1481018066406]]
[code:[BZZ],lon:[-1.58361995220184],lat:[51.749964]]
[code:[STN],lon:[0.234999999404],lat:[51.8849983215]]
[code:[LTN],lon:[-0.368333011865616],lat:[51.874698638916]]
[code:[SOU],lon:[-1.35679996013641],lat:[50.9502983093262]]
[code:[LHR],lon:[-0.461941003799],lat:[51.4706001282]]
[code:[LCY],lon:[0.055278],lat:[51.505278]]
[code:[SEN],lon:[0.695555984973907],lat:[51.5713996887207]]
----

グラフ内のすべての空港に'point'が作成されないようにクエリを最適化する方法はたくさんある。この特定のケースでは、例えば、イングランドの空港のみしか関心がないと判断する場合がある。これを行うには、クエリにチェックを追加して地域コードが'GB-ENG'の空港のみをテストされるのを確認するとよい。これが、そのチェックを追加して修正されたクエリである。

[source,groovy]
----
// Find other airports that within 100km of LHR
g.V().has('airport','region','GB-ENG').
      where(map{a=it.get().value('lat'); 
                b=it.get().value('lon'); 
                Geoshape.point(a,b).within(boundary)}.is(true)).
                valueMap('code','lat','lon')
----

これが再度クエリを実行した出力だ。返された結果の順序が異なることを除いて、同じ結果が得られた。しかしながら、このクエリは、'region'プロパティに対して前に作ったインデックスを利用して、地域'GB-ENG'にないすべての空港を除外できるので、より効率的だ。

[source,groovy]
----
[code:[LGW],lon:[-0.190277993679047],lat:[51.1481018066406]]
[code:[LHR],lon:[-0.461941003799],lat:[51.4706001282]]
[code:[LCY],lon:[0.055278],lat:[51.505278]]
[code:[STN],lon:[0.234999999404],lat:[51.8849983215]]
[code:[LTN],lon:[-0.368333011865616],lat:[51.874698638916]]
[code:[SOU],lon:[-1.35679996013641],lat:[50.9502983093262]]
[code:[SEN],lon:[0.695555984973907],lat:[51.5713996887207]]
[code:[BZZ],lon:[-1.58361995220184],lat:[51.749964]]
----

GeoSpatial API を使ってさまざまな地理的領域を表す形状を作成し、比較することができる。次の例は、ロンドンヒースロー(LHR_ を中心として半径 100 km の円を作成し、マンチェスター(MAN) を中心に２つ目の円を作成する方法を示している。'interest'メソッドを使って両方の円に点が表示されるかどうかを確認できる。

[source,groovy]
----
// Create a 100km radius circle with LHR at the center

lon_lhr = g.V().has('code','LHR').values('lon').next()
lat_lhr = g.V().has('code','LHR').values('lat').next()

lhr_circ = Geoshape.circle(lat_lhr,lon_lhr,100)

// Create a 100km radius circle with MAN at the center

lat_man = g.V().has('code','MAN').values('lat').next()
lon_man = g.V().has('code','MAN').values('lon').next()

man_circ = Geoshape.circle(lat_man,lon_man,100)

// Do any points in the two circles intersect?

lhr_circ.intersect(man_circ)

false
----

ご覧の通り、テストは 共有ポイントがないことを表す'false'を返す。ポイントが重なる場合にテストが機能することを証明するために、中央にリバプール(LPL) を中心とする別の100 km の円を生成して、それをマンチェスターの円と比較してみよう。

[source,groovy]
----
// Create a 100km radius circle with LPL at the center

lat_lpl = g.V().has('code','LPL').values('lat').next()
lon_lpl = g.V().has('code','LPL').values('lon').next()

lpl_circ = Geoshape.circle(lat_lpl,lon_lpl,100)  

// Do any points in the two circles intersect?

lpl_circ.intersect(man_circ)

true
----

'Geoshape'クラスにはいくつかの便利なメソッドが用意されている。LHR 頂点から取得した緯度と経度の値が有効であること、つまり実際に地球上のどこかのポイントを表していることを検証したい場合は次のように行うとよい。

[source,groovy]
----
Geoshape.isValidCoordinate(lat,lon)

true
----

以前、"<<latlonmanual>>" のセクションで、下記のクエリをお見せした。このクエリはロンドンヒースロー(LHR) 空港の周りの概念的な長方形内のすべての空港を見つける。この長方形は、LHR を中心として、反対側の対角線に１度の緯度経度を加算、減算することにより定義されている。

[source,groovy]
----
lat = g.V().has('code','LHR').values('lat').next()
lon = g.V().has('code','LHR').values('lon').next()

g.V().hasLabel('airport').has('lon',between(lon-1,lon+1)).
                          has('lat',between(lat-1,lat+1)).
                          valueMap('code','lat','lon')   
----

これが、クエリが生成する出力である。

[source,groovy]
----
[code:[LHR],lon:[-0.461941003799],lat:[51.4706001282]]
[code:[LGW],lon:[-0.190277993679047],lat:[51.1481018066406]]
[code:[LCY],lon:[0.055278],lat:[51.505278]]
[code:[STN],lon:[0.234999999404],lat:[51.8849983215]]
[code:[LTN],lon:[-0.368333011865616],lat:[51.874698638916]]
[code:[SOU],lon:[-1.35679996013641],lat:[50.9502983093262]]
----

JanusGraph Gepshape クラスを使って、下記に示すようにクエリを書き直すことができる。今回は'circle'を使う代わりに、ロンドンヒースロー(LHR) 周辺の地理的領域を表す'box'を作成する。

[source,groovy]
----
// Define a box around LHR with opposite diagonal corners 
// each one degree from LHR.
box = Geoshape.box(lat_lhr-1,lon_lhr-1,lat_lhr+1,lon_lhr+1)

// Find other airports that within the box
g.V().has('airport','region','GB-ENG').
      where(map{a=it.get().value('lat');
                b=it.get().value('lon');
                Geoshape.point(a,b).within(box)}.is(true)).
                valueMap('code','lat','lon')     
----

新しいクエリを実行した結果を下記に示す。ご覧のとおり、同じ空港が見つかった。

[source,groovy]
----
[code:[LGW],lon:[-0.190277993679047],lat:[51.1481018066406]]
[code:[LHR],lon:[-0.461941003799],lat:[51.4706001282]]
[code:[LCY],lon:[0.055278],lat:[51.505278]]
[code:[STN],lon:[0.234999999404],lat:[51.8849983215]]
[code:[LTN],lon:[-0.368333011865616],lat:[51.874698638916]]
[code:[SOU],lon:[-1.35679996013641],lat:[50.9502983093262]]
----

JanusGraph の GeoSpatial API を使って実行できる多くのことの例をいくつか示した。これが関心のある分野なのであれば、'Geoshape'と関連するクラスのAPI ドキュメントを読むことをおすすめする。

[[janusstorage]]
=== JanusGraph 用に 永続ストレージ技術を選ぶ

これまで、我々はグラフデータがコンピュータシステムのメモリ上にある例に集中してきた。これまで見た永続性の唯一の形式は、グラフ全体をJSON または、XMLとして保存し、将来的にメモリに読み込みなおすことだ。明らかに、多くの本番システムでは、データの永続性に関して、もっとよいストーリーが必要だ。JanusGraphは、グラフデータを永続化する様々なバックエンドデータベースをサポートする。少し後で、"<<dockercass>>" セクションで、これらのデータベースの選択肢の１つを使って実験する簡単な方法を調査する。

JanusGraph をダウンロードしてインストール（解凍）すると、JanusGraph がインストールされたディレクトリ配下に /conf というディレクトリがみつかる。このディレクトリには、JanusGraph をさまざまなバックエンドデータストアに接続するために使うことができる多数のJava プロパティファイルがある。構成によっては、これらのこのプロパティファイルは変更なしで動くか、編集する必要がある場合もある。各プロパティファイルには、様々な設定の機能を説明する詳細なコメントがある。

NOTE: JanusGraph の公式ドキュメントには、現在サポートされているバックエンドストアそれぞれの詳しい構成情報が記載されている。
http://docs.janusgraph.org/latest/storage-backends.html

JanusGraph を使うときに利用可能な永続ストレージオプションのいくつかを簡単に見ていこう。

[[berkleyintro]]
==== Oracle バークレーDB

アプリケーションが単一のマシンで実行されていて、永続ストアが必要な場合、Oracle Berkley DBはよい選択だ。すべてのデータはアプリケーションが実行されているシステムの同じローカルディスクに永続化される。Berkley DBはインメモリバックエンド以上単一のマシン上でグラフアプリケーションを開発、テストをしたい開発者に人気がある。あなたが、Java か Groovy を使ってアプリケーションを開発しているとすると、Berkley DB Java Edition として知られるBerkley DB の Java バージョンは、アプリケーションに埋め込んで、アプリケーションと同じJVM を使って実行する一連のライブラリとして提供される。Berkley DB JE は単一のマシン上で実行されるので、保存できるグラフデータの量は、そのマシンで利用可能なディスクのサイズに依存する。

適度なサイズのグラフだけが必要な本番システムの場合、これも有効な選択だ。アプリケーションが、頂点が１億を超えるような非常に大きなグラフを生成する可能性がある場合、次で説明する他のマルチノードクラスタ対応のストレージオプションを調査する必要があるかもしれない。複数のユーザが並行してアクセスしてグラフを変更する必要があるのであれば、Berkley DB はおそらく最適な選択ではないだろう。

JanusGraph の'/conf'ディレクトリには、次のように Berkey をサポートする新しい JanusGraph インスタンス生成するのに使うことができる`janusgraph-berkleyje.properties`というファイルが含まれている。

[source,groovy]
----
graph = JanusGraphFactory.open("conf/janusgraph-berkleyje.properties")
----

または、Berkley DB を使う際には設定すべきものがあまりないので、次のように、JanusGraph にプロパティを直接渡すこともできる。２つ目の'set'コマンドは、データをディスク上のどこに保存するかを指定する。

[source,groovy]
----
graph = JanusGraphFactory.build().
          set("storage.backend","berkleyje").
          set("storage.directory","/mydata").
          open()
----

Oracle Berkley DB は 次のURL にある Oracle のウェブサイトからダウンロードが可能だ。
http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/overview/index.html

[[cassandraintro]]
==== Apache Cassandra

Berkley DB が提供するような単一のマシンストレージソリューションではニーズを満たさないのであれば、他にも水平スケーリングや高可用性を提供する選択肢がいくつかある。Apache Cassandra はそのような選択肢の１つだ。どのストレージソリューションを選ぶかは、本書のスコープを超える多数の要因による。しかしながら、すでに組織あるいはデータセンターに Apache Cassandra がデプロイされていて、設定管理する方法を知っている人がいるのであれば、JanusGraph のバックエンドストレージのニーズに適した選択肢になりうる。他のビッグデータシステムと同様、 Apache Cassandra はワークロードタイプに最適なパフォーマンスを得るには、チューニングとメンテナンスが必要だ。新しいスキルを開発し、 いくつかの実験を行う必要が出てくる場合がある。Apache Cassandra は Java で書かれていて、Cassandra インスタンスを実行している仮想マシン内で発生するガーベージコレクションの頻度に注意を払うことが重要になる。ガーベージコレクションが頻発すると、グラフのパフォーマンスに大きな影響を及ぼすかもしれない。Cassandra をデプロイするには、ローカルマシンの単一インスタンスから、マルチノードクラスタまで、たくさんのやり方がある。デプロイ方法はスケーラビリティと冗長性のニーズに依る。Cassandra は Berkley DB と同様、必要に応じて組み込みモードでも実行できることに注意してほしい。 

NOTE: 詳細な構成情報については、 http://docs.janusgraph.org/latest/storage-backends.html にある JanusGraph の公式ドキュメントを参照していただきたい。

少しあとで、"<<dockercass>>" のセクションで、開発とテストに適した環境を提供するDocker コンテナを使った Cassandra の 単一ノードインスタンスのデプロイについて見ていく。

JanusGraphの'/conf'ディレクトリにはApache Cassandra を使う際に使うことができるプロパティファイルがいくつか含まれている。どれを使うべきかは、Cassandra のデプロイ方法に依存する。あとで、外部インデックスを使う際に環境を構成するのに必要な追加のステップについて見ていく。しかしながら、外部インデックスを使わずにCassandra を使う場合は、下記のように接続することができる。

[source,groovy]
----
graph = JanusGraphFactory.open("conf/janusgraph-cassandra.properties")
----

プロパティファイルを編集して、Cassandra システムの ホスト名とIPアドレスの追記が必要になるだろう。デフォルトでは、プロパティファイルは'localhost'を使うように構成されている。

Apache Cassandra は 下記のURL にある Apache のウェブサイトからダウンロードできる。　http://cassandra.apache.org/

[[scyllaintro]]
==== ScyllaDB

ScyllaDB は、Apache Cassandra と API 互換だが、C++で実装されている。Apache Cassandra を使う際に使用するのと同じ構成ファイルで ScyllaDB でも使えるはずだ。

ScyllaDB は次のURL からダウンロードできる。 http://www.scylladb.com/

[[hbaseintro]]
==== Apache HBase

すでに Hadoop や HDFS 環境がセットアップされている、あるいはデプロイする計画があるのであれば、 Apache HBaseが JanusGraph データストアに適している可能性がある。 Apache HBase は、Apache Cassandra と同様、非常に大きなテーブルをサポートするデータベースである。JanusGraph を Apache HBase ストアに接続するのに利用可能なプロパティファイルのいくつかのが。'/conf'ディレクトリにある。

NOTE: 詳細な構成情報については、 http://docs.janusgraph.org/latest/storage-backends.html にある JanusGraph 公式ドキュメントを参照いただきたい。

どのプロパティファイルを使うかは、外部インデックスを使う必要があるかどうかによる。しかしながら、HBase を外部インデックスなしで使うのであれば、下記のように接続することができる。

[source,groovy]
----
graph = JanusGraphFactory.open("conf/janusgraph-hbase.properties")
----

Cassandra のプロパティファイルと同様、HBase のプロパティファイルは'localhost'に接続するように事前設定されている。別のマシンに接続する場合は、'open'を呼び出す前に編集してホスト名とIPアドレスを適切に更新する必要があるだろう。

Apache HBase は次のURLにある Apache ウェブサイトからダウンロードできる。 https://hbase.apache.org/ 

==== Google Bigtable

これまで説明してきた選択肢はすべて、社内でダウンロードして実行できるオープンソースの代替手段だ。完全を期すために、JanusGraph データを社内でホストするために選択可能な「有料の」代替手段へのポインタをいくつか紹介する。Google Bigtable は Apache HBase と API 互換である。JanusGraph で使う独自の HBase クラスタをホストする代わりにホストする代替手段を提供する。もちろん、ホストされたデータベースサービスに対して料金を支払うのが、グラフデータを社内にホストするか、選択したホスティングサービスで管理する独自の環境をセットアップするかのかを決める必要がある。

Google Bigtable についてより詳しくは次のURLを参照いただきたい。 https://cloud.google.com/bigtable/

==== IBM Compose for JanusGraph

IBM はホスト、Compose プラットフォームを介して管理された JanusGraph 環境を 用意している。この環境では、IBM はScyllaDB クラスタで動くJanusGraph を含む環境全体を管理する。Google Bigtable と同様、これは、有料で利用できるホスト型サービスである。JanusGraph で使うためにCassandra 互換クラスタを自分で管理するという考え方が、許容できるものではないのであれば、これは検討すべき選択肢だ。

このサービスの詳細については、次のURLを参照いただきたい。 https://www.ibm.com/cloud/compose/janusgraph

==== 他の Tinkerpop 互換製品とサービス

現在、JanusGraphのサポート自体は提供されていないが、他のストアがサポートされた TinkerPop や Gremlin のサポートを提供している他の製品やクラウドにホストされた環境がいくつかある。ホスト型とインハウス型の両方の選択肢がある。Apache TinkerPop プロジェクトはTinkerPop 互換のグラフストアのリストを維持している。そのリストは、 http://tinkerpop.apache.org/providers.html にある。

本当に良いのは、Apache TinkerPop、特に、Gremlin クエリとトラバーサル言語が、人々がグラフデータベースを構築して操作するための手法な方法の１つになることだ。

[[dockercass]]
=== Cassandra と JanusGraph で実験するために Docker を使う

Docker コンテナを使うことは、新しいアイデアや新しいテクノロジを実験する際、あるいは、よくあることだがそれらを両方同時に実行している際に、素早く実行するための素晴らしい方法になりうることがわかった。Apache Cassandra のとても便利なコンテナ化された実装が利用可能であり、ダウンロードして数秒で実行可能であり、JanusGraph でテストするために使うことができる。本セクションでは、単一の Cassandra ノードを起動して実行し、JanusGraph を使って'air-routes'グラフをセットアップする手順について説明する。私は、必要なDockerランタイムをプラットフォーム上にすでにダウンロードし、インストール済みであることを前提としている。私はほとんどのDockerテストを Linux システム上で行っているが、Windows や Mac OS でも利用可能なランタイムがある。docker がインストールされていると仮定すると、Cassandraは、下記に示すように、単純な'docker pull'コマンドを使ってインストールできる。

コマンドを入力する必要がある場所を明確にするために、Linux ターミナルシェルに入力する必要のあるコマンドに "sh> " のプレフィクスをつけ、Gremlin コンソールに入力するコマンドには、" gremlin> " プレフィクスを付けることに注意してほしい。

[source,console]
----
sh> docker pull cassandra
----

[[cassstart]]
==== Cassandra コンテナを開始する

Dockerが Cassandra イメージをダウンロードできたら、Cassandra の単一のインスタンスを起動して実行するのは非常に簡単だ。Dockerを構成ｓるうのに使える方法はいろいろある。簡単にするために、コマンドラインパラメータを使う。このコマンドは、下記の注に示されているように、いくつかの処理を実行する。読みやすくするためにコマンドを４行に分割した。

[source,console]
----
sh> docker run -d -p 7001:7001 -p 7199:7199 -p 9042:9042 -p 9160:9160 \  <1> <2> <3>
-v  /var/lib/cassandra:/var/lib/cassandra \  <4>
-e CASSANDRA_START_RPC=true \  <5>
--name cass  cassandra   <6>
----

<1> Cassandra コンテナの新しいインスタンスを開始する
<2> "-d" フラグを使って、バックグランドでコマンドを実行する
<3> JanusGraph が Cassandra インスタンスに接続できるように、Cassandra が使う 主要ポートを指定する ("-p" フラグ）
<4> Cassandra のボリュームをローカルディスクにマップ (マウント）する。これは、データが格納される場所である。これを指定しなかったら、データはロストしてしまう。
<5> -e CASSANDRA_START_RPC=true の設定を使って Thrift サポートを有効化する。これは デフォルトで有効になっている CQL を使うのであれば、必要ない。
<6> あとで簡単に参照できるように、コンテナの名前を "cass" にする

新しいコンテナの信仰状況を確認したいのであれば、いつでも、下記のコマンドを使ってログをチェックできる。

[source,console]
----
sh> docker logs cass
----

他の Docker コンテナと同様、Cassandra コンテナは、次のコマンドを使って必要に応じて停止、開始することができる。JanusGraph がデータの書き込みでビジー状態であれば、コンテナを停止しないように注意するべきである。

[source,console]
----
sh> docker stop cass

sh> docker start cass
----

[[cassconnect]]
==== JanusGraph を Cassandra に接続する

これで、Cassandra のインスタンスが実行されたので、JanusGraph のダウンロードに含まれている Gremlin コンソールを起動し、Cassandra に接続する。Cassandra は接続に使える様々なプロトコルをサポートする。これらには、Astyanax (Netflix より)、Thrift、CQL が含まれる。本セクションでは、Thrift と CQL について説明する。これらのプロトコルについての詳細な調査については本書の範囲を超えているが、それらについてもっと読みたいのであれば、いくつかのWeb検索でたくさんのドキュメントが見つかるだろう。Thrift と Astyanax の両方はすでに廃止されていてCQLが採用されていることに注意してほしい。将来のある時点では、古いプロトコルのサポートが終了していると思われるので、JanusGraph を Cassandra に接続する主な手段としておそらくCQL を快適に使うのをお勧めする。

TIP: janus-cassandra.groovyt というスクリプトが https://github.com/krlawrence/graph/tree/main/sample-code の sample-code フォルダに用意されている。このスクリプトは本セクションで説明していることすべてを自動化するので、学習することをお勧めする。

JanusGraph のダウンロードには、多数のプロパティファイルが含まれている。それらは、JanusGraph フォルダのルート配下の'/conf'フォルダにある。これらのプロパティファイルは、JanusGraph を様々なバックエンドテクノロジに接続するのに使うことができる。これらのプロパティファイルは必要に応じて編集することができるが、ローカルマシン(localhost) で実行されている Cassandra で デフォルトの Cassandra ポートを使う限り、この説明のために何も編集する必要はない。

NOTE: Cassandra をリモートマシン上で動かす場合は、プロパティファイルを編集するか、あるいは新しく作成して、リモートシステムの適切なホスト名とIPアドレスを含める必要がある。

JanusGraph を CQL プロトコルを使って Cassandra に接続するのであれば、下記に示すように、Janusgraph-cql.properties ファイルを使うとよい。

[source,groovy]
----
gremlin> graph = JanusGraphFactory.open('conf/janusgraph-cql.properties') 
----

このコマンドを発行すると、警告メッセージのあとに、長いスタックトレースが表示されるかもしれない。何か恐ろしいことが起こったように見えるかもしれないが、これは無視することができ、引き続き正常に機能する。これはコミュニティでよく知られている問題だと思う。

潜在的な警告メッセージは別として、すべてうまくいけば、コマンドを実行したあとに、下記の出力のようなものが表示される。これは、127.0.0.1 のローカルマシンで動いている Cassandra インスタンスへのCQL コネクション接続があることを示している。

[source,groovy]
----
graphtraversalsource[standardjanusgraph[cql:[127.0.0.1]], standard]
----

Thrift プロトコルを使ってJanusGraphを Cassandoraに接続したいのであれば、下記に示すように、janusgraph-cassandra.properties ファイルを使うとよい。

[source,groovy]
----
gremlin> graph = JanusGraphFactory.open('conf/janusgraph-cassandra.properties')
----

コマンドが成功すると、このような出力が返される。

[source,groovy]
----
standardjanusgraph[cassandrathrift:[127.0.0.1]]
----

これらのコマンドのいずれかが実行されると、新しいJanusGraph インスタンスが生成され、JanusGraph は指定されたいプロトコルを使って Cassandra への接続を試みる。真新しい(空の) Cassandra インスタンスに初めて接続すると、頂点やエッジ、プロパティを作成する前に、まずキー定義を作成して、グラフのスキーマを定義し、必要なインデックスを作成する必要がある。Cassandra をバックストアとして使って、'air-routes'データを使って実験をしたいのであれば、sample-code フォルダの janus-cassandra.groovy というスクリプトを使うとよい。必要に応じて コンソールから JanusGraph 管理 API を使って実験ができ、頂点やエッジを追加する前に、キーやインデックスを生成し、トラバーサルソースオブジェクトを生成することができる。

janus-cassandra.groovy スクリプトを実行するのを選ぶと、必要なキーやインデックスが生成されて、air-routes グラフが読み込まれ、いくつかのテストが実行され、すべてがうまく機能していることを確認できる。次回には、データがすでにロードされ、スキーマが定義されているので、このセットアップ手順を１回だけ実行する必要があることに注意してほしい。

NOTE: グラフをローカルのファイルシステムにデータが保存されているCassandra インスタンスに保存しているので、次回JanusGraph を起動して、Cassandraに再接続すると、データがすでに用意されている。

Gremlin コンソールからスクリプトを実行すると、下記に示すように、':local'コマンドを使ってスクリプトをロードできる。

[source,groovy]
----
gremlin> :load janus-cassandra.groovy
----

スクリプトが期待通りに機能するのであれば、グラフをクエリできるはずだ。

[source,groovy]
----
gremlin> g.V().has('type','airport').count()

==>3379
----

グラフの操作を終了したら、グラフを閉じることをお勧めする。閉じたら、作業を再開する前に、上記の２つの'open'手順のいずれかを使って再接続する必要がある。

[source,groovy]
----
gremlin> graph.close()
----

前にデータをロードして閉じた状態でグラフに再接続したら、下記のコマンドを使うことができる。CQL の代わりに、Thrift を使っている場合は、代わりにjanusgraph-cassandra.properties ファイルを使う。

[source,groovy]
----
// Reconnect using CQL
gremlin> graph = JanusGraphFactory.open('conf/janusgraph-cql.properties') 

gremlin> g = graph.traversal()
----

テストと実験を行う際の一般的な要件は、すべてを破棄してやり直すことだ。これを行う最も簡単な方法は、下記に示すコマンドを使うことだ。これは、すべてのデータ、インデックス、スキーマ定義が削除されるので、本当に最初からやり直したい場合にのみ実行すること。

[source,groovy]
----
gremlin> JanusGraphFactory.drop(graph) 
----

'drop'操作を実行したら、前にjanus-cassandra.groovy スクリプトを使って'air-routes'データをロードしていた場合は、スクリプトを再実行してデータ、インデックス、スクリプトを元に戻す必要がある。

もう一つ、認識すべきことは、本セクションに示されている手法を使ってGremlin コンソールと JanusGraph を Cassandra に直接接続していることだ。これは、Gremlin コンソールから 設定を追加したり、JanusGraph にCassandra に接続する方法をプロパティファイルを使って指定したりすることなく、コマンドを直接発行できることを意味する。本書の後で、HTTP サーバを使ってグラフをフロントエンドできる Gremlin サーバを紹介する。JanusGraph は本当にJava ライブラリ (JARファイル）のセットであることも覚えておいてほしい。独自のプロセスを生成せず、サービスとして実行されない。なので、この場合、JanusGraph はGremlin コンソールのプロセスで実行されている。もちろん、Cassandra はスタンドアロンサービスとして実行されている。

[[nodetool]]
==== nodetool を見つける

何らかの理由により Cassandra の設定や全体的なステータスを確認したいのであれば、通常、'nodetool'コマンドを使う。この場合、コンテナ化されたバージョンの Cassandra コードを使っているので、'nodetool'を実行するには、コンテナ内でシェルセッションを開始する必要がある。これは下記に示すように、'docker exec'コマンドを使うとよい。一度コンテナ内に入ると、'nodetool'がデフォルトパスで使うことができる。下記の例は、bash のセッションを開始し、いくつかの'nodetool'コマンドを入力する方法を示している。最後に、セッションを囚虜うする。

[source,console]
----
sh> docker exec -it cass bash
----

シェルプロセスが開始されると、プロンプトが変更されて、コンテナのコンテキスト内で実行される。Once the shell process has started the prompt will change and you are now running

[source,console]
----
root@115ed53ef189:/
----

これで、'nodetool'コマンドを入力できるようになった。読みやすくするために、出力を少し切り捨てた。まず、実行している Cassandra のバージョンを確認しよう。

[source,console]
----
root@115ed53ef189:/ nodetool version

ReleaseVersion: 3.11.1
----

Thrift が実行されていることを確認しよう。

[source,console]
----
root@115ed53ef189:/ nodetool statusthrift

running
----

全体的な状態に関する情報をもっと詳しくほしい場合は、'nodetool info'コマンドを使うとよい。この出力は割愛した。

[source,console]
----
root@115ed53ef189:/ nodetool info

ID                     : 094e9a8c-99af-4d32-94da-49ed8c61b9fd
Gossip active          : true
Thrift active          : true
Native Transport active: true
Load                   : 3.64 MiB
Generation No          : 1517842270
Uptime (seconds)       : 2636
Heap Memory (MB)       : 102.43 / 1956.00
Off Heap Memory (MB)   : 0.03
Data Center            : datacenter1
Rack                   : rack1
Exceptions             : 0
----

コンテナの入力が完了すると、'exit'を入力して、コンテナに入った Linux のターミナルセッションに戻る。

[source,console]
----
root@115ed53ef189:/ exit

sh>
----


[[extindex]]
=== JanusGraph で 外部インデックスを使う

JanusGraph を使うと、ElasticSearch や Apache Solr などのテクノロジを使って外部インデックスを作成できる。グラフクエリの一部としてより洗練されたパターンマッチングを行う必要がある場合には、このようなインデックスを作成するとよい。このトピックは現在 Gremlin クエリや トラバーサル言語、テクノロジーをデプロイする方法のいくつかを詳細に紹介するという本書の範疇を少し逸脱するものだ。外部インデックスを作成する方法の詳細な説明については、次のURLにある JanusGraph のドキュメントにある。 https://docs.janusgraph.org/latest/indexes.html and https://docs.janusgraph.org/latest/index-backends.html


[[gremlinserver]]
== Gremlin サーバを導入する

本書のこれまでのところ、TinkerPop 対応のグラフストアをセットアップするためのいくつかの異なる方法をみてきた。最初は、TinkerGraph あるいは JanusGraph をローカルでデータをメモリ上に保持して動かすことにフォーカスした。また、Gremlin コンソールから接続できるように、JanusGraph を使って Cassandra を構成する方法についても説明した。ご存じのとおり、Cassandra はローカルで、あるいはリモートで実行することができるが、どちらの方法でも正常に接続するには、バックエンド構成の特定の詳細を知っておく必要がある。これには、使用されている IPアドレス。ポート、およびプロトコルを知ることが含まれている。

これは、グラフのユーザにとってこのレベルの洞察とバックエンドへのアクセスシナリオでは許容できるかもしれないが、実装の詳細のほとんどを非表示にしたままセキュアにアクセスするのが望ましい多くのシナリオがある。これはGremlin サーバの出番だ。

Gremlin サーバは、その名前が示すように、フロントエンド Webサーバを経由するグラフへのアクセスをセットアップする方法を提供する。このように、グラフのユーザは、グラフと通信するために、Gremlin サーバの名前あるいはIPアドレスを知っているだけでよい。テストするのに便利なローカルマシン上に Gremlin サーバをセットアップできるが、リモートサーバ上にグラフをセットアップしてユーザがこれにアクセスできるようにもできる。Gremlin サーバはさまざまな接続プロトコルや方法をサポートしている。Gremlin サーバに Gremlin コンソール、'curl'コマンドを用いらコマンドラインやアプリケーションから接続することができる。Gremlin サーバにはグラフの実装の詳細を隠すことができるという２つ目の利点がある。これにより、Apache TinkerPop 言語バインディングまだ持っていないプログラミング言語を使う人々が単純な HTTP プロトコルを使ってグラフを操作できるようになる。

NOTE: Apache TinkerPop の公式ドキュメントには、Gremlin サーバの構成と使い方に関する詳細な説明が含まれている。
http://tinkerpop.apache.org/docs/current/reference/#gremlin-server

Gremlinサーバには数多くの価値ある機能が用意されている。本セクションでは、以前に構築した Cassandra をバックエンドとする JanusGraph を使って Gremlin サーバを介して公開する方法について説明する。Gremlin サーバを構成、デプロイして使うには他にも便利な方法は多数ある。Gremlin サーバを使って今後も実験をする予定があるのであれば、公式ドキュメントを読むことを強くおすすめする。

NOTE: 本書が最初にリリースされた時、「現実世界」のユースケースの大部分は、直接アタッチあるいはインメモリのグラフにフォーカスされていた。Apache TinkerPop が進化するにつれて、Gremlin サーバを介してリモートにグラフを接続するのがはるかに一般的にになった。

[[serverconfig]]
=== Gremlin サーバを設定する

Gremlin サーバのランタイムは Apache TinkerPop の Webサイトから個別にダウンロードできる。しかしながら、Gremlin サーバを JanusGraph と組み合わせて使うのであれば、JanusGraph のダウンロードに同梱されているバージョンを使う必要がある。JanusGraph のバージョンは簡単にJanusGraph ランタイムと連携でき、Cassandra のようなJanusGraph で管理されたバックエンドストアに簡単に接続できいるようにあらかじめ設定されている。Gremlinサーバを最も簡単に設定する方法は、Gremlin サーバや JanusGraph ダウンロードに同梱されている YAMLやプロパティファイルを使うことだ。構成によっては、これらのファイルを編集する必要がある。

Apache TinkerPop のドキュメントには、Gremlin サーバを構成するための様々な方法を示す詳細な手順と、例がある。本セクションでは、JanusGraph と 前に設定した Dockerコンテナ化された Cassandra インスタンスをフロントエンドできる Gremlin サーバの設定にフォーカスするつもりだ。

JanusGraph のダウンロードを解凍した際にマシン上にインストールされたファイルを見ると、'conf/gremlin-server'のパスがあるのがわかるだろう。このディレクトリの中には、Gremlin サーバを起動して JanusGraph と様々なバックエンドストアで動作させるのに使うことができる一連の YAML とプロパティファイルがある。

この議論の残りの部分では、gremlin-server.yaml ファイルをスタート地点として使って、ちょっとした変更を加えていく。

Gremlin サーバはデフォルトでは、WebSockets接続用に設定されていて、それがGremlin コンソールがそれに接続する手段だ。WebSockets を使うことは、で長時間の全二重接続が可能になるので、推奨されるアプローチである。しかしながら、HTTPコネクションをサポートするのが望まれるようなユースケースが多数ある。また、WebSockets と HTTP 接続の両方を許す３つ目のオプションもある。Gremlin サーバを起動するときに使われるYAMLファイルでは、次のいずれかを指定する必要がある。



org.apache.tinkerpop.gremlin.server.channel.WebSocketChannelizer::
- サーバは WebSockets 接続を期待する(これが、デフォルト)
org.apache.tinkerpop.gremlin.server.channel.HttpChannelizer::
- サーバは、HTTP接続を期待する。
org.apache.tinkerpop.gremlin.server.channel.WsAndHttpChannelizer::
- サーバは、WebSockets と HTTP 接続の両方を受け入れる

gremlin-server.yaml の最初の部分を、ニーズに合わせて変更して、下記に示す。表示されていない部分には変更を加えていないが、ファイル全体に目を通して設定を確認することをお勧めする。現在のニーズでは、デフォルトで問題ない。しかしながら、あなたの環境では、デフォルトがニーズを満たさないかもしれない。TinkerPop ドキュメントには設定とその機能の詳細が記載されている。

では、YAML ファイルのこの実験に関連する部分を見てみよう。'WsAndHttpChannelizer'を使うことを選択したことに注意してほしい。これは WebSockets 越しでGremlin コンソールを、HTTP 越しで'curl'や'Ruby'のようなアプリケーション の両方を新しい Gremlin サーバに接続できるようにしたいからである。

janusgraph-cassandra-es.server.properties ファイルが'graphs'セクションで指定されている点にも注目してほしい。これは、JanusGraph のダウンロードの一部として提供されるファイルである。これは、Gremlin サーバがCassandra をバックエンドとするJanusGraph に接続するのに使うファイルである。プロパティファイルの名前にある'"-es"'はElasticsearch を参照している点に注意してほしい。JanusGraph を設定する際に外部インデックスを設定してないので、プロパティファイル中のElasticsearch を参照している行はコメントアウトすること。

'scriptEvaluationTimeout'の設定は重要だ。これは、クエリを打ち切る前に実行する時間をGremlin サーバに指定する。これは、クエリが完了したかどうかに関わらず、基本的にクエリの実行が許容される最大時間が確立される。この実験では、デフォルト設定の30000で十分だ。この値は許容されるミリ秒数を表す。サーバに送信されたクエリをもっと長く実行できるようにしたいのであれば、この値を増やすとよい。同じ Gremlin サーバを使う複数のユーザがいるのであれば、完了するまで時間がかかる可能性のある本当に複雑なクエリを許容したくないかもしれない点には注意してほしい。ちなみに、実際には、グラフにインデックスを作成してクエリをより高速に実行して時間を短縮できるのに、クエリを完了させるために、この値を増やす人がいたことがある。タイムアウト機能を無効したい場合は、タイムアウト値を０（ゼロ）にすることで無効化できる。

.gremlin-server.yaml
[source,groovy]
----
host: 0.0.0.0
port: 8182
scriptEvaluationTimeout: 30000
channelizer: org.apache.tinkerpop.gremlin.server.channel.WsAndHttpChannelizer
graphs: {
  graph: conf/gremlin-server/janusgraph-cassandra-es-server.properties
}
plugins:
  - janusgraph.imports
scriptEngines: {
  gremlin-groovy: {
    imports: [java.lang.Math],
    staticImports: [java.lang.Math.PI],
    scripts: [scripts/empty-sample.groovy]}}

# The rest of the file is not shown  
----

YAML ファイルやプロパティファイルと同様、Gremlin サーバを起動するのに用意する必要のある３つ目のファイルがある。このファイルには、サーバ起動時に実行されるGroovy コードを含めることができる。我々の目的では、デフォルトのファイルが必要なすべてだ。これらのファイルは、 標準の Gremlin サーバや JanusGraph インストールの一部である'scripts'ディレクトリに置く必要がある。あとでデフォルトのスクリプトを見ていく。

デフォルトでは、Gremlin サーバと JanusGraph の両方に、empty-sample.groovy という Groovy スクリプトが含まれている。このファイルは実際にはいくつかの興味深いことを行うので、この名前は少しミスリーディングを招く可能性がある。我々の目的にとって、このスクリプトが実行する最も有用なことは、Gremlin コンソールで、願わくは、これよりぜひ慣れ親しんでいただきたい、グラフトラバーサルソース、'g'オブジェクトを設定をして、利用できるようにすることだ。これにより、Gremlin サーバに接続しているコンソールのユーザが利用可能にする任意の他の'global'変数のテンプレートが提供される。このファイルは、サーバが開始、終了時に生成されるいくつかのデフォルトのログメッセージも設定する。独自のコードをこのスクリプトに追加したり、スクリプトを全体的に自前のものに置き換えたりできることに注意してほしい。Gremlin サーバのダウンロードの一部として含まれている追加のサンプルスクリプトがある。これらのスクリプトはサーバ起動プロセスの一部として、TinkerGraph インスタンスを生成したり、グラフデータの読み込みを行う。この手法を使って、スクリプトに簡単に行を追加して、サーバ起動時に、空のTinkerGraph が生成され、'air-routes'データが読み込まれるようにすることができる。

.empty-sample.groovy
[source,groovy]
----
// an init script that returns a Map allows explicit setting of global bindings.
def globals = [:]

// defines a sample LifeCycleHook that prints some output to the Gremlin Server console.
// note that the name of the key in the "global" map is unimportant.
globals << [hook : [
        onStartUp: { ctx ->
            ctx.logger.info("Executed once at startup of Gremlin Server.")
        },
        onShutDown: { ctx ->
            ctx.logger.info("Executed once at shutdown of Gremlin Server.")
        }
] as LifeCycleHook]

// define the default TraversalSource to bind queries to - this one will be named "g".
globals << [g : graph.traversal()]
----

これで、すべての構成ファイルが配置できたので、ターミナルウィンドウに次のコマンドを入力してGremlin サーバを起動できる。gremlin-server.sh ファイルは、Gremlin サーバあるいは JanusGraph インストールの'bin'ディレクトリにある。

[source,console]
----
sh> gremlin-server.sh conf/gremlin-server/gremlin-server.yaml
----

すべてがうまくいけば、Gremlin サーバからの出力が表示されるはずだ。サーバは強制終了されるまで実行を続ける。この場合、サーバを強制終了するのに必要なのは、単純な CTRL-C だけだ。CTRL-C すると、サーバは少しだけクリーンアップする。

TIP: start キーワードを使って、Gremlin  サーバをバックグランドタスクとして起動できる。

下記に示すように、起動コマンドの一部として、'start'キーワードを追加することにより、現在のターミナルウィンドウ上ではなく、バックグランドでGremlinサーバを起動することもできる。下記の例は、Gremlin サーバのzipファイルをインストールした場所からサーバを起動していることを前提としている。

[source,console]
----
sh> bin/gremlin-server.sh start

Server started 25897
----

デフォルトでは、起動中のサーバの設定情報は conf/gremlin-server.yaml ファイルで探される。この値を上書きする場合は、下記に示すように、サーバを起動する前に、'GREMLIN_YAML'という環境変数を指定する必要がある。

[source,console]
----
sh> export GREMLIN_YAML='conf/mysettings.yaml'
sh> bin/gremlin-server.sh start

Server started 25897
----

環境変数を定義する代わりに、bin/gremlin-server.conf というファイルを作成して、YAMLファイルの名前をその中に入れることができる。下記に例を示す。

[source,console]
----
GREMLIN_YAML='conf/mysettings.yaml'
----

Gremlin サーバが現在実行されているかどうかを確認したい場合は、'status'キーワードを使うとよい。

[source,console]
----
sh> bin/gremlin-server.sh status

Server running with PID 25897
----

サーバを停止するには、次のように、'stop'キーワードを使うとよい。

[source,console]
----
sh> bin/gremlin-server.sh stop

Server stopped [25897]
----

[[serverconsole]]
=== Gremlin サーバに Gemlin コンソールから接続する

実行中の Gremlin サーバに Gremlin コンソールから接続するのはかなり簡単だ。この場合、Apache TinkerPop のダウンロードの一部の Gremlinコンソールを使っているか、JanusGraph ダウンロードの一部のものを使っているかは関係ない。これは Gremlin サーバがバックエンドの実装の詳細を非常にうまく隠ぺいしているからだ。我々にとっては、Gremlin クエリをハンドリングできるHTTTPあるいは WebSockets のエンドポイントにすぎない。

サーバ再度の実装の詳細について心配する必要はないという私の声明には、私が現在認識している例外が1つある。この例外は、潜在的なバージョン不一致の結果だ。通常、TinkerPop ダウンロードは、最新のものが手元にあると仮定して、特定のグラフストアのリリースよりも少なくとも数回マイナーリリースされている。これは純粋に、TinkerPop がリリースされるたびに、GraphDB メンテナーがキャッチアップするのに少し時間がかかるからだ。これの具体例をすぐにお見せする。

Gremlin サーバと同様、YAML ファイルを使ってGremlin コンソールからリモート接続を設定することができる。この Gremlin コンソールには、　janusGraph にバンドルされているバージョンと同様、そのままで、あるいは必要に応じて編集して使うことができる一連のYAMLファイルが含まれている。Gremlin コンソールを 設定したばかりのGremlin サーバに接続するには、ファイル'remote.yaml'を使うとよい。下記に示すように、１か所変更する必要があった。'serializer'の行をコメントアウトして、少し修正したバージョンに置き換えた。これを行う必要があるのは、上述したバージョンの問題によるものだからだ。執筆時点では、JanusGraphは、Gremlin コンソールと Gremlin サーバ間の 通信のシリアル化プロトコルとして使われるGyroMessageSerializer のバージョン V1d0 サポートする。しかしながら、私の Gremlin コンソールはより新しいバージョン V3d0 のシリアライザで事前設定されている。コンソールとサーバは同じバージョンが使われるのが基本だ。この変更をしていなかったら、Gremlin コンソールと Gremlin サーバは正しく通信できないはずだ。'remote.yaml'ファイルには、接続するGremlin サーバホストの名前とポートも指定されていることに注意してほしい。すべてローカルで実行しているので、デフォルトホスト名の'Localhost'は正しい。リモートの Gremlin サーバに接続しようとしているのでれば、'hosts'の値を編集して Gremlin サーバが実行されているサーバの正しい識別名、あるいはIPアドレスを指定する必要がある。また、デフォルトの8182 番ポートも使うことができる。デフォルトでは、Gremlin サーバは 8182 ポート上でリッスンする。この値を変更する必要があるのは、違うポートを使って Gremlin サーバに接続している場合だけだ。

[source,groovy]
.remote.yaml
----
hosts: [localhost]
port: 8182
#serializer: { className: org.apache.tinkerpop.gremlin.driver.ser.GryoMessageSerializerV3d0, config: { serializeResultToString: true }}
serializer: { className: org.apache.tinkerpop.gremlin.driver.ser.GryoMessageSerializerV1d0, config: { serializeResultToString: true }}
----

[[remoteconn]]
==== リモートに接続する

これで、YAMLファイルの準備ができたので、Gremlin コンソールと Gremlin サーバ間の接続を確立するために必要なことは、コンソールの実行後に、次のコマンドを発行することだけだ。

[source,console]
----
gremlin> :remote connect tinkerpop.server conf/remote.yaml
----

これで、 Gremlin サーバに接続できたので、Gremlin コマンドを発行できるようになった。'air-routes'グラフがすでにリモートグラフにロードされているのであれば、すぐにクエリの発行を開始できる。クエリがリモートグラフに確実に送信されるようにするためには、クエリのまえに、'":>"' のプレフィクスを付与する必要がある。

[source,groovy]
----
gremlin> :> g.V().count()

==>3624
----

[[resultvar]]
==== Gremlin コンソールの結果変数

Gremlin コンソール内で作業を行う場合、注意すべきもう１つの便利な点は、サーバに送信されたクエリの結果,コンソールが'"local mode"'にある場合、表示されている結果が'result'という変数に格納されるということだ。下記のクエリを見てほしい。

[source,groovy]
----
gremlin> :>  g.V().hasLabel('continent').group().by('desc').by(out().count())

==>{South America=305, Asia=941, Europe=596, Africa=298, Antarctica=0, North America=981, Oceania=287}
----

'result'変数の中身を出力すると、クエリの結果が含まれていることがわかる。

[source,groovy]
----
gremlin> println result

[result{object={South America=305, Asia=941, Europe=596, Africa=298, Antarctica=0, North America=981, Oceania=287} class=java.lang.String}]
----

コンソールはまだローカルモードなので、インライン Groovy コードを使って後処理、この場合、'result'の中身をきれいに出力すること、を行うことができる。この機能は、覚えておく価値がある。結果を簡単に後処理したり、それらをローカルにファイルに保存したり、実行できるいくつかの興味深いことがある。

[source,groovy]
----
gremlin> for (x in result['object'][0][1..-2].split(', ')) println x

South America=305
Asia=941
Europe=596
Africa=298
Antarctica=0
North America=981
Oceania=287
----

[[remotemode]]
==== リモートモードで操作する

コンソールを 「ローカルモード」のままにしておくのと同じぐらい便利だが、リモートのグラフに対して、大量のクエリを発行しようとしているのであれば、コンソールを「リモートモード」にするともっと便利だ。これは次のようにするとできる。

[source,console]
----
gremlin> :remote console

All scripts will now be sent to Gremlin Server - [localhost/127.0.0.1:8182] - type ':remote console' to return to local mode
----

これで、コンソールは、「リモートモード」になった。入力したすべてのクエリは、Gremlin サーバに送信され、":>" プレフィクスを付与する必要はない。

[source,groovy]
----
gremlin> g.V().count()

==>3624
----

注目すべき点の１つは、Gremlin サーバから返される出力は、ローカルの TinkerGraph に接続されたGremlin コンソールを使ってコマンドを使った場合とは少し異なる場合はあることだ。これは、Gremlinコンソールが基本的に、これらの場合に、ユーザに表示される前に、出力に対し、'toString()'を実行するからだ。

[source,groovy]
----
gremlin> g.V().has('code','AUS').valueMap()

==>{country=[US], code=[AUS], longest=[12250], city=[Austin], elev=[542], icao=[KAUS], lon=[-97.6698989868164], type=[airport], region=[US-TX], runways=[2], lat=[30.1944999694824], desc=[Austin Bergstrom International Airport]}
----

出力フォーマットわずかな違いの例として、グラフがローカルのインメモリのTinkerGraph として実行されていたときの同じクエリの結果を下記に示す。

[source,groovy]
----
[country:[US],code:[AUS],longest:[12250],city:[Austin],elev:[542],icao:[KAUS],lon:[-97.6698989868164],type:[airport],region:[US-TX],runways:[2],lat:[30.1944999694824],desc:[Austin Bergstrom International Airport]]
----

すべてのコマンドを Gremlin サーバに送信し終えたら、次のようにモードを切り替えることができる。これでコマンドがローカルコンソールに送信される。これは、ローカルグラフとリモートグラフを同時に操作できることを意味する。なので、':remote console'コマンドはトグルだ。コマンドを使うたびに、コンソールはローカルモードとリモートモード、あるいはその逆に切り替わる。

[source,console]
----
gremlin> :remote console

==>All scripts will now be evaluated locally - type ':remote console' to return to
remote mode for Gremlin Server - [localhost/127.0.0.1:8182]
----

このコンソールセッションのリモート接続が完全に終了したら、次のように本当に閉じることができる。これを実行すると、':remote console'を再度動かす前に、接続を再確立させる必要がある。

[source,console]
----
gremlin> :remote close

==>Removed - Gremlin Server - [localhost/127.0.0.1:8182]

----

[[servercli]]
=== Gremlin サーバにコマンドラインから接続する

これで、HTTP と Web Scokets 接続の両方をサポートするGremlin サーバが起動され実行されているので、必要に応じて、'curl'コマンドだけを使って Gremlin サーバと通信を行うことができる。下記の 'curl'コマンドは、HTTP GET を使ってクエリを Gremlin サーバに送信する。

[source,console]
----
sh> curl "http://localhost:8182?gremlin=g.V().has('code','AUS').valueMap()" 
----

HTTP GET リクエストへのレスポンスで、サーバは下記のように、JSONにパッケージ化された結果を返す。出力は読みやすいようにフォーマットした。実際に返されたものには、改行が全くなく、非常に読みづらいものだった。

[source,groovy]
----
{"requestId":"a8ad654a-a5a3-4bb9-8474-69aca3c3db1e",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"country":["US"],
                       "code":["AUS"],
                    "longest":[12250],
                       "city":["Austin"],
                       "elev":[542],
                       "icao":["KAUS"],
                        "lon":[-97.6698989868164],
                       "type":["airport"],
                     "region":["US-TX"],
                    "runways":[2],
                        "lat":[30.1944999694824],
                       "desc":["Austin Bergstrom International Airport"]}],
           "meta":{}}}

----

下記の例は、HTTP POST を使って同じクエリの送信方法を示しているが、'valueMap'ステップが削除されている。Apache TinkerPop ドキュメントには、クエリをHTTP でGremlin サーバに送信するには、POST を使うのが推奨される方法である、と記載されている。この場合クエリをJSON でパッケージして送信しているので、引用符をエスケープする必要があることに注意してほしい。

[source,console]
----
sh> curl -X POST -d "{\"gremlin\":\"g.V().has('code','AUS')\"}" \
            "http://localhost:8182"
----

前のクエリと同様、HTTP POST 形式もJSON にパッケージ化された結果を返す。しかしながら、この場合、'valueMap'ステップを省いたので、JSONには頂点とそのプロパティのID値とラベルの形式で追加情報が含まれている。これは結果は、今回はマップではなく、頂点を表すからだ。再度出力を読みやすいようにフォーマットした。

//[source,json]]
[source,groovy]
----
{"requestId":"64c757b8-27a6-4509-a54c-ea35ba517667",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{
   "data":[
     {"id":12352, 
      "label":"airport",
      "type":"vertex",
      "properties":
        {"country":[{"id":"8p4-9j4-8p1", "value":"US"}],
            "code":[{"id":"93c-9j4-5j9", "value":"AUS"}],
         "longest":[{"id":"9hk-9j4-mx1", "value":12250}],
            "city":[{"id":"9vs-9j4-7wl", "value":"Austin"}],
            "elev":[{"id":"aa0-9j4-but", "value":542}],
            "icao":[{"id":"ao8-9j4-6bp", "value":"KAUS"}],
             "lon":[{"id":"b2g-9j4-dfp", "value":-97.6698989868164}],
            "type":[{"id":"bgo-9j4-745", "value":"airport"}],
          "region":[{"id":"buw-9j4-9hh", "value":"US-TX"}],
         "runways":[{"id":"c94-9j4-b2d", "value":2}],
             "lat":[{"id":"cnc-9j4-cn9", "value":30.1944999694824}],
            "desc":[{"id":"d1k-9j4-a9x",
                  "value":"Austin Bergstrom International Airport"}]}}],
            "meta":{}}}

----

まもなく出てくる "<<serverjson>>" のセクションに、処理しなければならない可能性のある JSON 結果の異なるタイプの例を盛り込んだ。

[[javagsclient]]
=== Java から withRemote を使って Gremlin サーバに接続する

Gremlin サーバから返されたJSONを直接操作することは完全に可能ではあるが、多くの場合、結果を適切な田尾ぷの変数に直接代入する方がより望ましい。使っているプログラミング言語に、適切な Gremlin 言語ドライバが存在するのであれば、これは設定するのは全く簡単だ。本セクションでは、Java アプリケーションから Gremlin サーバに接続し、TinkerPopで用意されている'withRemote'機能を利用する方法についてみていく。

TIP: 本セクションで示される例のソースコードは  https://github.com/krlawrence/graph/tree/main/sample-code にある RemoteClient.java のサンプルからのものだ。

小さなアプリケーションを断片ごとにみてみよう。まず、サーバへのコネクションを生成して、クエリ結果を取得するのに必要なクラスをインポートする必要がある。

[source,groovy]
----
import org.apache.tinkerpop.gremlin.driver.Cluster;
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;
import org.apache.tinkerpop.gremlin.structure.util.empty.EmptyGraph;
import org.apache.tinkerpop.gremlin.driver.remote.DriverRemoteConnection;
import org.apache.tinkerpop.gremlin.driver.ser.GryoMessageSerializerV1d0;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
----

これで、'RemoteClient'を呼び出し、 Gremlin サーバへのコネクションをセットアップする小さな Java クラスを定義できるようになった。これは、最初に、我々が接続するサーバと、使いたいプロトコルを記述するのに使われる'Cluster.Builder'インスタンスを生成することによって行われる。これらの設定がGremlin サーバが使うように設定されているものとマッチすることが重要だ。この簡単な例では、ホスト名として'localhost'を使っているだけだが、代わりにアクセス可能な任意の Gremlin サーバの名前を使うことができる。デフォルトの Gremlin サーバのポート 8182 が指定されていて、'GyroMessageServializerV1d0'シリアル化形式が選択されている。繰り返すが、これは、Gremlin サーバがサポートしているプロトコルとプロトコルのバージョンの両方とマッチする必要がある。

[source,groovy]
----
public class RemoteClient
{
  public static void main( String[] args )
  {
    Cluster.Builder builder = Cluster.build();
    builder.addContactPoint("localhost");
    builder.port(8182);
    builder.serializer(new GryoMessageSerializerV1d0());
----

Clister.Builder インスタンスがセットアップされたら、それを使って'Cluster'インスタンスを生成できる。

[source,groovy]
----
    Cluster cluster = builder.create();
----

最後に、操作するグラフがホストされている Gremlin サーバのGraphTraversalSource オブジェクトをセットアップする必要がある。TinkerPop ドキュメントでは、トラバーサルを生成するときは、'EmptyGraph'のインスタンスを使うことが推奨されている。これが完了すると、'withRemote'メソッドを呼び出して、リモートコネクションを確立することができる。作ったばかりのクラスタインスタンスはパラメータとして渡されることに注意してほしい。これはやや複雑に見えるが、Gremlin コンソールを使ってローカルのグラフに接続するときとそれほどの違いはない。唯一の違いは、このようにリモートコネクションを設定することにより、グラフに対してクエリの発行を始める際に、JSONオブジェクトが返されるのではなく、結果は自動的にJava 変数にシリアル化されることだ。これにより、コードは書くのがかなり簡単になり、基本的に、この時点以降、直接接続されているローカルグラフでも機能するコードと同じになる。

[source,groovy]
----
    GraphTraversalSource g =
      EmptyGraph.instance().traversal().
        withRemote(DriverRemoteConnection.using(cluster));
----

これで、新しいグラフトラバーサルソースオブジェクトを使って、 Gremlin クエリを発行することができる。結果は、'vmaps'と呼ばれる'List'に直接配置される。クエリは、地域コードがGreat Britain - England の省略形である'GB-ENG'の最初の10件の空港を見つける。

[source,groovy]
----
    List <Map<String,Object>> vmaps =
      g.V().has("airport","region","GB-ENG").limit(10).valueMap().toList();
    
    System.out.println("\n\nThe following airports were found\n");
    for (Map <String,Object> m : vmaps)
    {
      ArrayList code = (ArrayList) m.get("code");
      ArrayList desc = (ArrayList) m.get("desc");
      System.out.println(code.get(0) + " , " + desc.get(0));
    }

    cluster.close();
  }
}                                           
----

Javaアプリケーションをコンパイルして実行すると、出力は下記のようになる。

[source,groovy]
----
LEQ , Land's End Airport
LGW , London Gatwick
MAN , Manchester Airport
LHR , London Heathrow
LCY , London City Airport
STN , London Stansted Airport
EMA , East Midlands Airport
LPL , Liverpool John Lennon Airport
LBA , Leeds Bradford Airport
NCL , Newcastle Airport         
----

[[rubyclient]]
=== Ruby から Gremlin サーバに接続する

私の知る限り、本稿の執筆時点では、Ruby プログラマが利用できる 公式の Gremlin 言語バインディングは存在しない。したがってこれは、小さな量のコードを使って、Ruby プログラマが Gremlin サーバに接続して、 Gremlin クエリを発行する方法を示すのに最適なユースケースだ。

TIP: 下記に示すように、Rubyの例のソースコードである、gremlin-client-http.rbは、sample-code フォルダにある。
https://github.com/krlawrence/graph/tree/main/sample-code

下記のコードは、完全なスタンドアロンのRubyアプリケーションを表している。標準のRuby ライブラリを使っていて、追加の Ruby Gems やサードパーティライブラリは必要としない。示されている例は、 ローカルマシンで実行されているGremlin サーバに接続する。HTTP POST リクエストをパッケージ化して、Gremlin サーバに送信する。HTTPリクエストのボディは、JSONでエンコードされている。

.gremlin-client-http.rb
[source,ruby,linenums]
----
# Simple example of how you can connect to a Gremlin Server and
# issue queries from a Ruby application.

require 'net/http'
require 'uri'
require 'json'

uri = URI.parse("http://localhost:8182")

request = Net::HTTP::Post.new(uri)
req_options = { use_ssl: uri.scheme == "https", }

query = {"gremlin" => "g.V().has('code','AUS').out().count()"}
request.body = JSON.dump(query)

response = Net::HTTP.start(uri.hostname, uri.port, req_options) do |http|
  http.request(request)
end

puts "Response code from the server was #{response.code}"
puts response.body  
----

これは、Ruby バージョン 2.3.1 を使ってプログラムを実行したときに返される出力である。ご覧の通り、結果のボディには、前に'curl'コマンドを使ってリクエストを発行したときと同じように、JSONオブジェクトが含まれている。

[source,groovy]
----
Response code from the server was 200

{"requestId":"0129e905-6903-4658-9cfb-23404842ba12",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[62],"meta":{}}}
----

[[servertinkergraph]]
=== Gremlin サーバを TinkerGraph を使うように設定する

JanusGraph や Cassandora のデプロイへのリモートアクセスを提供する方法としてGremlinサーバを構成する方法についてすでに見てきた。基本的な TinkerGraph、インメモリグラフをバックエンドとしてGremlin サーバをセットアップすると便利なことがある。リモートのTinkerPop 対応のグラフデータベースで最終的に機能するコードを開発しているが、ローカルでテストと開発を行いたい場合にこれは便利な方法である。Gremlin サーバはクラウドにホストされているマシンで実行される、真のリモートエンドポイントとして構成することは可能だが、ローカルコンピュータで実行するように構成することもできる。私は実験中この方法でラップトップ上に設定することがよくある。本セクションでは、TinkerGraph で air-routes データセットをホストするローカルで実行されるGremlin サーバを構成する手順をウォークスルーする。

NOTE: 本セクションで説明されている設定ファイルは https://github.com/krlawrence/graph/tree/main/sample-data のsample-dataフォルダにある。

[[TGConfig]]
==== 設定ファイルを作成する

リモートの TinkerGraph を起動して実行するには、いくつかの設定をファイルを構成して Gremlin サーバを起動するだけでよい。作成すべき最初のファイルはGremlin サーバの起動時に読み込まれるYAML ファイルである。私はこれのために gremlin-server-air-routes.yaml というファイルを作成した。このファイルには実際にはGremlin サーバのダウンロードの一部として含まれているデフォルトの gremlin-server.yaml ファイルに少しだけ変更を加えた。主な変更点は、このファイルには、air-routes.groovy という/scripts フォルダにあるスクリプトへの参照が含まれている。このスクリプトは作成された air-routes データセットを TinkerGraph インスタンスへロードする。

NOTE: /data や /script など、本セクションで参照されているすべてのフォルダは、Gremlin サーバがインストールされた場所からの相対パスである。

gremlin-server-air-routes.yaml ファイルは、/conf フォルダに置く必要がある。

.gremlin-server-air-routes.yaml
[source,groovy]
----
host: localhost
port: 8182
scriptEvaluationTimeout: 30000
channelizer: org.apache.tinkerpop.gremlin.server.channel.WsAndHttpChannelizer
graphs: {
  graph: conf/tinkergraph-empty.properties}
scriptEngines: {
  gremlin-groovy: {
    plugins: { org.apache.tinkerpop.gremlin.server.jsr223.GremlinServerGremlinPlugin: {},
               org.apache.tinkerpop.gremlin.tinkergraph.jsr223.TinkerGraphGremlinPlugin: {},
               org.apache.tinkerpop.gremlin.jsr223.ImportGremlinPlugin: {classImports: [java.lang.Math], methodImports: [java.lang.Math#*]},
               org.apache.tinkerpop.gremlin.jsr223.ScriptFileGremlinPlugin: {files: [scripts/air-routes.groovy]}}}}
serializers:
  - { className: org.apache.tinkerpop.gremlin.driver.ser.GryoMessageSerializerV3d0, config: { ioRegistries: [org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerIoRegistryV3d0] }}            # application/vnd.gremlin-v3.0+gryo
  - { className: org.apache.tinkerpop.gremlin.driver.ser.GryoMessageSerializerV3d0, config: { serializeResultToString: true }}                                                                      # application/vnd.gremlin-v3.0+gryo-stringd
  - { className: org.apache.tinkerpop.gremlin.driver.ser.GraphSONMessageSerializerV1d0, config: { ioRegistries: [org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerIoRegistryV3d0] }}        # application/json
metrics: {
  slf4jReporter: {enabled: true, interval: 180000}}
strictTransactionManagement: false
idleConnectionTimeout: 0
keepAliveInterval: 0
maxInitialLineLength: 4096
maxHeaderSize: 8192
maxChunkSize: 8192
maxContentLength: 65536
maxAccumulationBufferComponents: 1024
resultIterationBatchSize: 64
----

JSONが返される際に元の V1 GraphSON 形式になるようにYAMLファイルを設定したことに注意してほしい。これは GraphSONMessageSerializerV1d0 メッセージシリアライザを使うように指定することによって行われる。V1形式と 新しい V3 形式の主な違いは、V1形式の一部として型情報が返されないことだ。ユーザは、Gremlinを学ぶ際は、この形式の方がはるかに読みやすいと思う。

YAML ファイルの中で参照されるプロパティファイルは、Gremlin サーバに付随するデフォルトのものから変更されていない。これは、空のインメモリ TinkerGraph を作成する。

tinkergraph-empty.properties ファイルも /conf フォルダに置く必要がある。

.tinkergraph-empty.properties
[source,groovy]
----
gremlin.graph=org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph
gremlin.tinkergraph.vertexIdManager=LONG
----

ファイル air-routes.groovy は/data フォルダから air-routes.graphml ファイルをロードするのに必要なメソッドを起動する。このファイルは、/script フォルダに置く必要がある。

.air-routes.groovy
[source,groovy]
----
def globals = [:]

globals << [hook : [
  onStartUp: { ctx ->
    ctx.logger.info("Loading 'air-routes' graph data.")
    graph.io(graphml()).readGraph('data/air-routes.graphml')
  }
] as LifeCycleHook]

globals << [g : graph.traversal()]
----

[[TGStart]]
==== サーバを起動する

"<<serverconfig>>" のセクションで説明したように、Gremlinサーバをフォアグランドで、あるいはバックグランドで開始することができる。最初のテストでは、フォアグランドで実行されるサーバを起動してみよう。

[source,console]
----
$ bin/gremlin-server.sh conf/gremlin-server-air-routes.yaml 
----

[[TGTest]]
==== サーバをテストする

これで Gremlin サーバが稼働し、前にGremlin サーバと JanusGraph をセットアップしたのと同じように、ホスト名として'localhost'を、ポート 8182 を使ってアクセスできるようになった。いつでも単純な'curl'コマンドを使って問題がないことを確認することをお勧めする。

[source,console]
----
$ curl "localhost:8182/gremlin?gremlin=g.V().has('code','SFO').valueMap()"
----

これが、返される出力である。以前に設定した GraphSONV1 形式であることに注意してほしい。

[source,groovy]
----
{"requestId":"fbcab664-7538-402f-85b4-1b14db88c968","status":{"message":"","code":200,"attributes":{}},"result":{"data":[{"country":["US"],"code":["SFO"],"longest":[11870],"city":["San Francisco"],"elev":[13],"icao":["KSFO"],"lon":[-122.375],"type":["airport"],"region":["US-CA"],"runways":[4],"lat":[37.6189994812012],"desc":["San Francisco International Airport"]}],"meta":{}}}
----

以前に見たのと同じ Gremlin コンソールのリモート接続設定を再利用することもできる。同様に、ホスト名'localhost'と、ポート 8182 を使ってGremlin サーバに接続することができる。下記の例では、すでに Gremlin コンソールを起動済みであることを前提としている。

[source,groovy]
----
gremlin> :remote connect tinkerpop.server conf/remote.yaml
==>Configured localhost/127.0.0.1:8182

gremlin> :remote console
==>All scripts will now be sent to Gremlin Server - [localhost/127.0.0.1:8182] - type ':remote console' to return to local mode

gremlin> g.V().has('code','SFO').valueMap().unfold()
==>country=[US]
==>code=[SFO]
==>longest=[11870]
==>city=[San Francisco]
==>elev=[13]
==>icao=[KSFO]
==>lon=[-122.375]
==>type=[airport]
==>region=[US-CA]
==>runways=[4]
==>lat=[37.6189994812012]
==>desc=[San Francisco International Airport]
----

本セクションを読めば、'air-routes'データセットを含んだインメモリの TinkerGraph をホストする Gremlin サーバをセットアップする方法を理解できたのではないかと思う。これはクエリとコードをローカルでをテストする際には便利な環境であり、最終的にはリモートの TinkerPop 対応のグラフデータベースと連携する必要がある。

次のセクションでは、返されたJSONを扱いやすくする方法と、Ruby プログラムに追加してJSONを扱う方法を見ていく。

[[servertweaks]]
=== 返されるJSONを操作しやすくするためにクエリを調整する

下記は、本書の前の方に出てきたクエリである。これは、8,000マイルよりも長いすべての経路を見つけ、空港のペアとその間の距離を返す。

[source,groovy]
----
g.V().as('a').outE().has('dist',gt(8000)).
      order().by('dist',desc).inV().as('b'). 
      filter(select('a','b').by('code').where('a', lt('b'))).
      path().by('code').by('dist')
----

TinkerGraphでGremlin コンソールを使ってこのクエリを実行すると、下記に示すように、コンソールによってある程度きれいに整形された結果が返される。

[source,groovy]
----
[AKL,9025,DOH]    [LAX,8246,RUH]
[AKL,8818,DXB]    [MEL,8197,YVR]
[LAX,8756,SIN]    [DXB,8150,IAH]
[CAN,8754,MEX]    [AUH,8139,SFO]
[IAH,8591,SYD]    [DFW,8105,HKG]
[DFW,8574,SYD]    [DXB,8085,SFO]
[ATL,8434,JNB]    [HKG,8054,JFK]
[SFO,8433,SIN]    [AUH,8053,DFW]
[AUH,8372,LAX]    [EWR,8047,HKG]
[DXB,8321,LAX]    [DOH,8030,IAH]
[JED,8314,LAX]    [DFW,8022,DXB]
[DOH,8287,LAX]
----

しかしながら、HTTP を介して Gremlin サーバを使う場合のように、完全なJSONレスポンスを返すシステムを使うと、Gremlin コンソールで用意されている「きれいな出力」の利便性は得られない。代わりに、上記で使ったものと全く同じクエリから、このように見えるものが返される。

//[source,json]
[source,groovy]
----
{"requestId":"5acca62c-7351-4b3d-bb20-3660f6feb3cc",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":
    [{"labels":[["a"],[],["b"]],"objects":["AKL",9025,"DOH"]},
    {"labels":[["a"],[],["b"]],"objects":["AKL",8818,"DXB"]},
    {"labels":[["a"],[],["b"]],"objects":["LAX",8756,"SIN"]},
    {"labels":[["a"],[],["b"]],"objects":["CAN",8754,"MEX"]},
    {"labels":[["a"],[],["b"]],"objects":["IAH",8591,"SYD"]},
    {"labels":[["a"],[],["b"]],"objects":["DFW",8574,"SYD"]},
    {"labels":[["a"],[],["b"]],"objects":["ATL",8434,"JNB"]},
    {"labels":[["a"],[],["b"]],"objects":["SFO",8433,"SIN"]},
    {"labels":[["a"],[],["b"]],"objects":["AUH",8372,"LAX"]},
    {"labels":[["a"],[],["b"]],"objects":["DXB",8321,"LAX"]},
    {"labels":[["a"],[],["b"]],"objects":["JED",8314,"LAX"]},
    {"labels":[["a"],[],["b"]],"objects":["DOH",8287,"LAX"]},
    {"labels":[["a"],[],["b"]],"objects":["LAX",8246,"RUH"]},
    {"labels":[["a"],[],["b"]],"objects":["MEL",8197,"YVR"]},
    {"labels":[["a"],[],["b"]],"objects":["DXB",8150,"IAH"]},
    {"labels":[["a"],[],["b"]],"objects":["AUH",8139,"SFO"]},
    {"labels":[["a"],[],["b"]],"objects":["DFW",8105,"HKG"]},
    {"labels":[["a"],[],["b"]],"objects":["DXB",8085,"SFO"]},
    {"labels":[["a"],[],["b"]],"objects":["HKG",8054,"JFK"]},
    {"labels":[["a"],[],["b"]],"objects":["AUH",8053,"DFW"]},
    {"labels":[["a"],[],["b"]],"objects":["EWR",8047,"HKG"]},
    {"labels":[["a"],[],["b"]],"objects":["DOH",8030,"IAH"]},
    {"labels":[["a"],[],["b"]],"objects":["DFW",8022,"DXB"]}],
    "meta":{}}}
----

返されるものが役に立つ場合がある。例えば、クエリで使った'a'と'b'のラベルを確認できるが、この場合、本当に必要なものは、空港コードと距離の最後の部分だ。このJSON をそのまま( おそらく JSON ヘルパークラスを使って）処理するコードを書くことにすることができるし、これは有効な選択だ。しかしながら、クエリを少し調整することにより、Gremlin に本当に必要なものを返させるようにすることができる。クエリの最後に、'.toList().toString()'を追加するとどうなるかを見てみよう。下記のクエリの修正したものを見ていただきたい。

[source,groovy]
----
g.V().as('a').outE().has('dist',gt(8000)).
      order().by('dist',desc).inV().as('b'). 
      filter(select('a','b').by('code').where('a', lt('b'))). 
      path().by('code').by('dist').toList().toString()
----

この変更された形式のクエリを Gremlin サーバに送信すると、Gremlin コンソールで作業してたときに得られた結果に非常によく似たものが返されるはずだ。下記に示すように、アプリケーションでの処理が確かに少し簡単になった。しかしながら、これは現時点では、すべての経路を含む単一の文字列を含んだリストなので、まだ理想の結果ではない。

[source,groovy]
//[source,json]
----
{"requestId":"63c660d0-28cf-41fc-86cf-5560a4e2fac0","status":{"message":"","code":200,"attributes":{}},"result":{"data":["[[AKL, 9025, DOH], [AKL, 8818, DXB], [LAX, 8756, SIN], [CAN, 8754, MEX], [IAH, 8591, SYD], [DFW, 8574, SYD], [ATL, 8434, JNB], [SFO, 8433, SIN], [AUH, 8372, LAX], [DXB, 8321, LAX], [JED, 8314, LAX], [DOH, 8287, LAX], [LAX, 8246, RUH], [MEL, 8197, YVR], [DXB, 8150, IAH], [AUH, 8139, SFO], [DFW, 8105, HKG], [DXB, 8085, SFO], [HKG, 8054, JFK], [AUH, 8053, DFW], [EWR, 8047, HKG], [DOH, 8030, IAH], [DFW, 8022, DXB]]"],"meta":{}}}
----

もう少し後処理を追加して単一の文字列を、各文字列が'[AKL,9025,DOH]'の形式の単一の経路である文字列の配列に分割することができる。これを実現する1つの方法は、各々の文字列の終わりにある不要な文字をトリムして、split を使ってそれを分割することだ。文字列には数多くのコンマがあるので、単純な'split(",")'を実行するだけじゃダメで必要なものが返されなかった。このsplit を機能させるには、文字列中に出現するすべての'],'を']x'に置き換えて、'split("x")'を使って分割をした。これが変更されたクエリだ。

[source,groovy]
----
g.V().as('a').outE().has('dist',gt(8000)).
      order().by('dist',desc).inV().as('b').
      filter(select('a','b').by('code').where('a', lt('b'))).
      path().by('code').by('dist').toList().toString()[1..-2].
      replaceAll('],',']x').split('x')
----

これが、返されたJSON から得られたものだ。各経路は文字列配列の文字列になった。ここから、各経路の空港名と距離を抽出するのは単純なタスクだ。

[source,groovy]
----
{"requestId":"9d8324a8-89e4-4c1e-be59-ff433784a3da",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[ " [AKL, 9025, DOH]",
                    " [AKL, 8818, DXB]",
                    " [LAX, 8756, SIN]", 
                    " [CAN, 8754, MEX]",
                    " [IAH, 8591, SYD]",
                    " [DFW, 8574, SYD]",
                    " [ATL, 8434, JNB]",
                    " [SFO, 8433, SIN]",
                    " [AUH, 8372, LAX]",
                    " [DXB, 8321, LAX]",
                    " [JED, 8314, LAX]",
                    " [DOH, 8287, LAX]",
                    " [LAX, 8246, RUH]",
                    " [MEL, 8197, YVR]",
                    " [DXB, 8150, IAH]",
                    " [AUH, 8139, SFO]",
                    " [DFW, 8105, HKG]",
                    " [DXB, 8085, SFO]",
                    " [HKG, 8054, JFK]",
                    " [AUH, 8053, DFW]",
                    " [EWR, 8047, HKG]",
                    " [DOH, 8030, IAH]",
                    " [DFW, 8022, DXB]"]
----

クエリが返すデータを少なくするのか、あるいは最初のクエリから取得したデータの完全なセットを返すのかは個人の好みの問題だ。返されるデータを減らすようにクエリで制限をかけることの利点の1つは、アプリケーションに返し、メモリやディスクに保存する必要のあるデータが少なくなること、場合によっては、はるかに少なくなることだ。しかしながら、ほとんどのプログラミング言語には、JSON オブジェクトを、マップなどのネイティブのデータ構造に簡単にデシリアライズする機能がサポートされているので、すべてのJSONを返して、残りの処理を自前で行うのが良いと思われる。

簡単な例として、前のセクションで作成したRubyアプリケーションに下記の行を追加して、後処理を追加する前の元のクエリを使うと、JSONから関心のある部分を簡単に取得できる。

[source,ruby]
----
res = JSON.parse(response.body)['result']['data']

res.each do |x|
  p x['objects']
end         
----

このコードは、Rubyの'JSON'クラスを使って Gremlin サーバからのJSON レスポンスを マップデータ構造にコンバートする。次に、JSONに含まれている名前でマップの各部分にアクセスできる。記述されているコードは、特定のキーワードのセットがJSONに存在することを期待していることに注意してほしい。すべてのクエリ結果にこれらのキーワードが含まれているわけではない。したがって、サーバが送信できる可能性のあるJSONで返す形式のいずれかを処理できるより汎用的なコードに変換するには、もう少し処理が必要になる。これは、更新したRuby コードを実行した出力である。今あるのは、素敵なリストのコレクションであり、その各々には２つの文字列と１つの整数値が含まれていることに注意してほしい。データは、さらに処理しやすい便利な形式になった。

[source,groovy]
----
["AKL", 9025, "DOH"]     ["LAX", 8246, "RUH"]
["AKL", 8818, "DXB"]     ["MEL", 8197, "YVR"]
["LAX", 8756, "SIN"]     ["DXB", 8150, "IAH"]
["CAN", 8754, "MEX"]     ["AUH", 8139, "SFO"]
["IAH", 8591, "SYD"]     ["DFW", 8105, "HKG"]
["DFW", 8574, "SYD"]     ["DXB", 8085, "SFO"]
["ATL", 8434, "JNB"]     ["HKG", 8054, "JFK"]
["SFO", 8433, "SIN"]     ["AUH", 8053, "DFW"]
["AUH", 8372, "LAX"]     ["EWR", 8047, "HKG"]
["DXB", 8321, "LAX"]     ["DOH", 8030, "IAH"]
["JED", 8314, "LAX"]     ["DFW", 8022, "DXB"]
["DOH", 8287, "LAX"]
----

次のセクションでは、Gremlin サーバによって返されるJSONのさらなる例のいくつかと、返されるデータの量を減らす方法の例をいくつか紹介する。

[[serverjson]]
=== Gremlin サーバからJSONが返されるさらなる例

Gremlin サーバによって返されるJSONは使われるクエリ、より具体的には、そのクエリが返すものに依存する。'result'の'data'パートで返されるものはすべて、最も外側のレベルで配列になる。その配列の中にあるものは単純な数字や文字列である可能性がある。また、文字列や、マップを含む他のオブジェクトのリストである可能性もある。可能性のある様々な形式のを扱うことができる汎用なコードを書こうとしているのであれば、それらがどのように見えるかを知ることが重要だ。下記の例では、いくつかの遭遇する可能性のあるレスポンスの形式を示してみた。主に'data'キーに続くJSON 部分に焦点を当てている。各例は、示されているクエリがHTTP プロトコルを使ってGremlin サーバに送信されたことを前提としている。いつものように、特定のクエリがどんなJSON を生成するかがわからない場合は、常にいくつかの実験を実行して調査する必要がある。

下記のクエリのいくつかは特定の結果を得るための最良の方法を表していないかもしれないことに注意していただきたい。それぞれが生成するJSON結果のタイプの感触が得られるように、様々なGremlin ステップを示すクエリを意図的に選択した。

==== 結果なし

下記のクエリは結果を返さない。JSONはこれを'data'が空のリスト'"[]"'として返される形式で反映する。

[source,groovy]
----
g.V().has('code','AUS').out('route').has('code','SYD')

{"requestId":"e68ce6d6-29a0-4a70-af35-b4e8bb123458",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[],"meta":{}}}
----

==== 整数の結果

単一の整数の結果を返すだけの単純なクエリは、以下に示すようにJSONを生成する。JSONの'result'セクションは単一の整数値をもつ'data'セクションを含む。

[source,groovy]
----
g.V().count()

{"requestId":"25fc4d45-3e58-4f72-99b1-fe1c6575fdd0",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[3624],"meta":{}}}
----

==== 文字列の結果

整数の結果と同様、単一の文字列の結果のみを返すクエリは、下記に示すようにJSONを生成する。JSONの'result'セクションには、メンバが1つのリストとしてエンコードされた単一の文字列の値の'data'セクションが含まれている。

[source,groovy]
----
g.V().has('code','DFW').values('city')

{"requestId":"0ae1e2af-adea-487c-b365-7ef76bb56791",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":["Dallas"],"meta":{}}}
----

==== 文字列のリスト

下記のクエリは空港コードを表す文字列のリストを含む'data'の配列を生成する。

[source,groovy]
----
g.V().has('code','SAF').out().values('code')

{"requestId":"264cbaf8-6679-43b0-936c-f65b9f6fd0ed",
"status":{"message":"","code":200,"attributes":{}},
"result":{"data":["PHX","DFW","LAX","DEN"],"meta":{}}}
----

==== 整数のリスト

下記のクエリは 滑走路の本数を表す整数のリストを含む'data'の配列を生成する。実際には、これに'sack'を使うことなく、単純な'values'ステップが同じ結果を生成するが、'sack'ステップを使う例を示したかったことに注意してほしい。

[source,groovy]
----
g.withSack(0).V().has('code','SAF').out().sack(sum).by('runways').sack()

{"requestId":"23598951-ffa4-440d-910f-eebc6d5f620a",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[3,7,4,6],"meta":{}}}
----

==== タイプが混在するリスト

クエリ結果には、様々な異なるデータ型が含まれているのが一般的だ。下記の例は文字列、整数、倍精度浮動小数点を含んだリストを生成する。前に触れたように、TinkerPop は返される結果の順序を保証しないので、それに依存しないように注意してほしい。

[source,groovy]
----
g.V().has('code','LGW').values('city','lat','runways')

{"requestId":"6043ce66-221b-49b8-a3f9-6131eef3b9c2",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":["London",2,51.1481018066406],"meta":{}}}
----

==== 値のマップ

想像のとおり、'valueMap'を使ってクエリから結果を生成する際に、生成されるJSONもまた、マップが含まれている。値が1つしかない場合でも各プロパティの値がリストにどのようにエンコードされているかに注意してほしい。

[source,groovy]
----
g.V().has('code','CDG').valueMap()

{"requestId":"c989a182-aa97-4ed7-bddb-7f0e3ad237d6",
    "status":{"message":"","code":200,"attributes":{}},
    "result":{"data":[{
       "country":["FR"],
          "code":["CDG"],
       "longest":[13829],
          "city":["Paris"],
          "elev":[392],
          "icao":["LFPG"],
           "lon":[2.54999995232],
          "type":["airport"],
        "region":["FR-J"],
       "runways":[4],
           "lat":[49.0127983093],
          "desc":["Paris Charles de Gaulle"]}],"meta":{}}}
----

==== 単一の頂点

クエリが頂点を返す場合、Gremlinサーバと通信するときに'"v[51]"'のようなものが返されるGremlin コンソールとは異なり、返されるものは、ID、ラベル、プロパティ、並びに各プロパティのIDを含む頂点について知るためのものすべてを表している JSON オブジェクトである。頂点全体を返す必要がない場合は、クエリに、関心のあるプロパティのみを返すようにクエリを書くとよいだろう。これはクエリが結果に大量の頂点を返す可能性がある場合に特に関係がある。

[source,groovy]
----
g.V().has('code','CDG')

{"requestId":"a70cab32-73a5-492f-a00b-0c7d66485b18",
    "status":{"message":"","code":200,"attributes":{}},
    "result":{"data":
       [{"id":69736,
      "label":"airport",
      "type":"vertex",
"properties":
     {"country":[{"id":"2e4t-1ht4-8p1", "value":"FR"}],
         "code":[{"id":"2ej1-1ht4-5j9","value":"CDG"}],
      "longest":[{"id":"2ex9-1ht4-mx1","value":13829}],
         "city":[{"id":"2fbh-1ht4-7wl","value":"Paris"}],
         "elev":[{"id":"2fpp-1ht4-but","value":392}],
         "icao":[{"id":"2g3x-1ht4-6bp","value":"LFPG"}],
         " lon":[{"id":"2gi5-1ht4-dfp","value":2.54999995232}],
         "type":[{"id":"2gwd-1ht4-745","value":"airport"}],
       "region":[{"id":"2hal-1ht4-9hh","value":"FR-J"}],
      "runways":[{"id":"2hot-1ht4-b2d","value":4}],
          "lat":[{"id":"2i31-1ht4-cn9","value":49.0127983093}],
         "desc":[{"id":"2ih9-1ht4-a9x","value":"Paris Charles de Gaulle"}]}}],
    "meta":{}}}
----

==== 選択された頂点の情報

返されるJSON の量を制限する１つの方法を下記に示す。空港の頂点の選択について、我々が関心があるのは、ID、空港コード、都市名だけであると仮定しよう。下記に示すように、各頂点について、これらの値だけを返すようにクエリを書くことができる。

[source,groovy]
----
g.V().hasLabel('airport').sample(3).
      union(id(),values('code','city'))

{"requestId":"4d308287-9725-4fa6-8c2b-b7e517ca5009",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[45096,"SCL","Santiago",
                  610336,"YWK","Wabush",
                  163880,"CAK","Akron"],"meta":{}}}
----

==== 単一のエッジ

単一の頂点を照会するときと同様に、単一のエッジを照会すると、エッジのラベルやIDを含む大量の情報や、そのエッジが接続する頂点に関する情報が返される。

[source,groovy]
----
g.V().has('code','SAF').outE().limit(1)

{"requestId":"cac0a975-33a0-4714-a797-1be782201a27",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"
        id":"2xhcd-1560-pat-39s",
    "label":"route",
     "type":"edge","inVLabel":"airport",
                  "outVLabel":"airport","
                         inV":4240,
                       "outV":53352,
                 "properties":{"dist":369}}],"meta":{}}}
----

==== 新しい頂点

新しい頂点といくつかのプロパティが追加されると、返されるJSONには、そのID、ラベル、プロパティと合わせてそのタイプを含むその頂点に関するすべての情報が含まれる。

[source,groovy]
----
g.addV('test').property('fruit','apple')

{"requestId":"accd4354-0db9-417d-927f-c0945e1721dc",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"id":4248,
          "label":"test",
           "type":"vertex",
     "properties":{"fruit":[{"id":"177-3a0-28lh",
                          "value":"apple"}]}}],"meta":{}}}
----

==== ID  だけを返す新しい頂点

新しい頂点を追加する際に、新しい頂点全体とそのプロパティを取得することにあまり関心がない場合、下記に示すように、新しい頂点のIDのみを返すようにクエリを記述するとよい。

[source,groovy]
----
g.addV('test').as('a').property('fruit','apple').select('a').id()

{"requestId":"c50d0fa7-5caa-4294-8eca-310f032b1c42",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[8344],"meta":{}}}
----

==== 値によるパス ( 文字列のリスト)

下記のクエリは、空港コードのリストとして2つの空港間のパスを返す。パスを表すJSON が返されるときに使われる新しい'object'キーに注意してほしい。

[source,groovy]
----
g.V().has('code','SAF').out().path().by('code').limit(1)

{"requestId":"b9a1655f-1b14-4313-96d0-085858f47de7",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"labels":[[],[]],
                   "objects":["SAF","PHX"]}],"meta":{}}}
----

==== 値によるパス (文字列と整数のリスト)

前のクエリと同様だが、今回はパスには、空港間の距離も含まれている。

[source,groovy]
----
g.V().has('code','SAF').outE().inV().path().by('code').by('dist').limit(1)


{"requestId":"c4eb3141-be1e-4335-aa04-50843f73838b",
    "status":{"message":"","code":200,"attributes":{}},
    "result":{"data":[{"labels":[[],[],[]],
                      "objects":["SAF",369,"PHX"]}],"meta":{}}}
----

==== ２つの頂点のパス

下記のクエリはパスを返すが、'by'モジュレータを含まないので、返されるものは、2つの頂点とそのID、ラベル、プロパティである。

[source,groovy]
----
g.V().has('code','SAF').out().path().limit(1)

{"requestId":"bcdc3113-d1f6-41cf-b2ad-b1409646677e",
    "status":{"message":"","code":200,"attributes":{}},
    "result":{"data":[{"labels":[[],[]],
           "objects":[{
              "id":53352,
           "label":"airport",
            "type":"vertex",
      "properties":{ 
         "country":[{"id":"1s0d-1560-8p1","value":"US"}],
             "code":[{"id":"1sel-1560-5j9","value":"SAF"}],
          "longest":[{"id":"1sst-1560-mx1","value":8366}],
             "city":[{"id":"1t71-1560-7wl","value":"Santa Fe"}],
             "elev":[{"id":"1tl9-1560-but","value":6348}],
             "icao":[{"id":"1tzh-1560-6bp","value":"KSAF"}],
              "lon":[{"id":"1udp-1560-dfp","value":-106.088996887}],
             "type":[{"id":"1urx-1560-745","value":"airport"}],
           "region":[{"id":"1v65-1560-9hh","value":"US-NM"}],
          "runways":[{"id":"1vkd-1560-b2d","value":3}],
              "lat":[{"id":"1vyl-1560-cn9","value":35.617099762}],
             "desc":[{"id":"1wct-1560-a9x","value":"Santa Fe"}]}},

             {"id":4240,
           "label":"airport",
            "type":"vertex",
      "properties":{
          "country":[{"id":"176-39s-8p1","value":"US"}],
             "code":[{"id":"1le-39s-5j9","value":"PHX"}],
          "longest":[{"id":"1zm-39s-mx1","value":11489}],
             "city":[{"id":"2du-39s-7wl","value":"Phoenix"}],
             "elev":[{"id":"2s2-39s-but","value":1135}],
             "icao":[{"id":"36a-39s-6bp","value":"KPHX"}],
              "lon":[{"id":"3ki-39s-dfp","value":-112.012001037598}],
             "type":[{"id":"3yq-39s-745","value":"airport"}],
           "region":[{"id":"4cy-39s-9hh","value":"US-AZ"}],
          "runways":[{"id":"4r6-39s-b2d","value":3}],
              "lat":[{"id":"55e-39s-cn9","value":33.4342994689941}],
             "desc":[{"id":"5jm-39s-a9x",
              "value":"Phoenix Sky Harbor International Airport"}]}}]}],
      "meta":{}}}
----

==== ２つの頂点とエッジのパス

下記のクエリは前のクエリと同様だが、エッジも含まれている。本当に返したいものについてクエリに具体的に指定しないとJSON が急激に大きくなることをここでお分かりになることを願う。これはパスの結果なので、ほとんどのデータが'object'キーないに含まれていることに注目してほしい。

[source,groovy]
----
g.V().has('code','SAF').outE().inV().path().limit(1)

{"requestId":"171d0f30-2f93-4ae6-a421-4601a35388a2",
 "status":{"message":"","code":200,"attributes":{}},
  "result":{"data":[{"labels":[[],[],[]],
  "objects":[
       {"id":53352,"label":"airport","type":"vertex",
       "properties":
           {"country":[{"id":"1s0d-1560-8p1","value":"US"}],
           "code":[{"id":"1sel-1560-5j9","value":"SAF"}],
           "longest":[{"id":"1sst-1560-mx1","value":8366}],
           "city":[{"id":"1t71-1560-7wl","value":"Santa Fe"}],
           "elev":[{"id":"1tl9-1560-but","value":6348}],
           "icao":[{"id":"1tzh-1560-6bp","value":"KSAF"}],
           "lon":[{"id":"1udp-1560-dfp","value":-106.088996887}],
           "type":[{"id":"1urx-1560-745","value":"airport"}],
           "region":[{"id":"1v65-1560-9hh","value":"US-NM"}],
           "runways":[{"id":"1vkd-1560-b2d","value":3}],
           "lat":[{"id":"1vyl-1560-cn9","value":35.617099762}],
           "desc":[{"id":"1wct-1560-a9x","value":"Santa Fe"}]}},
           
       {"id":"2xhcd-1560-pat-39s",
        "label":"route",
        "type":"edge",
        "inVLabel":"airport",
        "outVLabel":"airport",
        "inV":4240,"outV":53352,
            "properties":{"dist":369}},
            
       {"id":4240,"label":"airport","type":"vertex",
       "properties":
           {"country":[{"id":"176-39s-8p1","value":"US"}],
            "code":[{"id":"1le-39s-5j9","value":"PHX"}],
            "longest":[{"id":"1zm-39s-mx1","value":11489}],
            "city":[{"id":"2du-39s-7wl","value":"Phoenix"}],
            "elev":[{"id":"2s2-39s-but","value":1135}],
            "icao":[{"id":"36a-39s-6bp","value":"KPHX"}],
            "lon":[{"id":"3ki-39s-dfp","value":-112.012001037598}],
            "type":[{"id":"3yq-39s-745","value":"airport"}],
            "region":[{"id":"4cy-39s-9hh","value":"US-AZ"}],
            "runways":[{"id":"4r6-39s-b2d","value":3}],
            "lat":[{"id":"55e-39s-cn9","value":33.4342994689941}],
            "desc":[{"id":"5jm-39s-a9x",
              "value":"Phoenix Sky Harbor International Airport"}]}}]}],
      "meta":{}}}
----

==== 選択したマップ

クエリがクエリの中で先に定義されたラベルを参照する'select'ステップで終了する場合、返されるものは、ラベルがキーで値がクエリの中ででラベルが付与されたもののマップである。

[source,groovy]
----
g.V().has('code','SAF').as('a').out().has('code','DFW').as('b').
      select('a','b').by('code')

{"requestId":"af8de8e6-4137-4378-bb31-921e134d0661",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"a":"SAF","b":"DFW"}],"meta":{}}}
----

==== 射影されたマップ

'project'ステップもまた、前の例の'select'ステップと同じように、マップを生成する。

[source,groovy]
----
g.V().has('code','LGW').project('a','b').by('code').by(out().count())


{"requestId":"57819d0b-c27e-40d7-a89a-e69a6b4872a1",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"a":"LGW","b":204}],"meta":{}}}
----

==== 文字列とマップ

下記のパスクエリは空港コードを表す2つの文字列とエッジを表す完全なJSONオブジェクトを含むリストを返す

[source,groovy]
----
g.V().has('code','SAF').outE().inV().limit(1).path().by('code').by()

{"requestId":"5102bb14-e594-41ec-8643-89882377b1e7",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[{"labels":[[],[],[]],
           "objects":["SAF",
                      {"id":"2xhcd-1560-pat-39s",
                      "label":"route",
                      "type":"edge",
                      "inVLabel":"airport",
                      "outVLabel":"airport",
                      "inV":4240,
                      "outV":53352,
                      "properties":{"dist":369}},
                      "PHX"]}],"meta":{}}}
----

==== ネストされたマップ

コンソールを使う場合、あるいはアプリケーションプログラムから TinkerPop API を介して Gremlin コマンドを発行する場合、クエリを'fold'ステップで終了すると、すべての結果をリストに入れることができる。Gremlin サーバを使う場合、'fold'ステップでクエリを終了することは、結果はJSON内のリストに配置されるので、多くの場合冗長だ。下記の例では、'fold'ステップによりJSON が組み立てられる際に生成されたリスト内に単に余計なリストがネストされるだけだ。

[source,groovy]
----
g.V().has('region','US-OK').values('code').fold()


{"requestId":"edcea305-086d-4f8d-b79a-ff72c5a26847",
 "status":{"message":"","code":200,"attributes":{}},
 "result":{"data":[["OKC","TUL","LAW","SWO"]],"meta":{}}}

----


[[serialize]]
== 一般的なグラフのシリアル化形式

グラフデータをファイルに格納するには、いくつかの方法がある。本セクションでは、それらのいくつかについて簡単な概要を用意した。御覧の通り、単純なCSVファイルを使ってグラフデータを表現する方法はいくつかある。他にも XML形式、JSON形式などもある。これらのうち、ほとんどのツールやプラットフォームでサポートされていると思われるのはGraphMLである。しかしながら、Apache TinkerPop で用意されているすべての機能がGraphML を使って表現できるわけではない。それでは、一般的に使われている形式のいくつかを見てみよう。

[[csv]]
=== Comma Separated Values (CSV)

CSVファイルを使ってグラフを格納する方法はいくつかある。私が知る中では、単一の適切な形式はない。しかしながら、一般的で、便利な方法、特に頂点が多数のプロパティを含んでいる場合には、2つのCSVファイルを使うことだ。1つには、すべての頂点データを含め、もう1つにはすべてのエッジデータを含める。

[[csvair]]
==== 2つの CSV ファイルを使って air-routes データを表現する

'air-routes'グラフから空港データをCSV形式で保存する場合は、下記の例のようになる。読みやすくするために、この例にはすべてのプロパティ（あるいは実際にはすべての空港）が含まれているわけではない点に注意してほしい。各頂点には一意のIDが割り当てられていることに注目してほしい。エッジを定義する際に接続を構築するために頂点IDが必要になるので、これは重要だ。


----
"ID","LABEL","CODE","IATA","CITY","REGION","RUNWAYS","LONGEST","ELEV","COUNTRY"
"1","airport","ATL","KATL","Atlanta","US-GA","5","12390","1026","US"
"2","airport","ANC","PANC","Anchorage","US-AK","3","12400","151","US"
"3","airport","AUS","KAUS","Austin","Austin","US-TX","2","12250","542","US"
"4","airport","BNA","KBNA","Nashville","US-TN","4","11030","599","US"
"5","airport","BOS","KBOS","Boston","US-MA","6","10083","19","US"
"6","airport","BWI","KBWI","Baltimore","US-MD","3","10502","143","US"
"7","airport","DCA","KDCA","Washington D.C.","US-DC","3","7169","14","US"
"8","airport","DFW","KDFW","Dallas Ft. Worth","US-TX","7","13401","607","US"
"9","airport","FLL","KFLL","Fort Lauderdale","US-FL","2","9000","64","US"
----

グラフにおけるエッジである経路データには、下記のような形式を使う。通常、グラフシステムでエッジIDが割り当てられるので、エッジIDを含めていない。完全を期すために、ラベルを含めたが、しかしながらすべてのエッジが同じ型の場合、データを取り込むプログラムが割り当てるラベルをわかっている限り、これを省略してもよい。ほとんどのグラフシステムでは頂点のオプションであっても、エッジにラベルを付ける必要がある。これは空港データにも同様に当てはまることだ。しかしながら、同じCSVファイルにある頂点とエッジのタイプが異なる場合、その場合は明らかに、各エントリのラベルを常に含めておくのが最善である。

----
"LABEL","FROM","TO","DIST"
"route",1,3,811
"route",1,4,214
"route",2,8,3036
"route",3,4,755
"route",4,6,586
"route",5,1,945
----

一部のグラフシステムの中には、ここで示したようなCSVファイルがあると、それを処理してグラフを作成する縫合を指摘できる取り込みツールが用意されているものがある。しかしながら、他の多くの状況では、自分で自前のスクリプトや小さいプログラムを書いてそれを実行することもある。

グラフシステムが取り込むことができるようにCSVやGraphML を生成することができる Rubyや Groovy のスクリプトを書いていることがよくある。場合によっては、スクリプトを使ってCSVや GraphML データを取得してグラフを生成するための Gremlin ステートメントを生成した。これは他の一般的な方法、つまり、SQLデータベースを使っている際に、スクリプトを使って'INSERT'ステートメントを生成する方法と非常によく似ている。

また、CSVファイルを読み込んで、TInkerPop API や、Gremlin サーバの REST API を使ってグラフに頂点やエッジを挿入するためのJava や Groovy プログラムを書くこともした。しばらくグラフシステムを使っていると、おそらく同じようなことをしていることに気づくだろう。

==== 隣接行列形式

上記のCSVファイルを使って頂点とエッジに関するデータを格納する方法の例はそれを行うための便利な方法を示している。しかしながら、これが唯一の方法というわけではない。プロパティを含まないグラフの場合、下記に示すように、'adjacency matrix：隣接行列'を使ってグラフをレイアウトすることができる。文字は頂点ラベルを表し、1 はその間にエッジがあることを示していて、0は、エッジがないことを示している。この形式は頂点とエッジがプロパティがなく、グラフが小さいが、一般に大きなグラフを表現するのに適した方法ではない場合に役に立つ。

----
A,B,C,D,E,F,G
A,0,1,1,0,1,0,1
B,1,0,0,1,0,1,0
C,1,1,0,1,1,0,1
D,0,1,1,0,1,0,1
E,0,0,0,1,0,1,0
F,1,1,0,1,0,0,1
G,1,1,1,0,1,1,0
----

==== 隣接リスト形式

上記に示した隣接行列は隣接リストとして表すこともできる。この場合、各行の最初の列は頂点を表す。各行の残りの部分は、この頂点が接続されている他の頂点すべてを表す。

----
A,C,D,F,G
B,A,D,F
C,A,B,D,E,1
D,B,C,E,G
E,D,E
F,A,B,D,G
G,A,B,C,E,F
----

これは単純な例だが、この方法で'air-routes'グラフなどの、もっと複雑なグラフを表現することができる。頂点とそのプロパティが最初にリストされ、続けてその頂点が接続されている他の頂点すべてとそれらのエッジのプロパティがリストされる、より複雑なCSVファイルを作成することができる。

グラフデータベースシステムの中には、実際にグラフをディスクに格納するのに、この形式のバリエーションを使っているものがある。実際、JanusGraphは頂点とエッジのデータを永続ストアに格納する際に、このようなシステムをよく使う。

==== エッジリスト形式

'edge list'形式を使う場合、各行はエッジを表す。したがって、単純な例は下記のように表現することができる。いくつかのエッジのみを示す。


----
A,C
A,D
A,F
A,G
B,A
B,D
B,F
C,A
C,B
----

エッジリストを構築する方法はたくさんある。他の簡単な例として、下記に示すような形式で'air-routes'グラフの経路を表すことができる。この場合、各頂点間のエッジのラベルも含める。頂点はID値で表される。

----
[1,route,623]
[1,route,624]
[1,route,625]
[1,route,626]
[1,route,627]
[1,route,628]
[1,route,629]
[1,route,630]
[1,route,631]
[1,route,632]
----

空港の IATA コードとエッジラベルだけを使って非常に簡単なバージョンの'air-routes'グラフをエクスポートしたい場合、下記のように、Gremlin クエリを書くとよい。返された最初の10件の結果のみが表示されている。

[source,groovy]
----
g.V().outE().inV().path().by('code').by(label)

[ATL,route,MBS]
[ATL,route,MCN]
[ATL,route,MEI]
[ATL,route,MLB]
[ATL,route,MSL]
[ATL,route,PHF]
[ATL,route,PIB]
[ATL,route,SBN]
[ATL,route,TRI]
[ATL,route,TTN]
----

TIP: サンプルプログラムフォルダにGraphFromCSV.java というサンプルプログラムがあり、上記のようなCSVファイルを読み込み、そこからグラフを生成する方法を示している。

角カッコを含まないリストを出力したいのであれば、Javaの Iterator インタフェースから'forEachRemaining'メソッドを利用して、クエリの最後に少し後処理を追加するとよい。ここでも、最初の10件の結果のみを示している。

[source,groovy]
----
g.V().outE().inV().path().by('code').by(label).
      forEachRemaining{println it[0] + ',' + it[1] + ',' + it[2]}

ATL,route,MBS
ATL,route,MCN
ATL,route,MEI
ATL,route,MLB
ATL,route,MSL
ATL,route,PHF
ATL,route,PIB
ATL,route,SBN
ATL,route,TRI
ATL,route,TTN
----

=== GraphML

To be written

[source,xml]
----
<?xml version='1.0' ?>
<!-- ******************************************************* -->
<!-- Small sample taken from the air-routes.graphml file.    -->
<!-- ******************************************************* -->

<graphml xmlns='http://graphml.graphdrawing.org/xmlns'>
  <key id='type'    for='node' attr.name='type'    attr.type='string'></key>
  <key id='code'    for='node' attr.name='code'    attr.type='string'></key>
  <key id='icao'    for='node' attr.name='icao'    attr.type='string'></key>
  <key id='desc'    for='node' attr.name='desc'    attr.type='string'></key>
  <key id='region'  for='node' attr.name='region'  attr.type='string'></key>
  <key id='runways' for='node' attr.name='runways' attr.type='int'></key>
  <key id='longest' for='node' attr.name='longest' attr.type='int'></key>
  <key id='elev'    for='node' attr.name='elev'    attr.type='int'></key>
  <key id='country' for='node' attr.name='country' attr.type='string'></key>
  <key id='city'    for='node' attr.name='city'    attr.type='string'></key>
  <key id='lat'     for='node' attr.name='lat'     attr.type='double'></key>
  <key id='lon'     for='node' attr.name='lon'     attr.type='double'></key>
  <key id='dist'    for='edge' attr.name='dist'    attr.type='int'></key>
  <key id='labelV'  for='node' attr.name='labelV'  attr.type='string'></key>
  <key id='labelE'  for='edge' attr.name='labelE'  attr.type='string'></key>    
  
  <graph id='routes' edgedefault='directed'>

    <node id='1'>
    <data key='labelV'>airport</data>
    <data key='type'>airport</data>
    <data key='code'>ATL</data>
    <data key='icao'>KATL</data>
    <data key='city'>Atlanta</data>
    <data key='desc'>Hartsfield - Jackson Atlanta International Airport</data>
    <data key='region'>US-GA</data>
    <data key='runways'>5</data>
    <data key='longest'>12390</data>
    <data key='elev'>1026</data>
    <data key='country'>US</data>
    <data key='lat'>33.6366996765137</data>
    <data key='lon'>-84.4281005859375</data>
  </node>       

  <edge id='3610' source='1' target='3'>
    <data key='labelE'>route</data>
    <data key='dist'>811</data>
  </edge>

  </graph>
</graphml>
----

=== GraphSON

"<<graphmlandjsonintro>>" のセクションで説明したように、TinkerPop 3.2.2 以降、GraphSON 形式には複数のバージョンがある。オリジナルの バージョン 1.0 には型情報は含まれていなかった。バージョン 2.0 ではJSON内にデータ型を含めるという概念が導入された。TinkerPop 3.3 の一部として、GraphSON 3.0 が導入され、いくつかの型が新たに追加された。３つの形式すべてが引き続きサポートされている。デフォルトは GraphSON 3.0 になった。

To be written

[source,groovy]
----
graph=TinkerGraph.open()
g=graph.traversal()
g.addV('airport').property('code','AUS').as('aus').
  addV('airport').property('code','DFW').as('dfw').
  addV('airport').property('code','LAX').as('lax').
  addV('airport').property('code','JFK').as('jfk').
  addV('airport').property('code','ATL').as('atl').
  addE('route').from('aus').to('dfw').
  addE('route').from('aus').to('atl').
  addE('route').from('atl').to('dfw').
  addE('route').from('atl').to('jfk').
  addE('route').from('dfw').to('jfk').
  addE('route').from('dfw').to('lax').
  addE('route').from('lax').to('jfk').
  addE('route').from('lax').to('aus').
  addE('route').from('lax').to('dfw')
----

==== 隣接リスト形式 GraphSON

To be written

[source,json]
----
{"id":0,"label":"airport","inE":{"route":[{"id":17,"outV":4}]}, ... }
{"id":2,"label":"airport","inE":{"route":[{"id":18,"outV":4}, ... ]}}
{"id":4,"label":"airport","inE":{"route":[{"id":15,"outV":2}]}, ... }
{"id":6,"label":"airport","inE":{"route":[{"id":16,"outV":4}, ... ]}}
{"id":8,"label":"airport","inE":{"route":[{"id":11,"outV":0}]}, ... }
----

[source,json]
----
{
    "id": 0,
    "label": "airport",
    "inE": {
        "route": [{
            "id": 17,
            "outV": 4
        }]
    },
    "outE": {
        "route": [{
            "id": 10,
            "inV": 2
        }, {
            "id": 11,
            "inV": 8
        }]
    },
    "properties": {
        "code": [{
            "id": 1,
            "value": "AUS"
        }]
    }
} 
----

[source,json]
----
{"id":197,"label":"airport","inE":{"contains":[{"id":46566,"outV":3378},{"id":49931,"outV":3608}],"route":[{"id":9524,"outV":55,"properties":{"dist":520}},{"id":9753,"outV":57,"properties":{"dist":903}},{"id":22158,"outV":231,"properties":{"dist":1036}}]},"outE":{"route":[{"id":20448,"inV":231,"properties":{"dist":1036}},{"id":20446,"inV":55,"properties":{"dist":520}},{"id":20447,"inV":57,"properties":{"dist":903}}]},"properties":{"country":[{"id":2356,"value":"AU"}],"code":[{"id":2357,"value":"MCY"}],"longest":[{"id":2358,"value":5896}],"city":[{"id":2359,"value":"Maroochydore"}],"elev":[{"id":2360,"value":15}],"icao":[{"id":2361,"value":"YBSU"}],"lon":[{"id":2362,"value":153.091003418}],"type":[{"id":2363,"value":"airport"}],"region":[{"id":2364,"value":"AU-QLD"}],"runways":[{"id":2365,"value":2}],"lat":[{"id":2366,"value":-26.6033000946}],"desc":[{"id":2367,"value":"Sunshine Coast Airport"}]}}
----

==== ラップされた隣接リスト形式 GraphSON

To be written

[source,json]
----
{
    "vertices": [{
        "id": 0,
        "label": "airport",
        "inE": {
            "route": [{
                "id": 17,
                "outV": 4
            }]
        },
        "outE": {
            "route": [{
                "id": 10,
                "inV": 2
            }, {
                "id": 11,
                "inV": 8
            }]
        },
        "properties": {
            "code": [{
                "id": 1,
                "value": "AUS"
            }]
        }
    }, {
        "id": 2,
        "label": "airport",
        "inE": {
            "route": [{
                "id": 18,
                "outV": 4
            }, {
                "id": 10,
                "outV": 0
            }, {
                "id": 12,
                "outV": 8
            }]
        },
        "outE": {
            "route": [{
                "id": 14,
                "inV": 6
            }, {
                "id": 15,
                "inV": 4
            }]
        },
        "properties": {
            "code": [{
                "id": 3,
                "value": "DFW"
            }]
        }
    }, {
        "id": 4,
        "label": "airport",
        "inE": {
            "route": [{
                "id": 15,
                "outV": 2
            }]
        },
        "outE": {
            "route": [{
                "id": 16,
                "inV": 6
            }, {
                "id": 17,
                "inV": 0
            }, {
                "id": 18,
                "inV": 2
            }]
        },
        "properties": {
            "code": [{
                "id": 5,
                "value": "LAX"
            }]
        }
    }, {
        "id": 6,
        "label": "airport",
        "inE": {
            "route": [{
                "id": 16,
                "outV": 4
            }, {
                "id": 13,
                "outV": 8
            }, {
                "id": 14,
                "outV": 2
            }]
        },
        "properties": {
            "code": [{
                "id": 7,
                "value": "JFK"
            }]
        }
    }, {
        "id": 8,
        "label": "airport",
        "inE": {
            "route": [{
                "id": 11,
                "outV": 0
            }]
        },
        "outE": {
            "route": [{
                "id": 12,
                "inV": 2
            }, {
                "id": 13,
                "inV": 6
            }]
        },
        "properties": {
            "code": [{
                "id": 9,
                "value": "ATL"
            }]
        }
    }]
}
----


[[fr]]
== 参考文献

下記に、本書で取り上げられているトピックに関連する追加資料へのリンクを集めてある。リンクには、Apache TinkerPop コミュニティでメンテナンスされているウェブサイトと、Gremlin および関連するトピックが日々議論されているいくつかのメーリングリストが含まれている。

[[tplinks]]
=== Apache TInkerPop コミュニティへのリンク

.公式 Apache TinkerPop ホームページと、Gremlin ダウンロード
http://tinkerpop.apache.org/

.Apache TInkerPop スタートガイド
http://tinkerpop.apache.org/docs/current/tutorials/getting-started/

.現時点の Apache TinkerPop ドキュメント
http://tinkerpop.apache.org/docs/current/reference/

.Apache TinkerPop JavaDoc API リファレンス資料
http://tinkerpop.apache.org/javadocs/current/core/

http://tinkerpop.apache.org/javadocs/current/full/

.Gremlin IO シリアライズとファイルフォーマットのドキュメント
http://tinkerpop.apache.org/docs/current/dev/io/

.便利な Gremlin "レシピ"
http://tinkerpop.apache.org/docs/current/recipes/

.リリース毎の新機能を開設する Apache TinkerPop ドキュメント
http://tinkerpop.apache.org/docs/current/upgrade/

.グラフデータベースプロバイダ向け Apache TinkerPop ドキュメント
http://tinkerpop.apache.org/docs/current/dev/provider/

[[tutorials]]
==== チュートリアル

下記のリンクに一連のチュートリアルがある.

.Apache TinkerPop チュートリアル
http://tinkerpop.apache.org/docs/current/tutorials/

チュートリアルには下記が含まれている。

スタートガイド::
* http://tinkerpop.apache.org/docs/current/tutorials/getting-started/
Gremlin 言語の派生::
* http://tinkerpop.apache.org/docs/current/tutorials/gremlin-language-variants/
Gremlin の解剖学::
* http://tinkerpop.apache.org/docs/current/tutorials/gremlins-anatomy/
Gremlin コンソール::
* http://tinkerpop.apache.org/docs/current/tutorials/the-gremlin-console/


[[gremlindiscussionlists]]
=== Gremlin 関連メーリングリストとディスカッショングループ

.Gremlin ユーザ向け 公式メーリングリスト
https://groups.google.com/forum/#!forum/gremlin-users

.Apache TinkerPop 開発者メーリングリストアーカイブ
//https://lists.apache.org/list.html?dev&#64;tinkerpop.apache.org
https://lists.apache.org/

."gremlin" のタグが付いた Stack Overflow のポスト
https://stackoverflow.com/questions/tagged/gremlin

[[janusgraphlinks]]
=== JanusGraph 関連リンク

.JanusGraph ホームページ
http://janusgraph.org/

.JanusGraph 概要ドキュメント
http://docs.janusgraph.org/latest/

.JanusGraph API ドキュメント
http://docs.janusgraph.org/latest/javadoc.html

.JanusGraph ユーザ向け 公式メーリングリスト
https://groups.google.com/forum/#!forum/janusgraph-users

."janusgraph" のタグが付いた Stack Overflow のポスト
https://stackoverflow.com/questions/tagged/janusgraph

// vim: set tw=85 cc=+1 wrap spell redrawtime=20000:

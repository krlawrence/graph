// vim: set tw=85 cc=+1 wrap spell redrawtime=20000:
[[beq]]
BEYOND BASIC QUERIES
--------------------

So far we have looked mostly at querying an existing graph. In the following sections
we will look at many other topics that it is also important to be familiar with when
working with Gremlin. These topics include mixing in some Groovy or Java code with
your queries, as well as adding vertices (nodes), edges and properties to a graph and
also deleting them. We will also look at how to create a sub-graph and how to save a
graph to an XML or JSON file and a lot more. Let's start off with a short discussion
of query layout, reserved words and data modelling.

[[indents]]
A word about layout and indentation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As you begin to write more complex Gremlin queries they can get quite lengthy. In
order to make them easier for others to read it is recommended to spread them over
multiple lines and indent them in a way that makes sense. We are not going to
propose an indentation standard, we believe this should be left to personal
preference however there are a few things we want to mention in passing. When working
with the Gremlin console, if you want to spread a query over multiple lines then you
will need to end each line with a backslash character or with a character such as a
period or a comma that tells the Gremlin parser that there is more to come.

TIP: TinkerPop offers a Gremlin formatting tool called Gremlint -
https://tinkerpop.apache.org/gremlint/ - which will apply some basic spacing and
indenting to make Gremlin more readable.

The following example shows the query we already looked at in the Boolean operations
section of this book but this time edited so that it could be copy and pasted
directly into the Gremlin console.

[source,groovy]
----
g.V().hasLabel('airport') \
     .has('region',within('US-TX','US-LA','US-AZ','US-OK')) \
     .order().by('region',asc)   \
     .valueMap().select('code','region')

----

We can avoid the use of backslash characters if we lay the query out as follows. Each
line ends with a period which tells the parser that there are more steps coming.

[source,groovy]
----
g.V().hasLabel('airport').
  has('region',within('US-TX','US-LA','US-AZ','US-OK')).
  order().by('region',asc).
  valueMap().select('code','region')

----

If we do not give the parser one of these clues that there is more to come, the
Gremlin console will try and execute each line without waiting for the next line.

Some people find it easier to read queries when each step or modulator is given its
own line and indented appropriately. So we could layout the query as shown below and
it will still work just fine.


[source,groovy]
----
g.V().hasLabel('airport').
      has('region',within('US-TX','US-LA','US-AZ','US-OK')).
      order().
        by('region',asc).
      valueMap().
      select('code','region')

----

Whether you decide to use the backslash as a continuation character or leave the
period on the previous line is really a matter of personal preference. Just be sure
to do one or the other if you want to use multiple line queries within the Gremlin
console. There is no golden rule as to how many lines and how much indenting you
should use when laying out your more complex queries. However, whatever you decide to
do, it is worth remembering that others reading your work may find well laid out and
appropriately indented steps easier to read and understand.


[[rword]]
A warning about reserved word conflicts and collisions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Most of the time the issue we are about to describe will not be a problem. However,
there are cases where names of Gremlin steps conflict with reserved words and method
names in Groovy. Remember that Gremlin is coded in Groovy and Java. If you hit one of
these cases, often the error message that you will get presented with does not make
it at all clear that you have run into this particular issue. Let's look at some
examples. One step name in Gremlin that can sometimes run into this naming conflict
is the 'in' step. However, you do not have to worry about this in all cases. First
take a look at the following query.

[source,groovy]
----
g.V().has('code','AUS').in()
----

That query does not cause an error and correctly returns all of the vertices that are
connected by an incoming edge, to the 'AUS' vertex. There is no conflict of names
here because it is clear that the 'in' reference applies to the result of the has
step. However, now take a look at this query.

[source,groovy]
----
g.V().has('code','AUS').union(in(),out())
----

In this case the 'in' is on its own and not 'dot connected' to a previous step.
The Gremlin runtime (which remember is written in Groovy) will try to interpret this
and will throw an error because it thinks this is a reference to its own 'in' method.
To make this query work we have to adjust the syntax slightly as follows.

[source,groovy]
----
g.V().has('code','AUS').union(__.in(),out())
----

Notice that we added the '"__."' (underscore underscore period) in front of the 'in'
step. This is shorthand for '"the thing we are currently looking at"', so in this
case, the result of the 'has' step.

There are currently not too many Groovy reserved words to worry about. The three that
you have to watch out for are 'in', 'not' and 'as' which have special meanings in
both Gremlin and Groovy. Remember though, you will only need to use the '"__."'
notation when it is not clear what the reserved word, like 'in', applies to.

You will find an example of 'not' being used with the '"__."' prefix in the
"<<btree>>" section a bit later on.


[[dmodel]]
Thinking about your data model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
As important as it is to become good at writing effective Gremlin queries, it
is equally important, if not more so, to put careful consideration into how
you model your data as a graph. Ideally you want to arrange your graph so that
it can efficiently support the most common queries that you foresee it needing
to handle.

Consider this query description. "Find all flight routes that exist between airports
anywhere in the continent of Africa and the United States". When putting the
'air-routes' graph together we decided to model continents as their own vertices. So
each of the seven continents has a vertex. Each vertex is connected to airports
within that continent by an edge labeled "contains".

We could have chosen to just make the continent a property of each airport vertex but
had we done that, to answer the question about "routes starting in Africa" we would
have to look at every single airport vertex in the graph just to figure out which
continent contained it. By giving each continent its own vertex we are able to
greatly simplify the query we need to write.

Take a look at the query below. We first look just for vertices that are continents.
We then only look at the Africa vertex and the connections it has (each will be to a
different airport). By starting the query in this way, we have very efficiently
avoided looking at a large number of the airports in the graph altogether. Finally we
look at any routes from airports in Africa that end up in the United States. This
turns out to yield a nice and simple query in no small part because our data model in
the graph made it so easy to do.


[source,groovy]
----
// Flights from any Airport in Africa to any airport in the United States
g.V().hasLabel('continent').has('code','AF').out().as('a').
  out().has('country','US').as('b').
  select('a','b').by('code')
----

We could also have started our query by looking at each airport and looking to
see if it is in Africa but that would involve looking at a lot more vertices. The
point to be made here is that even if our data model is good we still need to
always be thinking about the most efficient way to write our queries.

[source,groovy]
----
// Gives same results but not as efficient
g.V().hasLabel('airport').as('a').in('contains').has('code','AF').
     .select('a').out().has('country','US').as('b').select('a','b').by('code')
----

Now for a fairly simple graph, like 'air-routes', this discussion of efficiency is
perhaps not such a big deal, but as you start to work with large graphs,
getting the data model right can be the difference between good and bad query
response times. If the data model is bad you won't always be able to work
around that deficiency simply by writing clever queries!

Keeping information in two places within the same graph
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sometimes, to improve query efficiency we find it is actually worth having the
data available more than one place within the same graph. An example of this
in the air routes graph would be the way we decided to model countries. We have
a unique vertex for each country but we also store the country code as a property
of each airport vertex. In a small graph this perhaps is overkill but we did it
to make a point. Look at the following two queries that return the same
results - the cities in Portugal that have airports in the graph.

[source,groovy]
----
g.V().has('country','code','PT').out("contains").values('city')

g.V().has('airport','country','PT').values('city')
----
The first query finds the country vertex for Portugal and then, finds all of the
countries connected to it. The second query looks at all airport vertices and
looks to see if they contain 'PT' as the country property.

In the first example it is likely that a lot fewer vertices will get looked at
than the first even though a few edges will also get walked as there are over
3,000 airport vertices but fewer than 300 country vertices. Also, in a production
system with an index in place finding the 'Portugal' vertex should be very fast.

Conversely, if we were already looking at an airport vertex for some other
reason and just wanted to see what country it is in, it is more convenient to
just look at the 'country' property of that vertex.

So there is no golden rule here but it is something to think about while
designing your data model.

Using a graph as an index into other data sources
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

While on the topic of what to keep in the graph, something to resist being
drawn into in many cases is the desire to keep absolutely everything in the
graph. For example, in the air routes graph we do not keep every single detail
about an airport (radio frequencies, runway names, weather information etc.)
in the airport vertices. That information is available in other places and easy
to find. In a production system you should consider carefully what needs to be
in your graph and what more naturally belongs elsewhere. One thing we could do
is add a URL as a property of each airport vertex that points to the airports
home page or some other resource that has all of the information. In this way
the graph becomes a high quality index into other data sources. This is a
common and useful pattern when working with graphs. This model of having
multiple data sources working together is sometimes referred to as 'Polyglot
storage'.

A few words about 'supernodes'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When a vertex in a graph has a large number of edges and is disproportionately
connected to many of the other vertices in the graph it is likely that many, if not
all, graph traversals of any consequence will include that vertex. Such vertices
(nodes) are often referred to as 'supernodes'. In some cases the presence of
'supernodes' may be unavoidable but with careful planning as you design your graph
model you can reduce the likelihood that vertices become 'supernodes'. The reason we
worry about 'supernodes' is that they can significantly impact the performance of
graph traversals. This is because it is likely that any graph traversal that goes 
via such a vertex will have to look at most if not all of the edges connected to that
vertex as part of a traversal.

The 'air-routes' graph does not really have anything that could be classed as a
'supernode'. The vertex with the most edges is the continent vertex for North America
that has approximately 980 edges. The busiest airports are IST and AMS and they both
have just over 530 total edges. So in the case of the 'air-routes' graph we do not 
have to worry too much.

If we were building a graph of a social network that included famous people we might
have to worry. Consider some of the people on Twitter with millions of followers.
Without taking some precautions, such a social network, modelled as a graph, could
face issues.

As you design your graph model it is worth considering that some things are perhaps
better modelled as a vertex property than as a vertex with lots of edges needing to
connect to it. For example in the air routes graph there are country vertices and 
each airport is connected to one of the country vertices. In the air routes graph 
this is not a problem as even if all of the airports in the graph were in the same 
country that would still give us fewer than 3,500 edges connected to that vertex. 
However, imagine if we were building a graph of containing a very large number of 
people. If we had several million people in the graph all living in same the country 
that would be a guaranteed way to get a 'supernode' if we modelled that relationship 
by connecting every person vertex to a country vertex using a 'lives in' edge. In 
such situations, it would be far more sensible to make the country where a person 
lives a property of their own vertex.

A detailed discussion of 'supernode' mitigation is beyond the scope of this book
but we encourage you to always be thinking about their possibility as you design your
graph and also be thinking about how you can prevent them becoming a big issue for
you.

[[grv]]
Making Gremlin even Groovier
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As we have already discussed, the Gremlin console builds upon the Groovy console, and
Groovy itself is coded in Java. This means that all of the classes and methods that
you would expect to have available while writing Groovy or Java programs are also
available to you as you work with the Gremlin Console. You can intermix additional
features from Groovy and Java classes along with the features provided by the
TinkerPop classes as needed. This capability makes Gremlin additionally powerful.
You can also take advantage of these features when working with Gremlin Server and
with other TinkerPop enabled graph services with the caveat that some features may be
blocked if viewed as a potential security risk to the server or simply because they
are not supported.

Every Gremlin query we have demonstrated so far is also, in reality, valid Groovy. We
have already shown examples of storing values into variables and looping using Groovy
constructs as part of a single or multi part Gremlin query.

In this section we are going to go one step further and actually define some
methods, using Groovy syntax, that can be run while still inside the Gremlin Console.
By way of a simple example, let's define a method that will tell us how far apart two
airports are and then invoke it.

[source,groovy]
----
// A simple function to return the distance between two airports
def dist(g,from,to) {
  d=g.V().has('code',from).outE().as('a').inV().has('code',to)
         .select('a').values('dist').next()
  return d }

// Can be called like this
dist(g,'AUS','MEX')
----

This next example shows how to define a slightly longer method that prints out
information about the degree of a vertex in a nice, human readable, form.

[source,groovy]
----
// Groovy function to display vertex degree
def degree(g,s) {
  v = g.V().has('code',s).next();
  o=g.V(v).out().count().next();
  i=g.V(v).in().count().next() ;
  println "Edges in  : " + i;
  println "Edges out : " + o;
  println "Total     : " +(i+o);
}

// Can be called like this
degree(g,'LHR')
----

Here is an example that shows how we can query the graph, get back a list of values
and then use a 'for' loop to display them. Notice this time how we initially store
the results of the query into the variable 'x'. The call to 'toList' ensures that 'x'
will contain a list (array) of the returned values.

[source,groovy]
----
// Using a Groovy for() loop to iterate over a list returned by Gremlin
x=g.V().hasLabel('airport').limit(10).toList()
for (a in x) {
  println(a.values('code').next() + " " + a.values('icao').next() + " " + a.values('desc').next())
}

// We can also do this just using a 'for' loop and not storing anything into a variable.
for (a in g.V().hasLabel('airport').limit(10).toList()) {
  println(a.values('code').next()+""+a.values('icao').next())
}
----

Sometimes (as you have seen above) it is necessary to make a call to 'next' to get
the result you expect returned to your variable.

[source,groovy]
----
number = g.V().hasLabel('airport').count().next()
println "The number of airports in the graph is " + number
----

Here is another example that makes a Gremlin query inside a 'for' loop.

[source,groovy]
----
for (a in 1..10) print g.V().has(id,a).values('code').next()+" "
----

This example returns a hash of vertices, with vertex labels as the keys and the
code property as the values. It then uses the label names to access the returned
hash.

[source,groovy]
----
a=g.V().group().by(label).by('code').next()
println(a["country"].size())
println(a["country"][5])
println(a["airport"][2])
----

Here is another example. This time we define a method that takes as input a traversal
object and the code for an airport. It then uses those parameters to run a simple
Gremlin query to retrieve all of the places that you can fly to from that airport.
It then uses a simple 'for' loop to print the results in a table. Note the use of
'next' as part of the 'println'. This is needed in order to get the actual values
that we are looking for. If we did not include the calls to 'next' we would actually
get back the iterator object itself and not the actual values.

[source,groovy]
----
// Given a traversal and an airport code print a list of all the places you can
// fly to from there including the IATA code and airport description.
def from(g,a) {
  places=g.V().has('code',a).out().toList();
  for (x in places) {println x.values('code').next()+" "+x.values('desc').next()}
}

// Call like this
from(g,'AUS')
----

This example creates a hash map of all the airports, using their IATA code as the
key. We can then access the map using the IATA code to query information about those
airports. Remember that the ';[]' at the end of the query just stops the console from
displaying unwanted output.

[source,groovy]
----
// Create a map (a) of all vertices with the code property as the key
a=g.V().group().by('code').next();[]

// Show the description stored in the JFK vertex
a['JFK'][0].values('desc')
----

Another useful way to work with variables is to establish the variable and then use
the 'fill' step to place the results of a query into it. The example below creates an
empty list called 'german'. The query then finds all the vertices for airports
located in Germany and uses the 'fill' step to place them into the variable.

[source,groovy]
----
german = []
g.V().has('airport','country','DE').fill(german)
----

We can then use our list as you would expect. Remember that as we are running inside
the Gremlin console we do not have to explicitly iterate through the list as you
would if you were writing a standalone Groovy application.

[source,groovy]
----
// How many results did we get back?
german.size

32

// Query some values from one of the airports in the list
german[0].values('city','code')

FRA
Frankfurt

// Feed an entry from our list back into a traversal
g.V(german[1]).values('city')

Munich

g.V(german[1]).out().count()

237
----

Towards the end of the book, in the "<<groovyapp>>" section, we will explore
writing some standalone Groovy code that can use the TinkerPop API and issue Gremlin
queries while running outside of the Gremlin Console as a standalone application.

[[varaus]]
Using a variable to feed a traversal
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sometimes it is very useful to store the result of a query in a variable and then, 
later on, use that variable to start a new traversal. You may have noticed we did 
that in the very last example of the prior section where we fed the 'german' variable
back in to a traversal. By way of another simple example, the code below stores the 
result of the first query in the variable 'austin' and then uses it to look for 
routes from Austin in second query. Notice how we do this by passing the variable 
containing the Austin vertex into the 'V' step.

[source,groovy]
----
 austin=g.V().has('code','AUS').next()
 g.V(austin).out()
----

You can take this technique one step further and pass an entire saved list of
vertices to 'V'. In the next example we first generate a list of all airports that
are in Scotland and then pass that entire list into 'V' to first of all count how 
many routes there are from those airports and then we start another query that looks 
for any route from those airports to airports in Germany.

[source,groovy]
----
// Find all airports in Scotland
a=g.V().hasLabel('airport').has('region','GB-SCT').toList()

// How many routes from these airports?
g.V(a).out().count()

// How many of those routes end up in Germany?
g.V(a).out().has('country','DE').values('code')
----

In this example of using with variables to drive traversals, we again create a list 
of airports. This time we find all the airports in Texas. We then use a Groovy 'each'
loop to iterate through the list. For each airport in the list we print the code of 
the starting airport and then the codes of every airport that you can fly to from 
there.

[source,groovy]
----
// Find all of the airports in Texas
texas=g.V().has('region','US-TX').toList()

// For each airport, print a list of all the airports that you can fly to from there.
texas.each {println it.values('code').next() + "===>" +
                    g.V(it).out().values('code').toList()}
----

This example, which is admittedly a bit contrived, we use a variable inside of a
'has' step. We initially create a list containing all of the IATA codes for each
airport in the graph. We then iterate through that list and calculate how many
outgoing routes there are from each place and print out a string containing the
airport IATA code and the count for that airport. Note that this could easily be done
just using a Gremlin query with no additional Groovy code. The point of this example
is more to show another example of mixing Gremlin, Groovy and variables.
Knowing that you can do this kind of thing may come in useful as you start to write
more complicated graph database applications that use Gremlin. You will see this
type of query done using just Gremlin in the section called "<<unwantededges>>"
later in this book.

[source,groovy]
----
m=g.V().hasLabel('airport').values('code').toList()
for (a in m) println a + " : " + g.V().has('code',a).out().count().next()
----

Lastly, here is an example that uses an array of values to seed a query.

[source,groovy]
----
['AUS','RDU','MCO','LHR','DFW'].
     each {println g.V().has('code','JFK').outE().inV().
                         has('code',it).path().by('code').by('dist').next()}
----

Here is the output from running the code.

[source,groovy]
----
[JFK, 1520, AUS]
[JFK, 427, RDU]
[JFK, 945, MCO]
[JFK, 3440, LHR]
[JFK, 1390, DFW]
----


[[addnodes]]
Adding vertices, edges and properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

So far in this book we have largely focussed on loading a graph from a file and
running queries against it. As you start to build your own graphs you will not always
start with a graph saved as a text file in GraphML, CSV, GraphSON or some other
format. You may start with an empty graph and incrementally add vertices and edges.
Just as likely you may start with a graph like the air routes graph, read from a
file, but want to add vertices, edges and properties to it over time. In this section
we will explore various ways of doing just that.

Adding an airport (vertex) and a route (edge)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following code creates a new airport vertex (node) and then adds a route (edge)
from it to the existing DFW vertex. We can specify the label name ('airport') and as
many properties as we wish to while creating the vertex. In this case we just provide
three. We can additionally add and delete vertex properties after a vertex has been
created. Examples of how to do that are coming up next.

[source,groovy]
----
// Add an imaginary airport with a code of 'XYZ' and connect it to DFW
xyz = g.addV('airport').property('code','XYZ').
                        property('icao','KXYZ').
                        property('desc','This is not a real airport').next()
----

Notice, in the code above where we add the vertex, how each 'property' step can be 
chained to the previous one when adding multiple properties. Whether you need to do 
it while creating a vertex or to add and edit properties on a vertex at a later date
you can use the same 'property' step.

The 'property' step also has a second form that takes a 'Map' of properties as an 
argument. This form can be useful as a shorthand compared to chained 'property'
calls, but also because it is common to have data in the form of a 'Map' in the 
normal course of development.

[source,groovy]
----
// Add an imaginary airport with a code of 'XYZ' and connect it to DFW
xyz = g.addV('airport').
        property([code: 'XYZ', icao: 'KXYZ', desc, 'This is not a real airport']).next()
----

We can now add a route from DFW to XYZ. We are able to use our 'xyz' variable to 
specify the destination of the new route using a 'to' step.

[source,groovy]
----
// Add a route from DFW to XYZ
g.V().has('code','DFW').addE('route').to(xyz)
----

We could have written the previous line to use a second 'V' step if we had not
previously saved anything in a variable. Note that while this use of a second 'V'
step will work locally, if you are sending queries to a Gremlin Server (a topic we
will discuss later in this book) this syntax is not supported and will not work.

[source,groovy]
----
g.V().has('code','DFW').addE('route').to(V().has('code','XYZ'))
----

We might also want to add a returning route from XYZ back to DFW. We can do this
using the 'from' step in a similar way as we used the 'to' step above.

[source,groovy]
----
// Add the return route back to DFW
g.V().has('code','DFW').addE('route').from(xyz)
----

Another way that we could have chosen to create our edge involves labelling the "XYZ"
vertex using an `as` step. The example below demonstrates this. Notice also how a 'V'
step is used to start a new traversal midway through the current one. The label
created using the `as` step is used to instruct the `to` step about the target vertex
for the new edge.

[source,groovy]
----
g.V().has('code','XYZ').as('a').V().has('code','DFW').addE('route').to('a')
----

You will see a bigger example that uses 'as' steps while creating vertices and edges
in the "<<testgraph>>" section that is coming up soon.

[[addlabeldynamic]]
Using a traversal to determine a new label name
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When using the  'addV' and 'addE' steps we can  use a traversal to determine what
the label used by a new vertex or edge should be. Take a look at the query below.
We have seen this type of query used earlier in the book. It simply tells us what
label the vertex representing the Austin (AUS) airport has.

[source,groovy]
----
g.V().has('code','AUS').label()

airport
----

The traversal above can be used inside of an 'addV' step as shown below. The first
string result returned by the provided traversal will be used as the label name.

[source,groovy]
----
g.addV(V().has('code','AUS').label()).property('code','XYZ')

v[53768]
----

We can inspect the new vertex using 'valueMap' to make sure that our label was
correctly assigned.

[source,groovy]
----
g.V(53768).valueMap(true)

[id:53768,code:[XYZ],label:airport]
----

We can now do something similar to dynamically work out what the label should be for
an edge between our new airport and Austin.

[source,groovy]
----
g.V(53768).addE(V().has('code','AUS').outE().limit(1).label()).
           to(V().has('code','AUS'))

e[53770][53768-route->3]
----

NOTE: Later in the book we will build upon these concepts to show how the property
keys and values from one vertex, as well as the label, can be copied into a new
vertex using a single query.

Once again, we can use a 'valueMap' step to make sure our new edge label looks OK.

[source,groovy]
----
g.E(53770).valueMap(true)

[id:53770,label:route]
----

[[proptraversal]]
Using a traversal to seed a property with a list
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You can use the results of a traversal to create or update properties. The example
below creates a new property called 'places' for the Austin airport vertex. The
values of the property are the results of finding all of the places that you can
travel to from that airport and folding their 'code' values into a list.

[source,groovy]
----
// Add a list as a property value
g.V().has('code','AUS').property('places',out().values('code').fold())
----

We can use a 'valueMap' step to make sure the property was created as we expected it
to be. As you can see a new property called 'places' has been created containing as
its value a list of codes.

[source,groovy]
----
g.V().has('code','AUS').valueMap('places')

[places:[[YYZ, LHR, FRA, MEX, PIT, PDX, CLT, CUN, MEM, CVG, IND, MCI, DAL, STL, ABQ, MDW, LBB, HRL, GDL, PNS, VPS, SFB, BKG, PIE, ATL, BNA, BOS, BWI, DCA, DFW, FLL, IAD, IAH, JFK, LAX, MCO, MIA, MSP, ORD, PHX, RDU, SEA, SFO, SJC, TPA, SAN, LGB, SNA, SLC, LAS, DEN, MSY, EWR, HOU, ELP, CLE, OAK, PHL, DTW]]]
----

To gain access to these values from your code or Gremlin console queries, we can use
the 'next' step. A simple example is given below where 'values' is used to retrieve
the values of the 'places' property and then we use 'size' to see how many entries
there are in the list.

[source,groovy]
----
g.V().has('code','AUS').values('places').next().size()

59
----

Once we have access to the list of values we can access them using the normal Groovy
array syntax. The example below returns the three values with an index between 2 and
4.

[source,groovy]
----
g.V().has('code','AUS').values('places').next()[2..4]

FRA
MEX
PIT
----

[[injectid]]
Using 'inject' to specify new vertex ID values
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If the graph database you are using supports user provided ID values, you can use an
'inject' step as one way to specify what you want the ID value of a new vertex to be.
For example consider the example below.

[source,groovy]
----
g.inject(99999L).addV().property(id,identity())

v[99999]
----

You can also specify more than one ID value if you want to create multiple vertices.

[source,groovy]
----
g.inject(99997L,99998L).addV().property(id,identity())

v[99997]
v[99998]
----

We chose to show use of 'inject' as it provides an interesting example. However, it
is not required to create new IDs in this way. Both of the examples below are also
valid ways to do the same thing. The first example just uses a literal value.

[source,groovy]
----
g.addV().property(id,99999L)

v[99999]
----

Alternatively we could pass in a variable.

[source,groovy]
----
n=99999L;
g.addV().property(id,n)

v[99999]
----

NOTE: Remember that these methods of specifying an ID value will only work if the
graph database that you are using allows you to specify your own ID values. This
varies by graph database implementation and you should check the documentation for
the system you are using before assuming that you can create your own custom ID
values.

Even if the graph database that you are using does support user provided ID values
you should check to see what data types can be used for them. All of the examples
above used LONG values. However, as one example, some graph databases that do allow
you to specify custom IDs only support String values. So the key thing is to check
the documentation before you start building your graph.

Even if a graph database does support custom ID values, if you try to create a vertex
using an ID that already exists the operation will fail. The example below shows what
happens when we try to add a vertex using an ID that already exists to a TinkerGraph.

[source,groovy]
----
g.inject(99999L).addV().property(id,identity())

Vertex with id already exists: 99999
----

[[testgraph]]
Quickly building a graph for testing
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sometimes for testing and for when you want to report a problem or ask for help on a
mailing list it is handy to have a small standalone graph that you can use. The code
below will create a mini version of the air routes graph in the Gremlin Console. Note
how all of the vertices and edges are created in a single query with each step joined
together.

[source,groovy]
----
graph = TinkerGraph.open()
g = traversal().with(graph)
g.addV('airport').property('code','AUS').as('aus').
  addV('airport').property('code','DFW').as('dfw').
  addV('airport').property('code','LAX').as('lax').
  addV('airport').property('code','JFK').as('jfk').
  addV('airport').property('code','ATL').as('atl').
  addE('route').from('aus').to('dfw').
  addE('route').from('aus').to('atl').
  addE('route').from('atl').to('dfw').
  addE('route').from('atl').to('jfk').
  addE('route').from('dfw').to('jfk').
  addE('route').from('dfw').to('lax').
  addE('route').from('lax').to('jfk').
  addE('route').from('lax').to('aus').
  addE('route').from('lax').to('dfw')
----

NOTE: The form of 'addV' that used to allow creation of a vertex and a property using
something like 'g.addV(label,"airport","code","AUS")' is now deprecated and should
not be used.

[[addloop]]
Adding vertices and edges using a loop
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sometimes it is more efficient to define the details of the vertices or edges that
you plan to add to the graph in an array and then add each vertex or edge using a
simple 'for' loop that iterates over it. The following example adds our
imaginary airports directly to the graph using such a loop. Notice that we do
not have to specify the ID that we want each vertex to have. The graph will
assign a unique ID to each new vertex for us.

[source,groovy]
----
vertices = [["WYZ","KWYZ"],["XYZ","KXYZ"]]
for (a in vertices) {g.addV("airport").property("code",a[0],"iata",a[1]).iterate()}
----

Note the call to 'iterate' at the end for without that terminal step, the query would
not execute. If you don't recall why 'iterate' is important you can read about it in
the "<<ignoringresults>>" section. 

This technique of creating vertices and/or edges using a 'for' loop can also be useful
when working with graphs remotely over HTTP connections. It is a very convenient way
to combine a set of creation steps into a single REST API call.

If you prefer a more Groovy like syntax you can also do this.

[source,groovy]
----
vertices = [["WYZ","KWYZ"],["XYZ","KXYZ"]]
vertices.each {
  g.addV("airport").property("code",it[0]).property("iata",it[1]).iterate()
}
----

[[addinject]]
Adding vertices and edges using 'inject'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The previous section on "<<addloop>>" used the loop semantics of programming 
languages to add multiple vertices by iterating over an array of data. In tihs 
section we will learn how you can do this entirely with Gremlin steps. As before we 
construct an array representing our graph data and give that to 'inject'. The 
"looping" we saw previously is similarly produced here by the standard Gremlin 
semantics which takes the array and uses 'unfold' to flatten the data such that each 
internal array triggers a call to the 'addV' step.

[source,groovy]
----
vertices = [["WYZ","KWYZ"],["XYZ","KXYZ"]]
g.inject(vertices).unfold().as("v").
  addV("airport").property("code", select("v").limit(local,1)).
                  property("iata", select("v").tail(local,1))
----

Each internal array is then given a label of "v" so that it can be referenced later
in the traversal. We reference it in the calls to 'property' where we 'select' the 
array and grab either the first item in the array (i.e. the "code") or the last (i.e.
the "iata") to serve as the property value.

Unlike the approach that uses a more standard Java loop, this approach executes the
graph mutation in a single query, where as the former approach will execute one 
query per item in the "vertices" array. 

[[addrepeat]]
Adding vertices using 'repeat'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The previous section on "<<addinject>>" demonstrated how to use add multiple vertices
given an array of data using only Gremlin steps. Another approach worth knowing about
is the use of 'repeat' step to achieve a similar end:

[source,groovy]
----
g.inject(0).repeat(addV('test').property(T.id, loops())).times(5)
----

Note the call to 'loops' when setting the identifier for the vertex. The 'loops' step
tracks the number of times that the 'repeat' has been called, essentially incremeting
by 1 for each call to 'addV' creating an auto-incremeting identifier. This technique
for creating vertices is often helpful when there is a need to generate some vertices
for testing.

[[upsert]]
Using 'mergeV' and 'mergeE' for upserting
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Checking to see if a vertex or edge already exists and then either inserting that 
element if it does not or updating the element that is found, is a common database
access pattern often referred to as an 'upsert'. There are a variety of ways to 
implement an upsert in Gremlin, but the 'mergeV' and 'mergeE' steps are designed 
specifically for this purpose and offer a wide degree of flexiblity in this task.

Let's assume we wanted to add a new airport, with the code '"XYZ"' but we are not
sure if the airport might have already been added. We can do all of those things 
using the most basic form of 'mergeV':

[source,groovy]
----
g.mergeV([code:'XYZ'])

v[53865]
----

As you can see, 'mergeV' takes a 'Map' as an argument where the keys and values
become the search criteria for the vertex. In the above case, it is similar to 
writing `has("code","XYZ")' to find a vertex. If 'mergeV' finds a vertex with that 
code and value, it return it. However, 'mergeV' has a dual purpose. Should the vertex
not be found, then 'mergeV' will automatically create a new vertex with a "code" of 
"XYZ" and return that. Evaluating that same query again will result in returning the
existing 'v[53865]'.

You may match on as many properties as necessary including 'T.id' and 'T.label':

[source,groovy]
----
g.mergeV([(T.label): 'airport', (T.id): 999999, code:'XYZ'])

v[999999]
----

Note that the match must be complete in that all keys designated in the 'Map' must 
match or else a new vertex will be created. In the example above, there is a vertex
present that has a code of '"XYZ"', but the one we created initially lacks a 
'T.label' of "airport" and has a different 'T.id' all together. 

We do not always want to utilize the same criteria for searching as we do creating.
Most commonly we tend to search by the element identifier, which is the fastest way
to check for existence. For these cases you will only want to provide that identifier
to the 'Map' given to 'mergeV' and separately specify the properties you want to use
to create the vertex if it is not found. You can do this with the 'option' modulator
and the 'Merge' enum.

[source,groovy]
----
g.mergeV([(T.id): 999999]).
    option(Merge.onCreate, [(T.label): 'airport', code:'XYZ'])

v[999999]
----

In this prior example, 'mergeV' will match on the vertex identifier of '999999' and
will return it if found. Otherwise, it will defer to the 'onCreate' action which
specifies a 'Map' of keys and values to use to create the new vertex. The 'onCreate'
'Map' inherits keys and values from the search map and would therefore include the 
'999999' in the creation of the vertex.

As we have a 'onCreate' to deal with the "does not exist" path for the search, we 
also have a 'onMatch' to allow more control over the "does exist" path to update an 
existing vertex. For example, if we wanted to change the code to update the code 
property to a lower-case '"xyz"' in the event the vertex exists, we could write the 
following:

[source,groovy]
----
g.mergeV([(T.id): 999999]).
    option(Merge.onCreate, [(T.label): 'airport', code:'XYZ'])
    option(Merge.onMatch, [code:'xyz'])

v[999999]
----

At this point we've demonstrated the general form of 'mergeV' where you give it a
'Map' of key/value pairs to use for a search and then use 'option' modulators to 
provide specific data to use to either create or update based on the initial match.
For more advanced use cases, we have some additional flexibility in how we supply the
'Map' arguments as they may all be supplied by way of a 'Traversal':

[source,groovy]
----
g.withSideEffect('search', [(T.id): 999998]).
  withSideEffect('create', [code: 'ZYX', (T.label): 'airport']).
  withSideEffect('match', [code: 'zyx']).
  mergeV(select('search')).
    option(Merge.onCreate, select('create')).
    option(Merge.onMatch, select('match'))
    
v[999998]
----

The prior example shows how you can use a step like 'select' to dynamically provide
a 'Map' argument to the various 'mergeV' parameters.

The counterpart to 'mergeV' is 'mergeE' where the same patterns can be used to upsert
edges. Edges have a bit more complexity in that addition to the property values they
may have, they also have an 'IN' and an 'OUT' (or 'from' and 'to') vertex that 
applies to them. Let's assume we want to look for an existing route edge between the 
'"XYZ"' airport that we just added and '"DFW"'. If we find that edge with that search
criteria we simply return it, but if it is not found then we will create it with a
dist property of 0. To do this we need the vertex ids that this edge relates to. We
can then use those ids to reference them in the search criteria:

[source,groovy]
----
g.V().has('code','DFW').id()

8

g.V().has('code','XYZ').id()

999999

g.mergeE([(T.label): 'route', (Direction.from): 8, (Direction.to): 999999]).
    option(Merge.onCreate, [dist: 0])

e[41224][8-route->999999]
    
g.E(41224L).elementMap()

[id:41224,label:route,IN:[id:999999,label:airport],OUT:[id:8,label:airport],dist:0]
----

It is not possible to create new vertices from 'mergeE' automatically. They must 
already exist for the edge to be created. In addition to 'onMatch' and 'onCreate', 
'mergeE' also allows for two other 'option' modulators: 'outV' and 'inV', which lets
you specify search criteria as a 'Map' for the 'from' and the 'to' of the edge. Using
that capability we could rewrite the previous example as follows:

[source,groovy]
----
g.mergeE([(T.label): 'route', (Direction.from): Merge.outV, (Direction.to): Merge.inV]).
    option(Merge.outV, [code: 'DFW']).
    option(Merge.inV, [code: 'XYZ']).
    option(Merge.onCreate, [dist: 0])
    

e[41224][8-route->999999]    
----

This section introduced the basics of the 'mergeV' and 'mergeE' steps, which provide
a powerful way in which to encapsulate upsert logics for vertices and edges. As you
continue through the following sections you will find more advanced features with 
these steps.

Incorporating 'fail' with 'mergeV' or 'mergeE'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We learned about 'fail' step in "<<coalfail>>" where it will throw an exception when it
is encountered. You can incorporate this step into 'mergeV' and 'mergeE' to stop a
traversal in cases where you don't want the traversal to continue in 'onCreate' or
'onMatch'.

Let's envision a case where you do not expect the '"XYZ"' airport to be present in 
the graph and that if it is you do not want the query to proceed any further in its 
processing. Since the 'option' modulator takes a traversal as an argument, you can 
give it a fail step for its 'onMatch'.

[source,groovy]
----
g.mergeV([code: 'XYZ']).
    option(Merge.onCreate, [(T.label): 'airport', code:'XYZ']).
    option(Merge.onMatch, fail('XYZ airport already exists'))

fail() Step Triggered
=========================================================================================================================================================================
Message  > XYZ airport already exists
Traverser> v[999999]
  Bulk   > 1
Traversal> fail("XYZ airport already exists")
Parent   > MergeVertexStep [mergeV(["code":"XYZ"]).option(Merge.onCreate,[(T.label):"airport","code":"XYZ"]).option(Merge.onMatch,__.fail("XYZ airport already exists"))]
Metadata > {}
=========================================================================================================================================================================
----

Note that the output above is the string representation of a 'FailException' as 
printed in Gremlin Console.

Specifying cardinality with 'mergeV'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Most of the time, vertex properties tend to be modelled with 'single' cardinality.
However, you may have situations where other cardinalities are used or are using a 
graph that defaults to a cardinality other than 'single'. The 'mergeV' step provides
two ways to explicitly set the cardinality for the properties given to it and both
make use of the 'Cardinality' enum. The first way to do this is to explcitly set the
cardinality per property value. For example, let's imagine that you want to use 'set'
cardinality for the code property.

[source,groovy]
----
g.mergeV([(T.id): 999999]).
    option(Merge.onCreate, [(T.label): 'airport', code: set('XYZ')])

v[999999]
----

By wrapping the '"XYZ"' in the 'set()', which is statically imported from 
'Cardinality.set', you mark that value in a way that 'mergeV' knows to tell the graph
to use that specific cardinality for that property. You could also do set this value
globally for the step by providing it as an argument after the 'Map':

[source,groovy]
----
g.mergeV([(T.id): 999999]).
    option(Merge.onCreate, [(T.label): 'airport', code: 'XYZ'], Cardinality.set)

v[999999]
----

When you offer 'set' this way, 'mergeV' will assume all property keys to use this 
cardinality. If there is an explicit cardinality specified, it will override the 
global setting.

[[coaladdv]]
[[upsert]]
When you need more flexibility than 'mergeV' and 'mergeE'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The 'mergeV' and 'mergeE' steps offer a wide breath of options to encapsulate 
upsert-like logic with varying mechanisms for matching, creating and updating. While
these steps are extremely flexible, you may yet find a scenario where they do not do
everything you require. In these cases, you may fall back to a lower order of Gremlin
steps that can offer more options, but be a bit more complex to implement and 
possibly lack the same performance capability as different graph providers may not be
able to optimize these queries as well as the more directly purposed 'mergeV' and
'mergeE' steps.

In the "<<coalconst>>" section we looked at how coalesce could be used to return a
constant value if the other entities that we were looking for did not exist. We can
reuse that pattern to produce a traversal that will only add a vertex to the graph if
that vertex has not already been created.

Let's assume we wanted to add a new airport, with the code '"XYZ"' but we are not
sure if the airport might have already been added.

We can check to see if the airport exists, using a basic 'has' step.

[source,groovy]
----
g.V().has('code','XYZ')
----

If it does not exist yet, which in this case it does not, nothing will be returned.
We could go one step further and change the query to return an empty list '[]' if the
airport does not exist by adding a 'fold' step to the query.

[source,groovy]
----
g.V().has('code','XYZ').fold()

[]
----

Now that we have a query that can return an empty list if a vertex does not exist we
can take advantage of this in a 'coalesce' step. The query below looks to see if the
airport already exists and passes the result of that into a 'coalesce' step.
Remember, 'coalesce' will return the result of the first traversal it looks at that
returns a good result. We can make the first parameter passed to 'coalesce' and
'unfold' step. This way in the case where the airport does not exist, 'unfold' will
return nothing and so 'coalesce' will attempt the second step. In this case our
second step creates a vertex for the airport '"XYZ"'.

[source,groovy]
----
g.V().has('code','XYZ').fold().coalesce(unfold(),addV().property('code','XYZ'))

v[53865]
----

As you can see the query above created a new vertex with an ID of '53865' as the
'XYZ' airport did not already exist. However, if we run the same query again, notice
that we get the same vertex back that we just created and not a new one. This is
because this time, the 'coalesce' step *does* find a result from the 'unfold' step
and so completed before attempting the 'addV' step.

[source,groovy]
----
g.V().has('code','XYZ').fold().coalesce(unfold(),addV().property('code','XYZ'))

v[53865]
----

Using 'coalesce' in this way provides us with a nice pattern for a commonly performed
task of checking to see if something already exists before we try to update it and
otherwise create it. This is often called an '"upsert"' pattern as the operation
potentially updates or inserts a vertex based on its existence or not.

The query below is perhaps a better example of an '"upsert"'. The query looks to
see if the vertex with an ID of 3 already exists. If it does it updates the 'runways'
property of that vertex be the value 3. If it does not exist it creates a new vertex 
and the property. As vertex v[3] already exists that is what the query returns, 
having first updated the 'runways' property.

[source,groovy]
----
g.V(3).fold().
       coalesce(unfold().property('runways',3),
       addV('airport').property('runways',3))

v[3]
----

If we now examine the properties of the vertex v[3] we can see that the 'runways'
value has been set to 3.

[source,groovy]
----
g.V(3).valueMap().unfold()

country=[US]
code=[AUS]
longest=[12250]
city=[Austin]
elev=[542]
icao=[KAUS]
lon=[-97.6698989868164]
type=[airport]
region=[US-TX]
runways=[3]
lat=[30.1944999694824]
desc=[Austin Bergstrom International Airport]
----

In the air routes graph there is no vertex with an ID of 9999999. So if we rerun the
previous '"upsert"' query, this time a new vertex will be created.

[source,groovy]
----
g.V(9999999).fold().
             coalesce(unfold().property('runways','3'),
             addV('airport').property('runways',3))

v[57343]
----

If we look at the 'valueMap' for the new vertex we can see that it was created as we
would have expected.


[source,groovy]
----
g.V(57343).valueMap().unfold()

runways=[3]
----

This technique is currently the recommended way of doing '"upsert"' operations with
Gremlin.

[[vertexcopy]]
Creating one vertex based on another
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is sometimes useful to be able to create a new vertex using the label and
properties from an existing vertex. We have already looked, in the
"<<addlabeldynamic>>" section, at some ways to create a new label using the value
of other labels but we have not yet looked at how to clone the properties from one
vertex onto another. A technique for doing that is discussed in the "<<dfwcopy>>"
section. Feel free to skip ahead but be aware that the techniques used in that
section have not yet been fully covered so you may want to also take a look at some
other sections along the way.

[[deleting]]
Deleting vertices, edges and properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

So far in this book we have looked at several examples where we created new
vertices, edges and properties but we have not yet looked at how we can delete them.
Gremlin provides the 'drop' step that we can use to remove things from a graph.


Deleting a vertex
^^^^^^^^^^^^^^^^^

In some of our earlier examples we created a fictitious airport vertex with a code of
'XYZ' and added it to the air routes graph. If we now wanted to delete it we could
use the following Gremlin code. Note that removing the vertex will also remove any
edges we created connected to that vertex.

[source,groovy]
----
// Remove the XYZ vertex
g.V().has('code','XYZ').drop()
----

[[deledge]]
Deleting an edge
^^^^^^^^^^^^^^^^

We can also use 'drop' to remove specific edges. The following code
will remove the flights, in both directions between AUS and LHR.

[source,groovy]
----
// Remove the flight from AUS to LHR (both directions).
g.V().has('code','AUS').outE().as('e').inV().has('code','LHR').select('e').drop()
g.V().has('code','LHR').outE().as('e').inV().has('code','AUS').select('e').drop()
----

[[delprop]]
Deleting a property
^^^^^^^^^^^^^^^^^^^

Lastly, we can use 'drop' to delete a specific property value from a specific vertex.
Let's start by querying the properties defined by the 'air-routes' graph for the San
Francisco airport.

[source,groovy]
----
g.V().has('code','SFO').valueMap()

[country:[US],code:[SFO],longest:[11870],city:[San Francisco],elev:[13],icao:[KSFO],lon:[-122.375],type:[airport],region:[US-CA],runways:[4],lat:[37.6189994812012],desc:[San Francisco International Airport]]
----

Let's now drop the 'desc' property and re-query the property values to prove that it
has been deleted.

[source,groovy]
----
g.V().has('code','SFO').properties('desc').drop()

g.V().has('code','SFO').valueMap()

[country:[US],code:[SFO],longest:[11870],city:[San Francisco],elev:[13],icao:[KSFO],lon:[-122.375],type:[airport],region:[US-CA],runways:[4],lat:[37.6189994812012]]
----

If we wanted to delete all of the properties currently associated with the SFO
airport vertex we could do that as follows.

[source,groovy]
----
g.V().has('code','SFO').properties().drop()
----

Another common pattern we might consider is to remove a property while simultaneously
adding a new one. Given what we've learned of Gremlin so far, we might be tempted to
try to follow 'drop' with another call to 'property' as follows.

[source,groovy]
----
g.V().has('code','SFO').properties('desc').drop().property('newProperty','test')

g.V().has('code','SFO').valueMap()

[country:[US],code:[SFO],longest:[11870],city:[San Francisco],lon:[-122.375],type:[airport],elev:[13],icao:[KSFO],region:[US-CA],runways:[4],lat:[37.6189994812012]]
----

We can see that we did indeed drop the 'desc' property, but the 'newProperty' key
we'd intended to insert is not present. This example presents an important aspect of
'drop'. The 'drop' step deletes the objects that flow into it and, as that deleted
object no longer exists, it also removes the object from the traversal stream. As
a result, steps following the 'drop' will not have an object to trigger their
execution. In our example above, 'property' never executes.

TIP: Since 'drop' does not allow steps placed after it to execute, it is often found
at the end of a traversal. It is worth noting however that its typical position in
a traversal does not make it a "<<var>>", i.e. it does not iterate the traversal. 
Since 'drop' returns no results, the usual terminating step to use in conjunction 
with it is 'iterate'.

Despite the 'drop' filter behavior, we'd still like to be able to remove a property
and then add a new one in the same traversal. In the "<<sideeffect>>" section, we
introduced how 'sideEffect' can be used to include additional processing without 
changing what gets passed on to the next stage of the query. We can wrap 'drop' in 
this step to handle the property removal as a side-effect of the traversal execution.

[source,groovy]
----
g.V().has('code','SFO').sideEffect(properties('desc').drop()).
                        property('newProperty','test')

g.V().has('code','SFO').valueMap()

[country:[US],code:[SFO],longest:[11870],newProperty:[test],city:[San Francisco],lon:[-122.375],type:[airport],elev:[13],icao:[KSFO],region:[US-CA],runways:[4],lat:[37.6189994812012]]
----

Removing all the edges or vertices in the graph
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This may not be something you want to do very often, but should you wish to remove
every edge in the graph you could do it, using the traversal object, 'g', as follows.
Note that for very large graphs this may not be the most efficient way of doing it
depending upon how the graph store handles this request.

[source,groovy]
----
// Remove all the edges from the graph
g.E().drop()
----

You could also delete the whole graph, vertices and edges, by deleting all of the
vertices!

[source,groovy]
----
// Delete the entire graph!
g.V().drop()
----

[[pkvrevisited]]
Property keys and values revisited
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We have already looked, earlier in the book, at numerous queries that retrieve,
create or manipulate in some way the value of a given property. There are still
however a few things that we have not covered in any detail concerning properties.
Most of the property values we have looked at so far have been simple types such as a
String or an Integer. In this section we shall look more closely at properties and
explain how they can in fact be used to store lists and sets of values. We will also
introduce in this section the concept of a property ID.

[[vertexprop]]
The 'Property' and 'VertexProperty' interfaces
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In a TinkerPop enabled graph, all properties are implementations of the 'Property'
interface. Vertex properties implement the 'VertexProperty' interface which itself
extends the 'Property' interface. These interfaces are documented as part of the
Apache TinkerPop JavaDoc. The interface defines the methods that you can use when
working with a vertex property object in your code. One important thing to note about
vertex properties is that they are immutable. You can create them but once created
they cannot be updated.

We will look more closely at the Java interfaces that TinkerPop defines in the
"<<javatinker>>" section a bit later in this book.

The VertexProperty interface does not define any "setter" methods
beyond the basic constructor itself. Your immediate reaction to this is likely to be
"but I know you can change a property's value using the 'property' step". Indeed we
have already discussed doing just that in this book. However, behind the scenes,
what actually happens when you change a property, is that a new property object is
created and used to replace the prior one. We will examine this more in a minute but
first let's revisit a few of the basic concepts of properties.

In a 'property graph' both vertices and edges can contain one or more properties. We
have already seen a query like the one below that retrieves the values from each of
the property keys associated with the DFW airport vertex.

[source,groovy]
----
g.V().has('airport','code','DFW').values()

US
DFW
13401
Dallas
607
KDFW
-97.0380020141602
airport
US-TX
7
32.896800994873
Dallas/Fort Worth International Airport
----

What we have not mentioned so far, however, is that the previous query is a shortened
form of this one.

[source,groovy]
----
g.V().has('airport','code','DFW').properties().value()

US
DFW
13401
Dallas
607
KDFW
-97.0380020141602
airport
US-TX
7
32.896800994873
Dallas/Fort Worth International Airport
----

If we wanted to retrieve the VertexProperty ('vp') objects for each of the properties
associated with the DFW vertex we could do that too. In a lot of cases it will be
sufficient just to use 'values' or 'valueMap' to access the values of one or more
properties but there are some cases, as we shall see when we look at property IDs,
where having access to the vertex property object itself is useful.

[source,groovy]
----
g.V().has('airport','code','DFW').properties()

vp[country->US]
vp[code->DFW]
vp[longest->13401]
vp[city->Dallas]
vp[elev->607]
vp[icao->KDFW]
vp[lon->-97.0380020141602]
vp[type->airport]
vp[region->US-TX]
vp[runways->7]
vp[lat->32.896800994873]
vp[desc->Dallas/Fort Worth In]
----

We have already seen how each property on a vertex or edge is represented as a key
and value pair. If we wanted to retrieve a list of all of the property keys
associated with a given vertex we could write a query like the one below that finds 
all of the property keys associated with the DFW vertex in the 'air-routes' graph.

[source,groovy]
----
g.V().has('airport','code','DFW').properties().key()

country
code
longest
city
elev
icao
lon
type
region
runways
lat
desc
----

We could likewise find the names, with duplicates removed, of any property keys
associated with any outgoing edges from the DFW vertex using this query. Note that
edge properties are implementations of 'Property' and not 'VertexProperty'.

[source,groovy]
----
g.V().has('code','DFW').outE().properties().key().dedup()

dist
----

We can use the fact that we now know how to specifically reference both the key and
value parts of any property to construct a query like the one below that adds up the
total length of all the longest runway values and number of runways in the graph and
groups them by property key first and sum of the values second.

[source,groovy]
----
g.V().hasLabel("airport").
      properties("runways","longest").
      group().by(key).by(value().sum())

[longest:25497644, runways:4816]
----

[[elementstep]]
The 'element' traversal step
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When you use the 'properties' step to navigate to a property object, you may find
that you want to return to the parent element that it is related to. The 'element'
step is used for this purpose and can be used to navigate from a property back to a
vertex, edge or vertex property. That final case of a "vertex property" refers to
situations where you have used 'properties' to access a meta-property as described
a bit later in the "<<metaprop>>" section.

[source,groovy]
----
g.V().has('airport','code','IAD').
  properties('code','city').element()

v[10]
v[10]
----

In the example shown above, we can see that "v[10]" is returned twice because
'element' was called twice, once for the "code" property and once for the "city"
property and both belong to the "v[10]" vertex.

[[propmap]]
The 'propertyMap' traversal step
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We have previously used the 'valueMap' step to produce a map of key/value pairs for
all of the properties associated with a vertex or edge. There is also a 'propertyMap'
step that can be used that yields a similar result but the map includes the vertex
property objects for each property.

[source,groovy]
----
g.V().has('code','AUS').propertyMap()
----

Here are the properties returned.

[source,groovy]
----
[country:[vp[country->US]], code:[vp[code->AUS]], longest:[vp[longest->12250]], city:[vp[city->Austin]], lon:[vp[lon->-97.6698989868164]], type:[vp[type->airport]], places:[vp[places->[YYZ, LHR, FRA, MEX,]], elev:[vp[elev->542]], icao:[vp[icao->KAUS]], region:[vp[region->US-TX]], runways:[vp[runways->2]], lat:[vp[lat->30.1944999694824]], desc:[vp[desc->Austin Bergstrom Int]]]
----

[[propid]]
Properties have IDs too
^^^^^^^^^^^^^^^^^^^^^^^

We have seen many examples already that show how both vertices and edges have a 
unique ID. What may not have been obvious however is that properties also have an ID. 
Unlike vertex and edge IDs property IDs are not guaranteed to be unique across the 
graph. Certainly with TinkerGraph we have encountered cases where a vertex and a 
property share the same ID. This is not really an issue because they are used in 
different ways to access their associated graph element.

The query below returns the vertex property object (vp) for any property in the graph
that has a value of 'London'.

[source,groovy]
----
g.V().properties().hasValue('London')
----

The query finds several London values.

[source,groovy]
----
vp[city->London]
vp[city->London]
vp[city->London]
vp[city->London]
vp[city->London]
vp[city->London]
----

At first glance, each of the values returned above looks identical. However, let's
now query their ID values.

[source,groovy]
----
g.V().properties().hasValue('London').id()
----

As you can see each property has a different, and unique, ID.

[source,groovy]
----
583
595
1051
1123
2467
7783
----

We can use these ID values in other queries in the same way as we have for vertices
and edges in some of our earlier examples.


[source,groovy]
----
g.V().properties().hasId(583)

vp[city->London]
----

We can query the value of this property as you would expect.

[source,groovy]
----
g.V().properties().hasId(583).value()

London
----

We can retrieve the name of the property key as follows.

[source,groovy]
----
g.V().properties().hasId(583).key()

city
----

We could also have used 'label' instead of 'key'

[source,groovy]
----
g.V().properties().hasId(583).label()

city
----

We can also find out which element (vertex or edge) that this property belongs to.

[source,groovy]
----
g.V().properties().hasId(583).next().element()

v[49]
----

We can also look at other property values of the element containing our property with
an ID of 583.

[source,groovy]
----
g.V().properties().hasId(583).next().element().values('desc')

London Heathrow
----

Should you need to you can also find out which graph this property is part of. In
this case it is part of a TinkerGraph.

[source,groovy]
----
g.V().has('airport','code','DFW').properties('city').next().graph()

tinkergraph[vertices:3619 edges:50148]
----

To further show that each property has an ID the following code retrieves a list of
all the vertex properties associated with vertex 'V(3)' and prints out the property
key along with its corresponding ID.

[source,groovy]
----
p = g.V(3).properties().toList()
p.each {println it.key + "\t:" + it.id}

country :28
code    :29
longest :30
city    :31
elev    :32
icao    :33
lon     :34
type    :35
region  :36
runways :37
lat     :38
desc    :39
----

NOTE: If you update a property, its ID value will also be changed as you have in
reality replaced the property with a new one which is allocated a new ID.

Take a look at the example below. First of all we query the ID of the 'city' property
from vertex 'V(4)'. Next we change its value to be 'newname' and then query the
property ID again. Note that the ID has changed. As mentioned above, vertex
properties are immutable. When you update a property value using the 'property' step,
a new property object is created that replaces the prior one.

[source,groovy]
----
g.V(4).properties('city').id()

43

g.V(4).property('city','newname')

g.V(4).properties('city').id()

53361
----

The fact that every property in a graph has an ID can improve performance of
accessing properties, especially in large graphs.

[[listprop]]
Attaching multiple values (lists or sets) to a single property
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A vertex property value can be a basic type such as a String or an Integer but it can
also be something more sophisticated such as a Set or a List containing multiple
values. You can think of these values as being an array but depending on how you
create them you have to work with them differently. In this section we will look at
how we can create multiple values for a single property key. Such values can be
setup when the vertex is first created or added afterwards. These more complex type 
of property values are not supported on edges.

If we wanted to store the IATA and ICAO codes for the Austin airport in a list
associated with a single property rather than as separate properties we could have
created them when we created the Austin vertex follows. You can also add properties 
to an existing vertex that have lists of values. We will look at how to do that later 
in this section.

[source,groovy]
----
g.addV().property('code','AUS').property('code','KAUS')
----

NOTE: The version of 'addV' that allowed you to specify something like
'g.addV('code','AUS','code','KAUS')' is now deprecated and should not be used.

By creating the 'code' property in this way, its cardinality type is now effectively
'LIST' rather than 'SINGLE'. While working with TinkerGraph we do not need to setup
explicit schemas for our property types. However, once we start working with a more
sophisticated graph system such as JanusGraph, that is something that we will both
want and need to be able to do. We cover the topic of cardinality in detail in the
"<<janusmgmt>>" section later in the book.

Now that we have created the 'code' property to have a list of values we can query
either one of the values in the list. If we look at the value map we get back from
the following example queries you can see both values in the list we associated with
the property 'code'.

[source,groovy]
----
g.V().has('code','AUS').valueMap()

[code:[AUS,KAUS]]

g.V().has('code','KAUS').valueMap()

[code:[AUS,KAUS]]
----

we can also query the values as normal.

[source,groovy]
----
g.V().has('code','AUS').values()

AUS
KAUS
----

We can also use the 'properties' step to get the result back as vertex properties
(vp). We discuss vertex properties in detail in the "<<vertexprop>>" section.

[source,groovy]
----
g.V().has('code','AUS').properties()

vp[code->AUS]
vp[code->KAUS]
----

For completeness we could also do this.

[source,groovy]
----
g.V().properties().hasValue('AUS')

vp[code->AUS]
----

[[propertycaution]]
A word of caution - behavior differences with 'property'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.Be aware!

There is a subtlety to be aware of when using 'property'. What happens can vary
depending on the context in which it is used. Only when done as part of an 'addV'
step immediately followed by multiple 'property' steps using the same key value will
a list be created. Look at the two examples below. They do not produce the same
results.


[source,groovy]
----
g.addV().property('one','hi').
         property('one','hello').
         property('two','goodbye').
         property('one','hello again').
         valueMap()

[one:[hi,hello,hello again],two:[goodbye]]
----

So our first query create a property with a key called 'one' followed by a list
containing '[hi,hello,hello again]'. Let's do the same test again but this time
create the vertex first and use an already created vertex to add properties to.

[source,groovy]
----
v = g.addV().next()

g.V(v).property('one','hi').
       property('one','hello').
       property('two','goodbye').
       property('one','hello again').
       valueMap()

[one:[hello again],two:[goodbye]]
----

This time, as we were not creating the vertex as part of the same set of steps, the
behavior changes. Each time the property key of 'one' is used the existing value is
replaced rather than being added as part of a list. We have seen this behavior cause
confusion more than once and it is something to be aware of! In the next section we
will ask Gremlin to explain this behavior to us!

[[explainstep]]
What did Gremlin do? - introducing 'explain'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you ever want to know how Gremlin compiles your query into a form that it is able
to execute you can ask it to tell you by adding an 'explain' step to the end of your
query. The query will not execute, instead you will be shown how Gremlin decided to
optimize your query. It actually shows you all the choices it considered but in the
examples below we am just going to show the one it picked in each case.

So, thinking about our previous discussion of how 'property' works differently
depending upon the context, if you were to use the 'explain' step to have Gremlin
show us the way it is going to execute our query you can see clearly the difference
between the two forms. We have truncated the output to keep things simple.

Here is what Gremlin shows us for the first query when we use an 'explain' step.
As you can see our query has been compiled into an 'AddVertexStep' with two
properties one of which is a list.

[source,groovy]
----
g.addV().property('one','hi').
         property('one','hello').
         property('two','goodbye').
         property('one','hello again').
         explain()

Final Traversal    [AddVertexStartStep({one=[hi, hello, hello
                      again], two=[goodbye]})]
----

Now if we look at the case where we have already created a vertex let's see what
'explain' returns. What we find is that this time Gremlin has compiled our query to a
'TinkerGraphStep' and is handling each property one by one. This has the result that
each time the same key is reused, the previous value is replaced.

[source,groovy]
----
g.V(v).property('one','hi').
       property('one','hello').
       property('two','goodbye').
       property('one','hello again').
       explain()

Final Traversal  [TinkerGraphStep(vertex,[v[54800]]),
                    AddPropertyStep({value=[hi], key=[one]}),
                    AddPropertyStep({value=[hello], key=[one]}),
                    AddPropertyStep({value=[goodbye], key=[two]}
                    ), AddPropertyStep({value=[hello again], key=[one]})]

----

If you need to work with properties and treat them as lists once the vertex has been
created, you need to explicitly add the 'list' keyword as part of the 'property' step
as we shall see in the next section.

[[updatelist]]
Updating properties stored in a list
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

So now we know how to create a vertex with property values in a list we need a way to
update those properties. We can do this using a special form of the 'property' step
where the first parameter is 'list' to show that what follows are updates to the
existing list and not replacements for the whole list.

The example below adds another code that is sometimes used when talking about the
Austin airport to our list of codes. If we left off the 'list' parameter the whole
property would be overwritten with a value of 'ABIA'.

[source,groovy]
----
g.V().has('code','AUS').property(list,'code','ABIA')
----

If we query the properties again we can see that there are now three values for the
'code' property.

[source,groovy]
----
g.V().has('code','AUS').properties()
vp[code->AUS]
vp[code->KAUS]
vp[code->ABIA]
----

We can observe the same thing by looking at our 'valueMap' results again.

[source,groovy]
----
g.V().has('code','AUS').valueMap()
[code:[AUS,KAUS,ABIA]]
----

If we want to delete one of the properties from the list we can do it using 'drop'.
If we look the value map after dropping 'ABIA' we can indeed see that it is gone from
the list.

[source,groovy]
----
g.V().has('code','AUS').properties().hasValue('ABIA').drop()

g.V().has('code','AUS').valueMap()
[code:[AUS,KAUS]]
----

If we want to drop an entire property containing one or more values we can do it as
follows.

[source,groovy]
----
g.V().has('code','AUS').properties('code').drop()
----

To add multiple values to the same property key in the same query we just need to
chain the 'property' steps together as shown below.

[source,groovy]
----
g.V().has('code','AUS').
      property(list,'desc','Austin Airport').
      property(list,'desc','Bergstrom')
----

This technique can be used to update an existing property that already has a list
of values or to add a new property with a list of values.

The same value can appear more than once with a property that has LIST cardinality.
The code fragment below creates a new vertex, with some duplicate values associated
with the 'dups' property.

[source,groovy]
----
g.addV('test').property('dups','one').property('dups','two').property('dups','one')

g.V().hasLabel('test').valueMap()

[dups:[one,two,one]]
----

We can add additional duplicate values after the vertex has been created.

[source,groovy]
----
g.V().hasLabel('test').property(list,'dups','two')

g.V().hasLabel('test').valueMap()

[dups:[one,two,one,two]]
----

[[propsets]]
Creating properties that store sets
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

So far we have just created values in a list that have 'LIST' cardinality which means
that duplicate values are allowed. If we wanted to prevent that from happening we can
use the 'set' keyword when adding properties to force a cardinality of 'SET'.

In the example below we create a new property called 'hw' for vertex 'V(3)' with
multiple values but using the 'set' keyword rather than the 'list' keyword that we
have used previously. We then look at the valueMap for the 'hw' property to check
that indeed our set was created.

[source,groovy]
----
g.V(3).property(set,'hw','hello').property(set,'hw','world')

g.V(3).valueMap('hw')

[hw:[hello,world]]
----

Let's now test that our set is really working as a set by adding a couple of
additional values. Note that we have already added the value 'hello' in the prior
steps so with the cardinality being 'SET' we expect that value to be ignored as there
is already a value of 'hello' in the set. We again display the valueMap to prove that
the set only has unique values in it.

[source,groovy]
----
g.V(3).property(set,'hw','hello').property(set,'hw','apple')

g.V(3).valueMap('hw')

[hw:[hello,world,apple]]
----

[[setlistnote]]
One more note about sets and lists
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Note that the other examples we have shown in this section are not the same as just
adding a list directly as a property value. In the example below the entire list is
treated as a single value.

[source,groovy]
----
g.V().has('code','AUS').property('x',['AAAA','BBBB'])

g.V().has('code','AUS').valueMap('x')

[x:[[AAAA,BBBB]]]
----

[[metaprop]]
Adding properties to other properties (meta properties)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TinkerPop has the ability to add a property to another property. Think of this in
a way as being able to add a bit of metadata about a property to the property
itself. This capability, not surprisingly, is often referred to as '"adding a meta
property to a property"'. There are a number of use cases where this capability can
be extremely useful. Common ones might be adding a date that a property was last
updated or perhaps adding access control information to a property.

The example below adds a meta property with a key of 'date' and a value of '6/6/2017'
to the property with a key of 'code' and a value of 'AUS'.

[source,groovy]
----
g.V().has('code','AUS').properties().hasValue('AUS').property('date','6/6/2017')
----

If you wanted to add the date to the 'code' property regardless of its current value,
then you could just do this.

[source,groovy]
----
g.V().has('code','AUS').properties('code').property('date','6/6/2017')
----


We can retrieve all of the meta properties on a specific property, such as the 'code'
property as follows.

[source,groovy]
----
g.V().has('code','AUS').properties('code').properties()

p[date->6/6/2017]
----

If you want to find all the properties associated with the AUS vertex that have a
meta property with a date of '6/6/2017' you can do that as follows.

[source,groovy]
----
g.V().has('code','AUS').properties().has('date','6/6/2017')

vp[code->AUS]
----

We can query for a specific meta property as follows, which will return any meta
properties that have a key of 'date'.

[source,groovy]
----
g.V().has('code','AUS').properties().hasValue('AUS').properties('date')

p[date->6/6/2017]
----

You can add multiple meta properties to a property while creating it. The following
will add a property called 'comment' to vertex 'V(3)' and also add two meta
properties to it representing the date the comment was made and who made it.

[source,groovy]
----
g.V(3).property('comment','I like this airport','date','6/6/2017','user','Kelvin')
----

We can query the graph to make sure everything worked as expected.

[source,groovy]
----
g.V(3).properties('comment')

vp[Comment->I like this airport]

g.V(3).properties('comment').properties()

p[date->6/6/2017]
p[user->Kelvin]
----

You can use 'drop' to remove meta properties but take care when doing so.
Take a look at the query below, which looks like it might
drop the meta property 'date', but will in fact drop the whole vertex.

[source,groovy]
----
g.V().has('code','AUS').
  properties().hasValue('AUS').property('date','6/6/2017').drop()
----

To remove a single meta property we need to use drop in this way

[source,groovy]
----
 g.V().has('code','AUS').properties('code').properties('date').drop()
----

Note that you cannot chain meta properties together endlessly. The main properties on
a vertex are 'VertexProperty' types. The meta property is a 'Property' type and you
cannot add another property to those. You can however add more than one meta
property to the same vertex property.

So as mentioned above, the meta property provides a way to attach metadata to another
property. This enables a number of important use cases including being able to attach
a date or ACL information to individual properties.

[[tp34vmmetaprop]]
Using 'unfold' and 'WithOptions' with Meta Properties
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There is an easy way to include both properties and their meta properties in the
result from a 'valueMap' step that follows a 'properties' step. Using this capability
requires that the graph database you are using has support for meta properties. The
examples below build upon the examples shown in the previous section.

TIP: All of the possible values that can be specified using WithOptions can be found
in the official Apache TinkerPop JavaDoc documentation
http://tinkerpop.apache.org/javadocs/current/full/org/apache/tinkerpop/gremlin/process/traversal/step/util/WithOptions.html[at
this location].

First of all, we know how to inspect the properties present for any vertex using the
'properties' step.

[source,groovy]
----
g.V().has('code','AUS').properties()

vp[country->US]
vp[code->AUS]
vp[longest->12250]
vp[city->Austin]
vp[elev->542]
vp[icao->KAUS]
vp[lon->-97.6698989868164]
vp[type->airport]
vp[region->US-TX]
vp[runways->2]
vp[lat->30.1944999694824]
vp[desc->Austin Bergstrom ...]
----

We also know how to look at the meta properties by following the 'properties' step
with a 'valueMap' step or a second 'properties' step. However, a value is returned
only when a property has a meta property. For all other properties the result is
simply an empty list.

[source,groovy]
----
g.V().has('code','AUS').properties().valueMap()

[]
[date:6/6/2017]
[]
[]
[]
[]
[]
[]
[]
[]
[]
[]
----

Using the new 'with' step and specifying options using 'WithOptions' we can generate
a result from 'valueMap' that includes the property values and their respective meta
properties. The example below generates a map containing the values for all
properties plus the key and value for any meta properties present.

[source,groovy]
----
g.V().has('code','AUS').
      properties().
      valueMap().with(WithOptions.tokens,WithOptions.values)
----

The values are shown for all properties but for the case where we have a 'date'
meta property, that is also shown.

[source,groovy]
----
[value:US]
[value:AUS,date:6/6/2017]
[value:12250]
[value:Austin]
[value:542]
[value:KAUS]
[value:-97.6698989868164]
[value:airport]
[value:US-TX]
[value:2]
[value:30.1944999694824]
[value:Austin Bergstrom International Airport]
----

Similarly we could just decide to include the key names in the results.

[source,groovy]
----
g.V().has('code','AUS').
      properties().
      valueMap().with(WithOptions.tokens,WithOptions.keys)
----

Once again the key and value are shown for the 'date' meta property.

[source,groovy]
----
[key:country]
[key:code,date:6/6/2017]
[key:longest]
[key:city]
[key:elev]
[key:icao]
[key:lon]
[key:type]
[key:region]
[key:runways]
[key:lat]
[key:desc]
----

To include both the keys and the values in the result along with the meta properties,
'WithOptions.all' can be used.

[source,groovy]
----
g.V().has('code','AUS').
      properties().
      valueMap().with(WithOptions.tokens,WithOptions.all)
----

Note that in this case, the ID for each property is also shown.

[source,groovy]
----
[id:28,key:country,value:US]
[id:29,key:code,value:AUS,date:6/6/2017]
[id:30,key:longest,value:12250]
[id:31,key:city,value:Austin]
[id:32,key:elev,value:542]
[id:33,key:icao,value:KAUS]
[id:34,key:lon,value:-97.6698989868164]
[id:35,key:type,value:airport]
[id:36,key:region,value:US-TX]
[id:37,key:runways,value:2]
[id:38,key:lat,value:30.1944999694824]
[id:39,key:desc,value:Austin Bergstrom International Airport]
----

[[deduce]]
Deducing the schema of a graph using queries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes, you may find yourself working with a graph while being unsure of its data
model or schema. Using some simple Gremlin queries we can quite easily figure out the
major elements that a graph contains. This technique should only be used if the
graph database you are using does not provide an explicit API for working with the
schema of a graph. First of all, we can figure out the vertex labels that are in use
as shown below. The 'dedup' step insures that we get a list of unique label names
back.

[source,groovy]
----
g.V().label().dedup()

version
airport
country
continent
----

Similarly, we can find out the names of the edge labels in the graph.

[source,groovy]
----
g.E().label().dedup()

route
contains
----

Now that we know the label names it is very easy to get the names of the property
keys for a vertex with a given label. The query below will display the names of the
property keys found in an 'airport' vertex.

[source,groovy]
----
g.V().hasLabel('airport').limit(1).next().keys()

country
code
longest
city
elev
icao
lon
type
region
runways
lat
desc
----

You could easily put the previous query inside a simple loop if you wanted to iterate
through each of the vertex labels that were discovered. As with vertices we can also
query edges to discover their key names. The query below finds the property key names
for 'route' edges.

[source,groovy]
----
g.E().hasLabel('route').limit(1).next().keys()

dist
----

Lastly now that we know the label names and we know how to find out the property key
names, we can also figure out the types associated with each key. The code below
creates an array called 'pkeys' containing all of the property key names for an
'airport' vertex. Having done that, the code iterates through the list in a simple
loop to find the type for each key. The code as shown is intended to be run inside
the Gremlin Console.

[source,groovy]
----
pkeys=g.V().hasLabel('airport').limit(1).next().keys()

pkeys.each {
  printf("%10s : %s\n" , it,
          g.V().hasLabel('airport').limit(1).
            values(it).next().class)};[]
----

When run, we get back a nicely formatted table showing the key names and their types.

[source,groovy]
----
   country : class java.lang.String
      code : class java.lang.String
   longest : class java.lang.Integer
      city : class java.lang.String
      elev : class java.lang.Integer
      icao : class java.lang.String
       lon : class java.lang.Double
      type : class java.lang.String
    region : class java.lang.String
   runways : class java.lang.Integer
       lat : class java.lang.Double
      desc : class java.lang.String
----

Later, in the "<<janusmgmt>>" section, we will look at how JanusGraph allows us to
define an explicit schema and also to query the schema using its Graph Management
API.

[[collrev]]
Collections revisited
~~~~~~~~~~~~~~~~~~~~~

As we have seen in many of the prior examples, very often, either in the middle or at
the end of a traversal, or both, we generate some kind of collection. In this section
we are going to take a more focused look at these collections and how to work with
them. In the following section we will look at collections and how they can be used
effectively in conjunction with so called 'reducing barrier' traversal steps.

[[collsteps]]
Steps that generate collections
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's start this discussion by first reviewing a few ways that a collection can be
generated. A simple example of a collection is the map that is generated by the
'group' step as shown in the example below.

[source,groovy]
----
g.V(1..5).group().by('code').by('runways')

[BNA:[4],ANC:[3],BOS:[6],ATL:[5],AUS:[2]]
----

Similarly a map is created when the 'groupCount' step is used.

[source,groovy]
----
g.V().hasLabel('airport').limit(40).groupCount().by('region')

[US-FL:5,PR-U-A:1,US-NV:1,US-MN:1,US-HI:1,US-IL:1,US-TX:6,US-AK:1,US-WA:1,US-VA:1,US-NY:4,US-CO:1,US-NC:1,US-LA:1,US-MD:1,US-IA:1,US-MA:1,US-CA:6,US-DC:1,US-UT:1,US-AZ:1,US-GA:1,US-TN:1]
----

Likewise, when we use the fold step a list is generated. We can use the 'order' step
with a 'local' scope to order the contents of the list.

[source,groovy]
----
g.V().hasLabel('airport').limit(20).values('runways').
      fold().order(local)

[2,2,2,3,3,3,3,3,4,4,4,4,4,4,4,5,5,6,7,8]
----

Here is an example of a 'union' step followed by a 'fold' step that generates a list
of two values. The 'union' step contains an 'identity' step to indicate that we want
the value of the incoming vertex as the first item of the union. We union that vertex
with a count of all routes from that vertex (DFW) and finally use a 'fold' step to
generate a list.

[source,groovy]
----
g.V().has('airport','code','DFW').union(identity(),out().count()).fold()

[v[8],221]
----

Note that the above syntax, is a shorthand form of the following.

[source,groovy]
----
g.V().has('airport','code','DFW').as('a').union(select('a'),out().count()).fold()

[v[8],221]
----

If we wanted to generate a map with keys and values rather than a list, we could use
a 'group' step. In this case the vertex is the keys and the number of outgoing
routes is the value.

[source,groovy]
----
g.V().has('airport','code','DFW').group().by().by(out().count())

[v[8]:221]
----

Another way that a map can be created is when the 'project' step is used.

[source,groovy]
----
g.V().has('airport','country','IE').project('loc','iata').by('city').by('code')

[loc:Dublin,iata:DUB]
[loc:Shannon,iata:SNN]
[loc:Cork,iata:ORK]
[loc:Charleston,iata:NOC]
[loc:Killarney,iata:KIR]
[loc:Waterford,iata:WAT]
[loc:Donegal,iata:CFN]
----

Also using a 'project' step, but a little more complex, this example creates a map with
two keys. The first, called 'dfw', will contain the vertex for the DFW airport and
the second, called 'route_count', will contain the number of outgoing routes from
DFW. Notice how the first 'by' step has no parameters so it returns the actual vertex
(rather than say a property from the vertex that we could select).

[source,groovy]
----
 g.V().has('code','DFW').project('dfw','route_count').
       by().by(outE().count())

[dfw:v[8],route_count:221]
----

As well as generating maps, we can also generate a set using a 'store' step so that
duplicate values are not stored. The 'withSideEffect' step can be used to initialize
the set. The 'cap' step emits the collection resulting from the side effect that we
created using the 'store' step. Among other things this allows us to return this
collection as the final result of a query.

[source,groovy]
----
g.withSideEffect('s', [] as Set).
  V().hasLabel('airport').limit(20).values('runways').
      store('s').cap('s').order(local)

[2,3,4,5,6,7,8]
----

The 'store' step can also be used in conjunction with a 'by' modulator to specify
exactly what is 'stored'. The query below uses a 'store' step to create a collection
of runways but avoids the need to use a 'values' step.

[source,groovy]
----
g.V().has('region','US-TX').store('r').by('runways').cap('r')

[2,2,2,2,2,2,2,2,7,5,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,1]
----

The 'aggregate' step also generates a collection as shown below. The collection is
actually a 'BulkSet' as we shall confirm shortly. The 'store' step also generates a
BulkSet.

[source,groovy]
----
g.V().has('airport','country','IE').aggregate('ireland').cap('ireland')

[v[60],v[91],v[311],v[477],v[635],v[785],v[1269]]
----

The query below uses an 'aggregate' step to find all the countries that you can fly
to from airports in Ireland but excludes routes that are between airports within
Ireland.

[source,groovy]
----
g.V().has('airport','country','IE').aggregate('ireland').
      out().where(without('ireland')).
      values('country').
      dedup().fold().order(local)
----

As you can see by looking at the results, the country code for Ireland, 'IE', is not
present in the list.

[source,groovy]
----
[AE,AT,BE,BG,CA,CH,CY,CZ,DE,DK,ES,ET,FI,FR,GR,HR,HU,IM,IS,IT,JE,LT,LU,LV,MA,MD,MT,NL,NO,PL,PT,QA,RO,SE,SK,TR,UK,US]
----

While 'aggregate' and 'store' on the surface appear identical, they actually behave
differently. The 'aggregate' step will block and immediately gather up everything 
from the prior traversal, whereas the 'store' step will only add things to its 
collection as they are seen. This is sometimes referred to as 'lazy aggregation'. 
Note also that even though we specified a 'limit' of 2, the 'store' step collected 
three elements as the third has already been seen before the limit step is applied.

[source,groovy]
----
g.V().has('airport','country','IE').store('a').limit(2).cap('a')

[v[60],v[91],v[311]]

g.V().has('airport','country','IE').aggregate('a').limit(2).cap('a')

[v[60],v[91],v[311],v[477],v[635],v[785],v[1269]]
----

Both 'aggregate' and 'store' can be followed by a 'by' modulator to specify more
precisely what should be collected. For example, if we wanted to store the number of
runways that each airport in Ireland has we could do so as follows.

[source,groovy]
----
g.V().has('airport','country','IE').
      aggregate('ireland').by('runways').cap('ireland')

[2,2,2,5,1,1,1]
----

If we are ever unsure what type of object has been created a call to 'getClass' can
be used to find out.

[source,groovy]
----
g.V(1..5).group().by('code').by('runways').next().getClass()

class java.util.HashMap

g.V(1..5).aggregate('a').cap('a').next().getClass()

class org.apache.tinkerpop.gremlin.process.traversal.step.util.BulkSet
----

Now that we have examined the various ways in which collections may get generated
during a traversal, it is important to understand how the contents of a collection
can be accessed and manipulated.

[[collaccess]]
Accessing the contents of a collection
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The keywords 'keys' and 'values' can be used to access the respective
parts of a collection that is a map. Take a look at the query below which returns a
map where airport codes are the keys and their city names are the values.

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city')

[BNA:[Nashville],ANC:[Anchorage],BOS:[Boston],ATL:[Atlanta],AUS:[Austin]]
----

We can use a 'count' step with 'local' scope to find out how big the collection is.

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city').count(local)

5
----

The queries below extract the keys and values from the map that the 'group' step
creates.

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city').select(keys)

[BNA,ANC,BOS,ATL,AUS]

g.V().hasLabel('airport').limit(5).group().by('code').by('city').select(values)

[[Nashville],[Anchorage],[Boston],[Atlanta],[Austin]]
----

We can also extract the keys and values from the results of the 'project' step we
used earlier. Note that the values comeback as a list containing a the DFW vertex and
the number of routes from DFW.

[source,groovy]
----
g.V().has('code','DFW').project('dfw','route_count').
      by().by(outE().count()).select(values)

[v[8],221]
----

Likewise the keys come back in a list.

[source,groovy]
----
g.V().has('code','DFW').project('dfw','route_count').
      by().by(outE().count()).select(keys)

[dfw,route_count]
----

We could also be even more specific and select which values we are interested in.

[source,groovy]
----
g.V().has('code','DFW').project('dfw','route_count').
       by().by(outE().count()).select('route_count')

221
----

We can also access the DFW vertex directly from the map.

[source,groovy]
----
g.V().has('code','DFW').project('dfw','route_count').
      by().by(outE().count()).select('dfw')

v[8]
----

Having extracted the vertex we can retrieve values from it. A bit later we will look
at ways we could continue our traversal from this point if we needed to, perhaps
looking at outgoing routes from DFW or adding a new route. You will find that
discussion in the "<<rbarriers>>" section.

[source,groovy]
----
g.V().has('code','DFW').project('dfw','route_count').
      by().by(outE().count()).select('dfw').values('desc')

Dallas/Fort Worth International Airport
----

As we shall see in the next two sections, sometimes it is necessary to use the
'unfold' step to access the contents of a collection and it is also sometimes
necessary to use 'local' scope.


[[unbundle]]
Using 'unfold' to unbundle a collection
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sometimes it is desirable to unbundle a collection so that we can work on it further.
This is what the 'unfold' step does. If we apply 'unfold' to the previous query you
can see what is generated. The collection that the 'group' step generates is a Map. 
The 'unfold' step turns the HashMap into a series of "entries" which are essentially 
just key/value pairs.

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city').unfold()

BNA=[Nashville]
ANC=[Anchorage]
BOS=[Boston]
ATL=[Atlanta]
AUS=[Austin]
----

If we wanted a list of values we could use 'unfold' again as shown below. You will
recall from our earlier discussion that vertex properties are stored as lists even
if there is only one property - a list of length one in other words. Note that this
shows that a single 'unfold' step will not recursively unbundle elements from a
collection.

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city').
      select(values).unfold()

[Nashville]
[Anchorage]
[Boston]
[Atlanta]
[Austin]
----

We could add a second 'unfold' to just get the city names back and remove the
containing lists.

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city').
      select(values).unfold().unfold()

Nashville
Anchorage
Boston
Atlanta
Austin
----

As an alternative, 'repeat' can be used when you want to unfold more than once as
shown below.

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city').
      select(values).repeat(unfold()).times(2)

Nashville
Anchorage
Boston
Atlanta
Austin
----

If we were not sure how many times we needed to 'unfold' we could change the query as
follows. The 'repeat' loop will unfold until there is only a list of lists left. The
final unfold will remove the remaining lists leaving us with just the text values.

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city').
      select(values).repeat(unfold()).until(count(local).is(1)).unfold()

Nashville
Anchorage
Boston
Atlanta
Austin
----

Having used 'unfold' to extract just the city names as strings, we could re-fold one
time to produce a list of airport names using the 'fold' step. This pattern of
unfolding, performing an operation and refolding is one that comes in handy quite
often, especially in more complex queries.

[source,groovy]
----
g.V().hasLabel('airport').limit(5).group().by('code').by('city').
      select(values).unfold().unfold().fold()

[Nashville,Anchorage,Boston,Atlanta,Austin]
----

It is probably worth pointing out that the 'keys' and 'values' keywords can also be
used with something as simple as a 'valueMap' step. Here is a simple example.

[source,groovy]
----
g.V(3).valueMap().select(keys)

[country,code,longest,city,elev,icao,lon,type,region,runways,lat,desc]

g.V(3).valueMap().select(values)

[[US],[AUS],[12250],[Austin],[542],[KAUS],[-97.6698989868164],[airport],[US-TX],[2],[30.1944999694824],[Austin Bergstrom International Airport]]
----

[[mergecollections]]
Ways to merge collections
^^^^^^^^^^^^^^^^^^^^^^^^^

We've seen how 'fold' can be used to to collect objects in a stream into a List. If
the objects themselves are Lists and you wish to merge them together to a new List
you can also do that with 'fold' after you've first flattened those individual
List objects with 'unfold'.

[source,groovy]
----
g.V().limit(5).map(out().values('code').fold())

[SKZ,KHI]
[ISB]
[KHI,MCT,TUK]
[DXB,KHI,DOH]
[PEW,PZH]

g.V().limit(5).map(out().values('code').fold()).unfold().fold()
 
[SKZ,KHI,ISB,KHI,MCT,TUK,DXB,KHI,DOH,PEW,PZH]
----

Merging maps together is slightly more complex than just a simple 'fold' because 
duplicate keys among the Maps must be resolved in some way. If you are not concerned
about duplicates or simply want the last pair duplicate to be in the resulting Map 
you could just use a specific form of 'fold' that include the 'addAll' operator:

[source,groovy]
----
g.V().limit(3).valueMap("code","desc")

[code:[MJD],desc:[Moenjodaro Airport]]
[code:[GIL],desc:[Gilgit Airport]]
[code:[GWD],desc:[Gwadar International Airport]]

g.V().limit(3).valueMap("code","desc").fold([:], addAll)

[code:[GWD],desc:[Gwadar International Airport]]
----

You also have the option to use the 'merge' step with collections:

[source,groovy]
----
g.V().has("code","IAD").valueMap().select(keys).merge(["name"])

[country,code,longest,city,lon,type,elev,name,icao,region,runways,lat,desc]

g.V().has("code","IAD").valueMap("code","desc").
  merge(V().has("code","DUB").valueMap("runways"))
  
[runways:[2],code:[IAD],desc:[Washington Dulles International Airport]]  
----

A more complex case for merging Maps occurs when you want to aggregate together 
values of the same the keys into a list, rather than having them overwrite one 
another. You can do this with Gremlin with a commonly used pattern of Gremlin steps,
the basics of which have been explained earlier in this section.

[source,groovy]
----
g.V().has("code",within("IAD","DUB")).valueMap("code","desc","runways").
  unfold().
  group().by(keys).by(select(values).unfold().fold())

[code:[IAD,DUB],runways:[4,2],desc:[Washington Dulles International Airport,Dublin International Airport]]
----

The previous example uses 'unfold' incoming Maps to entries and then groups on the 
keys of those entries thereby building a list of each of the values in the final Map.

[[localcollect]]
Using 'local' scope with collections
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sometimes if you want to work on the contents of a collection, whether to sort it or
perhaps select some subset of it it is often necessary to use 'local' scope. There
are other ways the following examples could be written but we wanted to show some
ways that 'local' scope can be combined with the 'order', 'range', 'limit' and 'tail'
steps while working with collections.

First of all let's, once again produce a collection using airports in Ireland. This
time we produce a map where the keys are the airport codes and the values are the
number of runways at that airport.

[source,groovy]
----
g.V().has('airport','country','IE').
      group().by('code').by('runways')

[DUB:[2],SNN:[5],NOC:[1],KIR:[2],ORK:[2],CFN:[1],WAT:[1]]
----

We already know how to select the keys from the map using our prior examples but for
completeness let's take a another look.

[source,groovy]
----
g.V().has('airport','country','IE').
      group().by('code').by('runways').select(keys)

[DUB,SNN,NOC,KIR,ORK,CFN,WAT]
----

If we wanted to sort the keys by ascending order we could use an 'order' step with
'local' scope.

[source,groovy]
----
g.V().has('airport','country','IE').
      group().by('code').by('runways').select(keys).order(local)

[CFN,DUB,KIR,NOC,ORK,SNN,WAT]
----

It is worth noting that this is a case where we could have used the 'unfold' and
'fold' pattern instead as shown below.

[source,groovy]
----
g.V().has('airport','country','IE').
      group().by('code').by('runways').select(keys).
      unfold().order().fold()

[CFN,DUB,KIR,NOC,ORK,SNN,WAT]
----

The next example also uses 'local' scope along with a 'limit' step to retrieve the
first two airport keys.

[source,groovy]
----
g.V().has('airport','country','IE').
      group().by('code').by('runways').select(keys).limit(local,2)

[DUB,SNN]
----

We can use the same 'local' scope with the 'tail' step to select the last three keys.

[source,groovy]
----
g.V().has('airport','country','IE').
      group().by('code').by('runways').select(keys).tail(local,3)

[ORK,CFN,WAT]
----

As you would expect we can also specify 'local' scope on a 'range' step.

[source,groovy]
----
g.V().has('airport','country','IE').
      group().by('code').by('runways').select(keys).range(local,3,5)

[KIR,ORK]
----
You can combine the 'limit' and 'tail' steps with 'local' scope to extract the
beginning or ending entries from a list of values as shown below. The following
query creates a list containing the IATA codes for all airports in Texas.

[source,groovy]
----
g.V().has('region','US-TX').values('code').fold()

[AUS,DFW,IAH,SAT,HOU,ELP,DAL,LBB,HRL,MAF,CRP,ABI,ACT,CLL,BPT,AMA,BRO,GGG,GRK,LRD,MFE,SJT,SPS,TYR,VCT,AFW]
----

Using 'local' scope with a 'limit' step we can extract just the first two entries
from the list.

[source,groovy]
----
g.V().has('region','US-TX').values('code').fold().limit(local,2)

[AUS,DFW]
----

Likewise, using 'local' scope with a 'tail' step we can extract just the last two
entries from the list.

[source,groovy]
----
g.V().has('region','US-TX').values('code').fold().tail(local,2)

[VCT,AFW]
----

It is worth noting that 'local' scope can also be used with a 'dedup' step. The
query below finds airports in the US and produces a sorted list of the unique region
codes by only allowing one airport from each region to proceed to the next steps of
the traversal.

[source,groovy]
----
g.V().has('country','US').dedup().by('region').values('region').order().fold()
----

The rewritten version of the query below allows the region codes for every airport to
be collected and then the 'dedup' is applied to the resultant collection using
'local' scope. The prior query is likely to be the more efficient way of doing this
but we wanted to make it clear that existing collections of values can have 'dedup'
applied to them using 'local' scope.

[source,groovy]
----
g.V().has('country','US').values('region').order().fold().dedup(local)

----

When either query is run, here are the results that are returned.

[source,groovy]
----
[US-AK,US-AL,US-AR,US-AZ,US-CA,US-CO,US-CT,US-DC,US-DE,US-FL,US-GA,US-HI,US-IA,US-ID,US-IL,US-IN,US-KS,US-KY,US-LA,US-MA,US-MD,US-ME,US-MI,US-MN,US-MO,US-MS,US-MT,US-NC,US-ND,US-NE,US-NH,US-NJ,US-NM,US-NV,US-NY,US-OH,US-OK,US-OR,US-PA,US-RI,US-SC,US-SD,US-TN,US-TX,US-UT,US-VA,US-VT,US-WA,US-WI,US-WV,US-WY]
----

Lastly, we can combine some of the prior examples to limit, order and deduplicate the
contents of a group. The query below does not include a 'limit' step so it retrieves
all possible results. The goal of the query is to build a group, with labels as the
keys and vertex 'code' properties as the values for both incoming and outgoing edges
connected to AUS (Austin). The results are deduplicated so that no airport code
appears twice.

[source,groovy]
----
g.V().has('code','AUS').
      both().
      group().
        by(label).
        by(values('code').fold().dedup(local).order(local))
----

When run it returns the following results.

[source,groovy]
----
[continent:[NA],country:[US],airport:[ABQ,ATL,BKG,BNA,BOS,BWI,CLE,CLT,CUN,CVG,DAL,DCA,DEN,DFW,DTW,ELP,EWR,FLL,FRA,GDL,HOU,HRL,IAD,IAH,IND,JFK,LAS,LAX,LBB,LGB,LHR,MCI,MCO,MDW,MEM,MEX,MIA,MSP,MSY,OAK,ORD,PDX,PHL,PHX,PIE,PIT,PNS,RDU,SAN,SEA,SFB,SFO,SJC,SLC,SNA,STL,TPA,VPS,YYZ]]
----

However, let's assume we wanted to limit the query to a maximum of ten results for
any of the keys in the group. We can do so by adding a 'limit' step with 'local'
scope as shown below.

[source,groovy]
----
g.V().has('code','AUS').
      both().
      group().
        by(label).
        by(values('code').fold().dedup(local).order(local).limit(local,10))
----

This time when run, the amount of results returned is restricted.

[source,groovy]
----
[continent:[NA],country:[US],airport:[ABQ,ATL,BKG,BNA,BOS,BWI,CLE,CLT,CUN,CVG]]
----

In the next section we will continue our look at Gremlin's collections and how they
can be used in conjunction with 'reducing barrier' steps to still achieve a desired
result. We will also see other cases where 'unfold' is needed to access the parts of
a collection that we care about.

[[rbarriers]]
Collections and reducing barrier steps
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you look at commonly asked questions about writing Gremlin queries on the Gremlin
Users discussion list, one area that repeatedly seems to cause people confusion is
the behavior of certain traversal steps that are known as 'reducing barrier' steps.
What these steps in essence do is reduce the results of the traversal so far to a
single traversal, often just a value or a collection of some kind and from that point
on you cannot refer back to things you did earlier in the query.

.Reducing barrier steps
[cols="^1,4"]
|==============================================================================
|max     | Returns the maximum value from a set of values.
|min     | Returns the minimum value from a set of values.
|sum     | Returns the sum of a set of values.
|count   | Counts the number of current elements.
|fold    | Aggregates current traversal into a map.
|==============================================================================

Take a look at the example below. On the surface, you might expect the query to count
all of the routes originating from the DFW airport and return the count '"b"' along
with the airport vertex '"a"'.

[source,groovy]
----
g.V().has('code','DFW').as('a').outE().count().as('b').select('a','b')
----

What actually happens is that nothing is returned. This is because the 'count' step
is a so called 'reducing barrier' step. Once the 'count' has been processed, you have
crossed the 'barrier' and the traversal variable '"a"' is no longer available to us.
We can still access '"b"' if we reference it by itself  as it is defined after the
'count' step as shown below.

[source,groovy]
----
g.V().has('code','DFW').as('a').outE().count().as('b').select('b')

221
----

In cases such as this, it is almost always possible to achieve the results that you
want by changing the way you write the query. It is important to gain an
understanding of how different traversal steps work. A great way to do that is to
experiment using the Gremlin Console and look at the way different steps operate. The
rewritten query below achieves our original goal.

[source,groovy]
----
g.V().has('code','DFW').group().by().by(outE().count())

[v[8]:221]
----

If this was all we needed then our job is done. We have a map containing the vertex
as the key and its outgoing route count as the value. However, there is still an
issue if we want to go further with this query. Take a look at the example below.
Because the query has reduced the prior traversal to essentially a small map,
including a count, we can no longer refer back to '"a"'.

[source,groovy]
----
g.V().has('code','DFW').as('a').group().by().by(outE().count()).select('a')
----

If for some reason, we wanted to retrieve the vertex that we had stored in '"a"', we
should instead pull it from the map that the 'group' step created. You can access the
keys of a map using the 'keys' keyword as a parameter to a 'select' step.

[source,groovy]
----
g.V().has('code','DFW').group().by().by(outE().count()).
                        select(keys)

[v[8]]
----

We have still not quite got the result we wanted as the vertex is still returned in a
list. So we can modify the query again to 'unfold' the map before we select the keys
from it.

[source,groovy]
----
g.V().has('code','DFW').group().by().by(outE().count()).
                        unfold().select(keys)
v[8]
----

If we wanted to get the value back instead of the key we can use the 'values' keyword
as follows.

[source,groovy]
----
g.V().has('code','DFW').group().by().by(outE().count()).
                        unfold().select(values)

221
----

To prove we could carry on adding to the query from here let's get back the airport
code that we started with.

[source,groovy]
----
g.V().has('code','DFW').group().by().by(outE().count()).
                        unfold().select(keys).values('code')

DFW
----

So, let's now add to our query and create a new vertex with a label 'dfwcount' that 
is going to store the number of routes originating in DFW using a property called
'current_count'.

[source,groovy]
----
g.V().has('code','DFW').group().by().by(outE().count()).as('ct').
      addV('dfwcount').
      property('current_count',select('ct').unfold().select(values))

v[54931]
----

We can inspect the new vertex to double check that our query worked as intended.

[source,groovy]
----
g.V(54931).valueMap(true)

[id:54931,current_count:[221],label:dfwcount]
----

Hopefully you are starting to see a pattern here. It is important to understand which
steps are 'reducing barrier' steps and be able to work with them in a way that allows
you to write queries that do what you need.

[[sumcollection]]
Calculating the 'sum' of a collection
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The query below returns a map where the keys are airport IATA codes and the values
are the number of runways at the airport. The results are ordered to aid readability.

[source,groovy]
----

g.V().hasLabel('airport').limit(10).
      group().by('code').by(values('runways')).
      order(local).by(values)

[FLL:2,AUS:2,DCA:3,BWI:3,ANC:3,BNA:4,IAD:4,ATL:5,BOS:6,DFW:7]
----

Given such a collection of airports and runways, we might want to calculate the total
number of runways present. The query below achieves that. Note that in order to
select the values from the collection an 'unfold' step is used to turn the collection
back into a stream from which the values can be selected.

[source,groovy]
----
g.V().hasLabel('airport').limit(10).
      group().by('code').by(values('runways')).
      unfold().
      select(values).
      sum()

39
----

We can also write the query using 'local' scope rather than an 'unfold' step as shown
below.

[source,groovy]
----
g.V().hasLabel('airport').limit(10).
      group().by('code').by(values('runways')).
      local(select(values).sum(local))

39
----

[[mathcollection]]
Using the 'math' step with collections
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Building on the examples from the previous section, let's now take these experiments
one step further and look at ways to apply the 'math' step to values from one or more
collections. Given we know that there are 10 values in our collection we can easily
use a 'math' step to calculate the average of those values.

[source,groovy]
----
g.V().hasLabel('airport').limit(10).
      group().by('code').by(values('runways')).
      unfold().
      select(values).
      sum().
      math('_ / 10')

3.9
----

We may not always know ahead of time  how many entries a collection has. The modified
example below uses a 'project' step to feed the 'math' step with two values
representing the total number of runways and the number of members in the collection.

[source,groovy]
----
g.V().hasLabel('airport').limit(10).
      group().by('code').by(values('runways')).
      project('total','number').
        by(select(values).unfold().sum()).
        by(count(local)).
      math('total / number')

3.9
----

Sometimes you may want to perform computations on the sums of multiple collections.
The two queries shown below create maps of airport and runway key/value pairs for all
the airports in New Mexico and Arizona respectively.

[source,groovy]
----
g.V().has('region','US-NM').
      group().by('code').by(values('runways'))

[ABQ:4,SVC:4,CNM:4,FMN:2,SAF:3,LAM:1,HOB:3,CVN:3,ROW:3]
----

If you were to add up the runways at the New Mexico airports you would find there are
27 and likewise there are 26 runways across the Arizona airports.

[source,groovy]
----
g.V().has('region','US-AZ').
      group().by('code').by(values('runways'))

[YUM:4,PRC:3,FLG:1,PHX:3,IFP:1,TUS:3,GCN:1,AZA:3,SOW:2,PGA:2,IGM:3]
----

Given these two collections, we might want to divide the sum of one set of values by
the other to calculate the ratio between the total number of runways in Arizona and
New Mexico. The query below does just that. While at first glance this query looks a
bit complicated, it is in fact just the result of combining the prior few queries we
have looked at into a single query.

[source,groovy]
----
g.V().has('region','US-NM').
      group().by('code').by(values('runways')).
      select(values).
      unfold().
      sum().
      store('a').
      V().has('region','US-AZ').
      group().by('code').by(values('runways')).
      select(values).
      unfold().
      sum().
      store('b').
      project('first','second').
        by(select('a').unfold()).
        by(select('b').unfold()).
      math('first / second')

1.0384615384615385
----

Given we calculated that there were 27 runways in New Mexico and 26 in Arizona we can
verify that we have the right result using the Gremlin Console.

[source,console]
----
gremlin> 27/26

==>1.0384615385
----


[[sackintro]]
Introducing 'sack' as a way to store values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As is hopefully now becoming apparent, to efficiently write certain types of queries
you need a way to build up a collection of items as the traversal takes place. We
have already looked at steps like 'aggregate' and 'store' that can create collections
of items during a traversal. However, the 'sack' step offers an additional capability
in that we can specify how items are added to the collection. For example they can be
added using addition, multiplication, subtraction or division. Alternatively we can
store the minimum or maximum value of a pair of values. These and other sack
operators will be used in different parts of this book.

[[sackbasics]]
Basic 'sack' operations
^^^^^^^^^^^^^^^^^^^^^^^

The 'sack' step, as shown in the examples below, is a side effect step, meaning it
can store values during a traversal but has no effect on what is passed on to the
next step.

By way of an introduction, take a look at the example below. All the query does as it
stands is create a list of the number of runways that each airport that you can fly
to from Santa Fe (SAF) has. We have not introduced a 'sack' step into the equation
yet.

[source,groovy]
----
g.V().has('code','SAF').out().values('runways').fold()

[7,4,3,6]
----

Now let's start to introduce some usage of sacks into the query. When working with a
'sack' we typically initialize the sack in some way. The example below initializes a
sack with a value of zero but does not yet do anything with it so the result is
unchanged.

[source,groovy]
----
g.withSack(0).V().has('code','SAF').out().
              values('runways').fold()

[7,4,3,6]
----

This time we add the runways to our sack using a sum operation, but as our starting
value is zero we are not actually changing the end result in any way. This is because
we essentially perform the operation '0 + runways' for each runway value. The final
call to 'sack' with no parameters causes the current contents of the 'sack' to be
returned. The 'fold' step, as before, puts whatever results we got from the 'sack'
into a list.

[source,groovy]
----
g.withSack(0).V().has('code','SAF').out().
              values('runways').sack(sum).sack().fold()

[7,4,3,6]
----

So let's finally do something that will change the result. Let's make the starting
value one rather than zero and see what happens.

[source,groovy]
----
g.withSack(1).V().has('code','SAF').out().
              values('runways').sack(sum).sack().fold()

[8,5,4,7]
----

Now, each time the number of runways was added to the sack using a 'sum' operator,
the operation that was performed was '1 + runways'. As you can see from the results,
in each case, the value returned is one higher than those from the previous query.
This is a very simple example but hopefully you can start to see how useful sacks can
be.

Before getting into some more interesting examples, it is worth pointing out that you
can also initialize a sack using the 'assign' operator as shown below. It is also
important to note that this sack initialization does not have to happen at the start
of the query when done in this way. In the example below, a constant value of one is
used, but we could equally well have used a traversal to initialize that sack as we
shall see in the next example.

[source,groovy]
----
g.V().sack(assign).by(constant(1)).has('code','SAF').
      out().values('runways').sack(sum).sack().fold()

[8,5,4,7]
----

Let's now make our query a bit more interesting. There are a couple of interesting
new twists shown in the query below. Firstly, the sack is initialized to contain the
number of runways from the AUS vertex whereas before we just used a simple constant.
Secondly, notice that rather than make an explicit call to 'values' before adding to
the sack, we can just use a 'by' modulator to specify what we want added to our sack.

[source,groovy]
----
g.V().has('code','AUS').sack(assign).by('runways').
  V().has('code','SAF').out().
      sack(sum).by('runways').sack().fold()

[9,6,5,8]
----

This time, as the Austin (AUS) airport has two runways our calculation in effect
became '2 + runways'.

Before looking at some slightly more complex queries that use multiple 'sack' steps,
we should take a look at some of the other operators. So far we have just used 'sum'.
The query below uses 'mult' which as its name implies will multiply the values
together rather than add them.

[source,groovy]
----
g.V().has('code','AUS').sack(assign).by('runways').
  V().has('code','SAF').out().
      sack(mult).by('runways').sack().fold()

[14,8,6,12]
----

Likewise, minus will subtract the values before putting them into the sack. Note that
the values are subtracted *from* the sack's initialization value.

[source,groovy]
----
g.V().has('code','AUS').sack(assign).by('runways').
  V().has('code','SAF').out().
      sack(minus).by('runways').sack().fold()

[-5,-2,-1,-4]
----

If we wanted to subtract the sack's initial value from the other values we can simply
initialize it with a negative value and perform a 'sum' operation.

[source,groovy]
----
g.V().sack(assign).by(constant(-1)).has('code','SAF').
      out().values('runways').sack(sum).sack().fold()

[6,3,2,5]
----

[[sackminmax]]
Using 'min' and 'max' with a 'sack'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There are many different operators that can be used with sacks. They are defined as
part of the TinkerPop Java Enum called 'Operator'. Two such operators that we can use
are 'min' and 'max'. The example below looks at the distances of all routes that 
start at SAF and in each case returns the minimum of the distance or 400 which is 
assigned to the sack at the start of the query.

[source,groovy]
----
g.V().sack(assign).by(constant(400)).has('code','SAF').
      outE().sack(min).by('dist').sack().fold()

[400,400,369,303]
----

In a similar vein, this query picks the maximum of the actual distance or 400.

[source,groovy]
----
g.V().sack(assign).by(constant(400)).has('code','SAF').
      outE().sack(max).by('dist').sack().fold()

[549,708,400,400]
----


[[sackcalc]]
Doing calculations using a 'sack'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now let's look at a more complex, and hopefully more interesting, example. The
challenge is to write a query that shows 10 routes that start at Santa Fe (SAF) and
have one stop. We also want to return the distance between each hop and the total
distance of the two hops. This is a perfect example of a query where using a 'sack'
can help. For completeness the results are sorted by overall route distance.

[source,groovy]
----
g.withSack(0).
  V().has('code','SAF').
      repeat(outE().sack(sum).by('dist').inV()).times(2).limit(10).
      order().by(sack()).
      sack().path().
      by('code').by('dist').by('code').by('dist').by('code').by()
----

If we run our query, we should get back something that looks like the output shown
below. Notice how the output from the 'sack' (the last item in each row) contains the
sum of the two prior route distances. So, for example, we can see that the total
distance from SAF to ATL with a stop in DFW is 1278 miles.

[source,groovy]
----
[SAF,549,DFW,190,AUS,739]
[SAF,549,DFW,225,IAH,774]
[SAF,549,DFW,630,BNA,1179]
[SAF,549,DFW,729,ATL,1278]
[SAF,549,DFW,1120,FLL,1669]
[SAF,549,DFW,1170,IAD,1719]
[SAF,549,DFW,1190,DCA,1739]
[SAF,549,DFW,1210,BWI,1759]
[SAF,549,DFW,1560,BOS,2109]
[SAF,549,DFW,3030,ANC,3579]
----

What may not be obvious from the query above is that we are in fact using multiple
'sack' steps within the same query. If we were to remove the 'repeat' and write the
query out in full this becomes more obvious.

[source,groovy]
----
g.withSack(0).
  V().has('code','SAF').
      outE().limit(10).sack(sum).by('dist').inV().
      outE().limit(10).sack(sum).by('dist').inV().
      sack().path().
      by('code').by('dist').by('code').by('dist').by('code').by()
----

Later, in the "<<sackauslhr>>" section, we will again use a 'sack' to help calculate
multi hop route distances using an approach similar to the example above.

So far we have just used simple integer values to initialize our sacks. However it is
also possible to use non primitive types such as maps when working with a sack. You
will find an example of 'sack' being used to generate a map in the "<<anothersack>>"
section.

[[nonsackcalc]]
Doing calculations without using a 'sack'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A similar result to those from the queries in the previous section can actually be
achieved without using a 'sack'. we find the 'sack' form to be quite concise but you
can also use a 'project' step to achieve similar results as shown below. The key
thing to notice about this query is that the path generated by the first half of the
query is unfolded to get the distances from the edges. As only edges have a 'dist'
property in the `air-routes` graph, a coalesce step is used to generate the distance
from the edges or a constant value of zero otherwise. If we did not do this the query
would generate an error message as airport vertices does not have a 'dist' property.

[source,groovy]
----
g.V().has('code','SAF').
      repeat(outE().inV().simplePath()).times(2).limit(10).
        project('path','total').
          by(path().by('code').by('dist')).
          by(path().unfold().coalesce(values('dist'),constant(0)).sum()).
          order().by(select('total'))
----

When run the query produces the following results. Note that the output includes the
'path' and 'total' key names and also that the path is in a list nested inside
another list.

[source,groovy]
----
[path:[SAF,549,DFW,190,AUS],total:739]
[path:[SAF,549,DFW,225,IAH],total:774]
[path:[SAF,549,DFW,630,BNA],total:1179]
[path:[SAF,549,DFW,729,ATL],total:1278]
[path:[SAF,549,DFW,1120,FLL],total:1669]
[path:[SAF,549,DFW,1170,IAD],total:1719]
[path:[SAF,549,DFW,1190,DCA],total:1739]
[path:[SAF,549,DFW,1210,BWI],total:1759]
[path:[SAF,549,DFW,1560,BOS],total:2109]
[path:[SAF,549,DFW,3030,ANC],total:3579]
----

The query can be refined a bit more to remove the 'path' and 'total' key names from
the result by just selecting the values for each.

[source,groovy]
----
g.V().has('code','SAF').
      repeat(outE().inV().simplePath()).times(2).limit(10).
        project('path','total').
          by(path().by('code').by('dist')).
          by(path().unfold().coalesce(values('dist'),constant(0)).sum()).
          order().by(select('total')).
          select(values)
----

Now the results are exactly the same as from the version of the query that used
'sack'. This was a longer query to write but in some cases, depending upon the graph
database implementation, could be more efficient as processing of results is left
until the second half of the query.

[source,groovy]
----
[[SAF,549,DFW,190,AUS],739]
[[SAF,549,DFW,225,IAH],774]
[[SAF,549,DFW,630,BNA],1179]
[[SAF,549,DFW,729,ATL],1278]
[[SAF,549,DFW,1120,FLL],1669]
[[SAF,549,DFW,1170,IAD],1719]
[[SAF,549,DFW,1190,DCA],1739]
[[SAF,549,DFW,1210,BWI],1759]
[[SAF,549,DFW,1560,BOS],2109]
[[SAF,549,DFW,3030,ANC],3579]
----

We can add one more refinement to make the results exactly the same as those from the
version of the query that used 'sack' by unfolding the results and then refolding
them with 'local' scope.

[source,groovy]
----
g.V().has('code','SAF').
      repeat(outE().inV().simplePath()).times(2).limit(10).
        project('path','total').
          by(path().by('code').by('dist')).
          by(path().unfold().coalesce(values('dist'),constant(0)).sum()).
          order().by(select('total')).
          select(values).local(unfold().unfold().fold())
----

Now the results look just the same was those we got using 'sack'.

[source,groovy]
----
[SAF,549,DFW,190,AUS,739]
[SAF,549,DFW,225,IAH,774]
[SAF,549,DFW,630,BNA,1179]
[SAF,549,DFW,729,ATL,1278]
[SAF,549,DFW,1120,FLL,1669]
[SAF,549,DFW,1170,IAD,1719]
[SAF,549,DFW,1190,DCA,1739]
[SAF,549,DFW,1210,BWI,1759]
[SAF,549,DFW,1560,BOS,2109]
[SAF,549,DFW,3030,ANC,3579]
----

The query can also be written using the same 'path' and 'coalesce' approach but this
time using a 'union' step with 'local' scope. This is more concise than the version
that uses 'project' and may be sufficient if you do not need to select parts of the
result individually using a key name.

[source,groovy]
----
g.V().has('code','SAF').
      repeat(outE().inV().simplePath()).times(2).limit(10).
      local(union(path().by('code').by('dist').unfold(),
                  path().unfold().coalesce(values('dist'),constant(0)).sum()).fold()).
      order().by(tail(local,1))
----

Once again we have the same results as we had when using 'sack' or 'project'.

[source,groovy]
----
[SAF,549,DFW,190,AUS,739]
[SAF,549,DFW,225,IAH,774]
[SAF,549,DFW,630,BNA,1179]
[SAF,549,DFW,729,ATL,1278]
[SAF,549,DFW,1120,FLL,1669]
[SAF,549,DFW,1170,IAD,1719]
[SAF,549,DFW,1190,DCA,1739]
[SAF,549,DFW,1210,BWI,1759]
[SAF,549,DFW,1560,BOS,2109]
[SAF,549,DFW,3030,ANC,3579]
----

As we have seen, the 'sack' form is quite concise however, the 'project' and 'union'
forms have a nice feature that they will work unchanged no matter how long the
resultant path is. As you may have noticed in the prior section the 'sack' version of
the query was tailored to produce results for a two hop query. We could of course
rewrite the 'sack' version to be equally flexible as shown below. The key difference
is that the result from the sack is not included in the path but factored in later
inside a 'union' step.

[source,groovy]
----
g.withSack(0).
  V().has('code','SAF').
      repeat(outE().sack(sum).by('dist').inV()).times(2).limit(10).
      order().by(sack()).
      local(union(path().by('code').by('dist'),
                  sack()).fold()).
      local(unfold().unfold().fold())
----

Again we have the same results.

[source,groovy]
----
[SAF,549,DFW,190,AUS,739]
[SAF,549,DFW,225,IAH,774]
[SAF,549,DFW,630,BNA,1179]
[SAF,549,DFW,729,ATL,1278]
[SAF,549,DFW,1120,FLL,1669]
[SAF,549,DFW,1170,IAD,1719]
[SAF,549,DFW,1190,DCA,1739]
[SAF,549,DFW,1210,BWI,1759]
[SAF,549,DFW,1560,BOS,2109]
[SAF,549,DFW,3030,ANC,3579]
----

So in summary, as is almost always the case, there is more than one way to get the
results you need using a Gremlin query.

[[sackpathlength]]
Computing hop counts using a 'sack'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The next query we are going to look at uses a 'sack' to keep track of how many flight
segments (or hops) a 'path' consists of. This means that along with the 'path' result
we can also return the path's 'hop count'.

The query below looks for routes between Austin and Wellington and returns the first
10 results found along with the number of flights that would need to be taken between
the source and destination airports. As part of the 'repeat' step, each time an 'out'
step is taken a 'constant' value of one is added to the sack for that individual
path. Finally a 'union' step is used to combine the individual path with its hop
count.

[source,groovy]
----
g.withSack(0).V().
  has('code','AUS').
  repeat(out().simplePath().sack(sum).by(constant(1))).
    until(has('code','WLG')).
  limit(10).
  local(union(path().by('code'),sack()).fold())
----

When run the query returns ten lists containing the airports visited and the number of
hops in each individual list.

[source,groovy]
----
[[AUS,DFW,SYD,WLG],3]
[[AUS,IAH,AKL,WLG],3]
[[AUS,LAX,SYD,WLG],3]
[[AUS,LAX,MEL,WLG],3]
[[AUS,LAX,AKL,WLG],3]
[[AUS,LAX,BNE,WLG],3]
[[AUS,SFO,SYD,WLG],3]
[[AUS,SFO,AKL,WLG],3]
[[AUS,YYZ,HND,SYD,WLG],4]
[[AUS,YYZ,HND,AKL,WLG],4]
----

To return the results with the longer routes coming first we could use the values in
the sack along with an 'order' step.

[source,groovy]
----
g.withSack(0).V().
  has('code','AUS').
  repeat(out().simplePath().sack(sum).by(constant(1))).
    until(has('code','WLG')).
  limit(10).
  order().by(sack(),desc).
  local(union(path().by('code'),sack()).fold())
----

This time the four hop routes appear first in the results.

[source,groovy]
----
[[AUS,YYZ,HND,SYD,WLG],4]
[[AUS,YYZ,HND,AKL,WLG],4]
[[AUS,DFW,SYD,WLG],3]
[[AUS,IAH,AKL,WLG],3]
[[AUS,LAX,SYD,WLG],3]
[[AUS,LAX,MEL,WLG],3]
[[AUS,LAX,AKL,WLG],3]
[[AUS,LAX,BNE,WLG],3]
[[AUS,SFO,SYD,WLG],3]
[[AUS,SFO,AKL,WLG],3]
----

As a side note, if we wanted to include the path's length rather than the hop count 
we could change the query as shown below. In this case a 'sack' step is not needed as
we can just count the length of each path.

[source,groovy]
----
g.V().has('code','AUS').
      repeat(out().simplePath()).
        until(has('code','WLG')).
      limit(10).
      local(union(path().by('code'),path().count(local)).fold())
----

This time the number shown is one bigger than in the previous example as the starting
airport is included in the overall count.

[source,groovy]
----
[[AUS,DFW,SYD,WLG],4]
[[AUS,IAH,AKL,WLG],4]
[[AUS,LAX,SYD,WLG],4]
[[AUS,LAX,MEL,WLG],4]
[[AUS,LAX,AKL,WLG],4]
[[AUS,LAX,BNE,WLG],4]
[[AUS,SFO,SYD,WLG],4]
[[AUS,SFO,AKL,WLG],4]
[[AUS,YYZ,HND,SYD,WLG],5]
[[AUS,YYZ,HND,AKL,WLG],5]
----

[[sackbooleans]]
Using boolean operators with a 'sack'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You can also use the boolean operators 'or' and 'and' when working with a 'sack'. The
examples below just test the basic functionality using constants of 'true' and
'false'. In the first example the result returned in the 'sack' is 'false' as we used
an 'and' operator to 'and' together the sack's initial value of 'true' and a constant
value of 'false'.

[source,groovy]
----
g.V(3).sack(assign).by(constant(true)).sack(and).by(constant(false)).sack()

false
----

This time we replace the 'and' operator with an 'or' and the result, as we would
expect, is 'true'.

[source,groovy]
----
g.V(3).sack(assign).by(constant(true)).sack(or).by(constant(false)).sack()

true
----

While proving we can do boolean operations using constants is interesting it is
perhaps not that useful. Where this functionality becomes more interesting is if the
values being used come from, for example, a vertex property. So let's create a couple
of vertices that each have a boolean property.

[source,groovy]
----
g.addV('happy').property('happy',true)

v[54852]

g.addV('sad').property('happy',false)

v[54854]
----

We can now write a query that uses a boolean operator to generate a result in our
sack. The example below is a bit arbitrary but it shows how the boolean operators can
be used. We start at the vertex with an ID of 3, initialize a 'sack' with the
constant 'true' and the use the 'and' operator against the 'happy' property of the
vertex with a label of 'happy'. We return the results in a path, which will contain
the starting vertex and the results of the 'and' operation. The result of the 'and'
is 'true' as the 'happy' vertex has a value of 'true' for its 'happy' property.

[source,groovy]
----
g.V(3).sack(assign).by(constant(true)).sack(and).
       by(V().hasLabel('happy').values('happy')).sack().path()

[v[3],true]
----

If we repeat the query but this time use the 'sad' vertex, we get the expected result
of 'false' from the 'and' operation.

[source,groovy]
----
g.V(3).sack(assign).by(constant(true)).sack(and).
       by(V().hasLabel('sad').values('happy')).sack().path()

[v[3],false]
----

[[sackaddall]]
Using 'addAll' and lists with a 'sack'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

So far we have looked at using numbers and boolean values with a sack. However, sacks
can also contain lists and, as we shall see later, maps.

The example below initializes a sack with an empty list '"[]"' and then uses the
'addAll' operator to store the same results we have seen generated above in a list.
Note that a 'fold' step is used to create a list of values that can then be added to
the sack. Later we shall look at other ways to build up lists with sacks that do not
first fold all of the traversal results into a list.

[source,groovy]
----
g.withSack([]).V().has('code','SAF').out().
               values('runways').fold().sack(addAll).sack()

[7,4,3,6]
----

You might be thinking, and you would be right, that we could have achieved the same
result without using a 'sack' at all and just using a fold 'step' as shown below.
However, the power of using a 'sack' becomes apparent when you need to build up a 
list containing the results of various parts of the query.

[source,groovy]
----
g.V().has('code','SAF').out().values('runways').fold()

[7,4,3,6]
----

The next example, below, shows how a list can be built up using more than one 'sack'
step. The 'sack' is initialized with an empty list and the runway counts of the
airports reachable from SAF are again added initially to the list using the 'addAll'
operator. Having done that we add the runway counts for the airports reachable from
AUS to the sack. You can see that the output starts with the same 7,4,3,6 sequence we
have seen before but is then followed by all the other values that were added by the
second 'sack' step.

[source,groovy]
----
g.withSack([]).V().has('code','SAF').out().
               values('runways').fold().sack(addAll).
               V().has('code','AUS').out().values('runways').fold().
               sack(addAll).sack()

[7,4,3,6,3,4,6,5,2,4,2,4,3,2,4,2,4,4,3,3,3,4,4,5,3,3,2,2,2,1,4,1,4,5,4,6,3,3,7,2,4,5,4,4,4,4,4,8,3,3,3,4,3,3,1,3,2,4,4,6,2,3,4,3,3,4]
----

Finally, here is the previous query again but this time the 'sack' is initialized
with a list that already has some values in it. You can see from the output that the
values we generated above are added after the 1,1,1,1 sequence that the sack was
initialized with.

[source,groovy]
----
g.withSack([1,1,1,1]).
     V().has('code','SAF').out().
     values('runways').fold().sack(addAll).
     V().has('code','AUS').out().values('runways').fold().
     sack(addAll).sack()

[1,1,1,1,7,4,3,6,3,4,6,5,2,4,2,4,3,2,4,2,4,4,3,3,3,4,4,5,3,3,2,2,2,1,4,1,4,5,4,6,3,3,7,2,4,5,4,4,4,4,4,8,3,3,3,4,3,3,1,3,2,4,4,6,2,3,4,3,3,4]
----

So far, all of the examples have used a 'fold' step before the 'sack' step. While
this gives us a useful result, it may not always be the result that we want. To put
it another way, what we get back is a single list containing all of the values that
we generated during the traversal. In some cases what we actually want might be a set
of lists where each list contains whatever the 'sack' was initialized with plus just
the values specific to each path the traverser takes. In other words, we want the
'sack' to have more of a local scope and not act like a global variable.

When we were thinking about this and doing some experiments using the Gremlin
Console, our first thought was "We can use a 'local' step for this". So, we initially
tried the query shown below. However, as you can see, while this definitely generated
some different output, it did not generate what we wanted.

[source,groovy]
----
g.withSack([1,1,1,1]).V().has('code','SAF').out().
     values('runways').local(fold().sack(addAll)).sack()

[1,1,1,1,7]
[1,1,1,1,7,4]
[1,1,1,1,7,4,3]
[1,1,1,1,7,4,3,6]
----

What is happening above is that the 'sack' is still acting more like a global
variable than a local one. Each 'sack' step generated a list that was based on the
previous one.

To get the results we wanted, we needed to use a 'clone' operation. This query uses
the Groovy closure or 'Lambda' syntax. We will investigate that syntax more a bit
later in the "<<lambdas>>" section but for now all we need to know is that the
'clone' will ensure that each traverser gets its own copy of the original sack and is
not affected by what other traversers do to their sacks. Remember that a Gremlin
query, or traversal, in essence causes a set of traversers to follow the paths
through the graph that your query demands.

[source,groovy]
----
g.withSack{[1,1,1,1]}{it.clone()}V().has('code','SAF').
       out().values('runways').local(fold().sack(addAll)).sack()

[1,1,1,1,7]
[1,1,1,1,4]
[1,1,1,1,3]
[1,1,1,1,6]
----

Later in the "<<lambdasack>>" section we  will revisit the topic of 'sacks' and
lambda expressions and see other ways that we could have written the previous query.

[[sackpredicate]]
Comparing properties and constants to the value of a sack
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

During a traversal you may want to incrementally modify a sack and then compare a
vertex or edge property against the current contents of a sack. The examples below
show ways of doing this. To keep things simple, initially we will use a sack that is
initialized to a value of six and does not change. This demonstrates how to compare
each airport's runway count against the value stored in the sack.

[source,groovy]
----

g.withSack(6).V().
  hasLabel('airport').as('a').
  where(gt('a')).
    by('runways').
    by(sack()).
  values('code')

DFW
ORD
----

As we mentioned in the "<<pathstepwarn>>" section, using an 'as' step to remember a
prior part of a traversal can be expensive in terms of memory usage. This will not be
an issue with small graphs such as `air-routes`, but can be problematic when
working with larger graphs. The query can be rewritten without the use of an 'as'
step as shown below.

[source,groovy]
----
g.withSack(6).V().
  hasLabel('airport').
  filter(project('a','b').
           by('runways').
           by(sack()).
         where('a', gt('b'))).
  values('code')

DFW
ORD
----

Obviously, while these examples demonstrate the concept, in reality we have not done
anything that truly warrants use of a 'sack' step so far. The query could easily have
been written as shown below. However, hopefully this gives you some basic building
blocks that enable sack and property values to be compared.

[source,groovy]
----
g.V().has('airport','runways',gt(6)).values('code')

DFW
ORD
----

Let's change our query to make the use of a sack more interesting. The query below
starts at Santa Fe (SAF) and traverses outgoing edges until the distance travelled
exceeds 10,000 miles. Only five results are returned.

[source,groovy]
----
g.withSack(0).V().
  has('code','SAF').
  repeat(outE().
         sack(sum).by('dist').
         inV()).
  until(sack().is(gt(10000))).
  limit(5).
  path().
    by('code').
    by('dist')
----

When we run the query we get back a series of routes that stop as soon as we have
travelled more than 10,000 miles.

[source,groovy]
----
[SAF,549,DFW,1560,BOS,7952,HKG]
[SAF,549,DFW,1230,LAX,8287,DOH]
[SAF,549,DFW,1230,LAX,8372,AUH]
[SAF,549,DFW,1230,LAX,8314,JED]
[SAF,549,DFW,1230,LAX,8246,RUH]
----

Finally, let's modify the query again to keep following routes starting at SAF, but
this time adding an additional constraint that each route must be no more than 2,500
miles. We keep going until we have travelled more than 8,000 miles. This again
demonstrates how we can use a sack to store a running total over the course of a
graph traversal. This time, the path that was followed along with the total distance
are combined using a 'union' step. We also added a 'simplePath' step to the query to
make sure we do not revisit airports.

TIP: Splitting long queries over multiple lines makes them easier to read and
understand.

You will notice that we have split the queries in this section over multiple lines to
aid readability. As your queries become more complex this becomes more important.

[source,groovy]
----
g.withSack(0).
  V().
  has('code','SAF').
  repeat(outE().
         has('dist',lte(2500)).
         sack(sum).by('dist').
         inV().
         simplePath()).
  until(sack().is(gt(8000))).
  limit(5).
  local(union(path().
                by('code').
                by('dist').
              unfold(),
              sack()).
        fold())
----

The results from running the modified query are shown below.

[source,groovy]
----
[SAF,708,LAX,2481,OGG,2401,SMF,2492,EWR,8082]
[SAF,708,LAX,2481,OGG,2401,SMF,2459,HNL,8049]
[SAF,708,LAX,2481,OGG,2352,SJC,2462,LIH,8003]
[SAF,708,LAX,2500,KOA,2375,OAK,2440,BWI,8023]
[SAF,708,LAX,2500,KOA,2375,OAK,2453,LIH,8036]
----

[[lambdas]]
Using Lambda functions
~~~~~~~~~~~~~~~~~~~~~~

Gremlin allows you to include a code fragment (sometimes called a Lambda function or
a closure) as part of a query. This is typically done as part of a 'filter', 'map' or
'sideEffect' step but there are other places where you will find this concept used
such as when working with 'sacks'. This technique provides a lot of additional
flexibility in how queries can be written. However, care should be used. When
processing your query, Gremlin will try to optimize it as best as it can. For regular
traversal steps such as 'out' and 'has' Gremlin will do this optimization for you.
However for closures (code inside braces '{}') Gremlin cannot do this and will just
pass the closure on to the underlying runtime. With people just getting started with
Gremlin there is a great temptation to over use in-line code. This is a natural thing
to want to do as for programmers it feels like the programming they are used to.
However, there is often, if not always, a pure Gremlin traversal step that can be
used to do what is needed. Of course with all rules there are exceptions.

NOTE: For reasons of security not all graph databases, especially those that are
managed as hosted services, allow lambdas to be included in queries. You should
always check the documentation for the graph database that you are using.

By way of a very simple example, the code below declares a variable '"c"' and
initializes it to zero. The Gremlin query that follows then adds one to '"c"' each
time it finds an airport vertex located in Oregon. We then use a 'println' to display
the updated value for '"c"'.

[source,groovy]
----
c = 0
g.V().has('region','US-OR').sideEffect{ c += 1 }.values('code').fold()

println "I found ${c} airports in Oregon"
----

When we run our query here is what comes back.

[source,groovy]
----
[PDX,EUG,LMT,MFR,OTH,RDM,PDT]
I found 7 airports in Oregon
----

Of course, in reality we would probably just use a 'count' when counting things or
put them into a list and look at the size of the list returned  but the above
example gives a nice, and hopefully easy to understand, example of a closure being 
used as part of a 'sideEffect' step.

For completeness, here is the query re-written a couple of different ways without the
use of a 'sideEffect' or closures. If all we wanted was the count we could do this of
course.

[source,groovy]
----
num = g.V().has('region','US-OR').values('code').count().next()
println "I found ${num} airports in Oregon"

I found 7 airports in Oregon
----

If we wanted to save a list of the airport codes found and also count them we could
do this.

[source,groovy]
----
oregon = []
g.V().has('region','US-OR').values('code').fill(oregon);[]
println oregon
println "I found ${oregon.size} airports in Oregon"
----

Here is the output, this time  with the airport codes and the count.

[source,groovy]
----
[PDX, EUG, LMT, MFR, OTH, RDM, PDT]
I found 7 airports in Oregon
----

Here is another example of a closure being used where a 'has' step could and should
have been used instead.

[source,groovy]
----
// What airports are located in London?
g.V().hasLabel('airport').filter{it.get().property('city').value() =="London"}
----

Here is the same query just using the 'has' step. This is a case where we
should not be using a lambda function as Gremlin can handle this just fine all
by itself.


[source,groovy]
----
// What airports are located in London?
g.V().hasLabel('airport').has('city','London')
----

We think you will agree that the second version is a lot simpler to read and
enables Gremlin to do its thing.

Here is one more example of a query that contains a 'sideEffect' step. The main part 
of the query finds airports with 6 runways and counts them. That result will still be
returned but the side effect will also cause the codes of those airports to also be 
printed. This is a bit of a contrived example but it shows how 'sideEffect' behaves 
when combined with a closure.

[source,groovy]
----
// Example of the 'sideEffect' step
g.V().has('runways',6).sideEffect{print it.get().values('code').next()+" "}.count()
----

TIP: The moral here is, avoid closures unless you can genuinely find no other way to
achieve what you need. It is fair we think to observe that sometimes coming up with a
closure to do what you want is easier than figuring out the pure Gremlin way to do it
but if at all possible using just Gremlin steps is still the recommended path to
take. Lambda functions in general are discouraged.

Gremlin currently does not have any regular expression support built in to the
language. However, as we will explore later in the "<<janpred>>" section, JanusGraph
does provide some support. When working with a graph, such as TinkerGraph, that has
no built in regular expression support you can use a 'filter' step combined with a
Lambda as shown in the following two examples. The examples take advantage of methods
provided by the Java String class. Support for additional text search predicates is
likely to appear in future Apache TinkerPop releases.

[source,groovy]
----
g.V().hasLabel('airport').
      filter{ it.get().value('city').startsWith('Dal')}.
      values('city')
----

When the query is run, all the airport city names matching the pattern are found.

[source,groovy]
----
Dallas
Dallas
Dalaman
Dalian
Dalcahue
Dalat
Dalanzadgad
----

The next example uses a 'filter' step combined with a closure to find any airport 
vertex that has a description containing the letter '"F"' followed by a period, as in
'"F."'. While this makes an interesting example, there are other ways to achieve this
result. One such way would be to used a mixed index and special text searching 
predicates. That, however, is a topic for quite a bit later on.

[source,groovy]
----
g.V().hasLabel('airport').as('a').values('desc').
     filter{it.toString().contains('F.')}.select('a').
     local(values('code','desc').fold())

[JFK,New York John F. Kennedy International Airport]
[BDA,Bermuda, L.F. Wade International International Airport]
[SLU,George F. L. Charles Airport]
[EUX,F. D. Roosevelt Airport]
----

[[mapstep]]
Introducing the 'Map' step
^^^^^^^^^^^^^^^^^^^^^^^^^^

The 'map' step will be familiar to users of programming languages such as Ruby,
Python or indeed Groovy. It is often useful to be able to take a set of results, or
in the case of Gremlin, the current state of a graph traversal, and modify it in some
way before passing on those results to the next part of the traversal. This is what
the 'map' step allows us to do.

The 'map' step can accept a traversal or a closure as input. The results of the
traversal or closure will be passed on to the next step in the overall traversal.
Below is a simple example of a 'map' step using a traversal to modify what is passed
on.

[source,groovy]
----
g.V().hasLabel('airport').limit(10).map(properties('city'))
----

When this query is run the output returned is the selected vertex properties for each
of the 10 airports that were selected.

[source,groovy]
----
vp[city->Atlanta]
vp[city->Anchorage]
vp[city->Austin]
vp[city->Nashville]
vp[city->Boston]
vp[city->Baltimore]
vp[city->Washington D.C.]
vp[city->Dallas]
vp[city->Fort Lauderdale]
vp[city->Washington D.C.]
----

We could go one step further and have the 'map' step produce a key and value map for
us.

[source,groovy]
----
 g.V().hasLabel('airport').limit(10).
       map(properties('city').group().by(key()).by(value()))

[city:Atlanta]
[city:Anchorage]
[city:Austin]
[city:Nashville]
[city:Boston]
[city:Baltimore]
[city:Washington D.C.]
[city:Dallas]
[city:Fort Lauderdale]
[city:Washington D.C.]
----

As we mentioned above, in many cases, a 'map' step is used in the middle of a query
to change what is passed on to the next step. The example below takes the output from
the 'map' step and sorts the results in descending order based on the city names.
Obviously there are simpler ways we could write this query but this demonstrates what
'map' does quite well.

[source,groovy]
----
g.V().hasLabel('airport').limit(10).
      map(properties('city').group().by(key()).by(value())).
      unfold().order().by(values,asc)
----

Here is the output from running the query showing the sorted city names.

[source,groovy]
----
city=Anchorage
city=Atlanta
city=Austin
city=Baltimore
city=Boston
city=Dallas
city=Fort Lauderdale
city=Nashville
city=Washington D.C.
city=Washington D.C.
----

In some cases there are other steps, such as the 'values' step that can be used as a
shorthand form of a 'map' step. The following two queries yield the same results for
example. There is no need to write an explicit 'map' step when a shorthand form
exists.

[source,groovy]
----
g.V().hasLabel('airport').limit(10).map(values('city')).fold()

[Atlanta,Anchorage,Austin,Nashville,Boston,Baltimore,Washington D.C.,Dallas,Fort Lauderdale,Washington D.C.]

g.V().hasLabel('airport').limit(10).values('city').fold()

[Atlanta,Anchorage,Austin,Nashville,Boston,Baltimore,Washington D.C.,Dallas,Fort Lauderdale,Washington D.C.]
----

Now let's look at an example where a lambda function (closure) is used. First of
all, take a look at the query below. It simply returns us a list containing the IDs
of the first ten airports in the graph.

[source,groovy]
----
g.V().hasLabel('airport').limit(10).id().fold()

[1,2,3,4,5,6,7,8,9,10]
----

Imagine we wanted to write a query, similar to the one above, that will modify each
of those IDs returned in the query above by adding one to each. Take a look at the
query below. We have introduced a 'map' step. The 'map' step takes as a parameter a
closure (or lambda) function telling it how we want it to operate on the values
flowing in to it. The 'it' is Groovy syntax for '"the thing that came in"' (in this
case a traversal). The 'get' is needed to gain access to the current vertex and its
properties. Lastly we get the 'id' of the vertex and add one to it. The modified
values are then passed on to the next step of the traversal where they are made into
a list by the 'fold' step.

[source,groovy]
----
g.V().hasLabel('airport').limit(10).map{it.get().id() + 1}.fold()

[2,3,4,5,6,7,8,9,10,11]
----

NOTE: This is an area where Groovy and Java have a similar but different syntax.
If you wanted to use the query above in a Java program you would need to use the
Java lambda function syntax.

What is nice about the 'map' step is that it allows us to do within the query itself
what we would otherwise have to do after the query was over using a 'for each' type
of loop construct.

One other thing to note about the 'map' step is that the closure provided can have
multiple steps, separated by semi-colons. The following query demonstrates this.

[source,groovy]
----
g.V().hasLabel('airport').limit(10).map{a=1;b=2;c=a+b;it.get().id() + c}.fold()

[4,5,6,7,8,9,10,11,12,13]
----

Note that only the value from the last expression in the closure is returned from the
'map'. So in the example above the result of 'c=a+b', 3, is added to each ID.

As we have already seen, there are often multiple ways to achieve the same result
when working with Gremlin. It is also true that some ways are almost always better
than others in terms of performance or some other metric. In the "<<sackintro>>" we
used a 'sack' step to add one to a set of results as follows.

[source,groovy]
----
g.withSack(1).V().has('code','SAF').out().
              sack(sum).by('runways').sack().fold()

[8,5,4,7]
----

We could achieve the same result using a 'map' step. However, doing so introduces the
need to use a closure which the version using 'sack' avoids. Avoiding unnecessary use
of closures is a Gremlin best practice.

[source,groovy]
----
g.V().has('code','SAF').out().values('runways').map{it.get() + 1}.fold()

[8,5,4,7]
----

In the next section we will take a look at some other cases where lambda expressions
are very useful as well as a few more examples of the 'map' step being used.


[[lambdasack]]
Using lambdas with 'sack' steps
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In the "<<sackaddall>>" section we introduced ways in which 'sack' steps could
operate on lists. Now that we know a bit more about the 'map' step and how Gremlin
can take advantage of Groovy closures (lambda functions) we can explore some
additional ways of working with sacks.

When we looked at 'sack' steps and lists earlier we used the query below as one of
the examples.

[source,groovy]
----
g.withSack{[1,1,1,1]}{it.clone()}V().has('code','SAF').
       out().values('runways').local(fold().sack(addAll)).sack()

[1,1,1,1,7]
[1,1,1,1,4]
[1,1,1,1,3]
[1,1,1,1,6]
----

Now that we have looked at 'map' steps, another way we could write the query, not
necessarily the best way, but it does illustrate use of a 'map', is shown below.

[source,groovy]
----
g.withSack{[1,1,1,1]}{it.clone()}V().has('code','SAF').out().
     values('runways').map{x->[x]}.sack(addAll).sack()

[1,1,1,1,7]
[1,1,1,1,4]
[1,1,1,1,3]
[1,1,1,1,6]
----

Just for completeness, here is what would happen if we ran the same query, without
the 'clone' (or split) being used.

[source,groovy]
----
g.withSack([1,1,1,1]).V().has('code','SAF').out().
     values('runways').map{x->[x]}.sack(addAll).sack()

[1,1,1,1,7]
[1,1,1,1,7,4]
[1,1,1,1,7,4,3]
[1,1,1,1,7,4,3,6]
----

A different way we could write the query, and this is something that we have not yet
examined in this book, is to use a closure directly with the 'sack' step itself.

[source,groovy]
----
 g.withSack([1,1,1,1]).V().has('code','SAF').out().
      values('runways').sack{a,v->a+=[v]}.sack()

[1,1,1,1,7]
[1,1,1,1,4]
[1,1,1,1,3]
[1,1,1,1,6]
----

We could also initialize the sack with a map '"[:]'" instead of a list and use a
lambda function to manipulate it as shown below.

[source,groovy]
----
g.withSack{[:]}{it.clone()}.V().has('code','SAF').out().
     sack {m,v->m[v.values('code').next()]=v.values('runways').next();m}.sack()

[DFW:7]
[LAX:4]
[PHX:3]
[DEN:6]
----

Just to show what happens, here is the same query with the 'clone' step removed.

[source,groovy]
----
g.withSack([:]).V().has('code','SAF').out().
     sack {m,v->m[v.values('code').next()]=v.values('runways').next();m}.sack()

[DFW:7]
[DFW:7,LAX:4]
[DFW:7,LAX:4,PHX:3]
[DFW:7,LAX:4,PHX:3,DEN:6]
----

If all we wanted back was a single list of key value pairs, such as the one in the
last line of the output above, we can write a query to do that. One way we could do
it is to use a 'map' and not use a 'sack' step at all as shown below.

[source,groovy]
----
g.V().has('code','SAF').out().
      map{m=[:];m[it.get().values('code').next()]=
      it.get().values('runways').next();m}.unfold().fold().next().getClass()

[DFW=7,LAX=4,PHX=3,DEN=6]
----

However, doing it using a 'sack' feels cleaner in our view, as shown below. Note that
in this case what is returned is a Java LinkedHashMap data structure whereas the
previous query generated an ArrayList of  LinkedHashMap.Entry objects. Also, it is
worth noting that all we had to do to get the result that we wanted in this case was
to add a 'fold' step between the 'sack' steps.

[source,groovy]
----
 g.withSack([:]).V().has('code','SAF').out().
      sack{m,v -> m[v.value('code')]=v.values('runways').next()}.fold().sack()

[DFW:7,LAX:4,PHX:3,DEN:6]
----

There are other ways that you might choose to write queries like these, that avoid the
use of closures altogether, but hopefully these examples show some interesting ways
that closures can be combined with 'sack' steps.


[[flatmap]]
Introducing the 'flatMap' step
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There are a set of fundamental steps that the other Gremlin query language steps
build upon. One of those is 'map'. Another, that we have not looked at so far in
this book, is 'flatMap'. The two steps are similar but have a fundamental difference
that may not be obvious from the examples we have looked at so far. The key
difference is as follows. If a 'map' step receives multiple inputs it only passes on
the first one it received to the next step whereas a 'flatMap' step passes them all
on. Let's look at a couple of examples that demonstrate this and then look at how we
can take advantage of this in practice.

The example below shows what happens when an 'out' step is used inside of a 'map'
step. Only the first vertex that was encountered is returned.

[source,groovy]
----
g.V().has('code','SAF').map(out())

v[8]
----

If we do the same experiment but using a 'flatMap' step you can see that all of the
vertices are returned.

[source,groovy]
----
g.V().has('code','SAF').flatMap(out())

v[8]
v[13]
v[20]
v[31]
----

Where a flatMap can be useful is in a case like the one below. The example is a bit
contrived but there are situations where being able to do things like this come in
quite handy. Take a look at the query below. It starts off by finding the AUS vertex.
Next it traverses all of the outgoing edges, finds the vertices at the end of those
edges and returns all  the paths travelled. Notice that both the city names and the
edge are included in the results.


[source,groovy]
----
g.V().has('code','AUS').outE().inV().
      path().by('city').by().limit(3)

[Austin,e[3712][3-route->43],Tucson]
[Austin,e[3713][3-route->45],Philadelphia]
[Austin,e[3714][3-route->46],Detroit]
----

Let's imagine we have a good reason for needing to look at the edge but that we don't
want the edge to be part of the result. What we can do is put the 'outE().inV()' part
of the traversal inside a 'flatMap'. As we know from our tests above, a 'flatMap'
will return all of the results passed into it, which in this case will be the
incoming vertices connected to the edges. When we now perform the 'path' step, the
edge details are no longer part of the path because they were essentially removed
from the path by the 'flatMap' step. This is a useful pattern to be aware of as it
can come in handy in some cases.

[source,groovy]
----
// Hide the edge from the path!
g.V().has('code','AUS').flatMap(outE().inV()).
      path().by('city').limit(3)

[Austin,Tucson]
[Austin,Philadelphia]
[Austin,Detroit]
----

We cannot use a 'map' step to achieve the same result as it will only return the first
path as shown below.

[source,groovy]
----
g.V().has('code','AUS').map(outE().inV()).
      path().by('city').limit(3)

[Austin,Tucson]
----

Of course, if all we really wanted was the result from the prior query we could just
do this.

[source,groovy]
----
g.V().has('code','AUS').out().path().by('city').limit(3)

[Austin,Tucson]
[Austin,Philadelphia]
[Austin,Detroit]
----

Lastly, here is one more case where a 'flatMap' can be useful. In the example below
we wanted to check the property on an edge as part of a 'repeat' step but not have
the edge itself be included in the resultant paths. The query uses the route distance
to filter out routes between airports that are shorter than 2,000 miles.

[source,groovy]
----
g.V().has('code','AUS').
      repeat(flatMap(outE().has('dist',gt(2000)).inV())).
      times(2).
      path().
      limit(5)
----

When the query is run the results returned only include the vertices. Note that once
again, the 'flatMap' step differs from the 'map' step in that for each path being
explored, it allows the last result generated, in this case the result of the 'inV'
step, to pass to the next step in the traversal.

[source,groovy]
----
[v[3],v[49],v[61]]
[v[3],v[49],v[64]]
[v[3],v[49],v[67]]
[v[3],v[49],v[69]]
[v[3],v[49],v[71]]
----

The query below has the  'flatMap' step removed.

[source,groovy]
----
g.V().has('code','AUS').
      repeat(outE().has('dist',gt(2000)).inV()).
      times(2).
      path().
      limit(5)
----

When run, this time the results do indeed include the edges as well as the vertices.

[source,groovy]
----
[v[3],e[5162][3-route->49],v[49],e[8448][49-route->61],v[61]]
[v[3],e[5162][3-route->49],v[49],e[8449][49-route->64],v[64]]
[v[3],e[5162][3-route->49],v[49],e[8450][49-route->67],v[67]]
[v[3],e[5162][3-route->49],v[49],e[8452][49-route->69],v[69]]
[v[3],e[5162][3-route->49],v[49],e[8454][49-route->71],v[71]]
----

[[tre]]
Turning graphs into trees
~~~~~~~~~~~~~~~~~~~~~~~~~

TinkerPop defines a Tree API but it is not that well fleshed out and has not been
updated in a long time. The 'tree' step allows you to create a tree from part of a
graph using a Gremlin traversal. The example below creates a tree, of depth 3, where
the Austin (AUS) vertex is the root of the tree. The next level of the tree is all
vertices directly connected to AUS. The third level is made up of all the vertices
connected by routes to the vertices in the previous level.

[source,groovy]
----
//Generate a tree the AUS vertex and its neighbors and their neighbors
tree = g.V().has('code','AUS').
             repeat(out()).
               times(2).
             tree().by('code').next()
----

The object returned to our variable 'tree' will be an instance of the
'org.apache.tinkerpop.gremlin.process.traversal.step.util.Tree' class. That class
provides a set of methods that can be used when working with a Tree.

[source,groovy]
----
// Look at part of the tree directly
tree['AUS']['DFW']

// You can also use the TinkerPop Tree API to work with the tree
tree.getLeafObjects()
tree.getObjectsAtDepth(1)
tree.getObjectsAtDepth(1)
tree.getObjectsAtDepth(2)
----

We will see the  Tree API used again in the "<<btree>>" section later on.

[[subgraph]]
Creating a sub graph
~~~~~~~~~~~~~~~~~~~~

Using Gremlin, you can create a subgraph which is a subset of the vertices and edges
in a larger graph you are working with. Once created, to work with a sub graph, you
create a traversal source object specific to that new graph and distinct from the one
being used to process the main graph. Subgraphs are created using the 'subgraph'
traversal step. Note that 'subgraph' works with edges (not vertices) and adds both
those edges and the vertices that they connect with to the new subgraph being
created.

TIP: You can find all of the sample data in the book's GitHub repository.
https://github.com/krlawrence/graph/tree/main/sample-data

Let's start with a simple example. One of the sample data sets shipped with this book
is a small version of the main ''air-routes'' graph called `air-routes-small.graphml`.
It contains routes between just the first 46 airports in the full graph. We can quite
easily write a query to generate the subgraph representing the flights between those
airports by extracting the edges and vertices from the full graph. Take a look at the
query below. First we find all the vertices that have an ID between 1 and 46
inclusive. Then we find all of their outgoing edges but filter out any that do not
also end up at an airport within the same ID range of 1 through 46. Lastly we use a
'subgraph' step to add those edges and vertices to a new subgraph. Note that the
'subgraph' step has to be given a label. In this case we just used '+++'+++a+++'+++'.
This allows us, should we need to, to add to a new subgraph from more that one part
of a traversal. In this case we have no more to add so a 'cap' step is used to
complete the creating of the 'subgraph'. The variable 'subg' will now contain a
reference to the newly created graph.

[source,groovy]
----
subg=g.V(1..46).outE().
       filter(inV().hasId(within(1L..46L))).
       subgraph('a').cap('a').next()
----

Note that when we run the query, Gremlin shows is that we created a new TinkerGraph
containing 46 vertices and 1326 edges.

[source,groovy]
----
tinkergraph[vertices:46 edges:1326]
----

Now that the subgraph is created, we need to create a traversal source object for it
so that we can issue queries against it. Gremlin shows us details of the new
traversal source object once it has been created.

[source,groovy]
----
sgt = subg.traversal()

graphtraversalsource[tinkergraph[vertices:46 edges:1326], standard]
----

Now that we have a traversal source object for our newly created subgraph we can run
some queries against it.

[source,groovy]
----
// What airports are in the subgraph?
sgt.V().values('code').fold()

[ATL,ANC,AUS,BNA,BOS,BWI,DCA,DFW,FLL,IAD,IAH,JFK,LAX,LGA,MCO,MIA,MSP,ORD,PBI,PHX,RDU,SEA,SFO,SJC,TPA,SAN,LGB,SNA,SLC,LAS,DEN,HPN,SAT,MSY,EWR,CID,HNL,HOU,ELP,SJU,CLE,OAK,TUS,SAF,PHL,DTW]

// How many of the 46 airports can you fly to from LAX?
sgt.V().has('code','LAX').out().count()

40
----

Here are some more examples of working with subgraphs. The query below will create a
subgraph of all vertices and edges directly connected to the Austin (AUS) vertex. 
Note that using 'bothE' means we get incoming and outgoing edges. In these examples 
the more meaningful label 'subGraph' is used to label the subgraph being created.

[source,groovy]
----
subg = g.V().has('code','AUS').bothE().
             subgraph('subGraph').cap('subGraph').next()
----

If we only wanted the outgoing routes from Austin we could change the query to just
use an 'outE' step instead.

[source,groovy]
----
subg = g.V().has('code','AUS').outE('route').
             subgraph('subGraph').cap('subGraph').next()
----

The next example is a little more sophisticated. It will create a subgraph starting
with the Austin vertex but this time going out two hops. We achieve this using a
'repeat' step.

[source,groovy]
----
subg = g.V().has('code','AUS').
       repeat(bothE().subgraph('subGraph').outV()).times(2).
       cap('subGraph').next()

[tinkergraph[vertices:1294 edges:11336]
----

As before we can now work with the newly created subgraph.

[source,groovy]
----
// Get a traversal source object so that we can traverse
// the newly created sub graph.
sgt = subg.traversal()

// What sort of vertices ended up in the subgraph?
sgt.V().groupCount().by(label)

[continent:2,country:5,airport:1287]
----

Here is a more complicated example. The query will create a subgraph just of airports
and routes that are inside Europe. Effectively this will make the Europe only version
of the air routes main graph. At first glance, this query looks a bit overwhelming
but if you read it slowly and look at each step you should be able to make sense of
what it is doing. It is quite a bit more sophisticated than the previous examples in
that as well as extracting the routes and airports into the subgraph it also extracts
all of the relevant countries and continents as well.Note that this query also uses
multiple 'subgraph' steps.

[source,groovy]
----
// Create a sub graph only of airports in Europe and routes between those airports

subg = g.V().hasLabel('continent').has('code','EU').
             outE('contains').subgraph('eu-air-routes').inV().as('a').
             inE('contains').subgraph('eu-air-routes').
             outV().hasLabel('country').
             select('a').outE().as('r').
             inV().hasLabel('airport').in().hasLabel('continent').
             has('code','EU').select('r').subgraph('eu-air-routes').
             cap('eu-air-routes').next()

tinkergraph[vertices:630 edges:13665]
----

As before we can now work with the newly created subgraph.

[source,groovy]
----
// Create a traversal source object for the subgraph
sgt = subg.traversal()

// How many routes are there in the subgraph?
sgt.E().hasLabel('route').count()

12499

// What sort of vertices ended up in the subgraph?
sgt.V().groupCount().by(label)

[continent:1,country:46,airport:583]
----

The following query uses the new Europe only subgraph to find out where we can
get to from London Heathrow (LHR) within Europe.

[source,groovy]
----
sgt.V().has('code','LHR').out().values('code').fold()

[FAO,JMK,FCO,JTR,KBP,AMS,RJK,TLS,PRG,BCN,LED,MAD,OPO,VIE,ZRH,GVA,LCG,BRU,MUC,MAN,INN,CGN,INV,GOT,BLL,VCE,KRK,SNN,MJV,OSL,MPL,ARN,EDI,PUY,GLA,BDS,DME,SVO,ORY,NCE,MXP,ATH,ZAG,BUD,BIO,IBZ,WAW,MLA,SOF,BEG,IST,HAM,STR,PSA,BLQ,NTE,CPH,LUX,DUS,TXL,LIS,GIB,KEF,PMI,AGP,LBA,ABZ,NCL,BSL,SVG,BGO,TLL,ORK,VKO,SPU,BHD,HAJ,LIN,LYS,MRS,OTP,CDG,RTM,FRA,HEL,DUB]
----

The ability to create a subgraph from a larger graph is a very powerful feature that
Gremlin provides for us. If you have a large graph but only want to work with a part
of it it is nice to be able to create a subgraph from it and perhaps even work with
that subgraph locally in memory while running some queries.

[[graphmlandjsonintro]]
Working with GraphML and GraphSON
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Apache TinkerPop supports the loading and saving of entire graphs using GraphML and
GraphSON. GraphML is a broadly supported XML standard that can be used to represent
entire graphs. GraphSON is a JSON format defined as part of the Apache TinkerPop
project that also allows whole graphs to be represented. It is also possible to use
GraphSON to represent the results of a Gremlin graph query in JSON format. In this
section we will take a look at all of these topics. The whole subject of using
GraphML and GraphSON will be revisited a few more times later in the book. Knowledge
of GraphSON becomes especially important once you start working with the Gremlin
Server. That topic will be covered in detail as part of the "<<gremlinserver>>"
section quite a bit later. Both GraphML and GraphSON are covered in detail as part of
the "<<serialize>>" section.

NOTE: The official Apache TinkerPop documentation includes some good coverage of this
topic. That documentation can be found at
http://tinkerpop.apache.org/docs/current/reference/#_gremlin_i_o and in
https://tinkerpop.apache.org/docs/current/dev/io/

There are currently three versions of GraphSON and each has an option to include
embedded type information or to rely on standard JSON types. The original 1.0 version
has a complicated embedded type format that is difficult to parse and is typically
not used anymore. Version 2.0 introduce a new embedded type format that is much
more compact and easier to parse and 3.0 added a few additional types to the format.
The default format unless explicitly specified is currently GraphSON 3.0.

[[sav]]
Saving (serializing) a graph as GraphML (XML) or GraphSON (JSON)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Using TinkerPop you can save a graph either in GraphML or GraphSON format. GraphML
is an industry standard XML format for describing a graph and is recognized by many
other applications such as Gephi. GraphSON was defined as part of the TinkerPop
project and is less broadly supported outside of TinkerPop enabled tools and graphs.
However, whereas GraphML is considered lossee for some graphs (it does not support
all of the data types and structures used by TinkerPop), GraphSON is not
considered so when configured to include embedded types.

Saving a graph to a GraphML file can be done using the following Gremlin expression.
You might want to try it on one of your graphs and look at the output generated. You
can also take a look at the `air-routes.graphml` file distributed with this book if
you want to look at a well laid out (for human readability) GraphML file. Bear in
mind that by default, TinkerPop will save your graph in a way that is not easily
human readable without using a code beautifier first. Most modern text editors can
also beautify XML files well.

Gremlin has an `io()` step which provides a way to write a graph to file:

[source,groovy]
----
// Using the .xml (or .graphml) file extension will save the graph as GraphML
g.io('my-graph.xml').write()
----

TinkerPop offers two different JSON packaging options. These are not to be confused
with the three different syntax versions. The default encoding option stores each
vertex in a graph and all of its edges as a single JSON document. This is repeated
for every vertex in the graph. This is essentially what is known as 'adjacency list'
format. If you serialize a graph to file using this method and look at the file
afterwards you will see that each line (which could be very wide) is a standalone
JSON object.

The second variant is referred to as a 'wrapped adjacency list' format. In this
flavor all of the vertices and edges are stored in a single large JSON object inside
of an enclosing 'vertices' object.

NOTE: The GraphSON file generated will not be very human readable without doing
      some pretty printing on it using something like the Python json tool
      ('python -m json.tool my-graph.json') or using a text editor that can beautify
      JSON.

The Gremlin line below will create a file containing the 'adjacency list' form of
GraphSON.

[source,groovy]
----
// Using the .json file extension will save the graph as unwrapped JSON
g.io("my-graph.json").write()
----

The following will create a file containing the 'wrapped adjacency list' form of
GraphSON.

[source,groovy]
----
// Create a single (wrapped) JSON file
writer = GraphSONWriter.build().wrapAdjacencyList(true).create()
g.io("my-graph.json").with(IO.writer, writer).write()
----

TIP: If you are ingesting large amounts of data into a TinkerPop enabled graph, the
unwrapped flavor of GraphSON is probably a much better choice than GraphML or wrapped
GraphSON. Using this format you can stream data into a graph one vertex at a time
rather than having to try and send the entire graph as a potentially huge JSON file
all in one go.

Note that by default your graph will be saved using the GraphSON 3.0 format. Should
you wish to use one of the older formats you can still do so but will need to
explicitly specify which version you want Gremlin to generate. In the example below
the graph is saved using GraphSON 1.0 format. Doing this requires the creation and
use of a mapper that will produce the format we need.

[source,groovy]
----
mapper = GraphSONMapper.build().version(GraphSONVersion.V1_0).create();
writer = GraphSONWriter.build().wrapAdjacencyList(true).mapper(mapper).create()
g.io("my-graph.json").with(IO.writer, writer).write()
----

If you want to learn more about the specifics of the GraphML and GraphSON formats,
they are covered in detail near the end of this book in the "<<serialize>>"
section.

[[reload]]
Loading a graph stored as GraphML (XML) or GraphSON (JSON)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In section 2 we saw how to load the `air-routes.graphml` file. In case you skipped
that part let's do a quick recap on loading GraphML files and also look at loading
a GraphSON JSON format file.

The only difference between loading a GraphML file or a GraphSON file is in the
file name extension, '.xml' and '.json' respectively.

[source,groovy]
----
// Using the .xml file extension will read the graph as GraphML
g.io('my-graph.xml').read()

// Using the .json file extension will save the graph as unwrapped JSON
g.io("my-graph.json").write()
----

[[graphsonmapper]]
Turning the results of a query into JSON
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In the sections above we explored how to save and load an entire graph using GraphSON
(JSON) or GraphML (XML). However what we have not looked at so far are any ways to
see query results expressed as JSON objects within the Gremlin Console. As we shall
explore in the "<<gremlinserver>>" section when you communicate with a Gremlin Server
from an application or from the command line using a tool such as 'curl' and send
queries to a graph over HTTP or WebSockets the results are returned as JSON objects.

NOTE: There is not an equivalent XML object mapping capability. This is because
GraphML is designed to contain whole graphs and not query results.

When using the Gremlin Console the results of queries are presented to us in
a nice and fairly terse way and we are not shown any JSON. Most of the time this is
exactly what we want. However, if for any reason you want to see what the JSON for a
query result looks like it is possible to do just that. You can do this using the
regular Gremlin Console and a TinkerGraph on your laptop. You do not need to be
connected to a Gremlin Server to use the examples that we are about to present.

The first thing you need to do is create an instance of a GraphSON mapper that can be
used to generate JSON for us from a query result. There are currently three versions
of GraphSON and each has an option to include embedded type information or to rely on
standard JSON types. The original 1.0 version has a complicated embedded type format
that is difficult to parse and is typically not used anymore. Version 2.0 introduce a
new embedded type format that is much more compact and easier to parse and 3.0 added
a few additional types to the format. The default format unless explicitly specified
is currently GraphSON 3.0.

The example below creates a 'GraphSONMapper' object that will generate GraphSON 3.0
format JSON where the 'typeInfo(TypeInfo.NO_TYPES)' indicates that embedded types
will be omitted.

[source,groovy]
----
jsonMapper = GraphSONMapper.build().
                version(GraphSONVersion.V3_0).
                typeInfo(TypeInfo.NO_TYPES).
                create().
                createMapper()
----

Next let's run a simple query that finds the vertex representing the Los Angeles
(LAX) airport.

[source,groovy]
----
lax = g.V().has('code','LAX').next()
----

The JSON mapper that we just created can now be used to display the query results as
JSON

[source,groovy]
----
jsonMapper.writeValueAsString(lax)
----

Here is the JSON that was generated. We have pretty printed it a bit to make it more
readable. Notice that the JSON includes the ID values for every property.

[source,json]
----
{
	"id": "13",
	"label": "airport",
	"type": "vertex",
	"properties": {
		"country": [{ "id": 149, "value": "US" }],
		"code": [{ "id": 150, "value": "LAX" }],
		"longest": [{ "id": 151, "value": 12091 }],
		"city": [{ "id": 152, "value": "Los Angeles" }],
		"lon": [{ "id": 155, "value": -118.4079971 }],
		"type": [{ "id": 156, "value": "airport" }],
		"elev": [{ "id": 153, "value": 127 }],
		"icao": [{ "id": 154, "value": "KLAX" }],
		"region": [{ "id": 157, "value": "US-CA" }],
		"runways": [{ "id": 158, "value": 4 }],
		"lat": [{ "id": 159, "value": 33.94250107 }],
		"desc": [{ "id": 160, "value": "Los Angeles International Airport" }]
	}
}
----

Let's create another 'GraphSONMapper' instance. We will again be generating
GraphSON 3.0 but this time we'll be including the embedded types. Including the
types is the default behavior, but we'll be explicit in defining the configuration
with 'typeInfo(TypeInfo.PARTIAL_TYPES)'.

[source,groovy]
----
jsonMapper = GraphSONMapper.build().
               version(GraphSONVersion.V3_0).
               typeInfo(TypeInfo.PARTIAL_TYPES).
               create().
               createMapper()
----

As there is a lot more information contained in the GraphSON with embedded
types we decided to use a somewhat simpler query and just generate a 'valueMap' for a
few of the properties contained in the LAX vertex to avoid having to show too much
output!

[source,groovy]
----
lax = g.V().has('code','LAX').valueMap(true,'code','city').next()
----

As before, we can use the mapper to generate the JSON.

[source,groovy]
----
jsonMapper.writeValueAsString(lax)
----

This time, as you can see, the JSON returned contains a lot more information. The key
thing to notice is the presence of all the '@type' and '@value' keys.

[source,json]
----
{
	"@type": "g:Map",
	"@value": [{
		"@type": "g:T",
		"@value": "id"
	}, "13", {
		"@type": "g:T",
		"@value": "label"
	}, "airport", "code", {
		"@type": "g:List",
		"@value": ["LAX"]
	}, "city", {
		"@type": "g:List",
		"@value": ["Los Angeles"]
	}]
}
----

As we mentioned, the subject of JSON will come up again when we start looking at
working with a Gremlin Server. This section has hopefully shown you how to save and
load an entire graph as either GraphML or GraphSON and should you so desire to see
the results of your queries as JSON. Remember that if you do save an entire graph as
JSON, unless you specify otherwise, the default format is GraphSON 3.0 with
embedded types.

[[traversal-strategies]]
Understanding TraversalStrategies
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When you write a Gremlin query and iterate it to get a result, the Gremlin execution
engine will take a moment to examine the query itself to determine if any registered
'TraversalStrategy' implementations meet their criteria for application. If one or
more do meet the criteria, then the strategy will modify the traversal according to
its rules. 

A `TraversalStrategy` can serve many kinds of functions but often serve one of four
functions:

* Decoration - These strategies embed application-level features into traversal 
logic.
* Verification - This is a strategy that does checks to ensure that the traversal is 
legal for the executing engine.
* Optimization - These strategies provide a more efficient way to express traversal
logic than the form original written.
* Finalization - These strategies make final internal adjustments after all other 
strategies are executed to ensure the traversal is ready for execution.

TinkerPop automatically registers a number of optimization, verification and 
finalization strategies by default. Graph database providers who implement TinkerPop
will usually have some strategies of those types to automatically register as well.
You would usually choose to add your own decoration strategies should your use case
call for one. We will discuss that in further detail momentarily, but let's first 
consider a basic optimization strategey and what it does to provide a more concrete
example. 

Let's assume that you write the following Gremlin, which calculates the degree of 
each vertex it encounters:

[source,groovy]
----
g.V().map(both().count())
----

This Gremlin will get you the count you seek, but it is a bit inefficient because it
chooses to count the adjacent vertices using 'both()' when it could simply count 
incident edges with 'bothE()' and achieve the same answer without requiring an extra
traversal to the vertex on the other side. It would have been better to write:

[source,groovy]
----
g.V().map(bothE().count())
----

As you work more with Gremlin, you will come to think in terms of those kinds of 
efficiencies, but Gremlin has a 'TraversalStrategy' for that called 
'AdjacentToIncidentStrategy' which will automatically rewrite the Gremlin you wrote 
in the first example to the one in the second when you execute it. Strategies like 
this one, and particularly ones registered automatically by the graph database you 
choose, can have a dramatic effect on the performance of your queries. Generally 
speaking you don't need to know much about what these types of strategies are doing,
or feel the need to remove any of the pre-registered strategies.

While those types of strategies aren't critical for most users to understand, it is 
definitely worth learning about decorative and some verification strategies. These
strategies offer actual features that can be automatically applied to a traversal 
that you write which will alter its behavior in ways that might be quite useful to
you. In the following sections, we will examine some of the more useful user-oriented
strategies provided by TinkerPop.

NOTE: Some strategies cannot work in remote contexts. 'EventStrategy' and 
'ElementIdStrategy' are two such strategies that will not work this way.

[[traversal-strategies-verification]]
Verification strategies
^^^^^^^^^^^^^^^^^^^^^^^

As a quick reminder, verification strategies validate the contents of a traversal to
ensure that it conforms with the strategies guidelines. If it does not, then it 
throws an exception rather than executing. The following strategies that TinkerPop 
provides tend to be useful:

* 'EdgeLabelVerificationStrategy' - ensures that labels are always used when using
'out()', 'in()' or 'both()' steps
* 'ReadOnlyStrategy' - ensures that the traversal contains no mutation steps that 
could modify the graph
* 'ReservedKeysVerificationStrategy' - ensures that certain strings are not use for
property keys, treating them as reserved words

[source,groovy]
----
verificationStrategy = EdgeLabelVerificationStrategy.build().
                                                     throwException().create()
// results in VerificationException - as out() does not have a label specified
g.withStrategies(verificationStrategy).V(1).out().iterate();

verificationStrategy = ReadOnlyStrategy.instance();
// results in VerificationException since a mutation step, addV(), is used
g.withStrategies(verificationStrategy).addV('airport').iterate();

// by default ReservedKeysVerificationStrategy blocks use of "id" and "label"
// which are commonly mistaken with T.id and T.label in Gremlin
verificationStrategy = ReservedKeysVerificationStrategy.build().
                                                        throwException().create()
// results in VerificationException since the "id" property key was used
g.withStrategies(verificationStrategy).addV('airport').property("id",123).iterate();
----

[[traversal-strategies-partition]]
PartitionStrategy
^^^^^^^^^^^^^^^^^

As its name suggests, 'PartitionStrategy' can be used to partition the graph into 
named groups that allow it to blind traversals from traveling to particular parts of
the graph. The key advantage to using 'PartitionStrategy' is that it automatically
handles the insertion of varous filter and mutation steps that would otherwise be
tedious to write and potentially easy to forget leading to mistakes. Moreover, the 
entire partitioning abstraction encapsulated in a strategy means that your Gremlin 
remains more readable in your code as the partition logic isn't applied until 
traversal execution time. 

For simplicity sake, let's look at an example of "PartitionStrategy' using an empty
graph and consider a multi-tenant scenario where there are two different users 
accessing the graph who should not be able to see the other's data. 

[source,groovy]
----
graph = TinkerGraph.open()

// create two partitions, one for each tenant. the "partitionKey" refers to the 
// property in the graph to use to store the partition value for tenant A or B.
// the "writePartition" is the value to assign to the "partitionKey" when writing
// to the graph and the "readPartition" is the set of values that the partition is
// allowed to see when reading from the graph. 
tenantA = new PartitionStrategy(partitionKey: "_partition", 
                                writePartition: "a", readPartitions: ["a"])
tenantB = new PartitionStrategy(partitionKey: "_partition", 
                                writePartition: "b", readPartitions: ["b"])

// create two instances of "g" each using a different strategy                                
gA = traversal().with(graph).withStrategies(strategyA)
gB = traversal().with(graph).withStrategies(strategyB)

gA.addV() // this vertex has a property of {_partition:"a"}
gB.addV() // this vertex has a property of {_partition:"b"}
gB.addV() // this vertex has a property of {_partition:"b"}


gA.V().count()

1

gB.V().count()

2
----

Let's look at how you would have written this same code if you didn't have 
'PartitionStrategy' and needed this sort of functionality.

[source,groovy]
----
graph = TinkerGraph.open()

g = traversal().with(graph)

g.addV().property('_partition', 'a')
g.addV().property('_partition', 'b')
g.addV().property('_partition', 'b')


g.V().has('_partition', 'a').count()

1

g.V().has('_partition', 'b').count()

2
----

As you can see in the above example, you would have to insert logic that was mostly 
irrelevant to what the traversal itself is doing. It isn't so hard in the example
where you just need to add a simple step or two, but consider a more complicated 
example and you can quickly see how useful this strategy can be if you have this 
use case.

[source,groovy]
----
// if air-routes was partitioned and you used PartitionStrategy, you could write
// normal Gremlin like this 
g.V().out('route')
  filter(bothE('route').count().is(lt(3))).
  union(both('route').has('code',within('AUS','TUS','YYZ')),
        bothE('route').has('dist', eq(100).otherV())).
  valueMap()

// but if you didn't have PartitionStrategy you'd have to write all the partitioning
// logic yourself in every query. you can see how much harder it is to read, requires
// more repetitive typing and might be error prone to write  
g.V().has('_partiition', 'a').
  out('route').has('_partiition', 'a')
  filter(bothE('route').has('_partiition', 'a').count().is(lt(3))).
  union(both('route').
          has('_partiition', 'a').
          has('code',within('AUS','TUS','YYZ')),
        bothE('route').
          has('_partiition', 'a').
          has('dist', eq(100).
          otherV().
          has('_partiition', 'a'))).
  valueMap()
----

NOTE: 'PartitionStrategy' is not always a fit for every situation. Standard rules 
about Gremlin and graphs still apply. For instance, a node with millions of edges, 
physically still has millions of edges even when using this strategy where you expect
to only use it to traverse a small fraction of those edges. The underlying graph 
database will really just be filtering those edges using the partition key, so you
query will still be limited to the speed with which it can do that.

[[traversal-strategies-seed]]
SeedStrategy
^^^^^^^^^^^^

'SeedStrategy' is mostly helpful when writing tests. Certain Gremlin features aren't 
determinisitic in what they do, which can make it hard to write good assertions for 
tests. By using 'SeedStrategy', you can ensure that 'coin()', 'sample()' and 
'Order.shuffle' will all behave in a deterministic fashion.

[source,groovy]
----
seedStrategy = new SeedStrategy(999998L) // specify the seed to reuse
g.withStrategies(seedStrategy).V().limit(10).values('code').
  fold().
  order(local).by(shuffle)
  
// repeated executions will always shuffle the same way to return the same result
[UET,DEA,GWD,LYP,PJG,MJD,RYK,DSK,CJL,GIL]
----  

[[traversal-strategies-subgraph]]
SubgraphStrategy
^^^^^^^^^^^^^^^^

'SubgraphStrategy' is quite similar to 'PartitionStrategy' and it would be worth
reading <<traversal-strategies-partition>> first to understand the benefits that are
discussed there as they are quite similar to the benefits gained here. As with 
'PartitionStrategy', 'SubgraphStrategy' is defined to blind traversals from traveling
to particular defined portions of the graph. Unlike 'PartitionStrategy' which 
restricts those places by way of a single property key, i.e. the "partitionKey", this
strategy allows you to define complex filtering rules using Gremlin itself to help 
define the subgraph that is available.

The basic idea for using `SubgraphStrategy` is to define filters for vertices, edges,
or vertex properties to constrain the traversal paths. As previously mentioned, you 
define the filters with Gremlin.

[source,groovy]
----
// define a subgraph that describes "short flights" where you only traverse
// routes with distances of less than 40 miles
strategy = new SubgraphStrategy(edges: __.has('dist',lt(40)))
g.withStrategies(strategy).V().out().count()

362

// extend the previous subgraph to include a subset of vertices, which now will limit
// queries to traverse edges under 40 miles and also among vertices in the specified
// set
strategy = new SubgraphStrategy(
                 vertices: __.has('code', within(['ADQ','OBU','SHG','AUK','KOT',
                                                  'KWK','RSH','RSH','PQS','PQS',
                                                  'KPN','IRC','AET','KWN','ORV',
                                                  'KGX','VAK','SGY','ANV','HNS',
                                                  'HNH','SVA','WMO','ELI','KSM',
                                                  'MNT','WBB','ANI','KYK','SKK'])),
                 edges: __.has('dist',lt(40)))
g.withStrategies(strategy).V().out().count()

7
----    

[[performance]]
Analyzing the performance of your queries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Apache TinkerPop includes a class called 'TimeUtil' that provides methods that you 
can use to time how long your queries are taking to run. A second class called
ProfileStep provides a way to get a more fine grained analysis of where the time is
spent during execution of a query. In this section, we are going to provide a few
examples of how to use the methods provided to analyze the execution time of a few
queries. We ran the tests on a laptop using the Gremlin Console with the 'air-routes'
data loaded into an in-memory TinkerGraph.

[[clock]]
Timing a query - introducing 'clock' and 'clockWithResult'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The 'TimeUtil' class provides several methods that can be used when working with
time. We are just going to focus on two of them, namely, 'clock' and
'clockWithResult'. These methods allow you to have a query run one or more times
while the execution time is tracked. After all iterations have completed, the average
time the query took in milliseconds is returned. Note that, especially for longer
queries, the time returned will not appear to be the same as if you tried to measure
the same 'clock' procedure using a stopwatch. This is because these methods both
perform a warm up pass before doing the actual timing. The warm up simply consists of
running the query one time before timing starts. This means that for a single timing
iteration, the 'human perceived time' will be roughly double the time returned by the
'clock' analysis. Let's take a look at a few examples.

Below is a very simple example of using a 'clock' step to measure the time it takes
to find all airport vertices in the graph that are in China. Note that the clock step
takes two parameters. The first is an integer telling it how many times to run the
query. The second is a query to execute wrapped in braces '"{...}"'. In other words a
closure. In the example below, the query is only run once as a parameter of 1 is
passed to the 'clock' method. From the result we can see that running this query one
time on our laptop took a bit more than 1.3 milliseconds.

[source,groovy]
----
clock(1) {g.V().has('airport','country','CN').next()}

1.364199
----

To get a more accurate assessment of how long a query takes it is sometimes a good
idea to average out the time over multiple attempts. This should reduce the impact of
any random system events from impacting your overall result. The example below
repeats the previous query but measures the average time taken across 100 iterations.
Note that, especially for longer running queries, the time returned will not be the
same as if you tried to time this process yourself using a stopwatch. This is because
the clock steps do a warm up pass before doing the actual testing. The warm up step
basically runs the query one time before it starts timing anything. This means that
for a single iteration the 'human perceived time' will be roughly double the time
returned by the 'clock' analysis. You can see from the results that when averaged
over 100 iteration the time taken is a bit less. You should not use these numbers as
hard and fast answers but rather use them to get a sense of in general how long a
query takes. If you repeated this test five times you would definitely get five
different results of a similar but not identical magnitude.

[source,groovy]
----
clock(100) {g.V().has('country','CN').next()}

0.70694013
----

Here is the same query run 1000 times just to verify that the timings stay more or
less the same.

[source,groovy]
----
clock(1000) {g.V().has('country','CN').next()}

0.6931818670000001
----

We have seen the following query before in the "<<sp>>" section. As you may recall it
finds 10 routes between Austin and Agra. Because there are not that many ways to get
to Agra this query requires a lot of graph traversals and so takes a while to
complete. Let's time how long it takes to execute this query one time.

[source,groovy]
----
clock(1){
    g.V().has('airport','code','AUS').
          repeat(out()).until(has('code','AGR')).
          limit(10).path().by('code').toList()}

4643.605562
----

As you can see it took quite a bit longer to run than our search for Chinese
airports. In fact it took well over 4 seconds to run. Let's run the same query 100
times and see what the average time taken looks like.

[source,groovy]
----
clock(100){
    g.V().has('airport','code','AUS').
          repeat(out()).until(has('code','AGR')).
          limit(10).path().by('code').toList()}

4816.6515936999995
----

So running the query 100 times gave a very similar result in this case. By way of an
interesting observation, notice the difference in time taken if we start in Agra and
look for routes to Austin. The average time over 100 iterations is less than 10
milliseconds. So we have uncovered an interesting possible optimization. Because
there are a lot more ways to get to Austin, finding 10 routes did not take very long.
This may not always be possible but keep in mind as you model your graph and design
your queries that where you start from can make a big difference!

[source,groovy]
----
clock(100){
   g.V().has('airport','code','AGR').
         repeat(out()).until(has('code','AUS')).
         limit(10).path().by('code').toList()}

9.068097369999998
----

You may have noticed that the 'clock' method only shows us the time that a query
takes to run and does not show us the actual result of running the query. This is
where the 'clockWithResult' method comes into play. We can reuse our 'airports in
China' query but this time notice that we also get the result of the query back.

[source,groovy]
----
clockWithResult(1) {g.V().has('country','CN').count().next()}

0.918276
209
----

If we run the 'Austin to Agra' query using 'clockWithResult' you can see that we do
indeed get the routes back as well as the timing.

[source,groovy]
----
clockWithResult(1){
    g.V().has('airport','code','AUS').
          repeat(out()).until(has('code','AGR')).
          limit(10).path().by('code').toList()}

4266.584279

[[AUS,YYZ,BOM,AGR],[AUS,LHR,BOM,AGR],[AUS,FRA,BOM,AGR],[AUS,EWR,BOM,AGR],[AUS,CLE,YYZ,BOM,AGR],[AUS,CLE,EWR,BOM,AGR],[AUS,OAK,EWR,BOM,AGR],[AUS,PHL,EWR,BOM,AGR],[AUS,PHL,YYZ,BOM,AGR],[AUS,PHL,LHR,BOM,AGR]]
----

Just for fun, the next four queries look for all the ways you can fly between Austin
(AUS) and Los Angeles (LAX) with zero, one, two or three stops. The query avoids any
routes that revisit Austin and uses 'simplePath' to avoid repeating the same route
twice. As you can see by the time we get to the last query, that takes three stops,
the query takes quite a bit of time to complete.

[source,groovy]
----
clockWithResult(1){
    g.V().has('code','AUS').as('a').
          repeat(out().where(neq('a'))).times(1).simplePath().
          has('code','LAX').path().by('code').count().next()}

1.698357
1
----

As you would expect, looking for routes with exactly one stop, does not take too long.

[source,groovy]
----
clockWithResult(1) {
    g.V().has('code','AUS').as('a').
          repeat(out().where(neq('a'))).times(2).simplePath().
          has('code','LAX').path().by('code').count().next()}

7.988092999999999
51
----

Looking for routes with exactly two stops takes quite a bit longer but is still
fairly fast.

[source,groovy]
----
clockWithResult(1) {
    g.V().has('code','AUS').as('a').
          repeat(out().where(neq('a'))).times(3).simplePath().
          has('code','LAX').path().by('code').count().next()}

435.423921
3389
----

As you can see by the time we get to the last query, that looks for exactly three 
stops, things take a lot longer to complete.


[source,groovy]
----
clockWithResult(1) {
    g.V().has('code','AUS').as('a').
          repeat(out().where(neq('a'))).times(4).simplePath().
          has('code','LAX').path().by('code').count().next()}

35295.633811
203359
----

Notice that for the 'clock' and 'clockWithResult' methods to work correctly you need
to end the query with a termination step such as 'next' or 'toList'. Alternatively
you can end the query with 'iterate'. In our testing, we found things did not always
work correctly when using 'iterate' so we tend to avoid it.

[[profile]]
Analyzing where time is spent - introducing 'profile'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You can use the 'profile' step to ask Gremlin to give you a more fine grained summary
of where the time is spent processing your query. Take a look at the example below.

[source,groovy]
----
g.V().has('region','US-TX').out().has('region','US-CA').
                            out().has('country','DE').profile()
----

After you run the query, instead of showing you the results, Gremlin will show you
where the time was spent processing the components of the query.

[source,console]
----
Step                                       Count  Traversers  Time (ms)    % Dur
===============================================================================
TinkerGraphStep(vertex,[region.eq(US-TX)])   26          26      1.810     9.71
VertexStep(OUT,vertex)                      701         701      0.877     4.70
HasStep([region.eq(US-CA)])                  47          47      0.561     3.01
VertexStep(OUT,vertex)                     3464        3464     12.035    64.54
NoOpBarrierStep(2500)                      3464         224      3.157    16.93
HasStep([country.eq(DE)])                    59           4      0.206     1.11
   >TOTAL                                     -           -     18.650        -
----

If we profile the 'Austin to Agra' query from the previous section you can see that
almost all the time was spent inside the 'repeat' loop looking for routes. In this
case that is not surprising but for more complex queries 'profile' can help you to
refine them.

[source,groovy]
----
g.V().has('airport','code','AUS').
      repeat(out()).until(has('code','AGR')).limit(10).
      path().by('code').profile()
----

Here is the 'profile' report. We truncated some of the text with '"..." so that it
will fit on a single page.

[source,console]
----
Step                              Count  Traversers       Time (ms)    % Dur
============================================================================
TinkerGraphStep(vertex,[~l...         1           1           2.125     0.02
RepeatStep([VertexStep(OUT,..        11          11        9357.962    99.97
  HasStep([code.eq(AGR)])                                  2627.621
  VertexStep(OUT,vertex)        1799981     1799981         509.392
  RepeatEndStep                      11          11        8848.030
RangeGlobalStep(0,10)                10          10           0.278     0.00
PathStep([value(code)])              10          10           0.126     0.00
   >TOTAL                             -           -        9360.493        -
----

[[tinkerindex]]
Introducing TinkerGraph indexes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TinkerGraph provides a rudimentary indexing capability but using it can still improve
overall performance of your queries. Two methods 'createIndex' and 'dropIndex' are
provided for creating and deleting indexes. Vertex and Edge properties can be indexed
as needed. A third method, 'getIndexedKeys' can be used to query what indexes have
been created. The example below runs the query we used in some of our prior tests
with and without an index being present for the 'code' vertex property.

[source,groovy]
----
clock(1){
    g.V().has('code','AUS').repeat(out().simplePath()).
          until(has('code','AGR')).limit(10).path().by('code').toList()}

2019.8820959999998
----

Let's now create an index for the 'code' property of every vertex and try the query
again. Note that 'Vertex' as used below is shorthand for 'Vertex.class'.

[source,groovy]
----
graph.createIndex('code',Vertex)

 clock(1){
     g.V().has('code','AUS').repeat(out().simplePath()).
           until(has('code','AGR')).limit(10).path().by('code').toList()}

1298.386245
----

We can query what indexes we have creates as follows.

[source,groovy]
----
graph.getIndexedKeys(Vertex)

code
----

Now let's drop the index.

[source,groovy]
----
graph.dropIndex('code',Vertex)
----

Because the air routes graph is small, a Vertex property index has little effect on
overall performance. However, as there are a lot more edges, perhaps creating an edge
property index could help some queries. Let's try an experiment. The following query
looks for all edges that have a 'dist' property of 1000.

[source,groovy]
----
clockWithResult(100) {g.E().has('dist',1000).count().next()}

9.80906926
24
----

Let's now create an index for the edge property called 'dist' and run the query
again. We can also, as before, check to see what edge indexes have been created.

[source,groovy]
----
graph.createIndex('dist',Edge)

graph.getIndexedKeys(Edge)

dist
----

This time you can see that our index has made a big difference.

[source,groovy]
----
clockWithResult(100) {g.E().has('dist',1000).count().next()}

0.046712609999999995
24
----

The timing difference between the two queries can be attributed to the index. In the
first case every edge in the graph (over 50,000 of them) had to be inspected. In the
second case the index was used to go directly to the edges with a 'dist' of 1000 and
no searching of all the edges was required. Note that the index only helps with exact
comparisons. A query such as the one below will not benefit from the index.

[source,groovy]
----
clockWithResult(100) {g.E().has('dist',gt(1000)).count().next()}

11.980037119999999
16430
----

Later on we will take a look at using an index with JanusGraph and look at external
indexing technologies such as Apache Solr and Elasticsearch that do support
more complex types of comparison predicates.

[[graphvars]]
Using graph variables to associate metadata with TinkerGraph
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A graph variable is a key/value pair that can be associated with a TinkerGraph.
Graph variables are not considered part of the graph that you would process with
Gremlin traversals but are in essence a way to associate metadata with a graph.
You can set and retrieve graph variables using the 'variables' method of the graph
object. Let's assume we wanted to add some metadata that allowed us to record who
the maintainer of the 'air-routes' graph is and when it was last updated. We could
do that as follows.

[source,groovy]
----
graph.variables().set('maintainer','Kelvin')
graph.variables().set('updated','July 18th 2017')
----

You can use any string that makes sense to you when naming your graph variable keys.
We can use the 'keys' method to retrieve the names of any keys currently in place as
graph variables.

[source,groovy]
----
graph.variables().keys()

updated
maintainer
----

The 'asMap' method will return any graph variables that are currently set as a map of
key/value pairs.

[source,groovy]
----
graph.variables().asMap()

updated=July 18th 2017
maintainer=Kelvin
----

We can use the 'get' method to retrieve the value of a particular key. Note that the
value returned is an instance of the 'java.util.Optional' class.

[source,groovy]
----
graph.variables().get('updated')

Optional[July 18th 2017]
----

If you want to delete a graph variable you can use the 'remove' method. In this next
example we will delete the 'maintainer' graph variable and re-query the variable map
to prove it has been deleted.

[source,groovy]
----
graph.variables().remove('maintainer')
graph.variables().asMap()

updated=July 18th 2017
----

[[olapoltp]]
OLTP vs OLAP
~~~~~~~~~~~~

When discussing graph processing two terms regularly come up. These terms are Online
Transaction Processing (OLTP) and Online Analytical Processing (OLAP). Most of the
queries we have looked at so far definitely fall into the OLTP category. Queries that
only look at a small part of a graph, often starting at a single node or a small
group of nodes and traversing out a few hops from there are considered OLTP
operations. Typically, an OLTP query takes a few seconds or less to run. They are
often used in response to a user query where an almost real time answer is needed.
Because the air routes graph is small - we can do even quite complex queries using
little more than a TinkerGraph and the Gremlin Console. This is not the case if your
graph contains billions of vertices and edges. That said, We have seen some OLTP type
queries, such as those looking for routes to remote airports, that can take
several minutes to run in the TinkerGraph environment.

NOTE: The TinkerPop documentation has in depth coverage of the various OLAP
capabilities that are supported.
http://tinkerpop.apache.org/docs/current/reference/#graphcomputer

Where OLAP comes into play is when you want to do detailed analysis across an entire
graph. This is especially true as graphs get large and require  powerful clusters of
nodes to underpin them. While OLTP queries typically take seconds or less, OLAP
queries can often take many minutes or even hours to complete.

Apache TinkerPop provides significant support for OLAP graph processing out of the
box and is designed to work well with distributed backend systems and software such
as Apache Spark and Apache Hadoop.

NOTE: While OLAP processing is typically done using powerful clusters, you can run
simple experiments using nothing more than a standalone in memory TinkerGraph.

Detailed coverage of doing OLAP processing is beyond the current scope of this book
but we are going to give a few simple examples below to at least provide a little
insight into what can be done. The TinkerPop documentation includes in depth coverage
of how to perform OLAP operations on a TinkerPop enabled graph and we recommend
reading it if you plan to perform OLAP style graph processing.

[[graphcomputer]]
Introducing the TinkerPop Graph Computer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A lot of new capability was added to the TinkerPop framework as part of the version 3
release. One such new capability is the concept of a 'Graph Computer'. In concrete
terms, GraphComputer is a Java interface that other TinkerPop classes implement to
provide the capability for different back end environments. Along with
'GraphComputer', the concept of a 'VertexProgram' is also introduced. Vertex Programs
allow us to specify the operations that we want to be performed across a graph,
potentially in conjunction with map reduce operations. TinkerPop comes with a set of
pre configured Vertex Programs and vertex program steps. Of course you can also write
your own.

One of the pre configured Vertex Programs is Page Rank. Let's take a look next at one
way it can be used.

[[translators]]
Translating Gremlin to different programming languages
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This book mostly focuses on writing Gremln in its Groovy syntax where it is easy to 
run inside of the Gremlin Console, which is a great convenience when learning or just
trying to work out a query. The Groovy syntax is actually quite close to the native
form of the Gremlin language. As most developers tend to write Gremlin in the 
language they are most comfortable, it isn't always well known that Gremlin has its 
own grammar that is used for parsing queries. For historical reasons, particularly 
where Gremlin long ago was wholly built on top of Groovy in versions prior to 
TinkerPop 3, the grammar for native Gremlin matches quite closely to Groovy's 
grammar. We refer to this native form of gremlin as 'gremlin-lang'.

The only time that you might encounter gremlin-lang is with Gremlin Server, which
uses the grammar by default to process queries. The grammar may also be used 
internally to TinkerPop-enabled graph systems that support the Gremlin Server 
protocols. Even in those cases, the Gremlin drivers hide that syntax away by 
translating the Gremlin you write in your programming language to the form expected 
by the grammar. If you are not using the drivers and are instead using raw HTTP 
requests, then you must write gremlin-lang yourself as a string to send to the 
server. When sending direct HTTP requests, it would be possible to use the drivers to
write Gremlin in your favorite programming langugage, get the gremlin-lang form and 
then manually submit that as a direct HTTP request, but it's hard to say what the 
benefit of that approach would be since the drivers are designed to hide that 
complexity from the application.

If you want to see the gremlin-lang form, you can get it from the traversal itself.
In the following example, we write our Gremlin in Groovy and then use its 
'gremlinLang' property (which is a shorthand for Java's 'getGremlinLang()') to get
the Gremlin native form after giving it the "g" representing the alias for the 
'GraphTraversalSource':

[source,groovy]
----
t = g.V().outE('knows');[]
t.gremlinLang.getGremlin("g")

g.V().outE("knows")
----

You can see in the prior example that gremlin-lang is not so different than Groovy.
The only difference is that the translation has normalized the single quotes to 
double quotes to define a string. That said, gremlin-lang can also equally accept 
single quotes for it string representation. The influence from Groovy on gremlin-lang
is evident here. We can see where the divergence from Groovy though with a slightly
longer example:

[source,groovy]
----
t = g.V().outE('knows').has('weight', 1 as byte);[]
t.gremlinLang.getGremlin("g")


g.V().outE("knows").has("weight",1B)
----

In Groovy, we define a 'byte' using the 'as' keyword. You can see in the translation
that gremlin-lang allows for a shorthand of a capital "B" suffix to the number to 
define a 'byte'. 

If you have gremlin-lang compliant Gremlin, you can translate it to any of the 
programming languages that TinkerPop supports using the 'GremlinTranslator'. This can
be helpful if you find an example written in a language you aren't familiar with and 
wish to convert it to one that you are. 

[source,groovy]
----
GremlinTranslator.translate("g.V().outE(\"knows\")", Translator.GO)

g.V().OutE("knows")
----

[[pagerank]]
Experiments with Page Rank
^^^^^^^^^^^^^^^^^^^^^^^^^^

Probably one of, if not the, most famous algorithms in the big data world is 'Page
Rank'. Originally developed at Google, the Page Rank algorithm was created as a way
to measure the relative importance of web pages. At a high level the algorithm looks
at the number of connections to a web page and the quality of those connections (as
in are they from a prominent place). That algorithm ports well to a graph database
environment as a graph, like the Web, is a heavily connected data structure. In our
graph database environment, we can use a page rank algorithm to assess a graph and
compute the likelihood in any given traversal that a particular vertex will get
visited. Although the new Graph Computer capabilities have been designed from the
ground up with distributed systems in mind, it is possible to use a stand a alone
TinkerGraph to experiment with a few of the capabilities.

The example below only assumes that you have a TinkerGraph running locally inside the
Gremlin Console with the 'air-routes' data loaded. You will notice a few differences
from the examples we have seen so far in this book. First of all, when we create our
graph traversal source object, we add a call to 'withComputer' to indicate that we
plan to be doing some things that require the Graph Computer capabilities. Having
created the traversal source we can setup our page rank. The query initially filters
out any vertex that is not an airport as will only want to rank airport vertices.
Next a call is made to the 'pageRank' step. The 'by' modulators tell the page rank
algorithm how we want the ranking done and what label to use for the ranking
results. In this case we want to look at outgoing 'route' edges and label all results
'r'. Before returning the results, we order based on descending ranking value.

[source,groovy]
----
// Page rank based on outgoing routes
g3 = traversal().with(graph).withComputer()

g3.V().hasLabel('airport').pageRank().by(outE('route')).by('r').
      order().by('r',desc).valueMap('code','r').limit(10)
----

Here is the output from running the page rank algorithm. The results show the airport
code along with the page rank value that was calculated.

[source,groovy]
----
[r:[15.527963207609702],code:[IST]]
[r:[15.005583346944613],code:[DFW]]
[r:[14.673184454287105],code:[ORD]]
[r:[14.365370693500969],code:[ATL]]
[r:[14.099719956639161],code:[PEK]]
[r:[14.061408826784106],code:[DXB]]
[r:[13.729782985109942],code:[DEN]]
[r:[13.552238441619048],code:[DME]]
[r:[13.502681833743711],code:[FRA]]
[r:[13.189393240835944],code:[CDG]]
----


Just as a point of reference, the query below finds the top 10 airports with the most
incoming routes.

[source,groovy]
----
g.V().hasLabel('airport').
      order().by(inE('route').count(),desc).limit(10).
      project('a','b').by('code').by(inE('route').count())
----

As you can see there is some correlation between the page rank results and the
airports with the most incoming routes which is perhaps not surprising. However,
notice that the page rank algorithm came up with some airports that a simple node
degree test did not come up with.

[source,groovy]
----
[a:FRA,b:282]
[a:AMS,b:275]
[a:IST,b:271]
[a:CDG,b:267]
[a:MUC,b:240]
[a:PEK,b:239]
[a:ORD,b:237]
[a:DXB,b:237]
[a:ATL,b:235]
[a:DFW,b:221]
----

The 'pageRank' step used in the prior query is a nice and convenient way for us to
quickly generate some rankings. However, it is important to understand how the query
would be written if we were to use the Graph Computer more directly and submit a
Vertex Program. You may find yourself taking this approach for your own custom 
'VertexProgram' implementations when working with a graph that supports OLAP in an
embedded mode. The example below sets up a 'PageRankVertexProgram' and runs it.
Notice that the result we get back includes a new graph with 3624 vertices and no
edges.

[source,groovy]
----
dcr = graph.compute().
      program(PageRankVertexProgram.build().
      edges(hasLabel('airport').outE('route')).
      create()).submit().get()

result[tinkergraph[vertices:3624 edges:0],memory[size:0]]
----

In case you are curious, we can check the precise type of the result object that is
returned from creating our vertex program.

[source,groovy]
----
dcr.getClass()

class org.apache.tinkerpop.gremlin.
      process.computer.util.DefaultComputerResult
----

Given the result we got back was a new graph we can create a new traversal and
inspect it. Notice that the Istanbul (IST) vertex in this graph contains an
additional property called 'gremlin.pageRankVertexProgram.pageRank'. This property
contains the page rank score that was returned for this vertex.

[source,groovy]
----
g2 = dcr.graph().traversal()

g2.V().has('code','IST').valueMap(true)

[id:161,country:[TR],code:[IST],longest:[9843],gremlin.pageRankVertexProgram.pageRank:[0.0047038762655771775],city:[Istanbul],lon:[28.8145999908],type:[airport],label:airport,elev:[163],icao:[LTBA],region:[TR-34],runways:[3],lat:[40.9768981934],desc:[Ataturk International Airport]]
----

Just to prove the original graph was untouched, let's check the IST vertex in that
graph. As you can see there are no new properties present.

[source,groovy]
----
g.V().has('code','IST').valueMap(true)

[id:161,country:[TR],code:[IST],longest:[9843],city:[Istanbul],lon:[28.8145999908],type:[airport],label:airport,elev:[163],icao:[LTBA],region:[TR-34],runways:[3],lat:[40.9768981934],desc:[Ataturk International Airport]]
----

Finally let's look at the 10 airports sorted by page rank score in descending order.
As you will observe, the scoring system is different but the selected airports are
the same as the ones returned by the in-line 'pageRank' step.

[source,groovy]
----
g2.V().order().by('gremlin.pageRankVertexProgram.pageRank',desc).limit(10).
       valueMap('code','gremlin.pageRankVertexProgram.pageRank')

[code:[IST],gremlin.pageRankVertexProgram.pageRank:[0.004594389373424941]]
[code:[DFW],gremlin.pageRankVertexProgram.pageRank:[0.004440623428637068]]
[code:[ORD],gremlin.pageRankVertexProgram.pageRank:[0.004342068075230758]]
[code:[ATL],gremlin.pageRankVertexProgram.pageRank:[0.004251005124367605]]
[code:[PEK],gremlin.pageRankVertexProgram.pageRank:[0.004172537469821617]]
[code:[DXB],gremlin.pageRankVertexProgram.pageRank:[0.004161183557641767]]
[code:[DEN],gremlin.pageRankVertexProgram.pageRank:[0.004063035588247088]]
[code:[DME],gremlin.pageRankVertexProgram.pageRank:[0.004009614722586433]]
[code:[FRA],gremlin.pageRankVertexProgram.pageRank:[0.003994862262812258]]
[code:[CDG],gremlin.pageRankVertexProgram.pageRank:[0.0039023184469861244]]
----

We have barely scratched the surface in this section on these new TinkerPop OLAP
capabilities. If this is an area that you are interested in we strongly recommend
reading the official TinkerPop reference documentation.



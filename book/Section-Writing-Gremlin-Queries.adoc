// vim: set tw=85 cc=+1 wrap spell redrawtime=20000:
[[gq]]
== WRITING GREMLIN QUERIES

Now that you hopefully have the 'air-routes' graph loaded it's time to start writing
some queries!

NOTE: Chapter 3 is focussed on queries that simply read from an existing graph. If
you are more interested in adding new vertices, edges and properties or modifying
existing properties you may want to jump to Chapter 4 and in particular the
"<<addnodes>>" section.

In this chapter we will begin to look at the Gremlin query language. We will start
off with a quick look at how Gremlin and SQL differ and are yet in some ways similar,
then present some fairly basic queries and finally get into some more
advanced concepts. Hopefully each set of examples presented, building upon things
previously discussed, will be easy to understand.

[[gremlinintro]]
=== Introducing Gremlin

Gremlin is the name of the graph traversal and query language that TinkerPop provides
for working with property graphs. Gremlin can be used with any graph store that is
Apache TinkerPop enabled. Gremlin is a fairly imperative language but also has some
more declarative constructs as well. Using Gremlin we can traverse a graph looking
for values, patterns and relationships, we can add or delete vertices and edges, we
can create sub-graphs, and lots more.

[[gremlinandsql]]
==== A quick look at Gremlin and SQL

While it is not required to know SQL in order to be productive with Gremlin, if you
do have some experience with SQL you will notice many of the same keywords and
phrases being used in Gremlin. As a simple example the SQL and Gremlin examples below
both show how we might count the number of airports there are in each country using
firstly a relational database and secondly a property graph.

When working with a relational database, we might decide to store all of the airport
data in a single table called 'airports'. In a very simple case (the air-routes
graph actually stores a lot more data than this about each airport) we could setup
our airports table so that it had entries for each airport as follows.

[source,text]
----
ID   CODE  ICAO  CITY             COUNTRY
---  ----  ----  ---------------  ----------
1    ATL   KATL  Atlanta          US
3    AUS   KAUS  Austin           US
8    DFW   KDFW  Dallas           US
47   YYZ   CYYZ  Toronto          CA
49   LHR   EGLL  London           UK
51   CDG   LFPG  Paris            FR
52   FRA   EDDF  Frankfurt        DE
55   SYD   YSSY  Sydney           AU
----

We could then use a SQL query to count the distribution of airports in each country 
as follows.

[source,sql]
----
SELECT country,count(country) FROM airports GROUP BY country;
----

We can do this in Gremlin using the 'air-routes' graph with a query like the one 
below (We will explain what all of this means later on in the book).

[source,groovy]
----
g.V().hasLabel('airport').groupCount().by('country')
----

You will discover that Gremlin provides its own flavor of several constructs that you
will be familiar with if you have used SQL before, but again, prior knowledge of SQL
is in no way required to learn Gremlin.

One thing you will not find when working with a graph using Gremlin is the concept of
a SQL 'join'. Graph databases by their very nature avoid the need to join things
together (as things that need to be connected already are connected) and this is a
core reason why, for many use cases, graph databases are a very good choice and can
be more performant than relational databases.

Graph databases are usually a good choice for storing and modelling networks. The
'air-routes' graph is an example of a network graph. A social network is of course
another good example. Networks can be modelled using relational databases too but as
you explore the network and ask questions like "who are my friends' friends?" in a
social network or "where can I fly to from here with a maximum of two stops?" things
rapidly get complicated and result in the need for multiple 'joins'.

As an example, imagine adding a second table to our relational database called
routes. It will contain three columns representing the source airport, the
destination airport and the distance between them in miles (SRC,DEST and DIST). It
would contain entries that looked like this (the real table would of course have
thousands of rows but this gives a good idea of what the table would look like).

[source,text]
----
SRC  DEST  DIST
---  ----  ----
ATL  DFW   729
ATL  FRA   4600
AUS  DFW   190
AUS  LHR   4901
BOM  AGR   644
BOM  LHR   4479
CDG  DFW   4933
CDG  FRA   278
CDG  LHR   216
DFW  FRA   5127
DFW  LHR   4736
LHR  BOM   4479
LHR  FRA   406
YYZ  FRA   3938
YYZ  LHR   3544
----

If we wanted to write a SQL query to calculate the ways of travelling from Austin
(AUS) to Agra (AGR) with two stops, we would end up writing a query that looked
something like this:

[source,sql]
----
SELECT a1.code,r1.dest,r2.dest,r3.dest FROM airports a1
  JOIN routes r1 ON a1.code=r1.src
  JOIN routes r2 ON r1.dest=r2.src
  JOIN routes r3 ON r2.dest=r3.src
  WHERE a1.code='AUS' AND r3.dest='AGR';
----

Using our 'air-routes' graph database the query can be expressed quite simply as
follows:

[source,groovy]
----
g.V().has('code','AUS').out().out().out().has('code','AGR').path().by('code')
----

Adding or removing hops is as simple as adding or removing one or more of the 'out'
steps which is a lot simpler than having to add additional 'join' clauses to our SQL
query. This is a simple example, but as queries get more and more complicated in
heavily connected data sets like networks, the SQL queries get harder and harder to
write whereas, because Gremlin is designed for working with this type of data,
expressing a traversal remains fairly straightforward.

We can go one step further with Gremlin and use 'repeat' to express the concept of
'three times' as follows.

[source,groovy]
----
g.V().has('code','AUS').repeat(out()).times(3).has('code','AGR').path().by('code')
----

Gremlin also has a 'repeat ... until' construct that we will see used later in this
book. When combined with the 'emit' step, 'repeat' provides a nice way of getting
back any routes between a source and destination no matter how many hops it might
take to get there.

Again, don't worry if some of the Gremlin steps shown here are confusing, we will
cover them all in detail a bit later. The key point to take away from this discussion
of SQL and Gremlin is that for data that is very connected, graph databases provide a
very good way to store that data and Gremlin provides a nice and fairly intuitive way
to traverse that data efficiently.

One other point worthy of note is that every vertex and every edge in a graph has a
unique ID. Unlike in the relational world where you may or may not decide to give a
table an ID column this is not optional with graph databases. In some cases the ID
can be a user provided ID but more commonly it will be generated by the graph system
when a vertex or edge is first created. If you are familiar with SQL, you can think
of the ID as a primary key of sorts if you want to. Every vertex and edge can be
accessed using its ID. Just as with relational databases, graph databases can be
indexed and any of the properties contained in a vertex or an edge can be added to
the index and can be used to find things efficiently. In large graph deployments this
greatly speeds up the process of finding things as you would expect. We look more
closely at IDs in the "<<wid>>" section.

[[bq]]
=== Some fairly basic Gremlin queries

A graph 'query' is often referred to as a 'traversal' as that is what we are in fact
doing. We are traversing the graph from a starting point to an ending point.
Traversals consist of one or more 'steps' (essentially methods) that are chained
together.

As we start to look at some simple traversals, here are a few 'steps' that you will
see used a lot. Firstly, you will notice that almost all traversals start with either
a 'g.V()' or a 'g.E()'. Sometimes there will be parameters specified along with those
steps but we will get into that a little later. You may remember from when we looked
at how to load the 'air-routes' graph in Section 2 we used the following instruction
to create a graph traversal source object for our loaded 'graph'.

[source,groovy]
----
g = traversal().with(graph)
----

Once we have a graph traversal source object we can use it to start exploring the 
graph. The 'V' step returns vertices and the 'E' step returns edges. You can also use
a 'V' step in the middle of a traversal as well as at the start but we will examine 
those uses a little later. The 'V' and 'E' steps can also take parameters indicating 
which set of vertices or edges we are interested in. That usage is explained in the 
"<<wid>>" section.

TIP: If it helps with remembering you can think of 'g.V()' as meaning "looking at all
of the vertices in the graph" and 'g.E()' as meaning "looking at all of the edges in 
the graph". We then add additional steps to narrow down our search criteria.

The other steps we need to introduce are the 'has' and 'hasLabel' steps. They can be
used to test for a certain label or property having a certain value. We will
encounter a lot of different Gremlin steps as we explore various Gremlin queries
throughout the book, including many other forms of the 'has' step, but these few are
enough to get us started.

You can refer to the official Apache TinkerPop documentation for full details on all
of the graph traversal steps that are used in this tutorial. With this tutorial
we have not tried to teach every possible usage of every Gremlin step and method,
rather, We have tried to provide a good and approachable foundation in writing many
different types of Gremlin query using an interesting and real-world graph.

NOTE: The latest TinkerPop documentation is always available at this URL:
https://tinkerpop.apache.org/docs/current/reference/

Below are some simple queries against the 'air-routes' graph to get us started. It is
assumed that the 'air-routes' graph has been loaded already per the instructions 
above. The query below will return any vertices (nodes) that have the 'airport' 
label.

[source,groovy]
----
// Find vertices that are airports
g.V().hasLabel('airport')
----

This query will return the vertex that represents the Dallas Fort Worth (DFW)
airport.

[source,groovy]
----
// Find the DFW vertex
g.V().has('code','DFW')
----

The next two queries combine the previous two into a single query. The first one just
chains the queries together. The second shows a form of the 'has' step that we have
not looked at before that takes an additional label value as its first parameter.

[source,groovy]
----
// Combining those two previous queries (two ways that are equivalent)
g.V().hasLabel('airport').has('code','DFW')

g.V().has('airport','code','DFW')
----

Here is what we get back from the query. Notice that this is the Gremlin Console's 
way of telling us we got back the 'Vertex' with an ID of 8.

[source,groovy]
----
v[8]
----

So, what we actually got back from these queries was a TinkerPop 'Vertex' data
structure. Later in this book we will look at ways to store that value into a
variable for additional processing. Remember that even though we are working with a
Groovy environment while inside the console, everything we are working with here, at
its core, is Java code. So we can use the 'getClass' method from Java to introspect 
the object. Note the call to 'next' which turns the result of the traversal into an
object we can work with further.

[source,groovy]
----
g.V().has('airport','code','DFW').next().getClass()

class org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerVertex
----

The 'next' step that we used above is one of a series of steps that the TinkerPop
documentation describes as 'terminal steps'. We will see more of these 'terminal
steps' in use throughout this book. As mentioned above, a terminal step
essentially ends the graph traversal and returns a concrete object that you can work
with further in your application. We will see 'next' and other related steps used in
this way when we start to look at using Gremlin from a standalone program a bit
later on. We could even add a call to 'getMethods()' at the end of the query above to
get back a list of all the methods and their types supported by the 'TinkerVertex'
class. If you'd like to jump ahead to learn more about terminal steps you can see
more examples in the "<<var>>" section.

[[values]]
==== Retrieving property values from a vertex

There are several different ways of working with vertex properties. We can add,
delete and query properties for any vertex or edge in the graph. We will explore each
of these topics in detail over the course of this book. Initially, let's look at
a couple of simple ways that we can look up the property values of a given vertex.

[source,groovy]
----
// What property values are stored in the DFW vertex?
g.V().has('airport','code','DFW').values()
----

Here is the output that the query returns. Note that we just get back the values of
the properties when using the 'values' step, we do not get back the associated keys.
We will see how to do that later in the book.

[source,groovy]
----
US
DFW
13401
Dallas
607
KDFW
-97.0380020141602
airport
US-TX
7
32.896800994873
Dallas/Fort Worth International Airport
----

The 'values' step can take parameters that tell it to only return the values for
the provided key names. The queries below return the values of some specific
properties.

[source,groovy]
----
// Return just the city name property
g.V().has('airport','code','DFW').values('city')

Dallas

// Return the 'runways' and 'icao' property values.
g.V().has('airport','code','DFW').values('runways','icao')

KDFW
7
----

[[exist]]
==== Does a specific property exist on a given vertex or edge?

You can simply test to see if a property exists as well as testing for it containing
a specific value. To do this we can just provide 'has' with the name of the property
we are interested in. This works equally well for both vertex and edge properties.

[source,groovy]
----
// Find all edges that have a 'dist' property
g.E().has('dist')

// Find all vertices that have a 'region' property
g.V().has('region')

// Find all the vertices that do not have a 'region' property
g.V().hasNot('region')

// The above is shorthand for
g.V().not(has('region'))
----

[[count]]
==== Counting things

A common need when working with graphs is to be able to count how "many of something"
there are in the graph. We will look in the next section at other ways to count
groups of things but first of all let's look at some examples of using the 'count'
step to count how many of various things there are in our 'air-routes' graph. First 
of all lets find out how many vertices in the graph represent airports.

[source,groovy]
----
// How many airports are there in the graph?
g.V().hasLabel('airport').count()

3504
----

Now, looking at edges that have a 'route' label, let's find out how many flight
routes are stored in the graph. Note that the 'outE' step looks at outgoing edges. In
this case we could also have used the 'out' step instead. The various ways that you
can look at outgoing and incoming edges is discussed in the "<<walk>>" section that
is coming up soon.

[source,groovy]
----
// How many routes are there?
g.V().hasLabel('airport').outE('route').count()

50637
----

You could shorten the above a little as follows but this would cause more edges to 
get looked at as we do not first filter out all vertices that are not airports.

[source,groovy]
----
// How many routes are there?
g.V().outE('route').count()

50637
----

You could also do it this way but generally starting by looking at all the Edges in
the graph is considered bad form as property graphs tend to have a lot more edges
than vertices.

[source,groovy]
----
// How many routes are there?
g.E().hasLabel('route').count()

50637
----

We have not yet looked at the 'outE' step used above. We will look at it very soon
however in the "<<walk>>" section.

[[countgroup]]
==== Counting groups of things

Sometimes it is useful to count how many of each type (or group) of things there are
in the graph. This can be done using the 'group' and 'groupCount' steps. While for a
very large graph it is not recommended to run queries that look at all of the
vertices or all of the edges in a graph, for smaller graphs this can be quite useful.
For the air-routes graph we could easily count the number of different vertex and
edge types in the graph as follows.

[source,groovy]
----
// How many of each type of vertex are there?
g.V().groupCount().by(label)
----

If we were to run the query we would get back a map where the keys are label names
and the values are the counts for the occurrence of each label in the graph.

[source,groovy]
----
[continent:7,country:237,version:1,airport:3504]
----

There are other ways we could write the query above that will yield the same result.
One such example is shown below.

[source,groovy]
----
// How many of each type of vertex are there?
g.V().label().groupCount()

[continent:7,country:237,version:1,airport:3504]
----

We can also run a similar query to find out the distribution of edge labels in the
graph. An example of the type of result we would get back is also shown.

[source,groovy]
----
// How many of each type of edge are there?
g.E().groupCount().by(label)

[contains:7008,route:50637]
----

As before we could rewrite the query as follows.

[source,groovy]
----
// How many of each type of edge are there?
g.E().label().groupCount()

[contains:7008,route:50637]
----

By way of a side note, the examples above are shorthand ways of writing
something like this example which also counts vertices by label.

[source,groovy]
----
// As above but using group()
g.V().group().by(label).by(count())

[continent:7,country:237,version:1,airport:3504]
----

NOTE: There are often a number of different ways to write Gremlin that will obtain
the same result. See the <<idiomaticgremlin>> Section for more details.

We can be more selective in how we specify the groups of things that we want to
count. In the examples below we first count how many airports there are in each
country. This will return a map of key:value pairs where the key is the country code
and the value is the number of airports in that country. As the fourth and fifth
examples show, we can use 'select' to pick just a few values from the whole group
that got counted. Of course if we only wanted a single value we could just count the
airports connected to that country directly but the last two examples are intended to
show that you can count a group of things and still selectively only look at part of
that group.

[source,groovy]
----
// How many airports are there in each country?
g.V().hasLabel('airport').groupCount().by('country')

// How many airports are there in each country? (look at country first)
g.V().hasLabel('country').group().by('code').by(out().count())
----

We can easily find out how many airports there are in each continent using 'group' to
build a map of continent codes and the number of airports in that continent. The
output from running the query is shown below also.

[source,groovy]
----
// How many airports are there in each continent?
g.V().hasLabel('continent').group().by('code').by(out().count())

[EU:605,AS:971,NA:989,OC:305,AF:321,AN:0,SA:313]
----

These queries show how 'select' can be used to extract specific values from the map
that we have created. Again you can see the results we get from running the query.

[source,groovy]
----
// How many airports are there in France (having first counted all countries)
g.V().hasLabel('airport').groupCount().by('country').select('FR')

59

// How many airports are there in France, Greece and Belgium respectively?
g.V().hasLabel('airport').groupCount().by('country').select('FR','GR','BE')

[FR:59,GR:39,BE:5]
----

The 'group' and 'groupCount' steps are very useful when you want to count
groups of things or collect things into a group using a selection criteria. You
will find a lot more examples of grouping and counting things in the section called
"<<countmore>>".

[[walk]]
=== Starting to walk the graph

So far we have mostly just explored queries that look at properties on a vertex or
count how many things we can find of a certain type. Where the power of a graph
really comes into play is when we start to 'walk' or 'traverse' the graph by looking
at the connections (edges) between vertices. The term 'walking the graph' is used to
describe moving from one vertex to another vertex via an edge. Typically when using
the phrase 'walking a graph' the intent is to describe starting at a vertex
traversing one or more vertices and edges and ending up at a different vertex or
sometimes, back where you started in the case of a 'circular walk'. It is very easy
to traverse a graph in this way using Gremlin. The journey we took while on our
'walk' is often referred to as our 'path'. There are also cases when all you want to
do is return edges or some combination of vertices and edges as the result of a query
and Gremlin allows this as well. We will explore a lot of ways to modify the way a
graph is traversed in the upcoming sections.

The table below gives a brief summary of all the steps that can be used to 'walk' or
'traverse' a graph using Gremlin. You will find all of these steps used in various
ways throughout the book. Think of a graph traversal as moving through the graph from
one place to one or more other places. These steps tell Gremlin which places to move
to next as it traverses a graph for you.

In order to better understand these steps it is worth defining some terminology. One
vertex is considered to be 'adjacent' to another vertex if there is an edge
connecting them. A vertex and an edge are considered 'incident' if they are
connected to each other.

.Where to move next while traversing a graph
[cols="^1,4"]
|==============================================================================
|out   * | Outgoing adjacent vertices.
|in    * | Incoming adjacent vertices.
|both  * | Both incoming and outgoing adjacent vertices.
|outE  * | Outgoing incident edges.
|inE   * | Incoming incident edges.
|bothE * | Both outgoing and incoming incident edges.
|outV    | Outgoing vertex.
|inV     | Incoming vertex.
|otherV  | The vertex that was not the vertex we came from.
|==============================================================================

Note that the steps labelled with an '*' can optionally take the name of one or more
edge labels as a parameter. If omitted, all relevant edges will be traversed.

==== Some simple graph traversal examples

To get us started, in this section we will look at some simple graph traversal
examples that use some of the steps that were just introduced. The 'out' step is
used to find vertices connected by an outgoing edge to that vertex and the 'outE'
'step' is used when you want to examine the outgoing edges from a given vertex.
Conversely the 'in' and 'inE' steps can be used to look for incoming vertices and
edges. The 'outE' and 'inE' steps are especially useful when you want to look at the
properties of an edge as we shall see in the "<<exedge>>" section. There are several
other steps that we can use when traversing a graph to move between vertices and
edges. These include 'bothE', 'bothV' and 'otherV'. We will encounter those in the
"<<otherv>>" section.

So let's use a few examples to help better understand these graph traversal steps.
The first query below does a few interesting things. Firstly we find the vertex
representing the Austin airport (the airport with a property of 'code' containing the
value 'AUS'). Having found that vertex we then go 'out' from there. This will find
all of the vertices connected to Austin by an outgoing edge. Having found those
airports we then ask for the values of their 'code' properties using the 'values'
step. Finally the 'fold' step puts all of the results into a list for us. This just
makes it easier for us to inspect the results in Gremlin Console.

[source,groovy]
----
// Where can I fly to from Austin?
g.V().has('airport','code','AUS').out().values('code').fold()
----

Here is what you might get back if you were to run this query in your console.

[source,groovy]
----
[PHL,PDX,DTW,OKC,ONT,CLT,CUN,MEM,CVG,IND,MCI,DAL,STL,ABQ,MKE,MDW,OMA,TUL,PVR,NAS,LIT,
 JAX,PVD,SMF,BHM,SDF,BUF,BOI,LBB,ECP,HRL,RNO,CMH,DSM,CZM,AMA,BTR,CHS,GDL,GRR,LIR,PNS,
 SJD,TYS,VPS,XNA,HDN,SFB,BUR,ASE,BZN,BKG,PIE,ATL,BNA,BOS,BWI,DCA,DFW,FLL,IAD,IAH,JFK,
 LAX,MCO,MIA,MSP,ORD,PHX,RDU,SEA,SFO,SJC,TPA,SAN,LGB,SNA,SLC,LAS,DEN,SAT,YYZ,HNL,YVR,
 MSY,LHR,EWR,LGW,HOU,FRA,ELP,AMS,CLE,YYC,OAK,MEX,TUS,PIT]
----

All edges in a graph have a label. However, one thing we did not do in the previous
query was specify a label for the 'out' step. If you do not specify a label you will
get back any connected vertex regardless of its edge label. In this case it does not
cause us a problem as airports only have one type of outgoing edge, labeled 'route'.
However, in many cases, in graphs you create or are working with, your vertices may 
be connected to other vertices by edges with differing labels so it is good practice
to get into the habit of specifying edge labels as part of your Gremlin queries. So 
we could change our query just a bit by adding a label reference on the 'out' step 
as follows.

[source,groovy]
----
// Where can I fly to from Austin?
g.V().has('airport','code','AUS').out('route').values('code').fold()
----

Despite having just stated that consistently using edge labels in queries is a good
idea, unless you truly do want to get back all edges or all connected vertices,
We will break our own rule quite a bit in this book. The reason for this is purely to
save space and make the queries we present shorter.

Here are a few more simple queries similar to the previous one. The first example can
be used to answer the question "Where can I fly to from Austin, with one stop on the
way?". Note that, as written, coming back to Austin will be included in the results
as this query does not rule it out!

[source,groovy]
----
// Where can I fly to from Austin, with one stop on the way?
g.V().has('airport','code','AUS').out('route').out('route').values('code')
----

This query uses an 'in' step to find all the routes that come into the London City
Airport (LCY) and returns their IATA codes.

[source,groovy]
----
// What routes come in to LCY?
g.V().has('airport','code','LCY').in('route').values('code')
----

This query is perhaps a bit more interesting. It finds all the routes from London
Heathrow airport in England that go to an airport in the United States and returns
their IATA codes.

[source,groovy]
----
// Flights from London Heathrow (LHR) to airports in the USA
g.V().has('code','LHR').out('route').has('country','US').values('code')
----

[[pathintro]]
==== What vertices and edges did I visit? - Introducing 'path'

A Gremlin method (often called a step) that you will see used a lot in this book is
'path'. After you have done some graph walking using a query you can use 'path' to
get a summary back of where you went. A simple example of a 'path' step being used is
shown below. Throughout the book you will see numerous examples of 'path' being used
including in conjunction with one or more 'by' steps to specify how the path result
should be formatted.

This particular query will return the vertices and outgoing edges starting at the
London City (LCY) airport vertex. You can read this query like this: "Start at the
LCY vertex, find all outgoing edges and also find all of the vertices that are on the
other ends of those edges". The 'inV' step gives us the vertex at the other end of
the outgoing edge.

[source,groovy]
----
// This time, for each route, return both vertices and the edge that connects them.
g.V().has('airport','code','LCY').outE().inV().path()
----

If you run that query as-is you will get back a series of results that look
like this. This shows that there is a route from vertex 88 to vertex 77 via an
edge with an ID of 15142.

[source,groovy]
----
[v[88],e[15142][88-route->77],v[77]]
----

While this result is useful, we might want to return something more human readable
such as the IATA codes for each airport and perhaps the distance property from the
edge that tells us how far apart the airports are. We could add some 'by' modulators
to our query to do this. The Apache TinkerPop documentation uses the phrase
'modulator' to describe steps that are not really independent steps but instead alter
the behavior of the steps that they are associated with.

TIP: A 'modulator' is a step that influences the behavior of the step that it is
associated with. Examples of such modulator steps are 'by' and 'as'.

Take a look at the modified form of the query shown below and an example of the
results that it will now return. If this is not fully clear yet don't panic. Both
'path' and 'by' are used a lot throughout this book.

[source,groovy]
----
g.V().has('airport','code','LCY').outE().inV().
      path().by('code').by('dist')
----

When you run this modified version of the query, you will receive a set of results
that look like the following line.

[source,groovy]
----
[LCY,456,GVA]
----

The 'by' modulator steps are processed in a round-robin fashion. If there are not
enough modulators specified for the total number of elements in the path, Gremlin
just loops back around to the first 'by' step and so on. So even though there were
three elements in the path that we wanted to have formatted, we only needed to
specify two 'by' modulators. This is because the first and third elements in the path
are of the same type, namely airport vertices and we wanted to use the same property
name, 'code', in each of those cases. If we instead wanted to reference a different
property name for each element of the path result, we would need to specify three
explicit 'by' modulator steps. This would be required if, for example, we wanted to
reference the 'city' property of the third element in the path rather than its
'code'.

TIP: The 'by' modulator steps are processed in a round-robin fashion in cases where
there are more results to apply them to than the number of 'by' modulators specified.

The example above is equivalent to this longer form of the same query.

[source,groovy]
----
g.V().has('airport','code','LCY').outE().inV().
      path().by('code').by('dist').by('code')
----

The example below shows a case where three different 'by' modulators are used. This
time the third 'by' modulator step references the 'city' property rather than the
airport 'code'. As you can see from the sample output, this time the city name
'Geneva' appears rather than the airport code 'GVA'.

[source,groovy]
----
g.V().has('airport','code','LCY').outE().inV().
      path().by('code').by('dist').by('city')

[LCY,456,Geneva]
----

Sometimes it is necessary to use a 'by' modulator that has no parameter as shown
below. This is because the element in the path is not a vertex or edge containing 
multiple properties but rather a single value, in this case, an integer.

[source,groovy]
----
g.V().has('airport','code','LCY').out().limit(5).
      values('runways').
      path().by('code').by('code').by()
----

The results show the codes for the airports we visited along with a number
representing the number of runways the second airport has.

[source,groovy]
----
[LCY,CDG,4]
[LCY,FRA,4]
[LCY,DUB,2]
[LCY,FCO,3]
[LCY,AMS,6]
----

It is also possible to use a traversal inside of a 'by' modulator. Such traversals
are known as '"anonymous traversals"' and they are discussed in greater details in
the "<<deepdivetraversals>>" section.

For now, it is enough to know that they allow us to do things like combine multiple
values together as part of a path result. The example below finds five routes that
start in Austin and creates a path result containing the airport code and city name
for both the source and destination airports. In this case, the anonymous traversal
contained within the 'by' modulator is applied to each element in the path.

[source,groovy]
----
g.V(3).out().limit(5).path().by(values('code','city').fold())

[[AUS,Austin],[PHL,Philadelphia]]
[[AUS,Austin],[PDX,Portland]]
[[AUS,Austin],[DTW,Detroit]]
[[AUS,Austin],[OKC,Oaklahoma City]]
[[AUS,Austin],[ONT,Ontario]]
----

To demonstrate that just about any arbitrary traversal can be placed inside the 'by'
modulator here is one more example that counts the number of outgoing routes for the
source and destination airports as part of generating the 'path' result.

[source,groovy]
----
g.V(3).out().limit(5).path().by(outE().count())

[98,147]
[98,80]
[98,145]
[98,33]
[98,23]
----

[[pathfromto]]
==== Modifying a 'path' using 'from' and 'to' modulators

The 'from' and 'to' modulators for the 'path' step enables us to not return the
entire path of a traversal but instead to be more selective.

First of all, look at the example below. In this case we have just used the same
'path' constructs used in the prior examples. The query returns the first 10 routes
found starting at Austin (AUS) with one stop on the way.

[source,groovy]
----
g.V().has('airport','code','AUS').out().out().path().by('code').limit(10)
----

As expected the results show each airport that was visited.

[source,groovy]
----
[AUS,PHL,SXM]
[AUS,PHL,RIC]
[AUS,PHL,LEX]
[AUS,PHL,ISP]
[AUS,PHL,SWF]
[AUS,PHL,DSM]
[AUS,PHL,MYR]
[AUS,PHL,CAE]
[AUS,PHL,CHA]
[AUS,PHL,CHS]
----

Given that every journey starts in Austin, we might not actually want the AUS airport
code to be part of the returned results. We might just want to capture the places 
that we ended up visiting after leaving Austin. This can be achieved by labelling the
parts of the traversal that we care about using 'as' steps and then using 'from' and
'to' modulators to tell the 'path' step what we are interested in. Take a look at the
modified version of the query below.

[source,groovy]
----
g.V().has('airport','code','AUS').out().as('a').out().as('b').
      path().by('code').from('a').to('b').limit(10)
----

This time AUS is not included in the 'path' results.

[source,groovy]
----
[PHL,SXM]
[PHL,RIC]
[PHL,LEX]
[PHL,ISP]
[PHL,SWF]
[PHL,DSM]
[PHL,MYR]
[PHL,CAE]
[PHL,CHA]
[PHL,CHS]
----
Because after skipping the AUS part of the path we did in fact want the rest of the
results we could have left off the 'to' modulator and written the query as follows.

[source,groovy]
----
g.V().has('airport','code','AUS').out().as('a').out().
      path().by('code').from('a').limit(10)
----

As you can see the results are the same as before.

[source,groovy]
----
[PHL,SXM]
[PHL,RIC]
[PHL,LEX]
[PHL,ISP]
[PHL,SWF]
[PHL,DSM]
[PHL,MYR]
[PHL,CAE]
[PHL,CHA]
[PHL,CHS]
----

Obviously there are a lot of ways that 'from' and 'to' can be used. By way of one
final example, let's create a version of the query with three 'out' steps. Note that
a bit later we will see how 'repeat' can be used when the same steps need to be used
repeatedly like this but that is not important to this specific example.

[source,groovy]
----
g.V().has('airport','code','AUS').out().out().out().
      path().by('code').limit(10)
----

As expected we now have an additional stop added to each of the journeys.

[source,groovy]
----
[AUS,PHL,SXM,NEV]
[AUS,PHL,SXM,AXA]
[AUS,PHL,SXM,EIS]
[AUS,PHL,SXM,EUX]
[AUS,PHL,SXM,SAB]
[AUS,PHL,SXM,ATL]
[AUS,PHL,SXM,BOS]
[AUS,PHL,SXM,FLL]
[AUS,PHL,SXM,IAD]
[AUS,PHL,SXM,JFK]
----

Let's now modify the query to limit which parts of the path are returned.

[source,groovy]
----
g.V().has('airport','code','AUS').out().as('a').out().as('b').out().
      path().by('code').from('a').to('b').limit(10)
----

As you can see, only the parts of the journey that we selected have been returned.

[source,groovy]
----
[PHL,SXM]
[PHL,SXM]
[PHL,SXM]
[PHL,SXM]
[PHL,SXM]
[PHL,SXM]
[PHL,SXM]
[PHL,SXM]
[PHL,SXM]
[PHL,SXM]
----

We could also have written the query as shown below to only show the results of each
path up to a certain point.

[source,groovy]
----
g.V().has('airport','code','AUS').out().out().as('b').out().
      path().by('code').to('b').limit(10)
----

This time only the first three airports visited are included in each result.

[source,groovy]
----
[AUS,PHL,SXM]
[AUS,PHL,SXM]
[AUS,PHL,SXM]
[AUS,PHL,SXM]
[AUS,PHL,SXM]
[AUS,PHL,SXM]
[AUS,PHL,SXM]
[AUS,PHL,SXM]
[AUS,PHL,SXM]
[AUS,PHL,SXM]
----

By way of a side note, in cases like this where more than one of the results is
identical, you may want to remove the duplicates. That is where the 'dedup' step is
useful. You will find coverage of 'dedup' in the "<<dedup>>" section. However, as a
little taste test, let's add a 'dedup' step to the end of our previous query and see
what happens.

[source,groovy]
----
g.V().has('airport','code','AUS').out().out().as('b').out().
      path().by('code').to('b').limit(10).dedup()

[AUS,PHL,SXM]
----

As you can see all of the duplicate results have now been removed. Hopefully this
gives you a good basic understanding of the 'path' step. You will see it used a lot
throughout the remainder of this book. However, there are a few things to be aware of
when using 'path'. Those concerns are explained in the "<<pathwarn>>" section a bit
later.

[[edgeexist]]
Does an edge exist between two vertices?
You can use the 'hasNext' step to check if an edge exists between two vertices and
get a Boolean (true or false) value back. The first query below will return
*true* because there is an edge (a route) between AUS and DFW. The second
query will return *false* because there is no route between AUS and SYD.

[source,groovy]
----
g.V().has('code','AUS').out('route').has('code','DFW').hasNext()

true

g.V().has('code','AUS').out('route').has('code','SYD').hasNext()

false
----

[[aselproj]]
==== Using 'as', 'select' and 'project' to refer to traversal steps

Sometimes it is useful to be able to remember a point of a traversal by giving it a
name (label) and refer to it later on in the same query. The query below uses an
'as' step to attach a label at two different parts of the traversal, each
representing different vertices that were found. A 'select' step is later used to
refer back to them.

[source,groovy]
----
g.V().has('code','DFW').as('from').out().
      has('region','US-CA').as('to').
      select('from','to')
----

This query, while a bit contrived, and in this case probably a poor substitute for
using 'path', returns the following results.

[source,groovy]
----
[from:v[8],to:v[151]]
[from:v[8],to:v[181]]
[from:v[8],to:v[244]]
[from:v[8],to:v[384]]
[from:v[8],to:v[605]]
[from:v[8],to:v[865]]
[from:v[8],to:v[872]]
[from:v[8],to:v[877]]
[from:v[8],to:v[13]]
[from:v[8],to:v[23]]
[from:v[8],to:v[24]]
[from:v[8],to:v[26]]
[from:v[8],to:v[28]]
[from:v[8],to:v[42]]
----

In the example above only the vertices themselves were selected. We can also use a
'by' modulator to specify which property to retrieve from the selected
vertices.

[source,groovy]
----
g.V().has('code','DFW').as('from').out().
      has('region','US-CA').as('to').
      select('from','to').by('code')
----

This time the results contain the airport codes.

[source,groovy]
----
[from:DFW,to:ONT]
[from:DFW,to:PSP]
[from:DFW,to:SMF]
[from:DFW,to:FAT]
[from:DFW,to:BUR]
[from:DFW,to:BFL]
[from:DFW,to:MRY]
[from:DFW,to:SBA]
[from:DFW,to:LAX]
[from:DFW,to:SFO]
[from:DFW,to:SJC]
[from:DFW,to:SAN]
[from:DFW,to:SNA]
[from:DFW,to:OAK]
----

While the prior example was perhaps not ideal, it does show how 'as' and 'select'
work. For completeness, here is the same query but using 'path'. You will see both
the 'select' and 'path' steps used a lot throughout this book.

[source,groovy]
----
g.V().has('code','DFW').out().
      has('region','US-CA').
      path().by('code')
----

Which would produce the following results. Notice that this time the results do not
have labels associated with them but are otherwise the same.

[source,groovy]
----
[DFW,ONT]
[DFW,PSP]
[DFW,SMF]
[DFW,FAT]
[DFW,BUR]
[DFW,BFL]
[DFW,MRY]
[DFW,SBA]
[DFW,LAX]
[DFW,SFO]
[DFW,SJC]
[DFW,SAN]
[DFW,SNA]
[DFW,OAK]
----

While the 'path' step is a lot more convenient, in some cases it can be very
expensive in terms of memory and CPU usage so it is worth remembering these
alternative techniques using 'as' and 'select'. That topic is discussed in more
detail in the "<<pathwarn>>" section.

You can also give a point of a traversal multiple names and refer to each later on in
the traversal/query as shown below.

[source,groovy]
----
g.V().has('type','airport').limit(10).as('a','b','c').
      select('a','b','c').
        by('code').by('region').by(out().count())
----

The 'project' step can achieve the same results as obtained from the combination of 
'as' and 'select' steps. The example below shows the previous query, rewritten to use
'project' instead of 'as' and 'select'.

[source,groovy]
----
g.V().has('type','airport').limit(10).
      project('a','b','c').
        by('code').by('region').by(out().count())
----

This query, and the prior query, would return the following results.

[source,groovy]
----
[a:ATL,b:US-GA,c:242]
[a:ANC,b:US-AK,c:41]
[a:AUS,b:US-TX,c:98]
[a:BNA,b:US-TN,c:75]
[a:BOS,b:US-MA,c:143]
[a:BWI,b:US-MD,c:91]
[a:DCA,b:US-DC,c:96]
[a:DFW,b:US-TX,c:253]
[a:FLL,b:US-FL,c:158]
[a:IAD,b:US-VA,c:158]
----

In the prior example we gave our variables simple names like 'a' and 'b'. However, it
is sometimes useful to give our traversal variables and named steps more meaningful
names and it is perfectly OK to do that. Let's rewrite the query to use some more
descriptive variable names.

[source,groovy]
----
g.V().has('type','airport').limit(10).
      project('IATA','Region','Routes').
        by('code').by('region').by(out().count())
----

When we run the modified query, here is the output we get.

[source,groovy]
----
[IATA:ATL,Region:US-GA,Routes:242]
[IATA:ANC,Region:US-AK,Routes:41]
[IATA:AUS,Region:US-TX,Routes:98]
[IATA:BNA,Region:US-TN,Routes:75]
[IATA:BOS,Region:US-MA,Routes:143]
[IATA:BWI,Region:US-MD,Routes:91]
[IATA:DCA,Region:US-DC,Routes:96]
[IATA:DFW,Region:US-TX,Routes:253]
[IATA:FLL,Region:US-FL,Routes:158]
[IATA:IAD,Region:US-VA,Routes:158]
----

The 'project' step can be applied to inputs other than graph elements. It can 
actually operate on any incoming traverser. For example, when 'project' follows 
'valueMap' the incoming traverser is a 'Map' object. 

[source,groovy]
----
g.V().has('code','IAD').valueMap().
  project('r','ct').by('runways').by(count(local))

[r:[4],ct:12]
----

The prior example shows how 'project' can access the "runways" key and count the 
number of entries in the 'Map'.

[[bymodulators]]
==== Traits of 'by' modulators

We've seen enough use of the 'by' modulator now to dive deeper on their general 
behavior. As we learned earlier, a 'by' modulator is a form of step that influences
the behavior of the step that it is associated with. Moreover, The 'by' modulators
are processed in a round-robin fashion in cases where there are more results to apply
them to than the number of 'by' modulators specified.

In addition to those basic definitions, there are some other points worth exploring.
First, let's take a look at the list of steps that support 'by' modulation, as 'by'
cannot be used on all steps:

[cols="1,1,1,1"]
|==============================================================================
|'aggregate' |'cyclicPath' |'dedup' |'group'
|'groupCount' |'math' |'order' |'path'
|'project' |'propertyMap' |'sack' |'sample'
|'select' |'simplePath' |'store' |'tree'
|'valueMap' |'where' | |
|==============================================================================

Next, let's revisit some usage with 'by' where it is commonly used with 'path' and
'project'.

[source,groovy]
----
g.V().has('airport','code','AUS').
  out().out().
  path().by('code').
  limit(10)
  
[AUS,PHL,SXM]
[AUS,PHL,RIC]
[AUS,PHL,LEX]
[AUS,PHL,ISP]
[AUS,PHL,SWF]
[AUS,PHL,DSM]
[AUS,PHL,MYR]
[AUS,PHL,CAE]
[AUS,PHL,CHA]
[AUS,PHL,CHS]

g.V().has('type','airport').limit(10).
      project('a','b','c').
        by('code').
        by('region').
        by(outE().count())
        
[a:ATL,b:US-GA,c:242]
[a:ANC,b:US-AK,c:41]
[a:AUS,b:US-TX,c:98]
[a:BNA,b:US-TN,c:75]
[a:BOS,b:US-MA,c:143]
[a:BWI,b:US-MD,c:91]
[a:DCA,b:US-DC,c:96]
[a:DFW,b:US-TX,c:253]
[a:FLL,b:US-FL,c:158]
[a:IAD,b:US-VA,c:158]
----

In both of the prior examples, the 'by' modulators were 'productive' which means that
when the 'by' is used by the modulated step, it generates a result. When the 'by'
does not emit a result it is said to be 'unproductive' and introduces an important
aspect of Gremlin semantics. Let's modify the first example with 'path' to make it
unproductive by introducing a mistype to the property key and referring to it as 
'"cde"' instead of '"code"':

[source,groovy]
----
g.V().has('airport','code','AUS').
  out().out().
  path().by('cde').
  limit(10)

// no results  
----

The prior example returns no results. The unproductive 'by' to 'path' forces it to 
behave a bit like a filter. Since 'path' can't use '"cde"' to access a valid property
key, it simply drops that traverser to prevent an error. Now, let's modify the second
example to make it unproductive for some cases, particularly those where the number 
of outgoing edges is less than 100:

[source,groovy]
----
g.V().has('type','airport').limit(10).
      project('a','b','c').
        by('code').
        by('region').
        by(outE().count().is(gt(100)))

[a:ATL,b:US-GA,c:101]
[a:ANC,b:US-AK]
[a:AUS,b:US-TX]
[a:BNA,b:US-TN]
[a:BOS,b:US-MA,c:101]
[a:BWI,b:US-MD]
[a:DCA,b:US-DC]
[a:DFW,b:US-TX,c:101]
[a:FLL,b:US-FL,c:101]
[a:IAD,b:US-VA,c:101]
----

As you can see the 'project' step will not emit a key for '"c"' when a modulator is
unproductive. Each step will have its own semantics for what it does with an
unproductive 'by', but typically there is a form of filtering operation that occurs
akin to what we've seen in the prior example. We will see more examples of 'by' 
introducing these kinds of behaviors as we learn new steps in future sections.

Let's look an another example with 'path' where the 'by' modulator is not productive.

[source,groovy]
----
g.V().has('airport','code','AUS').
  outE().inV().outE().inV().
  path().by('dist').
  limit(10).
  sum(local)

// no results  
----

The above example is similar to the earlier one but expands the path Gremlin travels
to include 'Edge' objects. In this case, the query seeks to sum the value of dist 
properties on edges in the path. The 'Vertex' objects will not have a dist property
key and therefore be unproductive. One way to change that is to ensure that vertices
produce a value with their 'by' modulator, by supplying a 'constant(0)' for those 
cases.

[source,groovy]
----
g.V().has('airport','code','AUS').
  outE().inV().outE().inV().
  path().
    by(constant(0)).
    by('dist').
  limit(10).
  sum(local)

3102
1628
1948
1559
1557
2399
1904
1952
2069
1980
----

With that small adjustment, vertices in the path can produce a '0' integer value
which can be summed with the dist property value from the edges.

[[multias]]
==== Using multiple 'as' steps with the same label

It is actually possible using an 'as' step to give more than one part of a traversal
the same label (name). In the example below, the label '+++'+++a+++'+++' is used
twice but you will notice that when the label is selected only the last item added is
returned.

[source,groovy]
----
g.V(1).as('a').V(2).as('a').select('a')

v[2]
----

There are some special keywords that can be used in conjunction with the 'select'
step in cases like this one. These keywords are 'first', 'last' and 'all' and their
usage is shown below.

[source,groovy]
----
g.V(1).as('a').V(2).as('a').select(first,'a')

v[1]

g.V(1).as('a').V(2).as('a').select(last,'a')

v[2]

g.V(1).as('a').V(2).as('a').select(all,'a')

[v[1],v[2]]
----

Here is another example of a query that labels two different parts of a traversal
with the same '+++'+++a+++'+++' label. As you can see from the results, only the
second one is used because of the 'last' keyword that is provided on the 'select'
step.

[source,groovy]
----
g.V().has('code','AUS').as('a').
      out().as('a').limit(10).
      select(last,'a').by('code').fold()

[PHL,PDX,DTW,OKC,ONT,CLT,CUN,MEM,CVG,IND]
----

Here is the same query but using the 'first' keyword this time as part of the
'select' step.

[source,groovy]
----
g.V().has('code','AUS').as('a').
      out().as('a').limit(10).
      select(first,'a').by('code').fold()

[AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS]
----

Note that when the same name is used to label a step, the data structure created by
Gremlin is essentially a List. As such, the 'by' modulator cannot be used when the
'all' keyword is used on the 'select' step. To get the values of each element in the
list we can use an 'unfold' step as shown below.

[source,groovy]
----
g.V().has('code','AUS').as('a').
      out().as('a').limit(10).
      select(all,'a').unfold().values('code').fold()

[AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS,AUS,
 PHL,PDX,DTW,OKC,ONT,CLT,CUN,MEM,CVG,IND]
----

Keywords such as 'all', 'first' and 'last' are discussed further in the
"<<javastatics>>" section later on in the book.

[[pathselect]]
==== Returning selected parts of a path

Sometimes, even using the 'from' and 'to' modulating steps along with a 'path' step
will not give you the results you are interested in. Using a 'select' step and some
'as' steps in a similar way to the example in the previous section we can select
specific parts of a traversal's "path". Consider the query below that finds a route
from Los Angeles (LAX) and returns the path.

[source,groovy]
----
g.V().has('code','LAX').
      out().
      out().
      out().
      out().
      out().
      limit(1).
      path().by('code')

[LAX,BER,SVG,KSU,OSL,BOS]
----

Now, imagine we want to just return every other stop as the result from our query.
The example below shows how to do just that.

[source,groovy]
----
g.V().has('code','LAX').
      out().as('stop').
      out().
      out().as('stop').
      out().
      out().as('stop').
      limit(1).
      select(all,'stop').
      unfold().
      values('code').fold()

[BER,KSU,BOS]
----

[[exedge]]
==== Examining the edge between two vertices

Sometimes, it is the edge between two vertices that we are interested in examining
and not the vertices themselves. Typically this is because we want to look at one or
more properties associated with that edge. By way of an example, let's imagine we
wanted to know how many miles the flight is between Miami (MIA) and Dallas Fort Worth
(DFW). In our air-routes graph, the distances between vertices are stored using a
property called 'dist' on any edge that has a 'route' label. We can use the 'outE'
and 'inV' steps to find the edge connecting Miami and Dallas. We can also use the
'select' and 'as' steps that we just learned about to help with this task. Take a
look at the query below. This will find the outgoing 'route' edge from MIA to DFW,
store it in the traversal variable 'e' and at the end of the query use 'select' to
return it as the result of the query.

[source,groovy]
----
g.V().has('code','MIA').outE().as('e').inV().has('code','DFW').select('e')
----

If we were to run the query, we would get back something similar to this

[source,groovy]
----
e[4266][16-route->8]
----

So we found the 'route' edge that connects the vertex with an ID of 16 (MIA) with the
airport that has an ID of 8 (DFW). While interesting, this is not exactly what we set
out to achieve. What we actually are interested in is the distance property of that
edge so we can see how far it is from Miami to Dallas Fort Worth. We need to add one
additional step to our query that will look at the 'dist' property of the edge. Let's
modify our query to do that.

[source,groovy]
----
g.V().has('code','MIA').outE().as('e').
      inV().has('code','DFW').select('e').values('dist')
----

If we run the query again we get back what we were looking for. We can see that it is
1,120 miles from Miami to Dallas Fort Worth.

[source,groovy]
----
1120
----

As a side note, we could have written the query using 'inE' and 'outV' and achieved
the same result by looking at the edge from Dallas to Miami.

[source,groovy]
----
g.V().has('code','MIA').inE().as('e').
      outV().has('code','DFW').select('e').values('dist')

1120
----

Throughout the remainder of the book you will find lots of examples that use steps
such as 'outE', 'inE', 'outV' and 'inV'.

[[limit]]
=== Limiting the amount of data returned

It is sometimes useful, especially when dealing with large graphs, to limit
the amount of data that is returned from a query. As shown in the examples
below, this can be done using the 'limit' and 'tail' steps. A little later in
this book we also introduce the 'coin' step that allows a pseudo random
sample of the data to be returned.

[source,groovy]
----
// Only return the FIRST 20 results
g.V().hasLabel('airport').values('code').limit(20)

// Only return the LAST 20 results
g.V().hasLabel('airport').values('code').tail(20)
----

Depending upon the implementation, it is probably more efficient to write the
query like this, with 'limit' coming before 'values' to guarantee fewer airports
are initially returned but it is also possible that an implementation would
optimize both the same way.


[source,groovy]
----
// Only return the FIRST 20 results
g.V().hasLabel('airport').limit(20).values('code')
----

Note that 'limit' provides a shorthand alternative to 'range'. The first of
the two examples above could have been written as follows.

[source,groovy]
----
// Only return the FIRST 20 results
g.V().hasLabel('airport').range(0,20).values('code')
----

We can also limit a traversal by specifying a maximum amount of time that it is
allowed to run for. The following query is restricted to a maximum limit of ten
milliseconds. The query looks for routes from Austin (AUS) to London Heathrow (LHR).
All the parts of this query are explained in detail later on in this book but we
think what they do is fairly clear. The 'repeat' step is explained in detail in the
"<<sp>>" section.

[source,groovy]
----
// Limit the query to however much can be processed within 10 milliseconds
g.V().has('airport','code','AUS').
      repeat(timeLimit(10).out()).until(has('code','LHR')).path().by('code')
----

Here is what the query above returned when run on our laptop.

[source,groovy]
----
[AUS,LHR]
[AUS,PHL,LHR]
[AUS,PDX,LHR]
[AUS,DTW,LHR]
[AUS,CLT,LHR]
[AUS,NAS,LHR]
----

If we give the query another 10 milliseconds to run, so 20 in total, you can see that
a few more routes were found.

[source,groovy]
----
// Limit the query to 20 milliseconds
g.V().has('airport','code','AUS').
      repeat(timeLimit(20).out()).until(has('code','LHR')).path().by('code')

[AUS,LHR]
[AUS,PHL,LHR]
[AUS,PDX,LHR]
[AUS,DTW,LHR]
[AUS,CLT,LHR]
[AUS,NAS,LHR]
[AUS,CHS,LHR]
[AUS,ATL,LHR]
[AUS,BNA,LHR]
[AUS,BOS,LHR]
[AUS,BWI,LHR]
[AUS,DFW,LHR]
----

[[retrrange]]
==== Retrieving a range of vertices

Gremlin provides various ways to return a sequence of vertices. We have already seen
the 'limit' and 'range' steps used in the previous section to return the first 20
elements of a query result. We can also use the 'range' step to select different
range of vertices by giving a non zero starting offset and an ending offset. The
'range' offsets are zero based, and while the official documentation states that the
ranges are inclusive/inclusive it actually appears from our testing that they are
inclusive/exclusive.

[source,groovy]
----
// Return the first two airport vertices found
g.V().hasLabel('airport').range(0,2)

v[1]
v[2]
----

The starting value given to a 'range' step does not have to be '0'. In the example
below we ask for the 3rd, 4th and 5th results found by specifying a range of
'"(3,6)"'.

[source,groovy]
----
// Return the fourth, fifth and sixth airport vertices found (zero based)
g.V().hasLabel('airport').range(3,6)

v[4]
v[5]
v[6]
----

Here is an example of how we can use the index '-1' to mean '"until the end of the
list"'. This is similar to the convention used in many programming languages when
working with arrays and list.

[source,groovy]
----
// Return all the remaining vertices starting at the 3500th one
g.V().range(3500,-1)
----

Here is another example that uses the 'range' step, this time looking only at
vertices with a label of 'country'. Notice how this time we found vertices with much
higher ID values.

[source,groovy]
----
g.V().hasLabel('country').range(0,2)

v[3505]
v[3506]
----

NOTE: There is no guarantee as to which airport vertices will be selected as this
depends upon how they are stored by the back end graph. Using TinkerGraph the
airports will most likely come back in the order they are put into the graph. This is
not likely to be the case with other graph stores such as JanusGraph. So do not rely
on any sort of expectation of order when using 'range' to process sets of vertices.

You can use 'skip' step as an alternative to 'range' in some cases. The 'skip'
step can be used whenever you would otherwise use 'range' where the second
parameter would be '-1' meaning "all remaining".

The two examples below will produce the same results.

[source,groovy]
----
g.V().has('region','US-TX').skip(5).fold()

g.V().has('region','US-TX').range(5,-1).fold()
----

Here is the output you might get from running either query.

[source,groovy]
----
[v[39],v[186],v[273],v[278],v[289],v[314],v[356],v[357],v[358],v[361],v[368],
 v[370],v[390],v[394],v[404],v[405],v[423],v[426],v[428],v[1118],v[3313],v[3416]]
----

To prove that the 'skip' and 'range' steps used above worked again, we can run the
query again with 'skip' removed and look at the results. You will notice, the first
five vertices listed were not included as part of the results from the prior
queries.

[source,groovy]
----
g.V().has('region','US-TX').fold()

[v[3],v[8],v[11],v[33],v[38],v[39],v[186],v[273],v[278],v[289],v[314],v[356],v[357],
 v[358],v[361],v[368],v[370],v[390],v[394],v[404],v[405],v[423],v[426],v[428],
 v[1118],v[3313],v[3416]]
----

You can also use the 'local' keyword to have 'skip' work on an incoming collection
within a traversal. The example below, while contrived, applies skip to the list
generated by the 'fold' step.

[source,groovy]
----
g.V().has('region','US-TX').fold().skip(local,3)

[v[33],v[38],v[39],v[186],v[273],v[278],v[289],v[314],v[356],v[357],v[358],v[361],
 v[368],v[370],v[390],v[394],v[404],v[405],v[423],v[426],v[428],v[1118],v[3313],
 v[3416]]
----

There are many other ways to specify a range of values using Gremlin. You will find
several additional examples in the "<<tranges>>" section.

==== Working with the end of a stream

When we want to take items from the end of the stream, we typicaly use the 'tail' 
step. With 'tail' you specify the number of elements to take from the end of the 
stream.

[source,groovy]
----
g.V().has('airport','code', within('IAD','DAL','JFK','DCA','DFW')).
  order().by('code').
  tail(1).
  values('code').fold()

[JFK]

g.V().has('airport','code', within('IAD','DAL','JFK','DCA','DFW')).
  order().by('code').
  tail(2).
  values('code').fold()

[IAD,JFK]
----

In the prior examples, we use 'order' to ensure consistent results for purpose of 
demonstration and you often must use 'order' in your own query writing to achieve the
same, but note that if you are using 'order', it might be better to rewrite the first 
as follows:

[source,groovy]
----
g.V().has('airport','code', within('IAD','DAL','JFK','DCA','DFW')).
  order().by('code',desc).
  limit(1).
  values('code').fold()
  
[JFK]
----

By using a 'desc' order, we can move JFK to the front of our stream and simply take
the first item it encounters, which likely speeds up the query considerably as most
graph databases should optimize the 'order' and we likely spare Gremlin from having
to iterate the entire stream to get to the last item with 'tail'. Depending upon your
requirements, you might find that you could use the same tactic for the second query
but note that the results have a slight difference.

[source,groovy]
----
g.V().has('airport','code', within('IAD','DAL','JFK','DCA','DFW')).
  order().by('code',desc).
  limit(2).
  values('code').fold()

[JFK,IAD]
----

In the prior example you can see that we get the same two results, but they are in
reversed order. You would have to reverse the 'order' to get the same result as the
first query. In these examples, we are dealing with a small dataset with a small set
of five results so the performance implications are not big for either approach, but
for larger scales you may find yourself making choices with these patterns that can 
have significant impact.

Sometimes you may find that you want to take the second to last item in the stream.
Finding the penultimate element of the stream just means taking the first item found
in the list of the last two:

[source,groovy]
----
g.V().has('airport','code', within('IAD','DAL','JFK','DCA','DFW')).
  order().by('code').
  tail(2).limit(1).
  values('code').fold()
  
[IAD]
----

Gremlin does not have a step for getting all elements of the stream except for the
last one. The following pattern allows you to do this by using 'store' to hold the
'tail' of the stream, which you can then use later to filter it away.

[source,groovy]
----
g.V().has('airport','code', within('IAD','DAL','JFK','DCA','DFW')).
  order().by('code').
  fold().
  sideEffect(tail(local).unfold().
             local(aggregate('t'))).
  unfold().where(neq('t')).by().by(unfold()).
  values('code').fold()
  
[DAL,DCA,DFW,IAD]
----

The pattern demonstrated in the prior examples shows how flexible Gremlin can be. 
With a solid command of the steps Gremlin offers and a clever application of them you
can accomplish a great many things. 

[[dedup]]
=== Removing duplicates - introducing 'dedup'

It is often desirable to remove duplicate values from query results. The 'dedup' step
allows us to do this. If you are already familiar with Groovy collections, the
'dedup' step is similar to the 'unique' method that Groovy provides. In the example
below, the number of runways for every airport in England is queried. Note that in
the returned results there are many duplicate values.

[source,groovy]
----
g.V().has('region','GB-ENG').values('runways').fold()

[2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,2,1,3,1,3,3,4,1,1]
----

If we only wanted a set of unique values in the result we could rewrite the query to
include a 'dedup' step. This time the query results only include one of each value.

[source,groovy]
----
g.V().has('region','GB-ENG').values('runways').dedup().fold()

[2,1,3,4]
----

It is also possible to use a 'by' modulator to specify how 'dedup' should be applied.
In the example below we only return one airport for each unique number of runways.

[source,groovy]
----
g.V().has('region','GB-ENG').dedup().by('runways').
      values('code','runways').fold()

[LHR,2,LCY,1,BLK,3,LEQ,4]
----

There is one more form of the 'dedup' step. In this form, one or more strings
representing labelled steps are provided as parameters. Take a look first of all at
the query below. It finds vertex 'V(3)' and labels it '+++'+++a+++'+++'. It then
finds vertex 'V(4)' and labels it '+++'+++c+++'+++'. Next it finds all the vertices
connected to V(4) and labels those '+++'+++b+++'+++'. Only the first 10 are
retrieved. Lastly a 'select' step is used to return the results. As expected vertices
3 and 4 are present in all of the results.

[source,groovy]
----
g.V(3).as('a').V(4).as('c').both().as('b').limit(10).
  select('a','b','c')

[a:v[3],b:v[1],c:v[4]]
[a:v[3],b:v[3],c:v[4]]
[a:v[3],b:v[5],c:v[4]]
[a:v[3],b:v[6],c:v[4]]
[a:v[3],b:v[7],c:v[4]]
[a:v[3],b:v[8],c:v[4]]
[a:v[3],b:v[9],c:v[4]]
[a:v[3],b:v[10],c:v[4]]
[a:v[3],b:v[11],c:v[4]]
[a:v[3],b:v[12],c:v[4]]
----

Taking the same query but adding a 'dedup' step that references the '+++'+++a+++'+++'
and '+++'+++c+++'+++' labels, removes all duplicate references that include those
vertices from the results so this time even though a 'limit' of 10 is used we only
actually get one result back.

[source,groovy]
----
g.V(3).as('a').V(4).as('c').both().as('b').limit(10).
  dedup('a','c').select('a','b','c')

[a:v[3],b:v[1],c:v[4]]
----

A bit later we will take a look at the concept of 'local' scope when working with
traversals. There are some examples of 'local' scope being used in conjunction with
'dedup' in the "<<localcollect>>" section.

It is also possible to use 'sets' to achieve similar results as we shall see in some
of the following sections such as the "<<setsandlists>>" section that is coming up
soon.

[[vm]]
=== Using 'valueMap' to explore the properties of a vertex or edge

A call to 'valueMap' will return all of the properties of a vertex or edge as an
array of key:value pairs. Basically what in Java terms is called a HashMap. You can
also select which properties you want 'valueMap' to return if you do not want them
all. Each element in the map can be addressed using the name of the key. By default
the ID and label are not included in the map unless a parameter of 'true' is
provided.

The query below will return the keys and values for all properties associated with
the Austin airport vertex.

[source,groovy]
----
// Return all the properties and values the AUS vertex has
g.V().has('code','AUS').valueMap().unfold()
----

If you are using the Gremlin Console, the output from running the previous command
should look something like this. The unfold step at the end of the query is used
to make the results easier to read.

[source,groovy]
----
country=[US]
code=[AUS]
longest=[12250]
city=[Austin]
elev=[542]
icao=[KAUS]
lon=[-97.6698989868164]
type=[airport]
region=[US-TX]
runways=[2]
lat=[30.1944999694824]
desc=[Austin Bergstrom International Airport]
----

NOTE: Notice how each key, like 'country', is followed by a value that is returned as
an element of a list. This is because it is possible (for vertices but not for edges)
to provide more than one property value for a given key by encoding them as a list or
as a set. We discuss how to better control this output in the paragraphs that follow.

Here are some more examples of how 'valueMap' can be used. If a parameter of 'true'
is provided, then the results returned will include the ID and label of the element
being examined.

[source,groovy]
----
// If you also want the ID and label, add a parameter of true
g.V().has('code','AUS').valueMap(true).unfold()

id=3
label=airport
country=[US]
code=[AUS]
longest=[12250]
city=[Austin]
elev=[542]
icao=[KAUS]
lon=[-97.6698989868164]
type=[airport]
region=[US-TX]
runways=[2]
lat=[30.1944999694824]
desc=[Austin Bergstrom International Airport]
----

You can also mix use of 'true' along with requesting the map for specific properties.
The next example will just return the ID, label and 'region' property.

[source,groovy]
----
// If you want the ID, label and a specific field like the region, you can do this
g.V().has('code','AUS').valueMap(true,'region')

[id:3,region:[US-TX],label:airport]
----

TIP: If you only need the keys and values for specific properties to be returned it
is recommended to pass the names of those properties as parameters to the 'valueMap'
step so it does not return a lot more data than you need. Think of this as the
difference, in the SQL world, between selecting just the columns you are interested
in from a table rather than doing a 'SELECT *'.

As shown above, you can specify which properties you want returned by supplying their
names as parameters to the 'valueMap' step. For completeness, it is worth noting
that you can also use a 'select' step to refine the results of a 'valueMap'.

[source,groovy]
----
// You can 'select' specific fields from a value map
g.V().has('code','AUS').valueMap().select('code','icao','desc')

[code:[AUS],icao:[KAUS],desc:[Austin Bergstrom International Airport]]
----

As an additional example of Gremlin's flexibility, note that you can also restrict 
the selected keys to all but those you specify.

[source,groovy]
----
 g.V('3').valueMap().as('vm').unfold().
   filter(select(keys).is(without('city','desc')))

country=[US]
code=[AUS]
longest=[12250]
elev=[542]
icao=[KAUS]
lon=[-97.6698989868164]
type=[airport]
region=[US-TX]
runways=[2]
lat=[30.1944999694824]
----

If you are reading the output of queries that use 'valueMap' from the console, it is
sometimes easier to read the output if you add an 'unfold' step to the end of the 
query as follows. The 'unfold' step will unbundle a collection for us. You will see 
it used in many parts of this book.

[source,groovy]
----
g.V().has('code','AUS').valueMap(true,'code','icao','desc','city').unfold()

code=[AUS]
city=[Austin]
icao=[KAUS]
id=3
label=airport
desc=[Austin Bergstrom International Airport]
----

You can also use 'valueMap' to inspect the properties associated with an edge. In
this simple example, the edge with an ID of 5161 is examined. As you can see the edge
represents a route and has a distance ('dist') property with a value of 1357 miles.

[source,groovy]
----
g.E(5161).valueMap(true)

[id:5161,label:route,dist:4663]
----

There are other ways to control the results that a 'valueMap' step return using
the 'with' modulator.

NOTE: The valueMap configuration options are described in the official
documentation at the following link
https://tinkerpop.apache.org/docs/current/reference/#valuemap-step.

Instead of using 'valueMap(true)' to include the ID and label of an element (a vertex
or an edge) in the results, the new 'with(WithOptions.tokens)' construct can
now be used as shown below.

[source,groovy]
----
g.V().has('code','SFO').valueMap().with(WithOptions.tokens).unfold()

id=23
label=airport
country=[US]
longest=[11870]
code=[SFO]
city=[San Francisco]
lon=[-122.375]
type=[airport]
elev=[13]
icao=[KSFO]
region=[US-CA]
runways=[4]
lat=[37.6189994812012]
desc=[San Francisco International Airport]
----

TIP: All of the possible values that can be specified using WithOptions can be found
in the official Apache TinkerPop JavaDoc documentation
https://tinkerpop.apache.org/javadocs/current/full/org/apache/tinkerpop/gremlin/process/traversal/step/util/WithOptions.html.

You can still include the ID and label in the results, along with a subset of the
properties, by explicitly naming the property keys you are interested in. In the
example below only the 'code' property is requested.

[source,groovy]
----
g.V().has('code','SFO').valueMap('code').with(WithOptions.tokens).unfold()

id=23
label=airport
code=[SFO]
----

You can use additional 'WithOptions' qualifiers to select just the labels.

[source,groovy]
----
g.V().has('code','SFO').
      valueMap('code').with(WithOptions.tokens,WithOptions.labels).
      unfold()

label=airport
code=[SFO]
----

In the same way you can choose to just have the ID value returned without the label.
[source,groovy]
----
g.V().has('code','SFO').
      valueMap('code').with(WithOptions.tokens,WithOptions.ids).
      unfold()

id=23
code=[SFO]
----

As discussed in the previous section, the property values returned by 'valueMap' are
by default represented as lists even if there is only a single property value
present.

You can very easily request that these values be returned as single values not
wrapped in lists. This can be done using a 'by' step modulator as shown below.

[source,groovy]
----
g.V().has('code','SFO').valueMap().by(unfold()).unfold()
----

Notice how all the values such as the city name, "San Francisco", are now just simple
strings or numeric values and not a single value wrapped in a list of length one.

[source,groovy]
----
country=US
code=SFO
longest=11870
city=San Francisco
elev=13
icao=KSFO
lon=-122.375
type=airport
region=US-CA
runways=4
lat=37.6189994812012
desc=San Francisco International Airport
----

NOTE: There are additional 'WithOptions' settings we can use to change how
properties with meta properties are returned by 'valueMap' This is covered later as
part of the "<<tp34vmmetaprop>>" section.

[[element-map]]
=== An alternative to 'valueMap' - introducing 'elementMap'

The 'elementMap' step is similar in many ways to the 'valueMap' step but makes
some things a little easier. When using 'valueMap' you need to explicitly request
that the ID and label of a vertex or an edge are included in query results. This
is not necessary when using 'elementMap'.

[source,groovy]
----
g.V().has('code','AUS').elementMap().unfold()

id=3
label=airport
country=US
code=AUS
longest=12250
city=Austin
elev=542
icao=KAUS
lon=-97.6698989868164
type=airport
region=US-TX
runways=2
lat=30.1944999694824
desc=Austin Bergstrom International Airport
----

As with 'valueMap', you can request only certain property values be included in
the resulting map. Note however that the property values are not returned as
list members. This is a key difference from 'valueMap'. In fact, if the value
for a given property is a list or set containing multiple values, 'elementMap'
will only return the first member of that list or set. If you need to return
'set' or 'list' cardinality values you should use 'valueMap' instead.

[source,groovy]
----
g.V().has('code','AUS').elementMap('city')

[id:3,label:airport,city:Austin]
----

The biggest difference between 'elementMap' and 'valueMap' becomes apparent when
looking at edges. For a given edge, as well as the ID and label and properties,
information about the incoming and outgoing vertices is also returned.

[source,groovy]
----
g.V(3).outE().limit(1).elementMap()

[id:3840,label:route,IN:[id:45,label:airport],OUT:[id:3,label:airport],dist:1430]
----

A similar result could be generated using 'valueMap' as shown below but it is
definitely a bit more work.

[source,groovy]
----
g.E(5161).project('v','IN','OUT').
            by(valueMap(true)).
            by(inV().union(id(),label()).fold()).
            by(outV().union(id(),label()).fold())

[v:[id:5161,label:route,dist:4663],IN:[132,airport],OUT:[1,airport]]
----

To make the output look even closer to the results returned by 'elementMap'
we could decide to add some additional 'project' steps.

[source,groovy]
----
g.E(5161).project('v','IN','OUT').
            by(valueMap(true)).
            by(project('id','label').
              by(inV().id()).
              by(inV().label())).
            by(project('id','label').
              by(outV().id()).
              by(outV().label())).
            unfold()
----

The results of running the query are shown below. We added an unfold step to the
query just to make the results a little easier to read.

[source,groovy]
----
v={id=5161, label=route, dist=4663}
IN={id=132, label=airport}
OUT={id=1, label=airport}
----

[[var]]
=== Assigning query results to a variable with a terminal step

It is extremely useful to be able to assign the results of a query to a variable. The
example below stores the results of the 'valueMap' call shown above into a variable
called 'aus'.

[source,groovy]
----
// Store the properties for the AUS airport in the variable aus.
aus=g.V().has('code','AUS').valueMap().next()
----

TIP: It is necessary to add a call to 'next' to the end of the query in order for
this to work. Forgetting to add the call to 'next' is a very commonly made mistake by
people getting used to the Gremlin query language. The call to 'next' terminates the
traversal part of the query and generates a concrete result that can be stored in a
variable. We refer to 'next' as a "terminal step". There are other terminal steps
such as 'toList' and 'toSet' that also perform this traversal termination action. We
will see those steps used later on.

Once you have some results in a variable you can refer to it as you would in any
other programming language. We will explore mixing Java and Groovy code with your
Gremlin queries later in this book. For now let's just use the Groovy 'println'
to display the results of the query that we stored in 'aus'. We
will take a deeper look at the use of variables with Gremlin later in the book when
we look at mixing Gremlin and Groovy in the "<<grv>>" section.

[source,groovy]
----
// We can now refer to aus using key:value syntax
println "The AUS airport is located in " + aus['city'][0]

The AUS airport is located in Austin
----

NOTE: Properties are stored as arrays of values. Even if there is only one
property value for the given key, we still have to add the '[0]' when referencing it
otherwise the whole array will be returned if we just used 'aus[+++'city'+++]'. We
will explore why property values are stored in this way in the "<<listprop>>"
section.

As a side note, the 'next' step can take a parameter value that tells it how much
data to return. For example if you wanted the next three vertices from a query like
the one below you can add a call to 'next(3)' at the end of the query. Note that
doing this turns the result into an ArrayList. Each element in the list will contain
a vertex.

[source,groovy]
----
verts=g.V().hasLabel('airport').next(3)

v[1]
v[2]
v[3]
----

We can call the Java 'getClass' method to verify the type of the values
returned.

[source,groovy]
----
verts.getClass()

class java.util.ArrayList

verts.get(1).getClass()

class org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerVertex
----

TIP: When using the Gremlin Console, you can check to see what variables you have 
defined using the command ':show variables'.

[[setsandlists]]
==== Introducing 'toList', 'toSet', 'bulkSet' and 'fill'

It is often useful to return the results of a query as a list or as a set. One way to
do this is to use 'toList' or 'toSet' methods. Below you will find an example of
each. The call to 'join' is used just to make the results easier to read on a single
line.

[source,groovy]
----
// Create a list of runway counts in Texas
listr = g.V().has('airport','region','US-TX').
              values('runways').toList().join(',')

2,7,5,3,4,3,3,3,3,4,2,3,2,3,2,2,3,2,1,3,2,3,4,3,4,2,1
----

Now let's create a set and observe the different result we get back.

[source,groovy]
----
// Create a set of runway counts in Texas (no duplicates)
setr = g.V().has('airport','region','US-TX').
             values('runways').toSet().join(',')

1,2,3,4,5,7
----

As a side note, in many cases we can use the 'dedup' step to remove duplicates from a
result. However, it is worth knowing that a set can be created as a result type as in
some cases this can be very useful. The example below performs the same 'runways'
query using a 'dedup' step. We added an 'order' step so that it is easier to compare
the results with the previous query.

[source,groovy]
----
// Create a list of runway counts in Texas (no duplicates)
g.V().has('airport','region','US-TX').
      values('runways').dedup().order().fold()

[1,2,3,4,5,7]
----

Finally, let's create the list again, but without the call to 'join', as
that creates a single string result which is not what we want in this case.

[source,groovy]
----
listr = g.V().has('airport','region','US-TX').
        values('runways').toList()
----

The variable can now be used as you would expect.

[source,groovy]
----
listr[1]
7

listr.size()
26

listr[1,3]
7
3
----

TinkerPop also provides a third method called 'bulkSet' that can be used to create a
collection at the end of a traversal. The difference between a 'bulkSet' and a 'set'
is that 'bulkSet' is a so called 'weighted set'. A 'bulkSet' stores every value but
includes a count of how many of each type is present. Let's look at a few examples.
First of all we can check that the 'bulkSet' does indeed contain all the values.

[source,groovy]
----
setb= g.V().has('airport','region','US-TX').values('runways').toBulkSet().join(',')

2,2,2,2,2,2,2,2,7,5,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,1,1
----

A 'bulkSet' offers some additional methods that we can call. One of these is
'uniqueSize' which will tell us how many unique values are present.

[source,groovy]
----
setb= g.V().has('airport','region','US-TX').values('runways').toBulkSet()

// How many unique values are in the set?
setb.uniqueSize()
6

// How many total values are present?
setb.size()
27
----

The 'asBulk' method returns a map of key/value pairs where the key is the number and
the value is the number of times that number appears in the set.

[source,groovy]
----
setb.asBulk()

2=8
7=1
5=1
3=11
4=4
1=2
----

There is another way to store the results of a query into a collection. This is
achieved using the 'fill' method. Unlike 'toList' and the other methods that we just
looked at, 'fill' will store the results into a pre-existing variable. The query
below defines a list called 'a' and stores the results of the query into it. This
will produce the same result as using 'toList'.

[source,groovy]
----
a = []
g.V().has('airport','region','US-TX').values('runways').fill(a)

a.size()
27

a[1,3]
7
3
----

We can define a variable that is a set and use 'fill' to achieve the same result as
using 'toSet'.

[source,groovy]
----
s = [] as Set
g.V().has('airport','region','US-TX').values('runways').fill(s)

println s

[2, 7, 5, 3, 4, 1]
----

[[ignoringresults]]
==== Ignoring query results with 'iterate'

There are a number of cases where the results of a query are not of interest to you.
A common situation where this happens is when you have a graph mutation query and are
only interested in persisting those changes to the database, but are not interested
in doing anything with the output that the traversal produces. 

[source,groovy]
----
g.addV('airport').property('code','AUS').as('aus').
  addV('airport').property('code','DFW').as('dfw').
  addE('route').from('aus').to('dfw').iterate()
----

In the example above, you can see that we add two vertices and an edge between them
with the return value being the edge. Has we used 'next' as the terminal step, the 
query would have returned the newly created edge. With the use of 'iterate' as the 
the terminal step, the query has no value returned. The vertices are added to the 
graph along with the edge and the edge is discarded. Additional calls to 'next' after
'iterate' will result in a 'NoSuchElementException'.

The use of 'iterate' can bring some performance improvements because it signals to 
the graph that you are not interested in the results which could save some processing
costs (e.g. serialization, network). 

[[deepdivetraversals]]
=== Deep dive on traversal terminology

In Gremlin, we use the word "traversal" often and there is a fair bit of terminology
associated with it. Understanding that terminology will greatly help with your
understanding of Gremlin. To get started in this learning, let's return to how we
create "g", known as the 'GraphTraversalSource', which is the connection to the graph
from which we can write Gremlin to query our data.

[source,groovy]
----
// create the Graph object which in this case is a TinkerGraph
graph = TinkerGraph.open()

// create the GraphTraversalSource object
g = traversal().with(graph)
----

In looking at the above code, you might wonder where the 'traversal()' method comes
from. This function is a member of the 'AnonymousTraversalSource' class and it is
considered good form to statically import it so that it can be called without the
class. Calling 'traversal()' constructs an anonymous traversal source which is like
having a graph traversal source without a connection to a graph. Calling 'with' on
this object binds it to a particular graph data source and then "g" is ready for you
to write your queries.

You may see examples in this book, blog posts or other documentation that shorthand
the creation of 'g' like

[source,groovy]
----
g = TinkerGraph.open().traversal()
----

While you can take this approach, it does preclude you from having reference to the
'Graph' object. While this is typically not a problem for TinkerGraph, it can be
an issue for other TinkerPop-enabled graphs that might require that reference to
release resources or access provider specific APIs.

Another tempting shorthand is to skip the creation of "g" like

[source,groovy]
----
graph = TinkerGraph.open()
graph.traversal().V()
----

If you take this approach, you unnecessarily create 'GraphTraversalSource' objects
which will just end up in garbage collection. Typically, you create 'g' once and then
reuse it. One of the other benefits to creating 'g' once is that it allows you to set
configurations on the graph traversal source once rather than for each traversal you
execute.

Configuration steps are used to setup options on the graph traversal source. These
steps are prefixed with 'with' and work in a builder pattern style as follows

[source,groovy]
----
graph = TinkerGraph.open()
g = traversal().with(graph)

// construct a GraphTraversalSource configured with ReadOnlyStrategy and a
// List side-effect named "d"
g = g.withStrategies(ReadOnlyStrategy.instance()).
      withSideEffect('d', [1,2,3])
----

Once 'g' is configured you can then use start steps to spawn a 'Traversal'. In
TinkerPop, a "traversal" is a term we consider synonymous with "query". In the
context of querying graphs, the word "traversal" implies movement which aligns with
the visual image of traversing about the vertices and edges of a graph to get the
data that you need.

While Gremlin has dozens of steps, not all of them can be used to spawn a
'Traversal'. Only those found on the 'GraphTraversalSource' can be used to do that.
The most commonly used start step is 'V', but there are a number of others, like
'E' to start by traversing edges or 'addV' to add a new vertex to the graph. It is
important to realize that a 'Traversal' object spawned from 'g' does not do much on
its own and requires that a terminal step be added to get the query results. This
point was introduced in the "<<var>>" section but it is worth revisiting again as it
is a common mistake made by new Gremlin users. It is easy to illustrate this point 
clearly with an example in Java.

[source,java]
----
// create the Traversal object - "t" is just a reference to the traversal and is
// not the result of "g.V()" being executed
Traversal t = g.V();

// to get the result we need a terminal step, in this case toList()
List<Vertex> l1 = t.toList();

// more commonly the traversal has the terminal step added right when it is spawned
List<Vertex> l2 = g.V().toList();
----

There is one more piece of terminology to consider and we've touched on them earlier.
Anonymous traversals were first introduced in the "<<pathintro>>" section, where they
were used to modify 'Path' objects returned from the 'path' step. One of those 
examples demonstrated how a 'by' modulator could be given an anonymous traversal to 
convert vertices in the returned path into a count of the number of outgoing routes 
from airports.

[source,groovy]
----
g.V(3).out().limit(5).path().by(outE().count())

[98,147]
[98,80]
[98,145]
[98,33]
[98,23]
----

We often see anonymous traversals used with 'by' but they can actually be used as an
argument for a great many Gremlin steps making them an integral part of the language.
Let's take a step back from usage and examine anonymous traversals as a concept.
Like the anonymous traversal source, an anonymous traversal is one that is not bound
to a graph. Instead of spawning from 'g', an anonymous traversal spawns from a class
named with a double-underscore.

[source,groovy]
----
// spawns a traversal bound to a graph
g.V().out()

// spawns an anonymous traversal without binding to a graph
__.V().out()

// the preferred approach is to statically import V() so that you can omit "__."
// the following anonymous traversal is the same as the one above
V().out()
----

As shown earlier with 'by', an anonymous traversal can be used as an argument for
many different traversal steps.

[source,groovy]
----
g.V().has('airport','code','AUS').
      repeat(timeLimit(10).out()).until(has('code','LHR')).path().by('code')
----

Without driving too deeply into the details of the example above, note that we've
used an anonymous traversal inside of both 'repeat' and 'until'.

In this section, we learned about Gremlin terminology. In summary, here are the key
points to remember:

* A 'Traversal' is a graph query.
* A 'GraphTraversalSource' is usually named "g" by convention and spawns 'Traversal'
objects.
* When either of these objects are referred to as "anonymous" they are not connected
to any graph.

Now that you've learned all of this important Gremlin terminology you are well
prepared for the more advanced topics to come.

[[wid]]
=== Working with IDs

Every vertex, every edge and even every property in a graph has a unique ID that can
be used to reference it individually or as part of a group. These IDs are immutable
and therefore, cannot be changed once assigned. Beware that the IDs you provide when
loading a graph from a GraphML or GraphSON file may not in many cases end up being
the IDs that the back-end graph store actually uses as it builds up your graph.
TinkerGraph for example will preserve user provided IDs but many graph databases such
as JanusGraph generate their own IDs. The same is true when you add vertices and
edges using a graph traversal or using the TinkerPop API. This is a long winded way
of saying that you should not depend on the IDs in your GraphML or GraphSON file that
you just loaded remaining unchanged once the data has been loaded into the graph
store. When you add a new vertex or edge to your graph using a traversal, the graph
system will automatically generate a new, unique ID for it. If you need to figure out
the ID for a vertex or an edge you can always get it from a query of the graph
itself.

TIP: Don't rely on the graph preserving the ID values you provide. Write code that
can query the graph itself for ID values. How IDs are managed will be graph database
implementation dependent.

Especially when dealing with large graphs, because using IDs is typically very
efficient, you will find that many of your queries will involve collecting one or
more IDs and then passing those on to other queries or parts of the same query. In
most if not all cases, the underlying graph system will have setup its data
structures, whether on disk or in memory, to be very rapidly accessed by ID value.

Let's demonstrate the use of ID values using a few simple examples. The query below
finds the ID, which is 8, for the vertex that represents the DFW airport.

[source,groovy]
----
 // What is the ID of the "DFW" vertex?
 g.V().has('code','DFW').id()

 8
----

Let's reverse the query and find the code for the vertex with an ID of 8.

[source,groovy]
----
// Simple lookup by ID
g.V().hasId(8).values('code')

DFW
----

We could also have written the above query as follows.

[source,groovy]
----
// which is the same as this
g.V().has(id,8).values('code')
----

Here are some more examples that make use of the ID value.

[source,groovy]
----
// vertices with an ID between 1 and 5 (note this is inclusive/exclusive)
g.V().hasId(between(1,6))

// Which is an alternate form of this
g.V().has(id,between(1,6))

// Find routes from the vertex with an ID of 6 to any vertex with an ID less than 46
g.V().hasId(6).out().has(id,lt(46)).path().by('code')

// Which is the same as
g.V().hasId(6).out().hasId(lt(46)).path().by('code')
----

You can also pass a single ID or multiple IDs directly into the 'V' step.
Take a look at the two examples below.

[source,groovy]
----
// What is the code property for the vertex with an ID of 3?
g.V(3).values('code')

AUS

// As above but for all of the specified vertex IDs
g.V(3,6,8,15).values('code')

AUS
BWI
DFW
MCO
----

You can also pass a list of ID values into the 'V' step. We take a closer look at
using variables in this way in the "<<varaus>>" section.

[source,groovy]
----
a=[3,6,8,15]

g.V(a).values('code')
----

If the graph database that you are using supports it you can set the ID of a
vertex at the time you create it. How that can be done is explained in the
"<<injectid>>" section.

Every property in the graph also has an ID as we shall explore in the "<<propid>>"
section a bit later on.

[[lab]]
=== Working with labels

It's a good idea when designing a graph to give the vertices and edges meaningful
labels. As with IDs, labels are immutable and therefore cannot be changed once
assigned. You can use these to help refine searches. For example in the 'air-routes'
graph, every airport vertex is labelled 'airport' and every country vertex, not
surprisingly, is labelled 'country'. Similarly, edges that represent a flight route
are labelled 'route'. You can use labels in many ways. We already saw the 'hasLabel'
step being used in the basic queries section to test for a particular label. Here are
a few more examples.

[source,groovy]
----
// What label does the LBB vertex have?
g.V().has('code','LBB').label()

// What airports are located in Australia? Note that 'contains' is an
// edge label and 'country' is a vertex label.
g.V().hasLabel('country').has('code','AU').out('contains').values('code')

// We could also write this query as follows
g.V().has('country','code','AU').out().values('code')
----

By using labels in this way we can effectively group vertices and edges into classes
or types. Imagine if we wanted to build a graph containing different types of
vehicles. We might decide to label all the vertices just 'vehicle' but we could
decide to use labels such as 'car', 'truck' and 'bus'. Ultimately the overall design
of your graph's data model will dictate the way you use labels but it is good to be
aware of their value.

NOTE: As useful as labels are, not all graph database engines provide support for
indexing them. You should check to see if the graph database technology you are using
allows for labels to be indexed. If that is not the case, it is recommended to use a
vertex or edge property, that can be indexed, as a surrogate for the label. This can
then be used in graph queries rather than relying on the vertex label. This is
especially important when working with large graphs where performance can become an
issue if the items you are looking for are not backed by an index.

Here are a few more examples of ways we can work with labels.

[source,groovy]
----
// You can explicitly reference a vertex label using the label() method
g.V().where(label().is(eq('airport'))).count()

// Or using the label key word
g.V().has(label,'airport').count()

// But you would perhaps use the hasLabel() method in this case instead
g.V().hasLabel('airport').count()

// How many non airport vertices are there?
g.V().has(label,neq('airport')).count()
g.V().where(label().is(neq('airport'))).count()

// Again, it might be more natural to actually write this query like this:
g.V().not(hasLabel('airport')).count()
----

The same concepts apply equally well when looking at edge labels as shown below.

[source,groovy]
----
// The same basic concepts apply equally to edges
g.E().has(label,'route').count()

g.E().where(label().is(eq('route'))).count()

g.E().hasLabel('route').count()
----

Of course we have already seen another common place where labels might get used.
Namely in the three parameter form of 'has' as in the example below. The first
parameter is the label value. The next two parameters test the properties of all
vertices that have the 'airport' label for a code of "'SYD'".

[source,groovy]
----
g.V().has('airport','code','SYD')
----

It is also possible to specify more than one label in the same step as shown below.
In general, whenever a step can be provided a label, more than one may also be
provided.

[source,groovy]
----
g.E().hasLabel('route','contains')
----

[[local]]
=== Using the 'local' step to make sure we get the result we intended

Sometimes it is important to be able to do calculations based on the current state of
a traversal rather than waiting until near the end. A common place where this is
necessary is when calculating the average value of a collection. In the next section
we are going to look at a selection of numerical and statistical operations that
Gremlin allows us to perform. However, for now lets use the 'mean' step to calculate
the average of something and look at the effect the 'local' step has on the
calculation. The 'mean' step works just like you would expect, it returns the mean,
or average, value for a set of numbers.

If we wanted to calculate the average number of routes from an airport, the first
query that we would write might look like the one below.

[source,groovy]
----
g.V().hasLabel('airport').out('route').count().mean()

50637.0
----

As you can see the answer we got back, '43400.0' looks wrong, and indeed it is. That
number is in fact the total number of outgoing routes in the entire graph. This is
because as written the query counts all of the routes, adds them all up, but does not
keep track of how many airports it visited. This means that calling the 'mean' step
is essentially the same as dividing the count by one.

So how do we fix this? The answer is to use the 'local' step. What we really want to
do is to create, in essence, a collection of values, where each value is the route
count for just one airport. Having done that, we want to divide the sum of all of
these numbers by the number of members, airports in this case, into the collection.

Take a look at the modified query below.

[source,groovy]
----
// Average number of outgoing routes from an airport.
g.V().hasLabel('airport').local(out('route').count()).mean()

14.451198630136986
----

The result this time is a much more believable answer. Notice how this time we placed
the __out(''route'').count()__ steps inside a 'local' step. The query below,
with the mean step removed, shows what is happening during the traversal as this
query runs. We truncated the output to just show a few lines.

[source,groovy]
----
g.V().hasLabel('airport').local(out('route').count()).limit(10)

242
41
98
75
143
91
96
253
158
158
----

What this shows is that for the first ten airports the collection that we are
building up contains one entry for each airport that represents the number of
outgoing routes that airport has. Then, when we eventually apply the 'mean' step it
will calculate the average value of our entire collection and give us back the result
that we were looking for.

Let's look at another example where we can use the 'local' step to change the results
of a query in a useful way. First of all, take a look at the query below and the
results that it generates. The query first finds all the airports located in Scotland
using the region code of 'GB-SCT'. It then creates an ordered list of airport codes
and city names into a list.

[source,groovy]
----
g.V().has('region','GB-SCT').order().by('code').
      values('code','city').fold()
----

Here are the results from running the query.

[source,groovy]
----
[ABZ,Aberdeen,BEB,Balivanich,BRR,Eoligarry,CAL,Campbeltown,DND,Dundee,EDI,Edinburgh,EOI,Eday,FIE,Fair Isle,FOA,Foula,
 GLA,Glasgow,ILY,Port Ellen,INV,Inverness,KOI,Orkney Islands,LSI,Lerwick,LWK,Lerwick,NDY,Sanday,NRL,North Ronaldsay,
 PIK,Glasgow,PPW,Papa Westray,PSV,Papa Stour Island,SOY,Stronsay,SYY,Stornoway,TRE,Balemartine,WIC,Wick,WRY,Westray]
----

However, it would be more convenient perhaps to have the results be returned as a
list of lists where each small list contains the airport code and city name with all
the small lists wrapped inside a big list. We can achieve this by wrapping the second
half of the query inside of a 'local' step as shown below.

[source,groovy]
----
g.V().has('region','GB-SCT').order().by('code').
      local(values('code','city').fold())
----

Here are the results of running the modified query. We have arranged the results in
two columns to aid readability.

[source,groovy]
----
[ABZ,Aberdeen]
[BEB,Balivanich]
[BRR,Eoligarry]
[CAL,Campbeltown]
[DND,Dundee]
[EDI,Edinburgh]
[EOI,Eday]
[FIE,Fair Isle]
[FOA,Foula]
[GLA,Glasgow]
[ILY,Port Ellen]
[INV,Inverness]
[KOI,Orkney Islands]
[LSI,Lerwick]
[LWK,Lerwick]
[NDY,Sanday]
[NRL,North Ronaldsay]
[PIK,Glasgow]
[PPW,Papa Westray]
[PSV,Papa Stour Island]
[SOY,Stronsay]
[SYY,Stornoway]
[TRE,Balemartine]
[WIC,Wick]
[WRY,Westray]
----

There are many other ways that 'local' can be used. You will find examples of those
throughout the book. You will see some that show how local can be used as a parameter
to the 'order' step when we dig deeper into route analysis in the "<<meanmode>>"
section.

[[st]]
=== Basic statistical and numerical operations

The following queries demonstrate concepts such as calculating the amount of a
particular item that is present in the graph, calculating the average (mean) of a set
of values and calculating a maximum or minimum value. The table below summarizes the
available steps.

.Basic statistical steps
[cols="^1,4"]
|==============================================================================
|count   | Count how many of something exists.
|sum     | Sum (add up) a collection of values.
|max     | Find the maximum value in a collection of values.
|min     | Find the minimum value in a collection of values.
|mean    | Find the mean (average) value in a collection.
|==============================================================================

We will dig a bit deeper into some of these capabilities and explain in more detail
in the "<<meanmode>>" section of the book. Some of these examples also take advantage
of the 'local' step that was introduced in the previous section. A way of calculating
the standard deviation within a data set is presented later in the "<<mathstep>>"
section. The results of running each query are also shown in the examples below.

[source,groovy]
----
// How many routes are there from Austin?
g.V().has("airport","code","AUS").out().count()

98

// Sum of values - total runways of all airports
g.V().hasLabel('airport').values('runways').sum()

4980
----

The 'mean' step allows us to find the mean (average) value in a data set.

[source,groovy]
----
// Statistical mean (average) value - average number of runways per airport
g.V().hasLabel('airport').values('runways').mean()

1.4212328767123288

// Average length of the longest runway across all airports
g.V().hasLabel('airport').values('longest').mean()

7544.5559360730595

// Average number of routes to and from an airport
g.V().hasLabel('airport').local(both('route').count()).mean()

28.902397260273972
----

The following queries find maximum and minimum values using the 'max' and 'min'
steps.

[source,groovy]
----
//maximum value - longest runway
g.V().hasLabel('airport').values('longest').max()

18045

// What is the biggest number of outgoing routes any airport has?
g.V().hasLabel('airport').local(out('route').count()).max()

310

//minimum value - shortest runway
g.V().hasLabel('airport').values('longest').min()

1300
----

It is also possible in more recent versions of Apache TinkerPop to use the 'min' and
'max' steps with more than just numeric values. These steps apply to any value
that are considered _"comparable"_. So, for example, we can now compare strings as
well as numbers. The examples below look for the minimum and maximum value in the
descriptive names of the continents.

[source,groovy]
----
g.V().hasLabel('continent').values('desc').min()

Africa

g.V().hasLabel('continent').values('desc').max()

South America
----

[[textsteps]]
=== Working with text

Gremlin has a wide variety of steps for manipulating text. String values in Gremlin 
often derive directly from property values, but you may encounter them by other means
as well. One of these ways is by means of the 'asString' step, which takes any type
and converts it to a string representation. 

[source,groovy]
----
// 18045 is a Long type
g.V().hasLabel('airport').values('longest').max()

18045

// 18045 is a String type
g.V().hasLabel('airport').values('longest').max().asString()

18045
----

Many of the operations you are used to having for working with strings are available
in Gremlin.

[cols="^1,4"]
|==============================================================================
|concat      | Concatenates one or more string value together with the incoming traverser
|format      | Formats a string using a user supplied template
|length      | Counts the number of characters in the string
|lTrim       | Removes whitespace from the left of the string
|toLower     | Converts the string to all lower case
|toUpper     | Converts the string to all upper case
|replace     | Replaces occurences of a specified string with another string value
|reverse     | Reverses the characters in a string
|rTrim       | Removes whitespace from the right of the string
|split       | Splits a string into multiple strings based on a specified delimiter
|substring   | Exacts a substring from the incoming string based on specified indices
|trim        | Removes whitespace from both ends of the string
|==============================================================================

The above steps should be generally recognizable to most developers and are for the 
most part self-explanatory. Let's look at a few examples of each to get a feel for 
how they work. We'll start with ones that require the least explanation first.

[source,groovy]
----
g.V().has('airport','code',within('IAD','MIA','LAX')).
  values('city')
  
Washington D.C.
Los Angeles
Miami
  
// convert each city to all lower case with toLower()
g.V().has('airport','code',within('IAD','MIA','LAX')).
  values('city').toLower()

washington d.c.
los angeles
miami

// convert each city to all upper case with toUpper()
g.V().has('airport','code',within('IAD','MIA','LAX')).
  values('city').toUpper()

WASHINGTON D.C.
LOS ANGELES
MIAMI

// get the number of characters for each city with length()
g.V().has('airport','code',within('IAD','MIA','LAX')).
  values('city').length()
  
15
11
5

// reverse() the characters for each city
g.V().has('airport','code',within('IAD','MIA','LAX')).
  values('city').reverse()  
  
.C.D notgnihsaW
selegnA soL
imaiM  
----

The 'substring' step is 0-based (inclusive) and optionally accepts an end index
(exclusive). 

[source,groovy]
----
g.V().has('airport','code',within('IAD','MIA','LAX')).
  values('code').
  substring(1)

AD
AX
IA
  
g.V().has('airport','code',within('IAD','MIA','LAX')).
  values('code').
  substring(0, 1)  

I
L
M
----

The 'split' step is a bit different than most of the string manipulation steps in 
that all the other steps produce one string as an out, whereas 'split' produces a 
list of strings.

[source,groovy]
----
g.V().has('airport','code',within('IAD','MIA','LAX')).
  values('city').
  split(' ')
  
[Washington,D.C.]
[Los,Angeles]
[Miami]  
----

Sometimes you will want to find occurrences of a particular character or string and
replace that with another.

[source,groovy]
----
g.V().has('airport','code',within('IAD','MIA','LAX')).
  values('code').replace(' ', '0')
  
I0D
MI0
L0X
----

We can use the 'replace' step to help demonstrate the steps that remove whitespace.
The following examples use 'inject' to start the traversal with some strings that 
include whitespace before and after a character. We will use the various 'trim' steps
to remove the whitespace and then 'replace' any that is left over to see which bit of
whitespace has been removed.

[source,groovy]
----
g.inject(' x', 'x ', ' x ').lTrim().replace(' ', 'Z')

x
xZ
xZ

g.inject(' x', 'x ', ' x ').rTrim().replace(' ', 'Z')

Zx
x
Zx

g.inject(' x', 'x ', ' x ').trim().replace(' ', 'Z')

x
x
x
----

When we want to put strings together we can use 'concat'. This most simple form of 
this step might be best demonstrated by adding a suffix to the end of a string or
prefix to the start of one.

[source,groovy]
----
g.V().has('airport','code',within('IAD','MIA','LAX')).
  values('code').concat('_suffix')

IAD_suffix
LAX_suffix
MIA_suffix

g.V().has('airport','code',within('IAD','MIA','LAX')).
  values('code').as('c').
  constant('prefix_').
  concat(select('c'))
  
prefix_IAD
prefix_LAX
prefix_MIA  
----

The 'concat' step has another form to consider where it can take a 'Traversal' as an
argument for more dynamic use cases. 

[source,groovy]
----
g.V().has('airport','code',within('IAD','MIA','LAX')).as('v').
  values('code').concat(constant(' is in '), select('v').values('city'))

IAD is in Washington D.C.
LAX is in Los Angeles
MIA is in Miami
----

There is an easier way to produce the output shown above. We can use the 'format' 
step to produce that in a more readable way.

[source,groovy]
----
g.V().has('airport','code',within('IAD','MIA','LAX')).
  format("%{code} is in %{city}")
 
IAD is in Washington D.C.
LAX is in Los Angeles
MIA is in Miami
----

Note how 'format' takes the incoming traverser, in this case an airport vertex, and
resolve the variable expressions designated by the '%{ }' forms. Here the value in 
the curly braces is resolved to a property value. They can also be used to resolve 
to map keys and step names.

[source,groovy]
----
g.V().has('airport','code',within('IAD','MIA','LAX')).
  elementMap().
  format("%{code} is in %{city}")
 
IAD is in Washington D.C.
LAX is in Los Angeles
MIA is in Miami
----

Another important feature of 'format' is the ability to add positional variables
which can be transformed using a 'by' modulator. This feature makes 'format' an 
extremely flexible step.

[source,groovy]
----
g.V().has('airport','code',within('IAD','MIA','LAX')).
  format("%{_} is in %{_} and has %{_} outgoing routes").
    by('code').
    by('city').
    by(outE('route').count())
 
IAD is in Washington D.C. and has 136 outgoing routes
LAX is in Los Angeles and has 195 outgoing routes
MIA is in Miami and has 171 outgoing routes
----

It's worth noting that many of these steps can take a 'Scope' argument. By default,
the scope is 'global' which means that the step operates on the value of the current 
traverser in the stream. In contrast, a 'local' scope implies that the incoming 
traverser in the stream contains a list of values on which the step will be applied.
So far, we've only looked at 'global' scope usage of these steps, but 'local' scope
allows for some interesting use cases.

[source,groovy]
----
// grab the first letter of each word in each city and lower case it
g.V().has('airport','code',within('IAD','MIA','LAX')).
  values('city').
  split(' ').
  substring(local,0,1).
  toLower(local)
  
[w,d]
[l,a]
[m]  
----

[[collectionsteps]]
=== Working with collections

Collections are containers for other values and refer to things like 'List', 'Set'
and 'Map'. Gremlin offers a variety of steps that help construct and manipulate these
objects. We've already seen how we can use a step like 'fold' to create a 'List' of
the objects in the traversal stream:

[source, groovy]
----
g.V().has('region','GB-ENG').values('runways').dedup().fold()

[2,1,3,4]
----

As for maps, Gremlin can produce them whenever you use a step like 'group' or 
'valueMap':

[source,groovy]
----
g.V().has('code','AUS').valueMap(true,'region')

[id:3,region:[US-TX],label:airport]
----

If you look at the result in the example above, collections might contain other 
collections, as shown with the region key where "US-TX" is in a 'List'. Since 
collections are core to the Gremlin language the following steps tend to be quite
helpful in many situations:

[cols="^1,4"]
|==============================================================================
|any         | Determines if any object in a 'List' matches a specified predicate
|all         | Determines if all objects in a 'List' match a specified predicate
|combine     | Combines an incoming 'List' with the list provided as an argument
|conjoin     | Takes objects in the incoming 'List' and converts them to a string joined by the specified delimiter  
|difference  | Calculates the difference between the incoming 'List' and the one provided as an argument
|disjunct    | Calculates the disjunct set between the incoming 'List' and the provided 'List' argument
|intersect   | Calculates the intersection between the incoming 'List' and the provided 'List' argument
|merge       | Merges the incoming collection with the one provided as an argument
|none        | Determines if no objects in a 'List' matches a specific predicate
|product     | Calculates the cartesian product of the incoming 'List' and the provided 'List'
|reverse     | Reverses the order of the incoming 'List'
|==============================================================================

TIP: The steps noted in the prior table are meant specifically for working with 
various collections types, but you should also note that many Gremlin steps 
inherently work with collections. For example, the 'local' versions of 'range', 
'limit or 'tail' are good at taking parts of a collection or 'unfold' that can be
used to deconstruct collections. These are some obvious examples, but as you learn 
more about Gremlin you will find many more.

Let's take a deeper look at these steps and how you might use them. We will start
with the three filtering steps of 'any' 'all' and 'none'. Oftentimes you will find 
yourself in a situation where you have written some Gremlin that collects your 
results into a 'List' like the following example where we have the number of runways 
for all airports in the "US-TX" region collected:

[source,groovy]
----
g.V().has('airport','region','US-TX').values('runways').fold()

[2,7,5,3,4,3,3,3,3,4,2,3,2,3,2,2,3,2,1,3,2,3,4,3,4,2,1]
----

If you were only interested in this result if the 'List' had a value of "4" in it, 
you could use 'any' and the 'P.eq' predicate:

[source,groovy]
----
g.V().has('airport','region','US-TX').values('runways').fold().any(eq(4))

[2,7,5,3,4,3,3,3,3,4,2,3,2,3,2,2,3,2,1,3,2,3,4,3,4,2,1]
----

Similarly, if you only wanted the 'List' if all the values were greater than 7, then
you could use 'all':

[source,groovy]
----
g.V().has('airport','region','US-TX').values('runways').fold().any(gt(7))

// no results
----

As the final complement to the 'all' and 'any' steps, 'none' can be used in cases 
where you only wanted the 'List' if none of its values were greater than 6:

[source,groovy]
----
g.V().has('airport','region','US-TX').values('runways').fold().none(gt(6))

// no results
----

If you need to push two 'List' objects together, you can use 'combine'. You can see 
a simple example of this step demonstrated as follows where we combine the incoming
'List' from 'fold' with a constant 'List' containing the value of 100:

[source,groovy]
----
g.V().has('airport','region','US-TX').values('runways').fold().combine([100])

[2,7,5,3,4,3,3,3,3,4,2,3,2,3,2,2,3,2,1,3,2,3,4,3,4,2,1,100]
----

A more advanced and likely useful form of 'combine' though is to supply a traversal
as the argument to dynamically choose the 'List' to combine. In the following 
example, we aggregate the runway values for all of the airports in the "US-VA" region
into "v" which is a 'List' and has the value '[1,1,2,2,2,2,3,4]'. We then traverse
'out' along the route edges and to 3 adjacent airport vertices. For each of those 
vertices, the 'map' step gets the runway value and does a 'fold' to produce a 'List'
with just that value in it. As a final step, it uses 'combine' to push that single
value 'List' together with the one stored in the aggregate "v" which we gather 
dynamically with 'select'.

[source,groovy]
----
g.V().has('airport','region',within('US-VA')).
  aggregate('v').by('runways').
  out('route').limit(3).
  map(values('runways').fold().combine(select('v')))
  
[1,4,2,2,2,2,3,1,1]
[3,4,2,2,2,2,3,1,1]
[2,4,2,2,2,2,3,1,1]
----

While we won't visit this form for all the 'List' steps we look at, you will notice 
that all of these sorts of 'List' transformation steps have both a literal constant 
form and this more dynamic form that uses a traversal as the  argument. We saw a 
similar pattern in <<textsteps>. 

The 'conjoin' step is interesting in that it is the only 'map'-like step that 
transforms the incoming 'List' to a different type. When you use 'conjoin' on a 
'List', it will take the values within it, transform each to a string and then join
them all together to a single string using the value that you specify as a delimiter.
A simple use case for this feature might be to produce a delimited list of values,
as that could be helpful for doing a fast export of data in a structured form. 

[source,groovy]
----
g.V().has('airport','region','US-VA').
  valueMap('code','longest','city').by(unfold()).
  map(select(values).conjoin('\t'))
  
11500   IAD     Washington D.C.
9001    ORF     Norfolk
9003    RIC     Richmond
6800    ROA     Roanoke
6001    CHO     Charlottesville
8003    PHF     Newport News
6002    SHD     Staunton/Waynesboro/Harrisonburg
5799    LYH     Lynchburg
----

Gremlin also allows you to perform basic operations on sets with 'difference', 
'disjunct', 'interesect' and 'product'. When you use these steps, it is important to
recognize that they each accept an incoming 'List' or 'Set', but if it is a 'List', 
it will be treated as a 'Set'. The same can be said for the argument given to these
steps. The output will be a 'Set'.

[source,groovy]
----
g.V().has('airport','region','US-VA').values('code').fold()

[IAD,ORF,RIC,ROA,CHO,PHF,SHD,LYH]
  
g.V().has('airport','region','US-VA').values('code').fold().
  difference(['SHD', 'MIA'])
  
[ORF,ROA,LYH,CHO,IAD,RIC,PHF]

g.V().has('airport','region','US-VA').values('code').fold().
  disjunct(['SHD', 'MIA'])
  
[ORF,MIA,ROA,LYH,CHO,IAD,RIC,PHF]

g.V().has('airport','region','US-VA').values('code').fold().
  intersect(['SHD', 'MIA']) 
  
[SHD]

g.V().has('airport','region','US-VA').values('code').fold().
  product(['SHD', 'MIA'])   

[[IAD,SHD],[IAD,MIA],[ORF,SHD],[ORF,MIA],[RIC,SHD],[RIC,MIA],[ROA,SHD],[ROA,MIA],
 [CHO,SHD],[CHO,MIA],[PHF,SHD],[PHF,MIA],[SHD,SHD],[SHD,MIA],[LYH,SHD],[LYH,MIA]]

----

We should not overlook the fact that these steps can also take a traversal as an 
argument as shown in the following example that uses 'aggregate' to collect all the 
airport codes in "US-VA" into a list side-effect of "x" and then  does an 'intersect'
on that value against a list of codes for outgoing routes:

[source,groovy]
----
g.V().has('airport','region','US-VA').aggregate('x').by('code').
  out('route').values('code').fold().
  intersect(select('x'))
  
[ORF,ROA,CHO,IAD,RIC,SHD]
----

The 'reverse' step reverses the order of an incoming object. While its typical use
would be for a list, it could also be used on a string.

[source,groovy]
----
g.V().has('airport','region','US-VA').values('code').fold()

[IAD,ORF,RIC,ROA,CHO,PHF,SHD,LYH]

g.V().has('airport','region','US-VA').values('code').fold().reverse()

[LYH,SHD,PHF,CHO,ROA,RIC,ORF,IAD]
----

When you need to merge two collections together you can use 'merge' step which works 
for lists, sets and maps. This step is similar to 'combine', but does not allow 
duplicates. 

[source,groovy]
----
g.V().has('airport','region','US-VA').values('code').fold().merge(['MIA','IAD'])

[ORF,MIA,ROA,LYH,CHO,IAD,RIC,SHD,PHF]

g.V().has('airport','region','US-VA').valueMap('code').merge([x: 10])

[x:10,code:[IAD]]
[x:10,code:[ORF]]
[x:10,code:[RIC]]
[x:10,code:[ROA]]
[x:10,code:[CHO]]
[x:10,code:[PHF]]
[x:10,code:[SHD]]
[x:10,code:[LYH]]
----

Once again, you may also provide a traversal argument to 'merge' to dynamically 
provide the object to merge to the incoming one.

[source,groovy]
----
g.V().has('airport','region','US-VA').aggregate('x').by('code').
  out('route').limit(5).values('code').fold().
  merge(select('x'))
  
[AOO,ORF,ROA,BGM,CHO,IAD,RIC,SHD,BKW,PHF,PBG,LYH,YTZ]
----

In the prior example, we gather the airport codes in "x" and then traverse 'out' 
along route edges and fold 5 of them to a list which we then 'merge' to "x" providing
a single list output of both lists without duplicates.

In many Gremlin examples we've seen so far, the 'select' step has been used to 
reference traverser data at a particular step label or, in the example just prior, to
get data designated as a side-effect. The 'select' step is also capable of accessing
'Map' data and can do so in multiple ways. You can use it to get all the 'keys' or 
'values' of a 'Map' with the 'Columns' enum:

[source,groovy]
----
g.V().has('airport','region','US-VA').valueMap('code','country').select(keys)

[country,code]
[country,code]
[country,code]
[country,code]
[country,code]
[country,code]
[country,code]
[country,code]

g.V().has('airport','region','US-VA').valueMap('code','country').select(values)

[[US],[IAD]]
[[US],[ORF]]
[[US],[RIC]]
[[US],[ROA]]
[[US],[CHO]]
[[US],[PHF]]
[[US],[SHD]]
[[US],[LYH]]
----

You can also use it to select individual values by their key:

[source,groovy]
----
g.V().has('airport','region','US-VA').valueMap('code','country').select('code')

[IAD]
[ORF]
[RIC]
[ROA]
[CHO]
[PHF]
[SHD]
[LYH]
----

The 'select' step supports more complex use cases as well. Let's envision a case 
where you had some external data that you wanted to integrate into your traversal
results. For example, here's a 'Map' of average temperature data keyed by a city
name.

[source,groovy]
----
temps = [Atlanta:66.2,Austin:70.9,Anchorage:42.6,Seattle:54.1]

Atlanta=66.2
Austin=70.9
Anchorage=42.6
Seattle=54.1
----

We can include that 'Map' as a side-effect to the traversal and access it via 
'select'. In the following example, the first select gets the 'Map' from the 
side-effect and injects it into the traversal stream. The second 'select' gets the
value in the Atlanta key of that 'Map'.

[source,groovy]
----
g.withSideEffect('t',temps).V().limit(1).
  select('t').select('Atlanta')
  
66.2
----

The ability to use 'select' in this fashion sets up the case for the data integration
case we initially wanted to showcase. The following query uses 'project' to transform
each city to a 'Map' with the city name going to the Location key and the AvgTemp
key getting set with a combined group of 'select' steps.

[source,groovy]
----
g.withSideEffect('t',temps).V().
  has('city',within('Austin','Atlanta','Anchorage','Seattle')).
  values('city').as('c').
  project('Location','AvgTemp').
    by().
    by(select('t').select(select('c'))) 
    
[Location:Atlanta,AvgTemp:66.2]
[Location:Anchorage,AvgTemp:42.6]
[Location:Austin,AvgTemp:70.9]
[Location:Seattle,AvgTemp:54.1]    
----

Let's break down that group of 'select' steps in the second 'by' modulator. We've 
already seen what 'select("t").select("Atlanta")' does in getting the temp map and 
grabbing the Atlanta key. When we replace Atlanta with 'select("c")', we're 
referencing the 'values("city")' step labelled with 'as("c")' and dynamically 
inserting its value as the key to extract from the 'Map', which ultimately allows us
to supply that value to 'project'. In short, chaining and nesting 'select' steps in 
this way provides a powerful pattern for dynamically pulling values from side-effect 
maps, enabling flexible data retrieval and transformation directly within the 
traversal.

The collection steps provide important utility functions for Gremlin. They allow you
to do helpful transformations to your data that can get your final result into the 
form your application ultimately needs. They also help make Gremlin queries read more
concisely where they often replace patterns of other Gremlin steps that do the same
job making queries much more readable.  

[[datesteps]]
=== Working with dates

From birthdays to auditing values like the "createdDate", applications often call you 
to store dates and times. There are several ways you might store dates in your graph: 

1. A long value representing milliseconds since the epoch
2. A ISO-8601 formatted date stored as a string
3. A native 'DateTime' value (if your graph database supports this type)

All three work well in their own way, but if you want to use Gremlin's date steps, 
you will need an actual date type to use with them, which means that for the first 
two options you would need to use the 'asDate' step to convert them to date types.

[source,groovy]
----
g.inject(1690934400000).asDate()

2023-08-02T00:00Z

g.inject("2023-08-02T00:00:00Z").asDate()

2023-08-02T00:00Z
----

To construct a date in Gremlin, you can use the 'datetime' function, which takes an
IOS-8601 formatted string as an argument:

[source,groovy]
----
g.inject(datetime("2023-08-02T00:00:00Z"))

2023-08-02T00:00Z
----

There are two date manipulation steps in Gremlin, 'dateAdd' and 'dateDiff'. The 
'dateAdd' step adds some number of specified time units to a date value. In the 
following example we add 1 week to the given date.

[source,groovy]
----
g.inject("2023-08-02T00:00:00Z").asDate().dateAdd(DT.day, 7)

2023-08-09T00:00Z
----

By supplying a negative number of units, we can effect a subtraction operation as 
shown in the next example.

[source,groovy]
----
g.inject("2023-08-02T00:00:00Z").asDate().dateAdd(DT.day, -7)

2023-07-26T00:00Z
----

The 'DT' enum allows units of time for 'second', 'minute', 'hour and 'day'.

NOTE: Date conversion in the above examples assume a time zone offset of UTC(+00:00).

The 'dateDiff' step is helpful when you want to find the difference between two 
dates in epoch time.

[source,groovy]
----
g.inject("2023-08-02T00:00:00Z").asDate().
  dateDiff(constant("2023-08-03T00:00:00Z").asDate())

-86400000
----

[[tranges]]
=== Testing values and ranges of values with P

We have already seen some ways of testing whether a value is within a certain range.
Gremlin provides a number of different predicates that we can use to do range
testing. The list below provides a summary of the available predicates. We will see
each of these in use throughout this book.

.Predicates that test values or ranges of values
[cols="^1,4"]
|==============================================================================
|eq      | Equal to
|neq     | Not equal to
|gt      | Greater than
|gte     | Greater than or equal to
|lt      | Less than
|lte     | Less than or equal to
|inside  | Inside a lower and upper bound, neither bound is included.
|outside | Outside a lower and upper bound, neither bound is included.
|between | Between two values inclusive/exclusive (upper bound is excluded)
|within  | Must match at least one of the values provided. Can be a range or a list
|without | Must not match any of the values provided. Can be a range or a list
|==============================================================================

.Other predicates
[cols="^1,4"]
|==============================================================================
|and     | Logical and conjunction
|or      | Logical or conjunction
|not     | Negation of a predicateg
|==============================================================================

NOTE: There are 'and', 'or' and 'not' predicates, but there are also 'and', 'or',
and 'not' steps. It is often helpful to use the appropriate 'P' or '__' prefix 
respectively for clairty when using this syntax, but you may also find it required
if your compiler cannot figure out which you intend to call.

The following queries demonstrate these capabilities being used in different ways.
First of all, here are some examples of some of the direct compare steps such as 'gt'
and 'gte' being used. The 'fold' step conveniently folds all of the results into a
list for us.

[source,groovy]
----
// Airports with at least 5 runways
g.V().has('runways',gte(5)).values('code','runways').fold()
----

Here is the output that we might get from running the query.

[source,groovy]
----
[ATL,5,BOS,6,DFW,7,IAH,5,ORD,7,DEN,6,DTW,6,YYZ,5,
 AMS,6,SNN,5,MKE,5,MDW,5,GIS,5,HLZ,5,NPE,5,NSN,5,
 PPQ,5,TRG,5,UFA,5,KRP,5]
----

The next three queries show examples of 'lt', 'eq' and 'neq' being used.

[source,groovy]
----
// Airports with fewer than 3 runways
g.V().has('runways',lt(3)).values('code','runways').fold()

// How many airports have 3 runways?
g.V().has('runways',eq(3)).count()

// How many airports have anything but just 1 runway?
g.V().has('runways',neq(1)).count()
----

Note that in some cases, such as when using a simple 'has' step the 'eq' is not
actually required. For example the query used above could be written as follows
instead.

[source,groovy]
----
g.V().has('runways',3).count()
----

You could also write this query using an 'is' step. You will find the 'is' step used
a lot in this book but mostly in conjunction with 'where' steps. To me the usage
below does not feel as elegant as the 'has' step alternative used above.

[source,groovy]
----
// How many airports have 3 runways?
g.V().values('runways').is(3).count()
----

Here are examples of 'inside' and 'outside' being used.

[source,groovy]
----
// Airports with greater than 3 but fewer than 6 runways.
g.V().has('runways',inside(3,6)).values('code','runways')

// Airports with fewer than 3 or more than 6 runways.
g.V().has('runways',outside(3,6)).values('code','runways')
----

Below are some examples showing 'within' and 'without' being used.

[source,groovy]
----
// Airports with at least 3 but not more than 6 runways
g.V().has('runways',within(3..6)).values('code','runways').limit(15)

// Airports with 1,2 or 3 runways.
g.V().has('runways',within(1,2,3)).values('code','runways').limit(15)

// Airports with fewer than 3 or more than 6 runways.
g.V().has('runways',without(3..6)).values('code','runways').limit(15)
----

The 'between' step lets us test the provided value for being greater than or equal to
a lower bound but less than an upper bound. The query below will find any airport
that has 5,6 or 7 runways. In other words, any airport that has at least 5 but fewer
than 8 runways.

[source,groovy]
----
// Airports with at least 5 runways but fewer than 8
g.V().has('runways',between(5,8)).values('code','runways').fold()
----

Here is the result of running the query.

[source,groovy]
----
[ATL,5,BOS,6,DFW,7,IAH,5,ORD,7,DEN,6,DTW,6,YYZ,5,
 AMS,6,SNN,5,MKE,5,MDW,5,GIS,5,HLZ,5,NPE,5,NSN,5,
 PPQ,5,TRG,5,UFA,5,KRP,5]
----

As with many queries we may build, there are several ways to get the same answer.
Each of the following queries will return the same result. To an extent which one
you use comes down to personal preference although in some cases one form of a query
may be better than another for reasons of performance.

[source,groovy]
----
g.V().hasId(gt(0)).hasId(lte(46)).out().hasId(lte(46)).count()

g.V().hasId(within(1..46)).out().hasId(lte(46)).count()

g.V().hasId(within(1..46)).out().hasId(within(1L..46L)).count()

g.V().hasId(between(1,47)).out().hasId(lte(46)).count()

g.V().hasId(within(1..46)).out().hasId(between(1,47)).count()

g.V().hasId(inside(0,47)).out().hasId(lte(46)).count()
----

NOTE: The values do not have to be numbers. We could also compare strings for
example.

Let's now look at a query that compares strings rather than numbers. The following
query finds all airports located in the state of Texas in the United States but only
returns their code if the name of the city the airport is located in is not 'Houston'.

[source,groovy]
----
g.V().has('airport','region','US-TX').
      has('city',neq('Houston')).
      values('code')
----

This next query can be used to find routes between Austin and Las Vegas. We use a
'within' step to limit the results we get back to just routes that have a plane
change in Dallas, San Antonio or Houston airports.

[source,groovy]
----
 g.V().has('airport','code','AUS').
       out().has('code',within('DFW','DAL','IAH','HOU','SAT')).
       out().has('code','LAS').path().by('code')
----

Here is what the query returns. Looks like we can change planes in Dallas or Houston
but nothing goes via San Antonio.

[source,groovy]
----
[AUS,DAL,LAS]
[AUS,DFW,LAS]
[AUS,IAH,LAS]
[AUS,SAT,LAS]
[AUS,HOU,LAS]
----

Conversely, if we wanted to avoid certain airports we could use 'without' instead.
This query again finds routes from Austin to Las Vegas but avoids any routes that go
via Phoenix (PHX) or Los Angeles (LAX).

[source,groovy]
----
 g.V().has('airport','code','AUS').
       out().has('code',without('PHX','LAX')).
       out().has('code','LAS').path().by('code')
----

Lastly this query uses both within and without to modify the previous query to just
airports within the United States or Canada as Austin now has a direct flight to
London in England. We probably don't want to go that way if we are headed to Vegas!

[source,groovy]
----
g.V().has('airport','code','AUS').out().
      has('country',within('US','CA')).
      has('code',without('PHX','LAX')).out().
      has('code','LAS').path().by('code')
----

The 'within' and 'without' steps can take a variety of input types. For example, each
of these queries will yield the same results.

[source,groovy]
----
// Range of values (inclusive, inclusive)
g.V().hasId(within(1..3))

// Explicit set of values
g.V().hasId(within(1,2,3))

// List of values
g.V().hasId(within([1,2,3]))
----

[[winout]]
==== Refining flight routes analysis using 'not', 'neq', 'within' and 'without'

As we saw in the previous section, it is often useful to be able to specifically
include or exclude values from a query. We have already seen a few examples of
'within' and 'without' being used in the section above. The following examples show
additional queries that use 'within' and 'without' as well as some examples that use
the 'neq' (not equal) and 'not' steps to exclude certain airports from query results.

The following query finds routes from AUS to SYD with only one stop but ignores any
routes that stop in DFW.

[source,groovy]
----
g.V().has('airport','code','AUS').
      out().has('code',neq('DFW')).
      out().has('code','SYD').path().by('code')
----

We could also have written the query using 'not'

[source,groovy]
----
g.V().has('airport','code','AUS').
      out().not(values('code').is('DFW')).
      out().has('code','SYD').path().by('code')
----

Similar to the above but adding an 'and' clause to also avoid LAX.

[source,groovy]
----
g.V().has('airport','code','AUS').
      out().and(has('code',neq('DFW')),has('code',neq('LAX'))).
      out().has('code','SYD').path().by('code')
----

The above syntax uses the '__.and()' step as opposed to the 'P.and()' predicate. We
can rewrite this query using the latter form which is a bit more compact and 
readable.

[source,groovy]
----
g.V().has('airport','code','AUS').
      out().has('code',neq('DFW').and(neq('LAX'))).
      out().has('code','SYD').path().by('code')
----

We could also have written the prior query this way replacing 'and' with 'without'.
This approach feels a lot cleaner and it is easy to add more airports to the
'without' test as needed. We will look more at steps like 'and' in the "<<bool>>"
section that is coming up soon.

[source,groovy]
----
// Flights to Sydney avoiding DFW and LAX
g.V().has('airport','code','AUS').
      out().has('code',without('DFW','LAX')).
      out().has('code','SYD').path().by('code')
----

Using 'without' is especially useful when you want to exclude a list of items from a
query. This next query finds routes from San Antonio to Salt Lake City with one stop
but avoids any routes that pass through a list of specified airports.

[source,groovy]
----
// How can I get from SAT to SLC but avoiding DFW,LAX,PHX and JFK ?
g.V().has('airport','code','SAT').
      out().has('code',without('DFW','LAX','PHX','JFK')).
      out().has('code','SLC').path().by('code')
----

In a similar way, 'within' allows us to specifically give a list of things that we
*are* interested in. The query below again looks at routes from SAT to SLC with one
stop but this time only returns routes that stop in one of the designated airports.

[source,groovy]
----
// From AUS to SLC with a stop in any one of DFW,LAX,PHX or TUS
g.V().has('airport','code','SAT').
       out().has('code',within('DFW','LAX','PHX','TUS')).
       out().has('code','SLC').path().by('code')
----

Here is what the query returns.

[source,groovy]
----
[SAT,DFW,SLC]
[SAT,LAX,SLC]
[SAT,PHX,SLC]
----

Here are two more examples that use 'without' and 'within' to find routes based on
countries.

[source,groovy]
----
// Flights from Austin to countries outside (without) the US and Canada
g.V().has('code','AUS').out().has('country',without('US','CA')).values('city')
----

Here is the output from running the query.

[source,groovy]
----
Cancun
Puerto Vallarta
Nassau
Cozumel
Guadalajara
Liberia
San Jos del Cabo
London
London
Frankfurt
Amsterdam
Mexico City
----

Here is a twist on the previous query that looks for destinations in Mexico or Canada
that you can fly to non stop from Austin.

[source,groovy]
----
// Flights from Austin to airports in (within) Mexico or Canada
g.V().has('code','AUS').out().has('country',within('MX','CA')).values('city')
----

This is what we get back from our new query.

[source,groovy]
----
Cancun
Puerto Vallarta
Cozumel
Guadalajara
San Jos del Cabo
Toronto
Vancouver
Calgary
Mexico City
----

Returning to the earlier use of 'neq', it is worth considering a subtlety of its
behavior as compared to various form of of 'not' used in conjuction with 'eq'. Let's
examine the differences with the following example where we start by getting a vertex
count and a count of the number of vertices that have a city property.

[source,groovy]
----
g.V().count()

3749

g.V().has('city').count()

3504
----

Recall that 'not' is both a step and a predicate. When used as a predicate from 'P', 
you essentially negate the state of the predicate given to it directly, so 'eq' 
simply becomes 'neq' as shown below.

[source,groovy]
----
g.V().has('city',neq('I-do-not-exist')).count()

3504

g.V().has('city',P.not(neq('I-do-not-exist'))).count()

0
----

The city property must exist for the equality to be tested. We'll next see that this
is not the case if we try to negate with the 'not' step.

[source,groovy]
----
g.V().not(has('city',eq('I-do-not-exist'))).count()

3749
----

Using 'not' step in the fashion demonstrates all 3749 vertices do not have a city
property with the name "i-do-not-exist". The difference here is that with 'not' step
negates the entirety of what 'has' is doing, accounting for a false if the city is
not present at all or a false where the 'eq' is not satisfied. The predicate for of
'not' on the other hand does not bother evaluating the predicate at all if the city
property isn't present.

==== Using 'coin' and 'sample' to sample a dataset

In any sort of analysis work it is often useful to be able to take a sample, perhaps
a pseudo random sample, of the data set contained within your graph. The 'coin' step
allows you to do just that. It simulates a biased coin toss. You give 'coin' a value
indicating how biased the toss should be. The value should be between 0 and 1, where
0 means there is no chance something will get picked (not that useful!), 1 means
everything will get picked (also not that useful!) and 0.5 means there is an even
50/50 chance that an item will get selected.

The following query simply picks airports with a 50/50 coin toss and returns the
airport code for the first 20 found.

[source,groovy]
----
// Pick 20 airports at random with an evenly biased coin (50% chance).
g.V().hasLabel('airport').coin(0.5).limit(20).values('code')
----

This next query is similar to the first but takes a subtly different approach.
It will select a pseudo random sample of vertices from the graph and for each one
picked return its code and its elevation. Note that a very small value of
0.05 (or 5% chance of success) is used for the 'coin' bias parameter this
time. This has the effect that only a small number of vertices are likely to get
selected but there is a better chance they will come from all parts of the
graph and avoids needing a 'limit' step. Of course, there is no guarantee how
many airports this query will pick!

[source,groovy]
----
// Select some vertices at random and return them with their elevation.
g.V().hasLabel('airport').coin(0.05).values('code','elev').fold()
----

We can see how fairly the 'coin' step is working by counting the number of vertices
returned. The following query should always return a count representing approximately
half of the airports in the graph.

[source,groovy]
----
g.V().hasLabel('airport').coin(0.5).count()
----

If all you want is, say 20 randomly selected vertices, without worrying about
setting the value of the coin yourself, you can use the 'sample'
step instead.

[source,groovy]
----
g.V().hasLabel('airport').sample(20).values('code')
----

==== Using 'Math.random' to more randomly select a single vertex

While the 'sample' step allows you to select one or more vertices at random, in our
testing, at least when using a TinkerGraph, it tends to favor vertices with lower
index values. So for example, in a test we ran this query 1000 times.

[source,groovy]
----
g.V().hasLabel('airport').sample(1).id()
----

What we found was that we always got back an ID of less than 200. This leads me to
believe that the 'sample(1)' call is doing something similar to this

[source,groovy]
----
g.V().hasLabel('airport').coin(0.01).limit(1)
----

Look at the code below. Even if we run that simple experiment many times it always
gives results similar to these.

[source,groovy]
----
(1..10).each { println g.V().hasLabel('airport').sample(1).id().next()}

69
143
94
115
36
47
23
22
129
67
----

Given the air-routes graph has over 3,300 airport vertices we wanted to come up with
a query that gave a more likely result of picking any one airport from across all of
the possible airports in the graph. By taking advantage of the Java Math class we can
do something that does seem to much more 'randomly' pick one airport from across all
of the possible airports. Take a look at the snippets of Groovy/Gremlin code below.

NOTE: More examples of using variables to store values and other ways to use
additional Groovy classes and methods with Gremlin are provided in the "<<grv>>" and
"<<varaus>>" sections.


[source,groovy]
----
// How many airports are there?
numAirports = g.V().hasLabel('airport').count().next()

3504

// Pick a random airport ID
x=Math.round(numAirports*Math.random()) as Integer

1968

// Get the code for our randomly selected airport
g.V(x).values('code')

BSG
----

This simple experiment shows that the numbers being generated using the 'Math.random'
approach appears to be a lot more evenly distributed across all of the possible 
airports.

[source,groovy]
----
(1..10).each { println Math.round(numAirports*Math.random()) as Integer}

435
285
2189
3459
1355
624
3437
1656
1620
1896
----

Note that this approach only works unmodified with the 'air-routes' graph loaded into a
TinkerGraph. This is because we know that the TinkerGraph implementation honors user
provided IDs and that in the 'air-routes' graph, airport IDs begin at one and are
sequential with no gaps. However, you could easily modify this approach to work with
other graphs without relying on knowing that the index values are sequential. For
example you could extract all of the IDs into a list and then select one randomly
from that list.

It is likely that this apparent lack of randomness is more specific to TinkerGraph
and the fact that it will respect user provided ID values whereas other graph systems
will probably store vertices in a more random order to begin with and therefore yield
a better selection of airports from across the graph.

If the airport IDs were not all known to be in a sequential order one after the
other, we could create a list of all the airport IDs and then select one at random by
doing something like this if we wanted to use our 'Math.random' technique.

[source,groovy]
----
airports = g.V().hasLabel('airport').id().toList()

numAirports = airports.size()

3504

x=Math.round(numAirports*Math.random()) as Integer

1754

g.V(airports[x-1])

v[1757]

g.V(airports[x-1]).values('code')

JTY
----

[[textpredicates]]
=== Text search predicates

Among the '"predicates"' Gremlin has available are the ones used in performing more
focused text searches. There are three predicates that search for the existence of
one or more characters within a string of text and three that search for the non
existence of one or more characters.

TIP: Additional information on the text predicates can be found in the official
Apache TinkerPop documentation here: https://tinkerpop.apache.org/docs/current/reference/#a-note-on-predicates

.Text searching predicates
[cols="^1,4"]
|==============================================================================
|startingWith     | Match text that starts with the given character(s)
|endingWith       | Match text that ends with the given character(s)
|containing       | Match text that contains the given character(s)
|regex            | Match text using a regular expression
|notStartingWith  | Match text that does not start with the given character(s)
|notEndingWith    | Match text that does not end with the given character(s)
|notContaining    | Match text that does not contain the given character(s)
|notRegex         | Match text that does not match a regular expression
|==============================================================================

In the sections below you will find examples of each predicate being used. Each
predicate is case sensitive so bear that in mind as you use them. To do a case
insensitive search you can chain multiple steps together combined by an 'or' step.

NOTE: All of these predicates are *_case sensitive_*.

NOTE: Most TinkerPop enabled graph stores that you are likely to use for any sort of
serious deployment will also be backed by an indexing technology like Solr or
Elasticsearch. In those cases some amount of more sophisticated search methods will
likely be made available to you. You should always check the documentation for the
system you are using to see what is recommended.

These predicates add to the existing Gremlin predicates that we looked at in the
"<<tranges>>" section.

[[startingwith]]
==== startingWith

The text that you search for can be one or more characters. Here is a
simple example that looks for unique city names that begin with an uppercase "X".

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',startingWith('X')).
      values('city')
----

As expected, when run we get back a set of names all beginning with an "X".

[source,groovy]
----
Xiamen
Xianyang
Xuzhou
Xilinhot
Xiangfan
Xining
Xalapa
Xieng Khouang
Xiahe
Xiaguan
Xichang
Xingyi
Xinyuan
Xigaze
Xinyang
----

The example below looks for any cities with names starting with "Dal". A 'dedup' step
is used to get rid of any duplicate names in the results.

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',startingWith('Dal')).
      values('city').
      dedup().
      fold()
----

When run, the query finds all the city names in the graph that begin with the
characters "Dal" as expected.

[source,groovy]
----
[Dallas,Dalaman,Dalian,Dalcahue,Dalat,Dalanzadgad]
----

As we mentioned, all of the text predicates are case sensitive. If we were
to search for city names starting with the characters "dal" we would not find any
matches. The query below demonstrates this.

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',startingWith('dal')).
      count()

0
----

Given the predicates are case sensitive, if, for example, you need to find matches
for both 'Dal' or 'dal' you can do that as shown below using an 'or' step and two
'has' steps.

[source,groovy]
----
g.V().hasLabel('airport').
      or(has('city',startingWith('dal')),
         has('city',startingWith('Dal'))).
      dedup().by('city').
      count()

6
----

[[endingwith]]
==== endingWith

The example below looks for any city names ending with that characters "zhi".

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',endingWith('zhi')).
      values('city')

Changzhi
----

[[containing]]
==== containing

We can also look for cities whose names contain a certain string of one or more
characters. The example below looks for any cities with the string "gzh" in their
name.

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',containing('gzh')).
      values('city')
----

When run the query produces the following results.

[source,groovy]
----
Guangzhou
Hangzhou
Zhengzhou
Changzhi
Changzhou
Yongzhou
Yangzho
----

[[regex]]
==== regex

For more advanced text matching scenarios you can use regular expressions as part of
a query. Note that the first example below could also be achieved using a Gremlin 
'within' step as it is still really doing exact string comparisons but it gives us a 
template for how to write any query containing a regular expression. The example that
follows finds all airports in cities with names that begin with 'Dal' so it will find
Dallas, Dalaman, Dalian, Dalcahue, Dalat and Dalanzadgad!.

[source,groovy]
----
// Using a filter to search using a regular expression
g.V().has('airport','type','airport').
      has('city', TextP.regex('Dallas|Austin')).values('code')


// A regular expression to find any airport with a city name that begins with "Dal"
g.V().has('airport','type','airport').
      has('city', TextP.regex('^Dal\\w*')).values('city')
----

Gremlin adheres to the regex syntax prescribed by the Java `Pattern` class documented
at https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Pattern.html
The Java regular expression syntax may be different than the one you are used to so
it is worth taking a few minutes to study the documentation at that URL.

[[notStartingWith]]
==== notStartingWith

Each of the text predicates has an inverse step. We can use the 'notStartingWith'
predicate to look for city names that do not start with "Dal".

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',notStartingWith('Dal')).
      count()

3497
----

The example above returns the same results we would get if we were to negate a
'startingWith' predicate as shown below.

[source,groovy]
----
g.V().hasLabel('airport').
      not(has('city',startingWith('Dal'))).
      count()

3497
----

[[notEndingWith]]
==== notEndingWith

Using 'notEndingWith' we can easily find cities whose names do not end with "zhi".

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',notEndingWith('zhi')).
      count()

3503
----

[[notContaining]]
==== notContaining

The query below counts the number of cities that do not contain the string "berg" in
their name.

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',notContaining('berg')).
      count()

3500
----

Let's now do something a little more interesting. The query below chains together a
number of has steps using 'notContaining' and 'containing' predicates to find cities
with names containing no basic, lowercase, vowels commonly used in the English
language but containing either of the secondary vowels.

[source,groovy]
----
g.V().hasLabel('airport').
      has('city',notContaining('e')).
      has('city',notContaining('a')).
      has('city',notContaining('i')).
      has('city',notContaining('u')).
      has('city',notContaining('o')).
      or(has('city',containing('y')),
         has('city',containing('h'))).
      values('city').
      dedup()
----

Only two results are found. Note that one of the results does contain a vowel but it
is an uppercase "O" and as such is allowed by the constraints that we specified.

[source,groovy]
----
Brnny
Osh
Kyzyl
----

[[notRegex]]
==== notRegex

The 'notRegex' predicate is mostly present for Gremlin language symmetry as regular 
expressions can naturally express negations itself. 

[source,groovy]
----
// A regular expression to find airports not in Dallas or Austin
g.V().has('airport','type','airport').
      has('city', TextP.notRegex('Dallas|Austin')).values('code')
----

[[sort]]
Sorting things - introducing 'order'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can use 'order' to sort things in either ascending (the default) or descending
order. Note that the sort does not have to be the last step of a query. It is
perfectly OK to sort things in the middle of a query before moving on to a further
step. We can see examples of that in the first two queries below. Note that the first
query will return different results than the second one due to the placement of the
'limit' step. We used 'fold' at the end of the query to collect all of the results
into a list. The 'fold' step can also do more than this. It provides a way of doing
the 'reduce' part of map-reduce operations. We will see some other examples of its
use elsewhere in this book, such as in the "<<mapreduce>>" section.

[source,groovy]
----
// Sort the first 20 airports returned in ascending order
g.V().hasLabel('airport').limit(20).values('code').order().fold()

[ANC,ATL,AUS,BNA,BOS,BWI,DCA,DFW,FLL,IAD,IAH,JFK,LAX,LGA,MCO,MIA,MSP,ORD,PBI,PHX]
----

As above, but this time perform the 'limit' step after the 'order' step.

[source,groovy]
----
// Sort all of the airports in the graph by their code and then return the first 20
g.V().hasLabel('airport').order().by('code').limit(20).values('code').fold()

[AAA,AAE,AAL,AAN,AAQ,AAR,AAT,AAX,AAY,ABA,ABB,ABD,ABE,ABI,ABJ,ABL,ABM,ABQ,ABR,ABS]
----

Here is a similar example to the previous two. We find all of the places you can fly
to from Austin (AUS) and sort the results as before, using the airport's IATA code,
but this time we also include the ICAO code for each airport in the result set.

[source,groovy]
----
g.V().has('code','AUS').out().order().by('code').
                        values('code','icao').fold()
----

Here are the results from running the query.

[source,groovy]
----
[ABQ,KABQ,AMA,KAMA,AMS,EHAM,ASE,KASE,ATL,KATL,BHM,KBHM,BKG,KBBG,BNA,KBNA,BOI,KBOI,
 BOS,KBOS,BTR,KBTR,BUF,KBUF,BUR,KBUR,BWI,KBWI,BZN,KBZN,CHS,KCHS,CLE,KCLE,CLT,KCLT,
 CMH,KCMH,CUN,MMUN,CVG,KCVG,CZM,MMCZ,DAL,KDAL,DCA,KDCA,DEN,KDEN,DFW,KDFW,DSM,KDSM,
 DTW,KDTW,ECP,KECP,ELP,KELP,EWR,KEWR,FLL,KFLL,FRA,EDDF,GDL,MMGL,GRR,KGRR,HDN,KHDN,
 HNL,PHNL,HOU,KHOU,HRL,KHRL,IAD,KIAD,IAH,KIAH,IND,KIND,JAX,KJAX,JFK,KJFK,LAS,KLAS,
 LAX,KLAX,LBB,KLBB,LGB,KLGB,LGW,EGKK,LHR,EGLL,LIR,MRLB,LIT,KLIT,MCI,KMCI,MCO,KMCO,
 MDW,KMDW,MEM,KMEM,MEX,MMMX,MIA,KMIA,MKE,KMKE,MSP,KMSP,MSY,KMSY,NAS,MYNN,OAK,KOAK,
 OKC,KOKC,OMA,KOMA,ONT,KONT,ORD,KORD,PDX,KPDX,PHL,KPHL,PHX,KPHX,PIE,KPIE,PIT,KPIT,
 PNS,KPNS,PVD,KPVD,PVR,MMPR,RDU,KRDU,RNO,KRNO,SAN,KSAN,SAT,KSAT,SDF,KSDF,SEA,KSEA,
 SFB,KSFB,SFO,KSFO,SJC,KSJC,SJD,MMSD,SLC,KSLC,SMF,KSMF,SNA,KSNA,STL,KSTL,TPA,KTPA,
 TUL,KTUL,TUS,KTUS,TYS,KTYS,VPS,KVPS,XNA,KXNA,YVR,CYVR,YYC,CYYC,YYZ,CYYZ]
----

By default a sort performed using 'order' returns results in ascending order. To
obtain results in descending order instead, 'desc' can be specified using a `by`
modulator. Likewise, 'asc' can be used to make it clear that sorting in ascending
order is required.

[source,groovy]
----
// Sort the first 20 airports returned in descending order
g.V().hasLabel('airport').limit(20).values('code').order().by(desc).fold()

[PHX,PBI,ORD,MSP,MIA,MCO,LGA,LAX,JFK,IAH,IAD,FLL,DFW,DCA,BWI,BOS,BNA,AUS,ATL,ANC]
----

You can also sort things into a random order using 'shuffle'. Take a look at the
example below and the output it produces.

[source,groovy]
----
g.V().hasLabel('airport').limit(20).values('code').order().by(shuffle).fold()

[BWI,MSP,PHX,DCA,IAH,LAX,DFW,BNA,BOS,MCO,ORD,LGA,AUS,PBI,MIA,FLL,ATL,JFK,IAD,ANC]
----

It is important to call attention to the use of 'by' modulators with 'order' as they
introduce some special semantics when they are unproductive, a topic we learned about
in the "<<bymodulators>>" section. Let's modify an earlier example to make the 'by'
unproductive by introducing a spelling mistake to the property key we want to order
on:

[source,groovy]
----
g.V().has('code','AUS').out().
  order().by('cde').
  values('code','icao').fold()
  
[]  
----

As you can see, an unproductive 'by' makes 'order' behave like a filter for those 
traversers that can't make use of '"cde"' (which in this case is all of them). This
filtering semantic is often quite helpful when working with heterogenous elements by
providing some flexibilty in the face of what could otherwise just been an exception.
These semantics could lead to a temptation to use them to explicitly filter in the
'by' as follows:

[source,groovy]
----
g.V().has('code','AUS').out().
  order().by(__.as('v').values('runways').is(gt(4)).select('v').values('code')).
  values('code','icao').fold()
  
[ATL,KATL,BOS,KBOS,DEN,KDEN,DFW,KDFW,DTW,KDTW,IAH,KIAH,MDW,KMDW,ORD,KORD,YYZ,CYYZ]  
----

While the prior example works, it is not an advisable approach because it reduces the
readability of the query. It would far more idiomatic to write the above query with
an explicit 'has' fitler as shown next:

[source,groovy]
----
g.V().has('code','AUS').
  out().has('runways',gt(4)).
  order().by('code').
  values('code','icao').fold()
  
[AMS,EHAM,ATL,KATL,BOS,KBOS,DEN,KDEN,DFW,KDFW,DTW,
 KDTW,IAH,KIAH,MDW,KMDW,MKE,KMKE,ORD,KORD,YYZ,CYYZ]
----

Below is an example where we combine the field we want to sort by 'longest'
and the direction we want the sort to take, 'desc' into a single 'by' instruction.

[source,groovy]
----
// List the 10 airports with the longest runways in decreasing order.
g.V().hasLabel('airport').order().by('longest',desc).valueMap().
      select('code','longest').limit(10)
----

Here is the output from running the query. To save space we have split the results
into two columns.

[source,groovy]
----
[code:[BPX],longest:[18045]]
[code:[RKZ],longest:[16404]]
[code:[ULY],longest:[16404]]
[code:[UTN],longest:[16076]]
[code:[DEN],longest:[16000]]
[code:[DOH],longest:[15912]]
[code:[GOQ],longest:[15748]]
[code:[HRE],longest:[15502]]
[code:[FIH],longest:[15420]]
[code:[ZIA],longest:[15092]]
----

Let's look at another way we could have coded the query we used earlier to find the 
longest runway in the graph. As you may recall, we used the following query. While 
the query does indeed find the longest runway in the graph, if we wanted to know 
which airport or airports had runways of that length we would have to run a second 
query to find them.

[source,groovy]
----
g.V().hasLabel('airport').values('longest').max()
----

Now that we know how to sort things we could write a slightly more complex query that
sorts all the airports by longest runway in descending order and returns the
'valueMap' for the first of those. While this query could probably be written more
efficiently and also improved to handle cases where more than one airport has the
longest runway, it provides a nice example of using 'order' to find an airport that
we are interested in.

[source,groovy]
----
g.V().hasLabel('airport').order().by(values('longest'),desc).limit(1).valueMap()
----

In the case of the 'air-routes' graph there is only one airport with the longest
runway. The runway at the Chinese city of Bangda is 18,045 feet long. The reason the
runway is so long is due to the altitude of the airport which is located 14,219 feet
above sea level. Aircraft need a lot more runway to operate safely at that altitude!

[source,groovy]
----
[country:[CN],longest:[18045],code:[BPX],city:[Bangda],lon:[97.1082992553711],type:[airport],elev:[14219],icao:[ZUBD],region:[CN-54],runways:[1],lat:[30.5536003112793],desc:[Qamdo Bangda Airport]]
----

[[sortkeyvalue]]
==== Sorting by key or value

Sometimes, when the results of a query are a set of one or more key:value pairs, we
need to sort by either the key or the value in either ascending or descending order.
Gremlin offers us ways that we can control the sort in these cases. Examples of how
this works are shown below.

The following example shows the difference between running a query with and without
the use of 'order' to sort using the keys of the map created by the 'group' step.

[source,groovy]
----
// Query but do not order
g.V().hasLabel('airport').limit(5).group().by('code').by('runways')

[BNA:[4],ANC:[3],BOS:[6],ATL:[5],AUS:[2]]
----

Notice also how 'local' is used as a parameter to 'order'. This
is required so that the ordering is done while the final list is being constructed.
If you do not specify 'local' then 'order' will have no effect as it will be applied 
to the entire result which is treated as a single entity at that point.

[source,groovy]
----
// Query and order by airport code (the key)
g.V().hasLabel('airport').limit(5).
      group().by('code').by('runways').
      order(local).by(keys,asc)

[ANC:[3],ATL:[5],AUS:[2],BNA:[4],BOS:[6]]
----

In this example we make the numbers of runways the key field and sort on it in
descending order.

[source,groovy]
----
g.V().hasLabel('airport').limit(10).
      group().by('runways').by('code').
      order(local).by(keys,desc)

[7:[DFW],6:[BOS],5:[ATL],4:[BNA,IAD],3:[ANC,BWI,DCA],2:[AUS,FLL]]
----

[[bool]]
=== Boolean operations

Gremlin provides a set of logical operators such as 'and', 'or' and 'not' that can be
used to form Boolean (true/false) type queries. In a lot of cases we find that 'or'
can be avoided by using 'within' for example and that 'not' can be sometimes avoided
by using 'without' but it is still good to know that these operators exist. The
'and' operator can sometimes be avoided by chaining 'has' steps together. That said
there are always cases where having these boolean steps available is extremely
useful.


[source,groovy]
----
// Simple example of doing a Boolean AND operation
g.V().and(has('code','AUS'),has('icao','KAUS'))

// Simple example of doing a Boolean OR operation
g.V().or(has('code','AUS'),has('icao','KDFW'))
----

You can also use 'and' in an infix way as follows so long as you only want to 'and'
two traversals together.

[source,groovy]
----
g.V().has('code','AUS').and().has('icao','KAUS')
----

As you would probably expect, an 'or' step can have more than two choices. This one
below has four. Also, note that in practice, for this query, using 'within' would be
a better approach but this suffices as an example of a bigger 'or' expression.

[source,groovy]
----
g.V().hasLabel('airport').or(has('region','US-TX'),
                             has('region','US-LA'),
                             has('region','US-AZ'),
                             has('region','US-OK')).
                           order().by('region',asc).
                           valueMap().select('code','region')
----

Using 'within' the example above could be written like this so always keep in mind
that using 'or' may not always be the best approach to use for a given query. We
will look more closely at the 'within' and 'without' steps in the following section.

[source,groovy]
----
g.V().hasLabel('airport').has('region',within('US-TX','US-LA','US-AZ','US-OK')).
                          order().by('region',asc).
                          valueMap().select('code','region')
----

This next example uses an 'and' step to find airports in Texas with a runway at least
12,000 feet long.

[source,groovy]
----
g.V().hasLabel('airport').and(has('region','US-TX'),
                              has('longest',gte(12000))).values('code')
----

As with the 'or' step, using 'and' is not always necessary. We could rewrite the
previous query as follows.

[source,groovy]
----
g.V().has('region','US-TX').has('longest',gte(12000))
----

Gremlin also provides a 'not' step which works as you would expect. This query finds
vertices that are not airports.

[source,groovy]
----
g.V().not(hasLabel('airport')).count()
----

This previous query could also be written as follows.

[source,groovy]
----
g.V().has(label,neq('airport')).count()
----

TIP: Depending on the model of your graph and the query itself it may or may not make
sense to use the boolean steps. Sometimes, as described above chaining 'has' steps
together may be more efficient or using a step like 'within' or 'without' may make
more sense.

Boolean steps such as 'and' can also be dot combined as the example below shows. This
query finds all the airports that have fewer than 100 outbound routes but more than 
94 and returns them grouped by airport code and route count. Notice how in this case 
the 'and' step is added to the 'lt' step using a dot rather than having the 'and' be 
the containing step for the whole test. The results from running the query are shown
below as well.

[source,groovy]
----
g.V().hasLabel('airport').
      where(out().count().is(lt(100).and(gt(94)))).
      group().by('code').by(out().count())

[RIX:96,DCA:96,VCE:99,GRU:97,SFB:95,AUS:98,OPO:95]
----

The query we just looked at could also be written as follows but in this case using
the 'and' step inline by dot combining it (as above) feels cleaner to me. As you can
see we get the same result as before.

[source,groovy]
----
g.V().hasLabel('airport').where(and(out().count().is(lt(100)),
                out().count().is(gt(94)))).
                group().by('code').by(out().count())

[RIX:96,DCA:96,VCE:99,GRU:97,SFB:95,AUS:98,OPO:95]
----

As we have pointed out several times already, there are often many ways to write a
query that will produce the same result. Here is an example of the previous two
queries rewritten to use a 'between' step instead of an 'and' step. Remember that
'between' is inclusive/exclusive, so we have to specify 101 as the upper bound and 95
as the lower bound.

[source,groovy]
----
g.V().hasLabel('airport').where(out().count().is(between(95,101))).
                          group().by('code').by(out().count())

[RIX:96,BRS:100,DCA:96,KBP:100,VCE:99,GRU:97,AYT:100,SFB:95,AUS:98,OPO:95]
----

Just for fun, here is the same query but rewritten to use an 'inside' step.

[source,groovy]
----
g.V().hasLabel('airport').where(out().count().is(inside(94,100))).
                          group().by('code').by(out().count())

[RIX:96,DCA:96,VCE:99,GRU:97,SFB:95,AUS:98,OPO:95]
----

As a side note, if we wanted to reverse the grouping so that the airports were
grouped by the counts rather than the codes we could do that as follows.

[source,groovy]
----
g.V().hasLabel('airport').
      where(out().count().is(lt(100).and(gt(94)))).
      group().by(out().count()).by('code')

[96:[DCA,RIX],97:[GRU],98:[AUS],99:[VCE],95:[OPO,SFB]]
----

You can also add additional inline 'and' steps to a query as shown below. Notice that
this time 'AUH' and 'NCE' are not part of the result set as they have 97 routes which
our new 'and' test eliminates.

[source,groovy]
----
g.V().hasLabel('airport').
      where(out().count().is(lt(100).and(gt(94)).and(neq(97)))).
      group().by(out().count()).by('code')

[96:[DCA,RIX],98:[AUS],99:[VCE],95:[OPO,SFB]]
----

The 'where' step was used lot in the examples above. Hopefully the effect of using it
was clear. Nonetheless we will explain in more detail how the 'where' step works in
the next section.

[[where]]
=== Using 'where' to filter things out of a result

We have already seen the 'where' step used in some of the prior examples. In this
section we will take a slightly more focussed look at the 'where' step. The 'where'
step is an example of a 'filter'. It takes the current state of a traversal and only
allows anything that matches the specified constraint to pass on to any following
steps. 'Where' can be used by itself, or as we shall see later, in conjunction with a
'by' modulator or following a 'match' or a 'choose' step.

TIP: It is worth noting that some queries that use 'where' can also be written using
'has' instead.

Let's start by looking at a simple example of how 'has' and 'where' can be
used to achieve the same result.

[source,groovy]
----
// Find airports with more than five runways
g.V().has('runways',gt(5))

// Find airports with more than five runways
g.V().where(values('runways').is(gt(5)))
----

In examples like the one above, both queries will yield the exact same results but
the 'has' step feels simpler and cleaner for such cases. Notice how in the 'where'
step version the 'gt' predicate has to be placed inside of an 'is' step. The next
example starts to show the real power of the 'where' step. We can include a traversal
inside of the 'where' step that does some filtering for us. In this case, we first
find all vertices that are airports and then use a 'where' step to only keep airports
that have more than 60 outgoing routes. Finally we count how many such airports we
found.

[source,groovy]
----
// Airports with more than 60 unique routes from them
g.V().hasLabel('airport').where(out('route').count().is(gt(60))).count()

215
----

In our next example, we want to find routes between airports that have an ID of less
than 47 but only return routes that are longer than 4,000 miles. Again, notice how we
are able to look at the incoming vertex ID values by placing a reference to 'inV' at
the start of the 'where' expression. The 'where' step is placed inside of an 'and'
step so that we can also examine the 'dist' property of the edge. Finally we return
the path as the result of our query.

[source,groovy]
----
// Routes longer than 4,000 miles between airports with and ID less than 47
g.V().hasId(lt(47)).outE().
      and(where(inV().id().is(lt(47))),values('dist').is(gt(4000))).
      inV().path().by('code').by('dist')
----

Below is what we get back as a result of running the query.

[source,groovy]
----
[ATL,4502,HNL]
[BOS,5083,HNL]
[IAD,4806,HNL]
[JFK,4970,HNL]
[ORD,4230,HNL]
[EWR,4950,HNL]
[HNL,4502,ATL]
[HNL,5083,BOS]
[HNL,4806,IAD]
[HNL,4970,JFK]
[HNL,4230,ORD]
[HNL,4950,EWR]
----

Sometimes you will be looking for results that match the inverse condition of a
'where' step. One way this can be achieved is to wrap the 'where' step inside of a
'not' step, as shown below.

NOTE: The double underscore prefix '"+++__.+++"' before the 'in' step is required as
'in' is a reserved word in Groovy. If you are using the Gremlin Console and do not
include the prefix you will get an error. This is explained in more detail in the
"<<rword>>" section a bit later. The '"+++__.+++"' notation is actually a reference
to a special TinkerPop Java class that has the name '"+++__+++"' (double underscore)
but don't worry about that for the time being. In fact, for now, just think of
'"+++__+++."' as meaning '"the result of the previous step"'. This will become
important once we start looking at writing a Java program to issue Gremlin queries
and is discussed in the "<<tpinterfaces>>" section quite a bit later on.

The query starts by finding the Austin airport (AUS) and then finds all outgoing
routes. We then look at all incoming 'contains' edges to see which country each
airport we can fly to is in. The 'not' step ensures that only airports that do not
have the United States country code of 'US' are selected.

[source,groovy]
----
g.V().has('airport','code','AUS').
      out().not(where(__.in('contains').has('code','US'))).
      valueMap('code','city')
----

As you can see, when we run the query, only destinations outside the United States
are returned.

[source,groovy]
----
[code:[CUN],city:[Cancun]]
[code:[PVR],city:[Puerto Vallarta]]
[code:[NAS],city:[Nassau]]
[code:[CZM],city:[Cozumel]]
[code:[GDL],city:[Guadalajara]]
[code:[LIR],city:[Liberia]]
[code:[SJD],city:[San Jos del Cabo]]
[code:[YYZ],city:[Toronto]]
[code:[YVR],city:[Vancouver]]
[code:[LHR],city:[London]]
[code:[LGW],city:[London]]
[code:[FRA],city:[Frankfurt]]
[code:[AMS],city:[Amsterdam]]
[code:[YYC],city:[Calgary]]
[code:[MEX],city:[Mexico City]]
----

This pattern comes in useful whenever you want to use a traversal inside of a 'where'
step and negate the results. Of course, there are other ways we could write this
particular query but we wanted to show an example of this technique being used. For
completeness, two simpler ways of writing this query that do not use 'where' at all
are shown below but there will be cases where combining 'not' and 'where' are your
best option.

[source,groovy]
----
g.V().has('airport','code','AUS').
      out().has('country', neq('US')).valueMap('code','city')

g.V().has('airport','code','AUS').
      out().not(has('country', 'US')).valueMap('code','city')
----

It is also possible to use some special forms of the 'and' and 'or' steps when
working with a 'where' step. Take a look at the query below. This will match airports
that you can fly to from Austin (AUS) so long as they have more than four runways
and do not have exactly six runways.

[source,groovy]
----
g.V().has('airport','code','AUS').out().
      where(values('runways').is(gt(4).and(neq(6)))).
      valueMap('code','runways')
----

Here is what the query returns. As you can see we only found airports that you can
fly to from AUS that have 5,7 or 8 runways.

[source,groovy]
----
[code:[MKE],runways:[5]]
[code:[MDW],runways:[5]]
[code:[ATL],runways:[5]]
[code:[DFW],runways:[7]]
[code:[IAH],runways:[5]]
[code:[ORD],runways:[7]]
[code:[YYZ],runways:[5]]
----

The same is true for the 'or' step. We could rewrite our query to find airports we
can fly to from Austin that have more than six or exactly four runways.

[source,groovy]
----
g.V().has('airport','code','AUS').out().
      where(values('runways').is(gt(6).or(eq(4)))).
      valueMap('code','runways')
----

The above is a shorter form of the following query which demonstrates another way we
could use the boolean operators within a 'where' step. In this case only two
traversals are allowed to be compared using the boolean operator (in this case an
'or' step).

[source,groovy]
----
g.V().has('airport','code','AUS').out().
      where(values('runways').is(gt(6)).or().values('runways').is(4)).
      valueMap('code','runways')
----

Our last example in this section uses a 'where' step to make sure we don't end up
back where we started when looking at airline routes with one stop. We find routes
that start in Austin, with one intermediate stop, that then continue to another
airport, but never end up back in Austin. A 'limit' step is used to just return the
first 10 results that match this criteria. Notice how the 'as' step is used to label
the 'AUS' airport so that we can refer to it later in our 'where' step. The effect of
this query is that routes such as AUS->DFW->AUS will not be returned but
AUS->DFW->LHR will be as it does not end up back in Austin.

[source,groovy]
----
// List 10 places you can fly to with one stop, starting at Austin but
// never ending up back in Austin
g.V().has('airport','code','AUS').as('a').
      out().out().where(neq('a')).
      path().by('code').limit(10)
----

As you work with Gremlin, you will find that the 'where' step is one that you use a
lot. You will see many more examples of 'where' being used throughout the remainder
of this book. In the next section we will look at some additional ways that 'where'
can be used.

[[whereby]]
==== Using 'where' and 'by' to filter results

A 'where' step can be followed with a 'by' modulator. The query below starts at the
Austin airport and finds all the airports that you can fly to from there. A 'where'
'by' step is then used to filter the results to just those airports that have the
same number of runways that Austin has. What is really nice about this is that we
do not have to know ahead of time how many runways Austin itself has as that is
handled for us by the query.

[source,groovy]
----
g.V().has('code','AUS').as('a').out().
      where(eq('a')).by('runways').valueMap('code','runways')
----

TIP: Combining the 'where' and 'by' steps allows you to write powerful queries in a
nice and simple way.

If you were to run the query in the Gremlin Console, these are the results that you
should see. Note that all the airports returned have two runways. This is the same
number of runways that the Austin airport has.

[source,groovy]
----
[code:[ONT],runways:[2]]
[code:[CUN],runways:[2]]
[code:[NAS],runways:[2]]
[code:[JAX],runways:[2]]
[code:[PVD],runways:[2]]
[code:[SMF],runways:[2]]
[code:[BHM],runways:[2]]
[code:[BUF],runways:[2]]
[code:[CMH],runways:[2]]
[code:[DSM],runways:[2]]
[code:[CZM],runways:[2]]
[code:[AMA],runways:[2]]
[code:[CHS],runways:[2]]
[code:[GDL],runways:[2]]
[code:[PNS],runways:[2]]
[code:[TYS],runways:[2]]
[code:[VPS],runways:[2]]
[code:[BUR],runways:[2]]
[code:[FLL],runways:[2]]
[code:[SNA],runways:[2]]
[code:[MSY],runways:[2]]
[code:[LHR],runways:[2]]
[code:[LGW],runways:[2]]
[code:[MEX],runways:[2]]
----

The ability to combine 'where' and 'by' steps together allows us to avoid having to
write the previous query in more complicated ways such as the one shown below.

[source,groovy]
----
g.V().has('code','AUS').as('a').out().as('b').
      filter(select('a','b').by('runways').where('a',eq('b'))).
      valueMap('code','runways')
----

There is also a two parameter form of the 'where' step that you may have noticed used
above. In this case the first parameter refers to a label defined earlier in the
query. Take a look at the example below. We find the vertex for the Austin (AUS)
airport and label it '+++'+++a+++'+++'. We then look at all the airports you can fly
to from there and label them '+++'+++b+++'+++'. We then use a 'where' step to compare
'+++'+++a+++'+++' and '+++'+++b+++'+++'. Only airports with fewer runways than Austin
should be returned.

[source,groovy]
----
g.V().has('airport','code','AUS').as('a').out().as('b').
      where('a',gt('b')).by('runways').valueMap('code','runways')
----

Austin has two runways so only airports with one runway are returned by this query
when run.

[source,groovy]
----
[code:[PVR],runways:[1]]
[code:[ECP],runways:[1]]
[code:[LIR],runways:[1]]
[code:[SJD],runways:[1]]
[code:[XNA],runways:[1]]
[code:[HDN],runways:[1]]
[code:[ASE],runways:[1]]
[code:[BKG],runways:[1]]
[code:[SAN],runways:[1]]
----

It is also possible to compare two different properties by adding a second 'by'
modulator. This is useful when vertex properties have different key names but may
contain the same values. The query below is definitely contrived, you could achieve
the same thing in a more simple way, but it does demonstrate two 'by' modulators
being used. The 'country' property of an airport vertex is compared with the 'code'
property of a 'country' vertex. The query first finds any airport vertex with a
'city' property containing the string 'London'. Next any connecting 'country'
vertices (ones connected by contains edges) are found. The 'where' test compares the
country code value of the two vertices. Lastly a 'select' is used to pick the
results that we want to return.

[source,groovy]
----
g.V().has('airport','city','London').as('a','r').
      in('contains').as('b').
      where('a',eq('b')).by('country').by('code').
      select('a','r','b').by('code').by('region')
----

When the query is run we get back all the airports with a city name of 'London' along
with their region code and country code.

[source,groovy]
----
[a:LHR,r:GB-ENG,b:UK]
[a:LGW,r:GB-ENG,b:UK]
[a:LCY,r:GB-ENG,b:UK]
[a:STN,r:GB-ENG,b:UK]
[a:LTN,r:GB-ENG,b:UK]
[a:YXU,r:CA-ON,b:CA]
----

As we mentioned the above query was used just as an example. In reality the following
query that does not use any 'where' steps would have sufficed in this case.

[source,groovy]
----
g.V().has('airport','city','London').
      valueMap('code','region','country')

[country:[UK],code:[LHR],region:[GB-ENG]]
[country:[UK],code:[LGW],region:[GB-ENG]]
[country:[UK],code:[LCY],region:[GB-ENG]]
[country:[UK],code:[STN],region:[GB-ENG]]
[country:[UK],code:[LTN],region:[GB-ENG]]
[country:[CA],code:[YXU],region:[CA-ON]]
----

As the 'where' step takes a predicate for its matching conditions, it allows for a
great deal of flexibilty in the types of filtering that you can do. In the following
example, we find '"IAD"' and use the first three letters of its city name to find
other airports that start with those three letters:

[source,groovy]
----
g.V().has('airport','code','IAD').as('a').
  V().hasLabel('airport').
  where(startingWith('a')).
    by('city').
    by(values('city').substring(0,3)).
  values('city')
----

Note that the order of the 'by' modulators is such that the first 'by' refers to the
incoming traverser to 'where' and the second refers to the "a" vertex referenced in
the 'startingWith'. 

We've seen how the number of 'by' modulators correspond to the parameters in the 
'where' and that they are applied in a round-robin fashion, starting with the 
value of the traverser being compared and then to the values it is to be compared 
with. We can further see this on display when we look at a query that uses 'between'
where there are three arguments to consider. For example, let's imagine we wanted to
find five airports that have a number of runways that are between one less and one 
more than 'IAD'. 

[source,groovy]
----
g.V().has('airport','code','IAD').values('runways').as('iadl','iadh').
  V().hasLabel('airport').
  where(between('iadl','iadh')).
    by('runways').
    by(math('_ - 1')).
    by(math('_ + 1')).
  limit(5).
  values('code').fold()
  
[ANC,BNA,BWI,DCA,IAD]
----

In this prior example, we find IAD and then keep that value in two step labels. Those
labels are used later as arguments to 'between'. Note that there are three 'by' 
modulators that follow the 'where'. The first refers to the current airport vertex 
that we are considering for this filter and that 'by' ensures we use the runways 
value in the comparison to 'between'. You can see that this initial 'by' relates to 
an implied reference to the current traverser as there is no label for it present in
the 'where'. The second two 'by' modulators refers to the step labels in the 
'between' and do a 'math' operation that subtract and add 1 to the number of runways 
for 'IAD'. In this way, you get the effect of dynamically calculating filtering 
arguments based on a prior portion of a query.

Let's imagine that we want to write a query to find all airports that have the same
region code as the French airport of Nice. Let's assume for now that we do not know
what the region code is so we cannot just write a simple query to find all airports
in that region. So, instead we need to write a query that will first find the region
code for Nice and then use that region code to find any other airports in the region.
Finally we want to return the airport code along with the city name and the region
code. One way of writing this query is to take advantage of the 'where...by'
construct.

Take a look at the query below and the output it generates.

[source,groovy]
----
g.V().has('code','NCE').values('region').as('r').
  V().hasLabel('airport').as('a').values('region').
      where(eq('r')).by().
      local(select('a').values('city','code','region').fold())

[NCE,Nice,FR-U]
[MRS,Marseille,FR-U]
[TLN,Toulon/Hyres/Le Palyvestre,FR-U]
[AVN,Avignon/Caumont,FR-U]
----

TIP: In the sample programs folder you will find a program called GraphRegion.java
that shows how to perform the query shown above in a Java program.

There are several things about this query that are interesting. Firstly because we
are comparing the results of two 'values' steps we do not provide a parameter to the
'by' step as we do not need to provide a property key. Secondly, we use a second
'V' step in the query to find all the airports that have the same region code as
Nice. Note that this also means that Nice is included in the results. Lastly we wrap
the part of the query that prepares the output in a form we want in a 'local' step so
that a separate list is created for each airport.

[[choose]]
=== Using 'choose' to write if...then...else type queries

The 'choose' step allows the creation of queries that are a lot like the "if then
else" constructs found in most programming languages. If we were programming in Java
we might find ourselves writing something like the following.

[source,java]
----
if (longest > 12000) {
    return(code);
} else {
    return(desc);
}
----

Gremlin offers us a way to do the same thing. The query below finds all the airports
in Texas and then will return the value of the 'code' property if an airport has a
runway longer than 12,000 feet otherwise it will return the value of the 'desc'.

[source,groovy]
----
// If an airport has a runway > 12,000 feet return its code else return its description
g.V().has('region','US-TX').
      choose(values('longest').is(gt(12000)),
             values('code'),
             values('desc')).
      limit(5)
----

When run the output returned should look like this.

[source,groovy]
----
AUS
DFW
IAH
San Antonio
Houston Hobby
----

If the "else" part of the 'choose' step is not provided then it behaves as a simple
"if".

[source,groovy]
----
g.V().has('region','US-TX').
      choose(values('longest').is(gt(12000)),
             values('code')).
             limit(5)
----

The "else" in this case is implied and the incoming element that the 'choose'
step received is passed on as shown below.

[source,groovy]
----
AUS
DFW
IAH
v[33]
v[38]
----

Here is another example that uses the same constructs.

[source,groovy]
----
// If an airport has a code of AUS or DFW report its region else report its country
g.V().hasLabel('airport').
      choose(values('code').is(within('AUS','DFW')),
             values('city'),
             values('region')).
     limit(5)
----

[[chooseconstant]]
==== Including a constant value - introducing 'constant'

Sometimes it is very useful, as the example below demonstrates, to return constant
rather than derived values as part of a query. This query will return the string
"some" if an airport has fewer than four runways or "lots" if it has more than four.

[source,groovy]
----
// You can also return constants using the constant() step
g.V().hasLabel('airport').limit(10).
      choose(values('runways').is(lt(4)),
             constant('some'),
             constant('lots'))
----

TIP: The 'constant' step can be used to return a constant value as part of a query.

Here is one more example that uses a 'sample' step to pick 10 airports and then
return either "lots" or "not so many" depending on whether the airport has more than
50 routes or not. Note also how 'as' and 'select' are used to combine both the
derived and constant parts of the query result that we will ultimately return.

[source,groovy]
----
g.V().hasLabel('airport').sample(10).as('a').
      choose(out('route').count().is(gt(50)),
             constant('lots'),
             constant('not so many')).as('b').
      select('a','b').by('code').by()
----

Here is an example of what the output from running this query might look like.

[source,groovy]
----
[a:PKA,b:not so many]
[a:ISL,b:not so many]
[a:NDR,b:not so many]
[a:PAZ,b:not so many]
[a:NER,b:not so many]
[a:KIX,b:lots]
[a:THD,b:not so many]
[a:YCD,b:not so many]
[a:BTJ,b:not so many]
[a:KBP,b:lots]
----

We could go one step further if you don't want the 'a:' and 'b:' keys returned as
part of the result by adding a 'select(values)' to the end of the query as follows.

[source,groovy]
----
g.V().hasLabel('airport').sample(10).as('a').
      choose(out('route').count().is(gt(50)),
             constant('lots'),
             constant('not so many')).as('b').
      select('a','b').by('code').by().select(values)
----

Here is what the output from the modified form of the query.

[source,groovy]
----
[IBZ,lots]
[DOH,lots]
[LRE,not so many]
[TCT,not so many]
[AMQ,not so many]
[YYC,lots]
[GUC,not so many]
[CEZ,not so many]
[PSC,not so many]
[JCB,not so many]
----

The 'constant' step is not limited to use within 'choose' steps. It can be used
wherever needed. You will find many examples of its use throughout this book
including in the "<<union>>" section.

[[option]]
=== Using 'option' to write case/switch type queries

When 'option' is combined with 'choose' the result is similar to the 'case' or
'switch' style construct found in most programming languages. In Java for example, we
might code a 'switch' statement as follows.

[source,java]
----
switch(airport) {
    case "DFW": System.out.println(desc); break;
    case "AUS": System.out.println(region); break;
    case "LAX": System.out.println(runways);
}
----

We can write a Gremlin query that follows the same pattern as our Java 'switch'
statement. As in the Java example we decided to lay our query out across multiple
lines to aid readability and clarity.

[source,groovy]
----
// You can combine choose and option to generate a more "case statement" like query
g.V().hasLabel('airport').
      choose(values('code')).
        option('DFW',values('desc')).
        option('AUS',values('region')).
        option('LAX',values('runways'))
----

The example below shows a 'choose' followed by four options. Note the default case
of 'none' is used as the catchall. Notice how in this case, the values returned are
constants.

[source,groovy]
----
// You can return constant values if you need to
g.V().hasLabel('airport').limit(10).
      choose(values('runways')).
        option(1,constant('just one')).
        option(2,constant('a couple')).
        option(7,constant('lots')).
        option(none,constant('quite a few'))
----

The 'option' step can also include a predicate, allowing more complex comparisons to
be made as part of that 'choose'. This allows testing that a value is greater than
or less than another, for example, as part of the 'option' step without needing to
write a more complex query.

The query below creates a group containing the counts of airports that fall into one
of the categories generated by the 'choose' and 'option' steps. Any airport situated
above 5,000 feet of elevation will be categorized as "high", greater than 3,000 feet
as "medium" and all others as "low".

[source,groovy]
----
g.V().hasLabel('airport').
      groupCount().
        by(choose(values('elev')).
             option(gt(5000),constant('high')).
             option(gt(3000),constant('medium')).
             option(none,constant('low')))

[high:163,low:3127,medium:214]
----

[[patmatch]]
=== Using 'match' to do pattern matching

The 'match' step allows a more declarative style of pattern based query to be
expressed using Gremlin. 'Match' can be a bit hard to master but once you figure it
out it can be a very powerful way of traversing a graph looking for specific
patterns. As we shall see however, sometimes a `where` step is more than adequate
and can be used to express similar patterns to those supported by 'match'.

Below is an example that uses 'match' to look for airline route patterns where there
is a flight from one airport to another but no return flight back to the original
airport. The first query looks for such patterns involving the JFK airport as the
starting point. You can see the output from running the query below it. This is the
correct answer as, currently, the British Airways Airbus A318 flight from London City
(LCY) airport stops in Dublin (DUB) to take on more fuel on the way to JFK but does
not need to stop on the way back because of the trailing wind.

[source,groovy]
----
// Find any cases of where you can fly from JFK non stop
// to a place you cannot get back from non stop. This query
// should return LCY, as the return flight stops in Dublin
// to refuel.
g.V().has('code','JFK').
      match(__.as('s').out().as('d'),
            __.not(__.as('d').out().as('s'))).
      select('s','d').by('code')

[s:JFK,d:LCY]
----

We can expand the query by leaving off the specific starting point of JFK and look
for this pattern anywhere in the graph. This really starts to show how important and
useful the 'match' Gremlin step is. We don't have any idea what we might find, but by
using 'match', we are able to describe the pattern of behavior that we are looking
for and Gremlin does the rest.

[source,groovy]
----
// Same as above but from any airport in the graph.
g.V().hasLabel('airport').
      match(__.as('s').out().as('d'),
            __.not(__.as('d').out().as('s'))).
      select('s','d').by('code')
----

If you were to run the query you would find that there are in fact over 200 places in
the graph where this situation applies. We can add a 'count' to the end of query to
find out just how many there are.

[source,groovy]
----
// How many occurrences of the pattern in the graph are there?
g.V().hasLabel('airport').
      match(__.as('s').out().as('d'),
            __.not(__.as('d').out().as('s'))).
      count()

339
----

The next query looks for routes that follow the pattern A->B->C but where there is no
direct flight of the form A->C. In other words it looks for all routes between two
airports with one intermediate stop where there is no direct flight alternative
available. Note that the query also eliminates any routes that would end up back at
the airport of origin. To achieve the requirement that we not end up back where we
started, a 'where' step is included to make sure we do not match any routes of the
form A->B->A.

[source,groovy]
----
g.V().hasLabel('airport').
      match(__.as('a').out().as('b')
           ,__.as('b').out().where(neq('a')).as('c')
           ,__.not(__.as('a').out().as('c'))).
      select('a','b','c').by('code').limit(10)
----

There are, of course a lot of places in the 'air-routes' graph where this pattern can
be found. Here are just a few examples of the results you might get from running the
query.

[source,groovy]
----
[a:ATL,b:YYZ,c:YVR]
[a:ATL,b:YYZ,c:LGW]
[a:ATL,b:YYZ,c:DEL]
[a:ATL,b:YYZ,c:HKG]
[a:ATL,b:YYZ,c:PEK]
[a:ATL,b:YYZ,c:BOM]
[a:ATL,b:YYZ,c:PRG]
[a:ATL,b:YYZ,c:BCN]
[a:ATL,b:YYZ,c:VIE]
[a:ATL,b:YYZ,c:YOW]
----

Here is another example of using 'match' along with a 'where'. This is actually a
different way of writing a query we saw earlier. This query starts out by looking at
how many runways Austin has and then looks at every airport that you can fly to from
Austin and then looks at how many runways those airports have. Only airports with the
same number as Austin are returned. Using a 'match' step for this task is overkill.
However, it does show the basic constructs used by the 'match' step and again
illustrates using values calculated in one part of a query later on in that same
query.

[source,groovy]
----
g.V().has('code','AUS').
      match(__.as('aus').values('runways').as('ausr'),
            __.as('aus').out('route').as('outa').values('runways').as('outr')
              .where('ausr',eq('outr'))).
      select('outa').valueMap().select('code','runways')
----

As we mentioned, the example above is not the best way to write this query and it can
be done without using a 'match' step at all and just using a 'where' step as shown in
the three examples below. Each one is simpler than its predecessor.

One way we could choose to write this query is using multiple select steps. This is
also not a very efficient solution but does work.

[source,groovy]
----
g.V().has('code','AUS').as('aus').values('runways').as('ausr').
      select('aus').out().as('outa').values('runways').as('outr').
      where('ausr',eq('outr')).
      select('outa').valueMap().select('code','runways')
----

A better way than either of the prior two combines a 'filter' step with the 'where'
and 'select' steps.

[source,groovy]
----
g.V().has('code','AUS').as('a').out().as('b').
      filter(select('a','b').by('runways').where('a',eq('b'))).
      valueMap('code','runways')
----

As mentioned in the "<<whereby>>" section, this query can be simplified further using
a 'where' step and a 'by' modulator.

[source,groovy]
----
g.V().has('code','AUS').as('a').out().
       where(eq('a')).by('runways').
       valueMap('code','runways')
----

So, while there is often a simpler way to write a query that avoids using the 'match'
step, for some queries, especially in more complex cases, it provides a useful and
powerful way to express in a more declarative way, a set of criteria that must be
met. However, before we resort to using a 'match' step we always think carefully
about other ways that we could write the query that might be simpler. We do this
because the syntax of the 'match' step can be tricky to get right without a fair bit
of trial and error in our experience.

[[patternwhere]]
==== Pattern matching using a 'where' step

As the Gremlin language has evolved, many queries that might seem a perfect candidate
for a 'match' step can actually also be written using a 'where' step but still in a
more declarative style. We can rewrite the query from the previous section that looks
at routes from JFK that do not have a return flight using a 'where' step as shown
below.

The way to read this, in a similar way as with a 'match' step is as follows. Starting
at JFK, look at all the places we can fly to but only keep those airports that do not
have a route back to JFK. Note that the 'as' step plays two roles in this query.
Outside of the 'where' step it is used to label steps in the query we want to refer
back to later. Inside the 'where' step it provides a convenient shorthand way to
refer back to the departure airport.

[source,groovy]
----
g.V().has('code','JFK').as('s').
      out().as('d').
      where(__.not(out().as('s'))).
      select('s','d').by('code')

[s:JFK,d:LCY]
----

As we have seen in some prior examples, if you only want the airport codes in the
result and not the "s" and "d" keys, adding an additional 'select' step is all that
it takes.

[source,groovy]
----
g.V().has('code','JFK').as('s').
      out().as('d').
      where(__.not(out().as('s'))).
      select('s','d').by('code').
      select(values)

[JFK,LCY]
----

The query can be expanded to search for this same pattern across the whole
graph. The example below returns the first ten routes found where there is no return
flight. The results are sorted in ascending order using the departure airport code.

[source,groovy]
----
g.V().hasLabel('airport').as('s').
      out().as('d').
      where(__.not(out().as('s'))).
      limit(10).
      select('s','d').by('code').
      order().by(select('s'))
----

When run the query returns the following results.

[source,groovy]
----
[s:AMS,d:DSS]
[s:BNE,d:BCI]
[s:BNE,d:BKQ]
[s:BOM,d:DIU]
[s:CLE,d:SJC]
[s:HEL,d:IVL]
[s:IAD,d:AMM]
[s:JFK,d:LCY]
[s:ORD,d:ADD]
[s:SIN,d:PBH]
----

[[union]]
=== Using 'union' to combine query results

The 'union' step works just as you would expect from its name. It allows us to
combine parts of a query into a single result. Just as with the boolean 'and' and
'or' steps it is sometimes possible to find other ways to do the same thing without
using 'union' but it does offer some very useful capability.

Here is a simple example that uses a 'union' step to produce a list containing a
vertex and the number of outgoing routes from that vertex. Note that in the next
section we will see that there are simpler ways to write this query while still using
a 'union' step. The main point to take away from this example is that you can use a
'union' step to combine the results of multiple traversals. This example combines the
results of two traversals but you can certainly combine more as needed. Note that the
'out' step starts from the vertex that was found immediately before the 'union' step
which in this case is the DFW vertex. So in other words the output from the prior
step is available to the steps within the 'union' step just as with other Gremlin
steps we have already looked at.

[source,groovy]
----
g.V().has('airport','code','DFW').as('a').
      union(select('a'),out().count()).fold()

[v[8],253]
----

Not that this is recommended, but the previous query could also be written as follows
using two 'has' steps both inside a single 'union' step. This does however
demonstrate that you can use a 'union' step to combine the results of fairly
arbitrary graph traversals.

[source,groovy]
----
g.V().union(has('airport','code','DFW'),
            has('airport','code','DFW').
               out().count()).fold()

[v[8],253]
----

As a side note, instead of using a 'union' step and producing a list, we might decide
to use a 'group' step and produce a map. A map might be preferable if you want to
access individual keys and values directly. It all depends, as always, on the results
that best fit the problem you are solving.

[source,groovy]
----
g.V().has('airport','code','DFW').
      group().by().by(out().count())

[v[8]:253]]
----

Another aspect of 'union' to consider is that it can be used as a start step, which
means that you can essentially start a traversal from multiple points.

[source,groovy]
----
g.union(V().has('airport','code','DFW'),
        V().has('airport','code','IAD')).
  values('code').fold()
        
[DFW,IAD]
----

The prior example is meant as a demonstration. Typically, it will make more sense to 
use a `union` this way when you have disparate sets of things you wish to combine to
a single traversal stream. In this case, you can see that we're just filtering 
airports by their code. It's more likely that you would write that query as follows:

[source,groovy]
----
g.V().has('airport','code',within('DFW','IAD')).values('code').fold()

[DFW,IAD]
----

[[unionidentity]]
==== Introducing the 'identity' step

Gremlin has an 'identity' step that we have not seen used so far in this book. The
'identity' step simply returns the entity that was passed in to the current step of a
traversal (in this case 'union') from the prior step. We can rewrite the query we
used above to use an 'identity' step. This simplifies the query as it removes the
need to use the 'as' and 'select' steps. As shown below, using 'identity' causes the
vertex 'V[8]' representing the DFW airport from the prior 'has' step to be included
in the result.

[source,groovy]
----
g.V().has('airport','code','DFW').
      union(identity(),out().count()).fold()

[v[8],253]
----

We could modify the query slightly to have the first part of the result returned be
the airport's IATA code rather than just a vertex.

[source,groovy]
----
g.V().has('airport','code','DFW').
      union(identity().values('code'),out().count()).fold()

[DFW,253]
----

[[unionconstant]]
==== Using 'constant' values as part of a 'union'

We have already seen the 'constant' step used in the "<<chooseconstant>>" section.
As you might expect, you can also use 'constant' steps within a 'union' step as the
two examples below show.

[source,groovy]
----
g.V(3).union(constant("Hello"),
             constant("There")).fold()

[Hello,There]
----

The 'identity' step that was just introduced above could be used to add the 'V[3]'
vertex to the result. We are now combining three traversal steps together inside of
the 'union' step.

[source,groovy]
----
g.V(3).union(constant("Hello"),
             constant("There"),
             identity()).fold()

[Hello,There,v[3]]
----

Finally, let's change the query again to include a city name in the result. Note that
the 'values' step refers to the property of the vertex that was referenced
immediately before the 'union' step so it will return the 'city' property of vertex
'V[3]'.

[source,groovy]
----
g.V(3).union(constant("Hello"),
             constant("There"),
             values('city')).fold()

[Hello,There,Austin]
----

[[unionmore]]
==== More examples of the 'union' step

The following query uses a 'sample' step to select 10 airports at random from the
graph. For each selected airport, a 'union' step is then used to combine the 'id' of
the vertex with a few properties. Note that 'local' scope is used so that the results
of each 'union' step are folded into a list.

[source,groovy]
----
g.V().hasLabel("airport").sample(10).
      local(union(id(),values("code","city")).fold())
----

Here is the output we got back from running the query.

[source,groovy]
----
[1534,CUL,Culiacn]
[2075,CKB,Clarksburg]
[1828,PZI,Panzhihua]
[2244,LOD,Longana]
[1348,GET,Geraldton]
[92,OSL,Oslo]
[2107,UIN,Quincy]
[2764,ODY,Oudomsay]
[3288,MCW,Mason City]
[3331,MPN,Mount Pleasant]
----

If 'local' scope had not been used, the result would have been a single list
containing all of the results as shown below.

[source,groovy]
----
g.V().hasLabel("airport").sample(10).
      union(id(),values("code","city")).fold()

[2410,FKS,Sukagawa,3159,YBX,Lourdes-De-Blanc-Sablon,918,HLN,Helena,
 465,DOL,Deauville,1258,YXY,Whitehorse,2000,VHC,Saurimo,2562,RCH,Riohacha,
 225,MBJ,Montego Bay,2535,LOH,La Toma (Catamayo),1385,REG,Reggio Calabria]
----

By way of another simple example, the following query returns flights that arrive in
AUS from the UK or that leave AUS and arrive in Mexico.

[source,groovy]
----
// Flights to AUS from the UK or from AUS to Mexico
g.V().has('code','AUS').
      union(__.in().has('country','UK'),
            out().has('country','MX')).
            path().by('code')
----

When we run that query, we get the following results showing that there are routes
from LHR and LGW in the UK and to the six airports PVR, CZM, SJD, MEX, CUN and GDL in
Mexico.

[source,groovy]
----
[AUS,LGW]
[AUS,LHR]
[AUS,CUN]
[AUS,PVR]
[AUS,CZM]
[AUS,GDL]
[AUS,SJD]
[AUS,MEX]
----

This query solves the problem "Find all routes that start in London, England and end
up in Paris or Berlin with no stops". Because city names are used and not airport
codes, all airports in the respective cities are considered.

[source,groovy]
----
g.V().has('city','London').has('region','GB-ENG').
         union(out('route').has('city','Paris'),
               out('route').has('city','Berlin')).
               path().by('code')
----

Here are the results from running the query. Note that routes from five different
London airports were found.

[source,groovy]
----
[LHR,ORY]
[LHR,CDG]
[LHR,BER]
[LGW,CDG]
[LGW,BER]
[LCY,CDG]
[LCY,ORY]
[STN,BER]
[LTN,CDG]
[LTN,ORY]
[LTN,BER]
----

As mentioned previously, sometimes, especially for fairly simple queries, there are
alternatives to using 'union'. Indeed, it is actually not necessary to use a 'union'
step to achieve the prior result. The re-written version of the query below will
return the same results as the version that uses a 'union' step. This time a simple
'has' step featuring a 'within' predicate is used instead.

[source,groovy]
----
g.V().has('city','London').has('region','GB-ENG').
      out('route').has('city',within('Berlin','Paris')).
      path().by('code')
----

The previous two queries used a 'path' step to essentially show each individual
route. We can adjust the version of the query that uses a 'union' step just a little
bit and instead turn the result into a series of lists where the first item in the
list is the origin airport and the remaining items in the list are the places you can
fly to from there within our criteria. The double underscore '"__"' is used in the
way that 'identity' could have been used to refer to the incoming vertex. The 'union'
step is wrapped in a 'local' step so that each 'union' is individually folded. If the
'local' step was omitted all of the results would be folded into a single list. In
this case, the 'union' step makes writing the query relatively easy and this is
probably a good example of where the 'union' step should be used. Namely, when you
want to combine multiple traversal results.

[source,groovy]
----
g.V().has('city','London').has('region','GB-ENG').
      local(union(__.values('code'),
                  out('route').has('city','Paris').values('code'),
                  out('route').has('city','Berlin').values('code')).
      fold())
----

Running the amended query shows us the results in perhaps a more useful form.

[source,groovy]
----
[LHR,ORY,CDG,BER]
[LGW,CDG,BER]
[LCY,CDG,ORY]
[STN,BER]
[LTN,CDG,ORY,BER]
----

[[unionthree]]
==== Using 'union' to combine more complex traversal results

So far the examples we have looked at mostly show fairly simple traversals being used
inside of a 'union' step. This next query is a bit more interesting. We again start
from any airport in London, but then we want routes that meet any of the criteria:

* Go to Berlin and then to Lisbon
* Go to Paris and then Barcelona
* Go to Edinburgh and then Rome

We also want to return the distances in each case. Note that you can union together
as many items as you need to. In this example we combine the results of
three sets of traversals to get the desired results.


[source,groovy]
----
// Returns any paths found along with the distances between airport pairs.
g.V().has('city','London').has('region','GB-ENG').
      union(outE().inV().has('city','Berlin').
                   outE('route').inV().has('city','Lisbon').
                   path().by('code').by('dist').by('code').by('dist'),
            outE().inV().has('city','Paris').
                   outE('route').inV().has('city','Barcelona').
                   path().by('code').by('dist').by('code').by('dist'),
            outE().inV().has('city','Edinburgh').
                   outE('route').inV().has('city','Rome').
                   path().by('code').by('dist').by('code').by('dist'))
----

Here is what we get back when we run our query

[source,groovy]
----
[LHR,598,BER,1432,LIS]
[LHR,227,ORY,513,BCN]
[LHR,216,CDG,533,BCN]
[LGW,592,BER,1432,LIS]
[LGW,191,CDG,533,BCN]
[LCY,204,CDG,533,BCN]
[LCY,217,ORY,513,BCN]
[STN,564,BER,1432,LIS]
[LTN,589,BER,1432,LIS]
[LTN,236,CDG,533,BCN]
[LTN,248,ORY,513,BCN]
----

The next query finds the total distance of all routes from any airport in Madrid to
any airport anywhere and also does the same calculation but minus any routes that end
up in any Paris airport. We have not yet seen the 'filter' step that is used below.
It is one of the foundational Gremlin steps that many others such as 'where' build
upon. A 'filter' step will only pass on to the next step in the query incoming
elements that meet the criteria specified within the 'filter'.

[source,groovy]
----
g.V().has('city','Madrid').outE('route').
      union(values('dist').sum(),
            filter(inV().has('city',neq('Paris'))).values('dist').sum())
----

Here is the output from running the query. As you can see the first number is
slightly larger than the second as all routes involving Paris have been
filtered out from the calculation.

[source,groovy]
----
435724
434426
----

It is worth noting that it is not required that every traversal inside of a union
step returns a result. The returned results will include any of the traversals that
did return something. The example below demonstrates this. Of course in practice you
would not write this particular query this way. However, we think this example
demonstrates a feature of the 'union' step that it is important to understand.

[source,groovy]
----
g.V().has('airport','code','AUS').
      union(out().has('code','LHR'),
            out().has('code','SYD'),
            out().has('code','DFW')).
      values('code')
----

If we run the query, you will see that SYD is not part of the results as there is no
route between Austin and Sydney.

[source,groovy]
----
LHR
DFW
----

For completeness, this query would more likely be written as follows rather than
using a 'union'.

[source,groovy]
----
g.V().has('airport','code','AUS').
      out().has('code',within('LHR','DFW','SYD')).
      values('code')

LHR
DFW
----

[[sideeffect]]
=== Using 'sideEffect' to do things on the side

The 'sideEffect' step allows you to do some additional processing as part of a query
without changing what gets passed on to the next stage of the query. The example
below finds the airport vertex V(3) and then uses a 'sideEffect' to count the number
of places that you can fly to from there and aggregates it in a traversal variable
named 'a' before counting how many places you can get to with one stop and storing
that value in 'b'. Note that there are other ways we could write this query but it
demonstrates quite well how 'sideEffect' works.

[source,groovy]
----
g.V(3).sideEffect(out().count().aggregate('a')).
       out().out().count().as('b').select('a','b')

[a:[98],b:8354]
----

Later in the book we will discuss lambda functions, sometimes called closures and
how they can be used. The example below combines a closure with a 'sideEffect' to
print a message before displaying information about the vertex that was found. Again
notice how the 'sideEffect' step has no effect on what is seen by the subsequent
steps. You can see the output generated below the query.

[source,groovy]
----
g.V().has('code','SFO').sideEffect{println "I'm working on it"}.values('desc')

I'm working on it
San Francisco International Airport
----

Later in the book we will look at other ways that side effects can be used to
solve more interesting problems.

[[aggregate]]
=== Using 'aggregate' to create a temporary collection

At the time of writing this book, there were 59 places you could fly to directly
(non stop) from Austin. We can verify this fact using the following query.

[source,groovy]
----
g.V().has('code','AUS').out().count()

98
----

If we wanted to count how many places we could go to from Austin with one stop, we
could use the following query. The 'dedup' step is used as we only want to know how
many unique places we can go to, not how many different ways of getting to all of
those places there are.

[source,groovy]
----
g.V().has('code','AUS').out().out().dedup().count()

1044
----

There is however a problem with this query. The 871 places is going to include (some
or possibly all of) the places we can also get to non stop from Austin. What we
really want to find are all the places that you can only get to from Austin with one
stop. So what we need is a way to remember all of those places and remove them from
the 871 some how. This is where 'aggregate' is useful. Take a look at the modified
query below

[source,groovy]
----
g.V().has('code','AUS').out().aggregate('nonstop').
     out().where(without('nonstop')).dedup().count()

946
----

After the first 'out' step all of the vertices that were found are stored in a
collection we chose to call 'nonstop'. Then, after the second 'out' we can add a
'where' step that essentially says "only keep the vertices that are not part of the
nonstop collection". We still do the 'dedup' step as otherwise we will still end up
counting a lot of the remaining airports more than once.

Notice that 812 is precisely 59 less than the 871 number returned by the previous
query which shows the places you can get to non stop were all correctly removed from
the second query. This also tells us there are no flights from Austin to places that
you cannot get to from anywhere else!

We will take a more in depth look at the various types of collections that you can
use as part of a Gremlin query in the "<<collrev>>" section a bit later.

[[inject]]
=== Using 'inject' to insert values into a query

Sometimes you may want to add something additional to be returned along with the
results of your query. This can be done using the 'inject' step. To start off, here
is a simple example showing how 'inject' fundamentally works. We insert some numbers
and ask Gremlin to give us the mean value.

[source,groovy]
----
g.inject(1,2,3,4,5).mean()

3.0
----

Of course just using 'inject' so we can do a simple mathematical computation is of
limited use. The next example shows how 'inject' can be used as part of a query. The
string 'ABIA', another acronym commonly used when referring to the Austin Bergstrom
International Airport, is injected into the query.

[source,groovy]
----
g.V().has('code','AUS').values().inject('ABIA')
----

If we were to run the query, here is what we would get back

[source,groovy]
----
ABIA
US
AUS
12250
Austin
542
KAUS
-97.6698989868164
airport
US-TX
2
30.1944999694824
Austin Bergstrom International Airport
----

[[injecttrick]]
==== A useful trick using 'inject'

There is also a useful trick that can be achieved using 'inject'. Take a look at the
query below.

[source,groovy]
----
g.V().choose(V().hasLabel('XYZ').count().is(0),constant("None found"))
----

If we were to run it we would get back multiple lines like those below. One for each
vertex in the graph in fact.

[source,groovy]
----
None found
None found
None found
None found
None found
...
----

In order to get just one result we might be tempted to write the query as
shown below.

[source,groovy]
----
g.choose(V().hasLabel('XYZ').count().is(0),constant("None found"))
----

However this will cause an error to be returned as a choose step cannot come
immediately after a traversal source object ('g'). To get around this we can
rewrite the query with an 'inject' step after the 'g'. We do not use the value of the
'inject' in the query but its presence allows us to follow it with a 'choose' step.

[source,groovy]
----
g.inject(1).choose(V().hasLabel('XYZ').count().is(0),constant("None found"))

None found
----

This is a trick that can come in useful from time to time. The query used to
demonstrate this point could indeed be rewritten to avoid any use of 'choose' but
hopefully the usefulness of 'inject' as a way to avoid using a 'V' when not wanted is
clear.

[[coalesce]]
=== Using 'coalesce' to see which traversal returns a result

Sometimes, when you are uncertain as to which traversal of a set you are interested
in will return a result you can have them evaluated in order by the 'coalesce' step.
The first of the traversals that you specify that returns a result will cause that
result to be the one that is returned to your query.

Look at the example below. Starting from the vertex with an ID of 3 it uses
'coalesce' to first see if there are any outgoing edges with a label of 'fly'. If
there are any, the vertices connected to those edges will be returned. If there are
not any, any vertices on any incoming edges labelled 'contains' will be returned.

[source,groovy]
----
// Return the first step inside coalesce that returns a vertex
g.V(3).coalesce(out('fly'),__.in('contains')).valueMap()
----

As there are not any edges labelled 'fly' in the 'air-routes' graph, the second
traversal will be the one whose results are returned.

If we were to run the above query using the 'air-routes' graph, this is what would be
returned.

[source,groovy]
----
[code:[NA],type:[continent],desc:[North America]]
[code:[US],type:[country],desc:[United States]]
----

We can put more than two traversals inside of a 'coalesce' step. In the following
example there are now three. Because some 'contains' edges do exist for this vertex,
the 'route' edges will not be looked at as the traversals are evaluated in left to
right order.

[source,groovy]
----
g.V(3).coalesce(out('fly'),
              __.in('contains'),
                out('route')).valueMap()
----

As we can see the results returned are still the same.

[source,groovy]
----
[code:[NA],type:[continent],desc:[North America]]
[code:[US],type:[country],desc:[United States]]
----

[[coalconst]]
==== Combining 'coalesce' with a 'constant' value

The 'coalesce' step can also be very useful when combined with a 'constant' value. In
the example below if the airport is in Texas then its description is returned. If it
is not in Texas, the string "Not in Texas" is returned instead.

[source,groovy]
----
g.V(1).coalesce(has('region','US-TX').values('desc'),constant("Not in Texas"))

Not in Texas

g.V(3).coalesce(has('region','US-TX').values('desc'),constant("Not in Texas"))

Austin Bergstrom International Airport
----

[[coalfail]]
==== Combining 'coalesce' with 'fail' step

We've not looked at 'fail' step before but it is a very straightforward step. If it
is encountered in the traversal, it will throw an exception.

[source,groovy]
----
g.V().fail()

fail() Step Triggered
================================
Message  > fail() step triggered
Traverser> v[0]
  Bulk   > 1
Traversal> V().fail()
Metadata > {}
================================
----

The above example shows what the Gremlin Console formatting of the generated 
'FailException'. You can also give it a custom error message.

[source,groovy]
----
g.V().fail("failed!!")

fail() Step Triggered
===============================
Message  > failed!!
Traverser> v[0]
  Bulk   > 1
Traversal> V().fail("failed!!")
Metadata > {}
===============================
----

When used with 'coalesce' you can trigger the failure condition if particular 
traversal does not produce the result you expect. Using the example from the 
"<<coalconst>>" section, if the airport is in Texas then its description is returned. 
If it is not in Texas, then the exception is thrown.

[source,groovy]
----
g.V(1).coalesce(has('region','US-TX').values('desc'),fail())

fail() Step Triggered
================================================================================================
Message  > fail() step triggered
Traverser> v[1]
  Bulk   > 1
Traversal> fail()
Parent   > CoalesceStep [V((int) 1).coalesce(__.has("region","US-TX").values("desc"),__.fail())]
Metadata > {}
================================================================================================

g.V(3).coalesce(has('region','US-TX').values('desc'),fail())

Austin Bergstrom International Airport
----

[[bycoal]]
Using 'coalesce' inside of 'by'

In the "<<coalconst>>" and "<<coalfail>>" sections we saw patterns that have a clear
applicability to 'by' modulators. Let's look at an example query that uses 
`groupCount'. 

[source,groovy]
----
g.V().groupCount().by("city").
  unfold().
  filter(select(values).is(gt(3)))
  
San Jose=4
London=6
Melbourne=4
Santa Rosa=4  
----

In the above example, we do a 'groupCount' by the city of the airport. We 'unfold'
the 'Map' to entries and then find only those entries that have a count greater than
3. When we use 'by("city")' we tell Gremlin to ignore vertices that do not have a
city as a property key. If we'd like to include those in the count, we could use 
'coalesce' inside of the 'by' so that we could return a 'constant' value to represent
that missing property.

[source,groovy]
----
g.V().groupCount().by(coalesce(values('city'), constant('No City'))).
  unfold().
  filter(select(values).is(gt(3)))

San Jose=4
No City=245
London=6
Melbourne=4
Santa Rosa=4
----

A bit later in the "<<coaladdv>>" section we will again use 'coalesce' to check to
see if a vertex already exists before we try to add it.

[[optional]]
=== Returning one of two possible results - introducing 'optional'

Sometimes it may be useful to return one of two results depending upon the outcome of
an attempted traversal. The 'optional' step will return either the results of the
provided traversal if there is a result or the result of the prior step if there is
no result.

In the example below, there is no direct route between Austin (AUS) and Sydney (SYD)
so the Austin vertex is returned by the 'optional' step.

[source,groovy]
----
g.V().has('code','AUS').optional(out().has('code','SYD')).values('city')

Austin
----

However, there is a route between Austin and Dallas Fort Worth (DFW) so as the
example below shows, this time the 'optional' step returns the DFW vertex.

[source,groovy]
----
g.V().has('code','AUS').optional(out().has('code','DFW')).values('city')

Dallas
----

Note that the previous queries behave in the same way that the 'coalesce' step would
behave if used as shown below. In this case, an 'identity' step is used to return the
prior vertex if the provided traversal does not return a result.

[source,groovy]
----
g.V().has('code','AUS').
      coalesce(out().has('code','SYD'),identity()).values('city')

Austin

g.V().has('code','AUS').
      coalesce(out().has('code','DFW'),identity()).values('city')

Dallas
----

[[midtraversalve]]
=== Using 'V' and 'E' mid-traversal

All of our queries so far have used the 'V' and 'E' step to help start a traversal.
We've seen them at the start of a traversal spawned from 'g' and as a spawn of 
anonymous child traversals with '__'. As start steps, they inject the objects that 
flow through the traversal stream. While they are commonly used at the start of a 
traversal, they can also be used in the middle of one. 

[source,groovy]
----
g.V().has('code','AUS').V().has('code', within('DFW','IAD')).
  values('code').fold()

[DFW,IAD]
----

In the above example, we first find the '"AUS"' airport vertex. That start traverser
triggers the mid-traversal 'V' that does a lookup for '"DFW"' and '"IAD"'. As a 
result, we get two vertices as the result. Each traverser that flows to the 
mid-traversal 'V' will issue that same filter, therefore, if we return two starting
vertices, we will get some duplication and 4 results as follows:

[source,groovy]
----
g.V().has('code', within('SFO','AUS')).V().has('code', within('DFW','IAD')).
  values('code').fold()

[DFW,IAD,DFW,IAD]
----

Mid-traversal 'V' has a similar counterpart for edges with 'E' and behaves in the 
same fashion.

[source,groovy]
----
g.V().has('code',within('SFO','AUS')).E(7612)

e[7612][23-route->184]
e[7612][23-route->184]
----

You typically find use for these mid-traversal steps when you do a mutation or 
side-effect first, but then want to traverse a wholly new path after that. Let's look
at a more advanced example to demonstrate this. First, let's find out what the 
longest route is leaving '"IAD"':

[source,groovy]
----
g.V().has('code','IAD').outE('route').
  values('dist').max()

8135
----

Now, let's extend on that query with mid-traversal 'V' to use that result to find 
"all routes from DFW that are longer than the longest route from IAD":

[source,groovy]
----
g.V().has('code','IAD').outE('route').
  values('dist').max().as('iad').
  V().has('code','DFW').outE('route').as('r').
  where(values('dist').where(gt('iad'))).
  inV().values('code').fold()

[SYD]
----

[[otherv]]
=== Other ways to explore vertices and edges using 'both', 'bothE', 'bothV' and 'otherV'

We have already looked at examples of how you can walk a graph and examine vertices 
and edges using steps such as 'out', 'in', 'outE' and 'inE'. In this section we 
introduce some additional ways to explore vertices and edges.

As a quick recap, we have already seen examples of queries like the one below that
simply counts the number of outgoing edges from the vertex with an ID of 3.

[source,groovy]
----
g.V(3).outE().count()

98
----

Likewise, this query counts the number of incoming edges to that same vertex.

[source,groovy]
----
g.V(3).inE().count()

100
----

The following query introduces the 'bothE' step. What this step does is return all of
the edges connected to this vertex whether they are outgoing or incoming. As we can 
see the count of 120 lines up with the values we got from counting the number of
outgoing and incoming edges. We might want to retrieve the edges, as a simple 
example, to examine a property on each of them.

[source,groovy]
----
g.V(3).bothE().count()

198
----

If we wanted to return vertices instead of edges, we could use the 'both' step. This
will return all of the vertices connected to the vertex with an ID of 3 regardless of
whether they are connected by an outgoing or an incoming edge.

[source,groovy]
----
g.V(3).both().count()

198
----

This next query can be used to show us the 198 vertices that we just counted in the
previous query. We sorted the results and used 'fold' to build them into a list to
make the results easier to read. Note how vertex 3 is *not* returned as part of the
results. This is important, for as we shall see in a few examples time, this is not
always the case.

[source,groovy]
----
g.V(3).both().order().by(id).fold()

[v[1],v[1],v[4],v[4],v[5],v[5],v[6],v[6],v[7],v[7],v[8],v[8],v[9],v[9],v[10],
 v[10],v[11],v[11],v[12],v[12],v[13],v[13],v[15],v[15],v[16],v[16],v[17],v[17],
 v[18],v[18],v[20],v[20],v[21],v[21],v[22],v[22],v[23],v[23],v[24],v[24],v[25],
 v[25],v[26],v[26],v[27],v[27],v[28],v[28],v[29],v[29],v[30],v[30],v[31],v[31],
 v[33],v[33],v[34],v[34],v[35],v[35],v[37],v[37],v[38],v[38],v[39],v[39],v[41],
 v[41],v[42],v[42],v[43],v[43],v[45],v[45],v[46],v[46],v[47],v[47],v[48],v[48],
 v[49],v[49],v[50],v[50],v[52],v[52],v[70],v[70],v[99],v[99],v[136],v[136],v[147],
 v[147],v[149],v[149],v[150],v[150],v[151],v[151],v[178],v[178],v[180],v[180],v[182],
 v[182],v[183],v[183],v[184],v[184],v[185],v[185],v[186],v[186],v[187],v[187],v[188],
 v[188],v[189],v[189],v[190],v[190],v[193],v[193],v[194],v[194],v[195],v[195],v[208],
 v[208],v[227],v[227],v[239],v[239],v[240],v[240],v[244],v[244],v[265],v[265],v[268],
 v[268],v[269],v[269],v[271],v[271],v[273],v[273],v[277],v[277],v[278],v[278],v[280],
 v[280],v[281],v[281],v[362],v[362],v[365],v[365],v[368],v[368],v[371],v[371],v[375],
 v[375],v[389],v[389],v[395],v[395],v[403],v[403],v[416],v[416],v[422],v[422],v[429],
 v[429],v[430],v[430],v[431],v[431],v[444],v[444],v[549],v[549],v[605],v[605],v[883],
 v[883],v[909],v[909],v[929],v[929],v[1274],v[1274],v[3730],v[3744]]
----

You probably also noticed that most of the vertices appear twice. This is because
for most air-routes there is an outgoing and an incoming edge. If we wanted to
eliminate any duplicate results we can do that by adding a 'dedup' step to our query.

[source,groovy]
----
g.V(3).both().dedup().order().by(id).fold()

[v[1],v[4],v[5],v[6],v[7],v[8],v[9],v[10],v[11],v[12],v[13],v[15],v[16],v[17],
 v[18],v[20],v[21],v[22],v[23],v[24],v[25],v[26],v[27],v[28],v[29],v[30],v[31],
 v[33],v[34],v[35],v[37],v[38],v[39],v[41],v[42],v[43],v[45],v[46],v[47],v[48],
 v[49],v[50],v[52],v[70],v[99],v[136],v[147],v[149],v[150],v[151],v[178],v[180],
 v[182],v[183],v[184],v[185],v[186],v[187],v[188],v[189],v[190],v[193],v[194],
 v[195],v[208],v[227],v[239],v[240],v[244],v[265],v[268],v[269],v[271],v[273],
 v[277],v[278],v[280],v[281],v[362],v[365],v[368],v[371],v[375],v[389],v[395],
 v[403],v[416],v[422],v[429],v[430],v[431],v[444],v[549],v[605],v[883],v[909],
 v[929],v[1274],v[3730],v[3744]]
----

We can do another count using our modified query to check we got the expected number
of results back.

[source,groovy]
----
g.V(3).both().dedup().count()

100
----

There are a similar set of things we can do when working with edges using the 'bothV'
and 'otherV' steps. The 'bothV' step returns the vertices at both ends of an edge and
the 'otherV' step returns the vertex at the other end of the edge. This is relative 
to how we are looking at the edge.

The query below starts with our same vertex with the ID of 3 and then looks at all the
edges no matter whether they are incoming or outgoing and retrieves all of the
vertices at each end of those edges using the 'bothV' step. Notice that this time our
count is 396. This is because for every one of the 198 edges, we asked for the vertex
at each end so we ended up with 396 of them.

[source,groovy]
----
g.V(3).bothE().bothV().count()

396
----

We can again add a 'dedup' step to get rid of duplicate vertices as we did before and
re-do the count but notice this time we get back 62 instead of the 61 we got before. 
So what is going on here?

[source,groovy]
----
g.V(3).bothE().bothV().dedup().count()

101
----
Let's run another query and take a look at all of the vertices that we got back this
time.

[source,groovy]
----
g.V(3).bothE().bothV().dedup().order().by(id()).fold()

[v[1],v[3],v[4],v[5],v[6],v[7],v[8],v[9],v[10],v[11],v[12],v[13],v[15],v[16],
 v[17],v[18],v[20],v[21],v[22],v[23],v[24],v[25],v[26],v[27],v[28],v[29],v[30],
 v[31],v[33],v[34],v[35],v[37],v[38],v[39],v[41],v[42],v[43],v[45],v[46],v[47],
 v[48],v[49],v[50],v[52],v[70],v[99],v[136],v[147],v[149],v[150],v[151],v[178],
 v[180],v[182],v[183],v[184],v[185],v[186],v[187],v[188],v[189],v[190],v[193],
 v[194],v[195],v[208],v[227],v[239],v[240],v[244],v[265],v[268],v[269],v[271],
 v[273],v[277],v[278],v[280],v[281],v[362],v[365],v[368],v[371],v[375],v[389],
 v[395],v[403],v[416],v[422],v[429],v[430],v[431],v[444],v[549],v[605],v[883],
 v[909],v[929],v[1274],v[3730],v[3744]]
----

Can you spot the difference? This time, vertex 3 (v[3]) *is* included in our results. 
This is because we started out by looking at all of the edges and then asked for all
the vertices connected to those edges. Vertex 3 gets included as part of that
computation. So beware of this subtle difference between using 'both' and the
'bothE().bothV()' pattern.

Let's rewrite the queries we just used again but replace 'bothV' with 'otherV'.
Notice that when we count the number of results we are back to 100 again.

[source,groovy]
----
g.V(3).bothE().otherV().dedup().count()

100
----

So let's again look at the returned vertices and see what the difference is.

[source,groovy]
----
g.V(3).bothE().otherV().dedup().order().by(id()).fold()

[v[1],v[4],v[5],v[6],v[7],v[8],v[9],v[10],v[11],v[12],v[13],v[15],v[16],v[17],
 v[18],v[20],v[21],v[22],v[23],v[24],v[25],v[26],v[27],v[28],v[29],v[30],v[31],
 v[33],v[34],v[35],v[37],v[38],v[39],v[41],v[42],v[43],v[45],v[46],v[47],v[48],
 v[49],v[50],v[52],v[70],v[99],v[136],v[147],v[149],v[150],v[151],v[178],v[180],
 v[182],v[183],v[184],v[185],v[186],v[187],v[188],v[189],v[190],v[193],v[194],
 v[195],v[208],v[227],v[239],v[240],v[244],v[265],v[268],v[269],v[271],v[273],
 v[277],v[278],v[280],v[281],v[362],v[365],v[368],v[371],v[375],v[389],v[395],
 v[403],v[416],v[422],v[429],v[430],v[431],v[444],v[549],v[605],v[883],v[909],
 v[929],v[1274],v[3730],v[3744]]
----

As you can see, when we use 'otherV' we do not get 'v[3]' returned as we are only
looking at the other vertices relative to where we started from, which was 'v[3]'.

[[sp]]
=== Shortest paths (between airports) - introducing 'repeat'

Gremlin provides a 'repeat...until' looping construct similar to those found in many
programming languages. This gives us a nice way to perform simple shortest path type
queries. We can use a 'repeat...until' loop to look for paths between two airports
without having to specify an explicit number of 'out' steps to try.

While performing such computations, we may not want paths we have already travelled
to be travelled again. We can ask for this behavior using the 'simplePath' step.
Doing so will speed up queries that do not need to travel the same paths through a
graph multiple times. Without the 'simplePath' step being used the query we are
about to look at could take a lot longer. The addition of a 'limit' step is also
important as without it this query will run for a LONG time looking for every
possible path!!

The query below looks for routes between Austin (AUS) and Agra (AGR). An important
query for those Austinites wanting to visit the Taj Mahal!

[source,groovy]
----
// What are some of the ways to travel from AUS to AGR?
g.V().has('code','AUS').
      repeat(out().simplePath()).
        until(has('code','AGR')).
        path().by('code').limit(10)
----

Here are the results from running the query. Notice how, using the 'repeat...until'
construct we did not have to specify how many steps to try.

[source,groovy]
----
[AUS,JFK,BOM,AGR]
[AUS,YYZ,BOM,AGR]
[AUS,LHR,BOM,AGR]
[AUS,EWR,BOM,AGR]
[AUS,FRA,BOM,AGR]
[AUS,AMS,BOM,AGR]
[AUS,PHL,YYZ,BOM,AGR]
[AUS,PHL,LHR,BOM,AGR]
[AUS,PHL,CDG,BOM,AGR]
[AUS,PHL,FRA,BOM,AGR]
----

You can also place the 'until' before the 'repeat' as shown below.

[source,groovy]
----
// Another shortest path example using until...repeat instead
g.V().has('code','AUS').
      until(has('code','SYD')).
        repeat(out().simplePath()).limit(10).
      path().by('code')
----

Here are the results from running the query.

[source,groovy]
----
[AUS,DFW,SYD]
[AUS,IAH,SYD]
[AUS,LAX,SYD]
[AUS,SFO,SYD]
[AUS,HNL,SYD]
[AUS,YVR,SYD]
[AUS,PHL,DFW,SYD]
[AUS,PHL,IAH,SYD]
[AUS,PHL,DOH,SYD]
[AUS,PHL,LAX,SYD]
----

We can also specify an explicit number of out steps to try using a 'repeat...times'
loop but this of course assumes that we know ahead of time how many stops we want to
look for between airports. In the next section we will introduce the 'emit' step that
gives you more control over the behavior of what is returned from 'repeat' loops.

[source,groovy]
----
g.V().has('code','AUS').repeat(out()).times(2).has('code','SYD').path().by('code')

[AUS,DFW,SYD]
[AUS,IAH,SYD]
[AUS,LAX,SYD]
[AUS,SFO,SYD]
[AUS,HNL,SYD]
[AUS,YVR,SYD]
----

The previous query is equivalent to this next one but doing it this way is less
flexible in that we can not as easily vary the number of 'out' steps, should, for
example we want to next try five hops instead of the current two.

[source,groovy]
----
g.V().has('code','AUS').out().out().has('code','SYD').path().by('code')
----

As is often the case when working with Gremlin there is more than one way to achieve
the same result. The 'loops' step, that can be used to control how long a repeat loop
runs, is essentially equivalent to the 'times' step. Take a look at the two queries
below. Both achieve the same result. The first uses 'loops' while the second uses
'times'. We prefer the readability offered by the use of 'times'.

[source,groovy]
----
g.V(3).repeat(out()).until(loops().is(2)).count()

8354

g.V(3).repeat(out()).times(2).count()

8354
----

NOTE: If you simply want to find out if any route exists between two airports, there
is a nice optimization that can be used. This is discussed in the
"<<doesanyrouteexist>>" section later in the book.

In the next section, we will look at how 'emit' can be used to
adjust the behavior of a 'repeat...times' loop.

[[emit]]
==== Using 'emit' to return results during a 'repeat' loop

Sometimes it is useful to be able to return the results of a traversal as it
executes. The example below starts at the Santa Fe airport (SAF) and uses a 'repeat'
to keep going out from there. By placing an 'emit' right after the 'repeat' we will
be able to see the paths that are taken by the traversal. If we did not put the
'emit' here this query would run for a very long time as the 'repeat' has no other
ending condition!

[source,groovy]
----
g.V().has('code','SAF').repeat(out()).emit().path().by('code').limit(10)

[SAF,DFW]
[SAF,LAX]
[SAF,PHX]
[SAF,DEN]
[SAF,DFW,YYZ]
[SAF,DFW,YVR]
[SAF,DFW,LHR]
[SAF,DFW,CDG]
[SAF,DFW,FRA]
[SAF,DFW,HEL]
----

Another place where 'emit' can be useful is when 'repeat' and 'times' are used
together to find paths between vertices. Ordinarily, if you use a step such as
'times(3)' then the query will only return results that are three hops out. However
if we use an 'emit' we can also see results that take fewer hops. First of all take a
look at the query below that does not use an 'emit' and the results that it
generates.

[source,groovy]
----
g.V(3).repeat(out()).times(3).has('code','MIA').
       limit(5).path().by('code')
----

The paths returned show a selection of ways to get to Miami from Austin with two
stops but none of the results show fewer than two stops. Is this what we really
wanted?

[source,groovy]
----
[AUS,PHL,SXM,MIA]
[AUS,PHL,RIC,MIA]
[AUS,PHL,ISP,MIA]
[AUS,PHL,CHS,MIA]
[AUS,PHL,GRR,MIA]
----

Now let's change the query to use an 'emit'. This time you can think of the query as
saying "at most three hops" or in airline terms "at most two stops".

[source,groovy]
----
g.V(3).repeat(out().simplePath()).emit().times(3).has('code','MIA').
       limit(5).path().by('code')
----

As you can see, by adding an 'emit' we got back a quite different set of results.
This is a really useful and powerful capability. Being able to express ideas such as
"at most three" provides us a way to write very clean queries in cases like this.

[source,groovy]
----
[AUS,MIA]
[AUS,PHL,MIA]
[AUS,DTW,MIA]
[AUS,CLT,MIA]
[AUS,CUN,MIA]
----

Note that using the emit step in the previous query we were able to write a more
compact form of this query which essentially does the same thing. Note the use of the
inline 'or' step in this example.

[source,groovy]
----
g.V(3).repeat(out().simplePath()).
         until(has('code','MIA').or().loops().is(3)).
       has('code','MIA').
       path().by('code').limit(5)
----

When run, as you can see, we get the same results back.

[source,groovy]
----
[AUS,MIA]
[AUS,PHL,MIA]
[AUS,DTW,MIA]
[AUS,CLT,MIA]
[AUS,CUN,MIA]
----

The 'emit' step can also take a parameter such as a 'has' step to filter out
intermediate results that we are not interested in. The query below will only show
intermediate results as the 'repeat' operates if they meet a given condition. In this
case the condition is that the path must have passed through the Prague (PRG)
airport's vertex. A 'limit' step is used to only show the first 10 results.

[source,groovy]
----
g.V(3).repeat(out().simplePath()).emit(has('code','PRG')).
       path().by('code').limit(10)
----

Here are the results from running the query.

[source,groovy]
----
[AUS,PHL,PRG]
[AUS,YYZ,PRG]
[AUS,LHR,PRG]
[AUS,EWR,PRG]
[AUS,LGW,PRG]
[AUS,FRA,PRG]
[AUS,AMS,PRG]
[AUS,PHL,BER,PRG]
[AUS,PHL,YYZ,PRG]
[AUS,PHL,LHR,PRG]
----

Without the condition as part of the 'emit' step we get different results as we are
shown every path the graph traverser is taking.

[source,groovy]
----
g.V(3).repeat(out().simplePath()).emit().path().by('code').limit(10)

[AUS,PHL]
[AUS,PDX]
[AUS,DTW]
[AUS,OKC]
[AUS,ONT]
[AUS,CLT]
[AUS,CUN]
[AUS,MEM]
[AUS,CVG]
[AUS,IND]
----

So far, while interesting, many of the results shown look at first glance as if they
could have been generated without using an 'emit'. However, the query below
is more interesting in that we use an 'until' step to specify a target airport of
Austin (AUS) that we are interested in getting to from Lerwick (LSI) in the Shetland
Islands. We also specify, as part of the 'emit' step, that we are interested in
seeing any routes found that involve any airports in New York State regardless of
whether or not they end up in Austin.

[source,groovy]
----
g.V().has('code','LSI').
     repeat(out().simplePath()).
        emit(has('region','US-NY')).
        until(has('code','AUS')).
     path().by('code').limit(10)
----

Here are the results the query generates, Notice how we got a mixture of New York
airports as well as Austin as our final destinations.

[source,groovy]
----
[LSI,MAN,JFK]
[LSI,MAN,EWR]
[LSI,EDI,JFK]
[LSI,EDI,EWR]
[LSI,EDI,SWF]
[LSI,GLA,JFK]
[LSI,GLA,EWR]
[LSI,MAN,ATL,ROC]
[LSI,MAN,ATL,BUF]
[LSI,MAN,ATL,ALB]
----

The 'emit' can also be placed before the 'repeat' step. This will cause the
result of the previous step in the query to be emitted before the results that
follow. In the example below, we start in Austin and go out two hops using a 'repeat'
loop. The first ten airport codes of the places we found are returned. Notice how AUS
is returned as the first value even though that is where we started from due to our
use of 'emit'.

[source,groovy]
----
g.V().has('airport','code','AUS').
      emit().repeat(out().simplePath()).times(2).limit(10).
      values('code').fold()

[AUS,PHL,SXM,RIC,LEX,ISP,SWF,DSM,MYR,CAE]
----

In some cases, an 'emit' placed after a 'repeat' step has the same effect as an
'until' step. Both queries below look for routes between Johannesburg (JNB) and
Sydney (SYD).

[source,groovy]
----
g.V().has('code','JNB').repeat(out()).until(has('code','SYD')).
      path().by('code').limit(3)

g.V().has('code','JNB').repeat(out()).emit(has('code','SYD')).
      path().by('code').limit(3)
----

When either query is run, the following results are returned.

[source,groovy]
----
[JNB,SYD]
[JNB,SIN,SYD]
[JNB,DXB,SYD]
----

You will see more examples of 'emit' being used in the "<<btree>>" section a bit
later.

[[nestedrepeat]]
==== Nested and named 'repeat' steps

The 'repeat' step can be nested inside another 'repeat' step as well as inside 'emit'
and 'until' steps.

TIP: The official documentation for these new capabilities can be located here:
https://tinkerpop.apache.org/docs/current/reference/#repeat-step

It is also possible to label a repeat step with a name so that it can be referenced
later in a traversal. Nested 'repeat' steps allow for some interesting new graph
traversal patterns. For example you might be traversing along a set of outgoing
edges, and for each vertex along the way want to traverse a set of incoming edges.
The `air-routes` graph does not have any relationships that demonstrate an ideal use
case for nested 'repeat' steps but the query below shows a simple example.

[source,groovy]
----
g.V().has('code','SAF').
      repeat(out('route').simplePath().
        repeat(__.in('route')).times(3)).
      times(2).
      path().by('code').
      limit(3).
      toList()
----

Running the query will generate results similar to those shown below. We start at
Santa Fe (SAF) and take one outbound route and arrive at Dallas Fort Worth (DFW). We
then look at three incoming routes which yields Lake Charles (LCH), Houston (IAH)
and Lom (LFW). We then take another outbound hop from DFW and find ourselves in
Los Angeles(LAX) we then look at three incoming routes from Los Angeles and find
San Diego (SAN), Albuquerque (ABQ) and one of San Francisco (SFO), Portland (PDX) or
Atlanta (ATL).

[source,groovy]
----
[SAF,DFW,LCH,IAH,LFW,LAX,SAN,ABQ,SFO]
[SAF,DFW,LCH,IAH,LFW,LAX,SAN,ABQ,PDX]
[SAF,DFW,LCH,IAH,LFW,LAX,SAN,ABQ,ATL]
----

As we mentioned, working with the air-routes data set does not perhaps present an
ideal use case for using nested repeat steps. Most of the edges are routes and most
of the vertices are airports. However, if your data had a broader variety of vertex
and edge types, this capability may come in quite handy.

NOTE: There is a stand alone example in the `sample-code/groovy` folder that creates
a small social graph and performs various nested 'repeat' step operations. That
sample is located here:
https://github.com/krlawrence/graph/blob/main/sample-code/groovy/nested-repeat.groovy

When using nested 'repeat' steps, in order for a 'loops' step to know which repeat
step it is attached to it is necessary to give each 'repeat' step its own label name.
The example below gives the 'repeat' step a label of '"r1"' and refers to that label
in the subsequent 'loops' step. Obviously, this example does not contain any nested
repeats but hopefully shows how this new labelling capability can be used.

[source,groovy]
----
g.V().has('code','SAF').
      repeat('r1',out().simplePath()).
        until(loops('r1').is(3).or().has('code','MAN')).
      path().by('city').
      limit(3).
      toList()
----

The results below show that we found Manchester once and reached our 'loops' limit 
the other two times.

[source,groovy]
----
[Santa Fe,Los Angeles,Manchester]
[Santa Fe,Dallas,Toronto,Atlanta]
[Santa Fe,Dallas,Toronto,Austin]
----

[[depthlimit]]
==== Limiting the results at each depth

Sometimes, while exploring a graph using 'repeat' steps, it is desirable to limit the
amount of results returned at any given depth of a traversal. Achieving this result 
is straightforward using 'limit' inside of 'repeat'. 

[source,groovy]
----
g.V().has('code','SFO').
      repeat(out().simplePath().limit(5)).
        times(3).
      path().by('code')

[SFO,FCA,LAS,CPH]
[SFO,FCA,LAS,CLT]
[SFO,FCA,LAS,CUN]
[SFO,FCA,LAS,PSP]
[SFO,FCA,LAS,MEM]
----

We get five results here, but we aren't seeing the results at each depth. We are only
seeing the output from the last iteration. We need to add 'emit' to 'repeat' so that
we instead see the output of each iteration.

[source,groovy]
----
g.V().has('code','SFO').
      repeat(out().simplePath().limit(5)).
        times(3).emit().
      path().by('code')
      
[SFO,FCA]
[SFO,JAC]
[SFO,MSO]
[SFO,MTJ]
[SFO,SUN]
[SFO,FCA,LAS]
[SFO,FCA,DEN]
[SFO,FCA,AZA]
[SFO,FCA,LAX]
[SFO,FCA,MSP]
[SFO,FCA,LAS,CPH]
[SFO,FCA,LAS,CLT]
[SFO,FCA,LAS,CUN]
[SFO,FCA,LAS,PSP]
[SFO,FCA,LAS,MEM]
----

Now the results clearly show the iteration-based output we hoped to see with 5 paths
taken for each of the three steps away from SFO.

[[cyclicpath]]
==== Haven't I been here before? - Introducing 'cyclicPath'

You can use the 'cyclicPath' step to find paths through the graph that revisit a
vertex seen earlier in the traversal. This does not necessarily mean revisiting the
starting vertex, it can be any vertex already seen while traversing a graph. An
example of some cyclic paths is shown below. The rather contrived query below finds
ten routes that both start and end in Austin (AUS) with a stop along the way.

[source,groovy]
----
// From Austin and back again with one stop.
g.V().has('code','AUS').
      out().out().cyclicPath().
      limit(10).path().by('code')
----

Here are the results from running the query.

[source,groovy]
----
[AUS,PHL,AUS]
[AUS,PDX,AUS]
[AUS,DTW,AUS]
[AUS,OKC,AUS]
[AUS,ONT,AUS]
[AUS,CLT,AUS]
[AUS,CUN,AUS]
[AUS,MEM,AUS]
[AUS,CVG,AUS]
[AUS,IND,AUS]
----

You can also use 'cyclicPath' as a termination condition for a 'repeat' loop. The
query below keeps following outbound 'route' edges until it ends up back where it
started. Once again, only the first ten results are selected.

[source,groovy]
----
g.V().has('code','AUS').
      repeat(out('route')).until(cyclicPath()).
      limit(10).path().by('code')
----

Here are the results from running the query. As you can see it generated the same
results in this instance but if we let it run for longer than just ten results it
would ultimately find a lot more cyclic paths as it is not restricted to just going
out one hop from its starting point. Indeed, if we did not restrict the number of
results we wanted the query would ultimately find every cyclic route in the graph.
That query could run for quite a while so we would not recommend trying it!

[source,groovy]
----
[AUS,PHL,AUS]
[AUS,PDX,AUS]
[AUS,DTW,AUS]
[AUS,OKC,AUS]
[AUS,ONT,AUS]
[AUS,CLT,AUS]
[AUS,CUN,AUS]
[AUS,MEM,AUS]
[AUS,CVG,AUS]
[AUS,IND,AUS]
----

If we let the previous query run a few hundred times you would start to see examples
of where the cycle is not back to the starting vertex. The two results below were
generated by letting the query find 500 cyclic paths. Note that in the second case
the cycle is back to Philidelphia (PHL) and not the starting vertex (AUS).

[source,groovy]
----
[AUS,PHL,SXM,PHL]
[AUS,PHL,RIC,PHL]
----

You can also use 'cyclicPath' combined with a 'not' predicate to avoid returning
cyclic results from a query.

[source,groovy]
----
g.V().has('code','AUS').
      out().
      out().not(cyclicPath()).limit(10).
      path().by('code')
----

Note that for the 'air-routes' graph this has the same effect as if we had written
the query as shown below.

[source,groovy]
----
g.V().has('code','AUS').as('a').
      out().
      out().where(neq('a')).limit(10).
      path().by('code')
----

Some graphs contain vertices that have an edge that loops immediately back to the
same vertex. Take a look at the code below that creates an edge with a label of
'loop' from the vertex with an ID of 3 back to the same vertex.

[source,groovy]
----
g.V(3).as('a').addE('loop').to('a')

e[61394][3-loop->3]
----

We can then use the 'cyclicPath' step to find such loops in the graph.

[source,groovy]
----
g.V().out().cyclicPath().path()

[v[3],v[3]]
----

To include the edge in the result, you just need to modify the query a little as
shown below.

[source,groovy]
----
g.V().outE().inV().cyclicPath().path()

[v[3],e[61394][3-loop->3],v[3]]
----

[[pathwarn]]
==== A warning that path finding can be memory and CPU intensive

Take a look at the query below. It returns the first 10 routes found that will get
you from Papa Stour (PSV), a small airport in the Shetland Islands, to Austin (AUS).
The 'simplePath' step is used to make sure the same exact path is never looked at
twice. This query runs quickly and returns some useful results.

[source,groovy]
----
g.V().has('code','PSV').
      repeat(out().simplePath()).
      until(has('code','AUS')).
      limit(10).
      path().
        by('code')
----

Here are some of the routes returned.

[source,groovy]
----
[PSV,LWK,FIE,KOI,MAN,ATL,AUS]
[PSV,LWK,FIE,KOI,MAN,BOS,AUS]
[PSV,LWK,FIE,KOI,MAN,IAD,AUS]
[PSV,LWK,FIE,KOI,MAN,IAH,AUS]
[PSV,LWK,FIE,KOI,MAN,JFK,AUS]
[PSV,LWK,FIE,KOI,MAN,LAX,AUS]
[PSV,LWK,FIE,KOI,MAN,MCO,AUS]
[PSV,LWK,FIE,KOI,MAN,MIA,AUS]
[PSV,LWK,FIE,KOI,MAN,ORD,AUS]
[PSV,LWK,FIE,KOI,MAN,SEA,AUS]
----

If we reverse the query as shown below we can run into trouble. In fact, if you run 
this query on your laptop, after a few minutes of high CPU usage and increased fan 
noise, it is likely you will get an error that the query ran out of available memory.

[source,groovy]
----
g.V().has('code','AUS').
      repeat(out().simplePath()).
      until(has('code','PSV')).
      limit(10).
      path().
        by('code')
----

The reason this happens is as follows. There are very few routes from PSV and not
many more from the airports it is closely connected to. Therefore, if you start the
query from PSV, you will fairly quickly find some paths that end up in AUS. However,
if you start from AUS there are a lot of possible routes that Gremlin has to explore
before it gets close to finding PSV. If it helps, think of a funnel where PSV is at
the narrow end and AUS is at the other. This is also sometimes referred to as having
a high or low "fan out" of possible routes depending on the query direction.

[[pathstepwarn]]
==== A warning that the 'path' and 'as' steps can also be memory intensive

The Gremlin 'path' step is incredibly useful and we find ourselves using it a lot.
However, there are some downsides to the use of 'path', especially when searching
entire graphs for non trivial results. Even if the paths that you are looking for
are less difficult to find than in the prior section, you should be aware that
keeping track of all the paths that you find and retrieving them using a 'path' step
can require a lot of memory to be used.

NOTE: The 'path' and 'as' steps can use a lot of memory and in some cases cause
issues.

The reason that so much memory can be consumed is that the 'path' step, even if
'simplePath' is used to avoid travelling the same exact path more than once, requires
the query processor to potentially store up a very large number of results before
finding the ones we are actually interested in. So while the 'path' step is
incredibly useful, be aware that in cases where a lot of paths need to be tracked, it
can get you into trouble if not used with care. A Gremlin query processor will have a
limited amount of memory available in which to execute a given query. Storing a large
amount of path information may exceed that limit causing query execution to fail.

Something that may not be immediately obvious is that using an 'as' step can also
require the query processor to, at least in part, store path information requiring
significant amounts of memory. The 'as' step allows us to refer back to the previous
state of a traversal but potentially requires a lot of memory to hold this state
during complex queries.

If you find yourself running into memory limitation issues there are often ways to
circumvent the problem using different approaches to writing the query. You will find
an example of such a case in the "<<sackpredicate>>" section.

[[nd]]
=== Calculating vertex degree

While working with graphs, the word 'degree' is used when discussing the number of
edges coming into a vertex (in degree), going out from a vertex (out degree) or
potentially both coming in and going out (degree). It's quite simple with Gremlin to
calculate various measures of degree as the following examples demonstrate.

The simplest way to calculate vertex degree is simply to count edges as shown below.

[source,groovy]
----
// Outgoing degree
g.V().has('airport','code','LHR').out().count()

221

// Incoming degree
g.V().has('airport','code','LHR').in().count()

223

// Overall degree
g.V().has('airport','code','LHR').both().count()

444
----

If you want to calculate the degree values for more than a single vertex, it can be
done more easily using the 'group' step. The query below will calculate the number 
of outgoing routes for every airport in the graph. If you run this query you will get
quite a lot of result data back as there are over 3,300 airports in the graph.

[source,groovy]
----
// Out degree (number of routes) from each vertex (airport)
g.V().hasLabel('airport').group().by('code').by(out('route').count())
----

The query below builds upon the prior one but just selects a few of the results.

[source,groovy]
----
// Outbound routes (degree) from LHR, JFK and DFW
g.V().hasLabel('airport').group().by('code').by(out('route').count()).
      select('LHR','JFK','DFW')
----

If we were to run the query the output should look like this.

[source,groovy]
----
[LHR:221,JFK:204,DFW:253]
----

We could change the query a little to calculate the in degree values. Note that we
can see that JFK has one fewer incoming route than it has outgoing.

[source,groovy]
----
g.V().hasLabel('airport').
      group().by('code').by(__.in('route').count()).
      select('LHR','JFK','DFW')

[LHR:221,JFK:203,DFW:253]
----

The query below is a little more complex but can be used to find the 10 airports with
the highest number of outgoing routes. Some of the concepts used such as 'local'
scope are covered in more detail a bit later on in the "<<localcollect>>" section.

[source,groovy]
----
g.V().hasLabel('airport').
      group().by('code').by(out().count()).
      order(local).by(values).unfold().tail(10).fold()
----

Here are the results from running the query. As you can see, Frankfurt Airport (FRA) 
has the highest number of outgoing routes. The topic of analyzing routes is revisited
in detail in the "<<mostroutes>>" section.

[source,groovy]
----
[ATL=242,DXB=248,PEK=248,DFW=253,ORD=265,MUC=270,AMS=283,CDG=293,IST=309,FRA=310]
----

The next query will calculate the route degree based on all, incoming and outgoing,
routes for ten airports. The query takes advantage of the 'project' step.

[source,groovy]
----
// Calculate degree (in and out) for each vertex.
g.V().hasLabel('airport').limit(10).
      project("v","degree").by('code').by(bothE('route').count())
----

Here is the output that this query generates.

[source,groovy]
----
[v:ATL,degree:484]
[v:ANC,degree:82]
[v:AUS,degree:196]
[v:BNA,degree:150]
[v:BOS,degree:286]
[v:BWI,degree:182]
[v:DCA,degree:192]
[v:DFW,degree:506]
[v:FLL,degree:316]
[v:IAD,degree:315]
----

We could of course also write the same query using a 'group' step as shown below.

[source,groovy]
----
g.V().hasLabel('airport').limit(10).
      group().by('code').by(bothE('route').count())
----

The results below were generated by running the query.

[source,groovy]
----
[DCA:192,BNA:150,DFW:506,BWI:182,ANC:82,BOS:286,FLL:316,ATL:484,IAD:315,AUS:196]
----

[[mathstep]]
=== Gremlin's scientific calculator - introducing 'math'

As we have seen in some of the prior sections, there are some Gremlin steps such as
'sum', 'count' and 'mean' that can be used to perform some fairly basic mathematical
operations. In addition to those steps, 'math' step was provides us to perform
scientific calculator style mathematical operations as part of a Gremlin graph
traversal. As these operators build upon the Java Math class it is worth becoming
familiar with that class if you are not already.

The table below provides a summary of the available operators sorted alphabetically.

.Scientific calculator operators
[cols="1,5"]
|==============================================================================
|+       | Arithmetic plus.
|-       | Arithmetic minus.
|*       | Arithmetic multiply.
|/       | Arithmetic divide.
|%       | Arithmetic modulo (remainder).
|^       | Raise to the power. (n^x).
|abs     | Absolute value
|acos    | Arc (inverse) cosine in radians.
|asin    | Arc (inverse) sine in radians.
|atan    | Arc (inverse) tangent in radians.
|cbrt    | Cube root
|ceil    | Returns the smallest (closest to negative infinity) double value that is greater than or equal to the argument and is equal to a mathematical integer.
|cos     | Cosine of angle given in radians.
|cosh    | Hyperbolic cosine.
|exp     | Returns Euler's number '"e"' raised to the given power '(e^x)'
|floor   | Returns the largest (closest to positive infinity) double value that is less than or equal to the argument and is equal to a mathematical integer.
|log     | Natural logarithm (base 'e')
|log10   | Logarithm (base 10)
|log2    | Logarithm (base 2)
|signum  | Returns the 'signum' function of the argument; zero if the argument is zero, 1.0 if the argument is greater than zero, -1.0 if the argument is less than zero.
|sin     | Sine of angle given in radians.
|sinh    | Hyperbolic sine
|sqrt    | Square root
|tan     | Tangent of angle given in radians.
|tanh    | Hyperbolic tangent.
|==============================================================================

The 'math' step behaves differently from other steps that we have looked at so far in
as much as the entire expression is passed in as a single string. This means that you
can use labels you have assigned as part of a traversal but you cannot use external
variables or static constant references such as 'Math.PI' inside the expression
itself. There are ways to easily work around this however as we shall see below.
We have not attempted to give an example of every single operator being used but the
examples provided should provide all of the basic building blocks you will need to
incorporate mathematical operators into your own Gremlin queries.

[[arithmentic]]
==== Performing simple arithmetic

Let's start by looking at a few basic examples. First of all the query below shows
that we can perform mathematical operations on literal values as part of a
traversal. The vertex we found at the start of the traversal is not used by the math
step in this case.

[source,groovy]
----
g.V().limit(1).math('100/2')

50.0
----

If you want to use the result of the prior step of a traversal as part of a 'math'
step the special symbol '"_"' (underscore) can be used as shown below. Note that the
'inject' step provides us a nice way to feed in values while experimenting with the
'math' step

[source,groovy]
----
g.inject(100).math('_ /2')

50.0
----

Now let's look at how vertex properties can be used by a 'math' step. To do this, we
can also use named traversal steps as part of a 'math' operation. The examples below
start by checking how many runways the DFW and SFO airports have. Then a 'math' step
is used to show how we can add those values together as part of a traversal.

[source,groovy]
----
// How many runways does DFW have?
g.V().has('airport','code','DFW').values('runways')

7

// How many runways does SFO have?
g.V().has('airport','code','SFO').values('runways')

4
----

Now let's use 'math' to add the values together as part of a single traversal. Note
that even though we are adding two integers together, the result comes back as a
double precision value. Also, note that the named steps '+++'+++a+++'+++' and
'+++'+++b+++'+++' are specified inside the single string that is passed to the math
step. This is a key difference from all other steps where we refer to one or more
traversal labels inside of a step. Lastly, notice that a 'by' modulator is used to
tell the 'math' step which properties we want to add together.

[source,groovy]
----
// Use named steps to add some results together.
g.V().has('airport','code','DFW').as('a').
      out().has('code','SFO').as('b').
      math('a + b').by('runways')

11.0
----

The 'math' step returns a double. If you would prefer an integer value you can always
convert it with 'asNumber'.

[source,groovy]
----
// Use named steps to add some results together.
g.V().has('airport','code','DFW').as('a').
      out().has('code','SFO').as('b').
      math('a + b').by('runways').
      asNumber(GType.INT)

11
----

The examples below show division and modulo operators being used on the results of a
'count' step.

[source,groovy]
----
g.V(3).out().count()

98

g.V(3).out().count().math('_ / 2')

49.0

g.V(3).out().count().math('_ % 5')

3.0
----

Note that the underscore character allowed us to avoid having to write the previous
queries using a pattern like the one used below where the count step is labelled as
'+++'+++a+++'+++'.

[source,groovy]
----
g.V(3).out().count().as('a').math('a / 2')

49.0
----

[[mathby]]
==== Using a 'by' modulator with a 'math' step

As with many Gremlin steps, a 'math' step can also be combined with one or more 'by'
modulators. First of all let's write a simple query to inspect the number of runways
and Santa Fe (SAF) and all of the places that you can fly to from there.

[source,groovy]
----
g.V().has('code','SAF').as('a').
      out().as('b').
      select('a','b').
        by(values('code','runways').fold())

[a:[SAF,3],b:[DFW,7]]
[a:[SAF,3],b:[LAX,4]]
[a:[SAF,3],b:[PHX,3]]
[a:[SAF,3],b:[DEN,6]]
----

Now let's modify the query to use a 'math' step to add the number of runways each
pair of airports has.

[source,groovy]
----
g.V().has('code','SAF').as('a').
      out().as('b').
      math('a + b').by('runways').
      asNumber(INT)

10
7
6
9
----

Of course, this is a simple example where 'math' is not really needed but hopefully
it shows how a 'by' modulator can be used with a 'math' step. For completeness, here
is the query rewritten to use a 'sum' step.

[source,groovy]
----
g.V().has('code','SAF').as('a').
      out().as('b').
      select('a','b').by('runways').select(values).sum(local)

10
7
6
9
----

[[mathconvert]]
==== Converting feet to meters

The length of the longest runway at each airport in the graph is stored as units of
feet. We can use a simple 'math' step to convert that value to meters.

[source,groovy]
----
g.V().has('code','DFW').values('longest').math('_ * 0.3048')

4084.6248
----

We could make the result a bit more interesting by adding a 'project' step to the
query.

[source,groovy]
----
g.V().has('code','DFW').
      project('Longest runway at','feet','meters').
        by('code').
        by('longest').
        by(values('longest').math('_ * 0.3048'))

[Longest runway at:DFW,feet:13401,meters:4084.6248]
----

[[mathtrig]]
==== Using the trigonometric functions

The trigonometric operators work as you would expect. All angles need to be specified
as radians and not degrees. You can do the conversion to radians yourself or use the
Java 'Math.toRadians' helper method if you prefer. The query below uses the 'math'
step to calculate the sine of 60 degrees and stores the result in a variable called
'"x"'.

[source,groovy]
----
// Calculate the sine of 60 degrees
x=g.inject(60*(Math.PI/180)).math('sin(_)').next()

0.8660254037844386
----

We can use our variable '"x"' to calculate the arcsine.

[source,groovy]
----
// Calculate the arcsine
g.inject(x).math('asin(_)')

1.0471975511965976
----

We can use the Gremlin console as a calculator to prove that we got the correct
answer back.

[source,groovy]
----
// Prove this is the right answer
Math.toRadians(60)

1.0471975511965976
----

Note that just as when using the Java Math library you have to be aware of possible
rounding errors. You would expect the calculation below to return 1.0 but it does not
as the conversion of 45 degrees to radians is not precise enough for the Math
library. Note that using the Java 'Math.toRadians' method does not achieve the
desired result either.

[source,groovy]
----
// Manual conversion
g.inject(45*(Math.PI/180)).math('tan(_)')

0.9999999999999999
----

Same experiment but using the helper method.

[source,groovy]
----
// Libraray conversion
g.inject(Math.toRadians(45)).math('tan(_)')

0.9999999999999999
----

This presents us with a chance to experiment with another of the operators that the
'math' step provides. We can use the 'ceil' operator to round our result up to the
nearest integer.

[source,groovy]
----
g.inject(Math.toRadians(45)).math('tan(_)').math('ceil(_)')

1.0
----

[[mathsignum]]
==== Using signum to make a choice

The 'signum' operator allows us to make a decision depending upon whether a numeric
value is positive, negative or zero as shown below.

[source,groovy]
----
g.inject(-10).math('signum(_)')
-1.0

g.inject(10).math('signum(_)')
1.0

g.inject(0).math('signum(_)')
0.0
----

We can use this capability to build a query that reports which side of
the Greenwich meridian an airport is located. Note that we had to use the '"D"'
suffix on the numbers in the 'option' steps as 'math' returns a double precision
result.

[source,groovy]
----
g.V().hasLabel('airport').sample(12).
      project('IATA','city','position').
        by('code').
        by('city').
        by(choose(values('lon').math('signum(_)')).
          option(0D,constant('on the meridian')).
          option(1D,constant('East')).
          option(-1D,constant('West')))

----

Here is an example of the output from running the query.

[source,groovy]
----
[IATA:MJZ,city:Mirny,position:East]
[IATA:ULN,city:Ulaanbaatar,position:East]
[IATA:AHU,city:Al Hoceima,position:West]
[IATA:AMA,city:Amarillo,position:West]
[IATA:JTC,city:Bauru,position:West]
[IATA:PIZ,city:Point Lay,position:West]
[IATA:UZR,city:Urdzhar,position:East]
[IATA:MNT,city:Minto,position:West]
[IATA:MKE,city:Milwaukee,position:West]
[IATA:PSA,city:Pisa,position:East]
[IATA:FWA,city:Fort Wayne,position:West]
[IATA:DBQ,city:Dubuque,position:West]
----

[[stddev]]
==== Calculating a standard deviation

We could use the new 'math' step to implement a query that calculates the standard
deviation for the number of runways each airport in the graph has. This allows us to
see use of the 'sqrt' and power (+++^+++) operators. We broke the solution into three
queries rather than try to force it all into one. Even now the final query of the
three is complicated enough we think! Notice how multiple 'math' steps are used in
the same query with the results from one being used as input to the next.

First of all let's calculate the mean (or average) number of runways in the graph.
Not surprisingly this number is close to 1.5 as as the majority of the airports only
have one or two runways.

[source,groovy]
----
// Average number of runways
mean=g.V().hasLabel('airport').values('runways').mean().next()

1.4212328767123288
----

We also need to know how many airports there are in the graph so that we can
calculate the variance as part of the standard deviation calculation.

[source,groovy]
----
// Total number of airports
count = g.V().hasLabel('airport').count().next()

3504
----

Now we are ready to make use of the square root and power operators and calculate the
standard deviation. As a reminder, the standard deviation is found by taking the
square root of the variance in a data set. The variance itself is calculated by for
each airport subtracting the mean from the number of runways it has and squaring it
and then taking the sum of those values and finally dividing that sum by the number
of airports. Let's write a query that can do all of that for us.

[source,groovy]
----
// Calculate the standard deviation
g.withSideEffect("m",mean).
  withSideEffect("c",count).
  V().hasLabel('airport').values('runways').
  math('(_ - m)^2').sum().math('_ / c').math('sqrt(_)')

0.7429770644987477
----

We could use another query to check on the distribution of runways in the graph to
see if we believe our standard deviation result.

[source,groovy]
----
 g.V().hasLabel('airport').groupCount().by('runways')

[1:2429,2:775,3:227,4:53,5:14,6:4,7:2]
----

Looking at the distribution, where a large majority of the airports have either one
or two runways, our result looks pretty reasonable. Clearly the few airports with 
six, seven or eight runways are the outliers in this sample and would fall well 
outside of the standard deviation from the mean that we calculated.

Just for fun, let's use the same basic set of steps once again but this time to find
the standard deviation for the number of outgoing routes in the graph.

As before we need to find the mean value for the data set. This time we need to find
the average number of outgoing routes in the graph. The airport count remains the
same of course.

[source,groovy]
----

mean=g.V().hasLabel('airport').local(out().count()).mean().next()

14.451198630136986

count = g.V().hasLabel('airport').count().next()

3504
----

Now we are ready to again calculate the standard deviation for the data set
representing all outgoing routes per airport.

[source,groovy]
----
g.withSideEffect("m",mean).
  withSideEffect("c",count).
  V().hasLabel('airport').local(out().count()).
  math('(_ - m)^2').sum().math('_ / c').math('sqrt(_)')

32.00790808644156
----

This time we got a much bigger number back as the result compared to when we looked
at runways. This reflects the differing distribution of routes between major and more
minor airports.

[[stddevone]]
==== Calculating a standard deviation in one query

In the previous section the steps to calculate the standard deviation were broken up
into three graph queries. It is possible to perform the entire task in a single
query as shown below.

[source,groovy]
----
g.V().hasLabel('airport').
      values('runways').fold().as('runways').
      mean(local).as('mean').
      select('runways').unfold().
      math('(_-mean)^2').mean().math('sqrt(_)')

0.7429770644987477
----

Using this approach means that we can avoid making multiple round trips to the graph
to generate the values we need. The query is not really a lot more complex either.
Which technique you find more convenient may come down to personal preference. Making
multiple queries in general is not always a bad thing but in this case using a single
query we think makes sense as it does not add much additional complexity to the steps
involved.

[[mathproject]]
==== Using 'project' to feed values to 'math'

The 'project' step can be used to create a map of key/value pairs that can in turn be
passed to a 'math' step. First of all let's create a query that generates a simple
projection containing the number of incoming and outgoing routes at the Austin
airport.

[source,groovy]
----
g.V().has('code','AUS').
      project('in','out').
        by(__.in('route').count()).
        by(out('route').count())

[in:98,out:98]
----

We can now add a 'math' step that uses the key names from the map created by the
'project' step and adds their values together.

[source,groovy]
----
g.V().has('code','AUS').
      project('in','out').
        by(__.in('route').count()).
        by(out('route').count()).
      math('in + out')

196.0
----

There are obviously many other operators that we have not provided examples for but
hopefully the ones we have provided give you a feel for ways that the 'math' step can
be used to create interesting queries.

[[withindex]]
=== Including an index with results - introducing 'withIndex' and 'indexed'

If for any reason you wanted an index value included as part of the results from a
query you can use the Groovy 'withIndex' or 'indexed' methods as shown below.

The 'withIndex' method adds the index value at the end of a list whereas the
'indexed' method adds it at the start. You can provide a starting index value as a
parameter. If no value is provided the default value for the first index will be
zero.

[source,groovy]
----
g.V().has('region','US-OK').values('code').withIndex()

[OKC,0]
[TUL,1]
[LAW,2]
[SWO,3]
----

NOTE: Note that 'indexed' and 'withIndex' are Groovy methods and not Gremlin
traversal steps. They will only work using graph databases that allow Groovy code to
be included as part of a query.

Here is the same query as before but using 1 as the starting index.

[source,groovy]
----
g.V().has('region','US-OK').values('code').withIndex(1)

[OKC,1]
[TUL,2]
[LAW,3]
[SWO,4]
----

Below is the query used again but this time with the 'indexed' method being used to
generate the index value.

[source,groovy]
----
g.V().has('region','US-OK').values('code').indexed(1)

[1,OKC]
[2,TUL]
[3,LAW]
[4,SWO]
----

[[tp34index]]
==== The 'index' step

The  'index' step adds a counter value to a 'list' or 'map' object and usage only
really makes sense in that context. As shown below, without a 'fold' step in the
query, the result set will consist of a number of individual lists all with an index
of zero.

TIP: The official Apache TinkerPop documentation for the 'index' step can be found at
the following link https://tinkerpop.apache.org/docs/current/reference/#index-step.

[source,groovy]
----
g.V().has('code','LHR').
      out().limit(5).
      values('code').index()

[[YUL,0]]
[[YEG,0]]
[[CGN,0]]
[[GOT,0]]
[[VCE,0]]
----

If we had a 'fold' step before calling 'index' however, the results will be indexed
in increments of one, starting at zero.

[source,groovy]
----
g.V().has('code','LHR').
      out().limit(5).
      values('code').fold().index()

[[YUL,0],[YEG,1],[CGN,2],[GOT,3],[VCE,4]]
----

Adding an 'unfold' step will yield a set of individual lists with each containing an
airport code and its index.

[source,groovy]
----
g.V().has('code','LHR').
      out().limit(5).
      values('code').fold().index().
      unfold()

[YUL,0]
[YEG,1]
[CGN,2]
[GOT,3]
[VCE,4]
----

The new 'with' modulator can be used to control the type of collection that 'index'
produces. To have the result returned as a map where the key is the index value the
query can be modified as follows.

[source,groovy]
----
g.V().has('code','LHR').
      out().limit(5).
      values('code').fold().
      index().with(WithOptions.indexer,WithOptions.map)

[0:YUL,1:YEG,2:CGN,3:GOT,4:VCE]
----

Finally the example below shows a 'with' step being used to ask for results as a list
which is the default. The results are then sorted in reverse order.

TIP: All of the possible values that can be specified using WithOptions can be found
in the official Apache TinkerPop JavaDoc documentation
https://tinkerpop.apache.org/javadocs/current/full/org/apache/tinkerpop/gremlin/process/traversal/step/util/WithOptions.html[at
this location].

Note that this query uses 'desc' rather than the now deprecated 'decr' to ask for
descending order results.

[source,groovy]
----
g.V().has('code','LHR').
      out().limit(5).
      values('code').fold().
      index().with(WithOptions.indexer,WithOptions.list).
      unfold().
      order().by(tail(local,1),desc)

[VCE,4]
[GOT,3]
[CGN,2]
[YEG,1]
[YUL,0]
----

[[index-reverse]]
==== Using 'index' to reverse a list

The Gremlin query language does not have a built in step or function that can be used
to reverse the contents of a list or other collection. However, this can be achieved
using the 'index' step. The example below takes advantage of the index step to give
each element of a list an index number.

[source,groovy]
----
g.inject(['A','B','C','D']).index()

[[A,0],[B,1],[C,2],[D,3]]
----

Given that building block, we can use those index values to order the list.

[source,groovy]
----
g.inject(['A','B','C','D']).index().
  unfold().
  order().
    by(tail(local,1),desc)

[D,3]
[C,2]
[B,1]
[A,0]
----

The query can be further refined so that the index values are not part of the result.

[source,groovy]
----
g.inject(['A','B','C','D']).index().
  unfold().
  order().
    by(tail(local,1),desc).
  limit(local,1).
  fold()

[D,C,B,A]
----

The same technique can be used with any collection generated as part of a query.

[source,groovy]
----
g.V().has('code','SAF').out().values('code').fold().index()

[[DFW,0],[LAX,1],[PHX,2],[DEN,3]]
----

Once again we can order the results using the index values.

[source,groovy]
----
g.V().has('code','SAF').
  out().values('code').fold().
  index().
  unfold().
  order().
    by(tail(local,1),desc).
  limit(local,1).
  fold()

[[DEN],[PHX],[LAX],[DFW]]
----

[[sx]]
=== More examples using concepts we have covered so far

The examples in this section build upon the topics that we have covered so far. The
query below finds cities that can be flown to from any airport in the Hawaiian
islands.

[source,groovy]
----
// Which cities can I fly to from any airport in the Hawaiian islands?
g.V().has('airport','region','US-HI').out().path().by('city')
----

If we run the query we would get back results similar to those below. Only a few of 
the full result set are shown.

[source,groovy]
----
[Honolulu,Brisbane]
[Honolulu,Shanghai]
[Honolulu,Kuala Lumpur]
[Honolulu,Tokyo]
[Honolulu,Seoul]
[Honolulu,Portland]
[Honolulu,Kahului]
[Honolulu,Hagta]
[Honolulu,Taipei]
...
----

The query below looks for airports in Europe using the continent vertex with a code 
of 'EU' as the starting point. The results are sorted in ascending order and folded
into a list.

[source,groovy]
----
// Find all the airports that are in Europe (The graph stores continent information
// as "contains" edges connected from a "continent" vertex to each airport vertex.
g.V().has('continent','code','EU').out('contains').values('code').order()
----

Here are some of the results that you get back from running the query.

[source,groovy]
----
AAL
AAQ
AAR
ABZ
ACE
ACH
ACI
AER
AES
AEY
AGB
AGF
AGH
AGP
AHO
AJA
AJR
ALC
...
----

The next queries show two ways of finding airports with 6 or more runways.

[source,groovy]
----
g.V().where(values('runways').is(gte(6))).values('code')

g.V().has('runways',gte(6)).values('code')
----

Next, let's look at two ways of finding flights from airports in South America to
Miami. The first query uses 'select' which is what we would have had to do in the
TinkerPop 2 days. The second query, which feels cleaner to me, uses the 'path' and
'by' step combination introduced in TinkerPop.

[source,groovy]
----
g.V().has('continent','code','SA').out().as('x').out().as('y').
      has('code','MIA').select('x','y').by('code')

g.V().has('continent','code','SA').out().out().
      has('code','MIA').path().by('code')
----

This query finds the edge that connects Austin (AUS) with Dallas Ft. Worth (DFW) and
returns the 'dist' property of that edge so we know how far that journey is.
[source,groovy]
----
// How far is it from DFW to AUS?
g.V().has('code','DFW').outE().as('a').
  inV().has('code','AUS').select('a').values('dist')

190
----

As an alternative approach, we could return a path that would include both airport
codes and the distance. Notice how we need to use 'outE' and 'inV' rather than just
'out' as we still need the edge to be part of our path so that we can get its 'dist'
property using a 'by' step.

[source,groovy]
----
g.V().has('code','DFW').outE().inV().has('code','AUS').path().by('code').by('dist')

[DFW,190,AUS]
----

If we wanted to find out if there are any ways to get from Brisbane to Austin with
only one stop, this query will do nicely!

[source,groovy]
----
// Routes from BNE to AUS with only one stop
g.V().has('code','BNE').out().out().has('code','AUS').path().by('code')

[BNE,LAX,AUS]
[BNE,SFO,AUS]
[BNE,HNL,AUS]
[BNE,YVR,AUS]
----

This is another way of doing the same thing but, once again, to me using 'path' feels
more concise. The only advantage of this query is that if all you want is the name
of any intermediate airports then that's all you get!

[source,groovy]
----
g.V().has('code','BNE').out().as('stop').
                        out().has('code','AUS').select('stop').values('code')

LAX
SFO
HNL
YVR
----

A common thing you will find yourself doing when working with a graph is counting
things. This next query looks for all the airports that have fewer than five outgoing
routes and counts them. It does this by counting the number of airports that have
fewer than five outgoing edges with a 'route' label. There are a surprisingly high
number of airports that offer this small number of destinations.

[source,groovy]
----
// Airports with fewer than 5 outgoing edges
g.V().hasLabel('airport').where(out('route').count().is(lt(5))).count()

2046
----

In a similar vein this query finds the airports with more than 200 outgoing routes.
The second query shows that 'where' is a synonym for 'filter' in many cases.

[source,groovy]
----
g.V().hasLabel("airport").where(outE('route').count().is(gt(200))).values('code')

g.V().hasLabel("airport").filter(outE("route").count().is(gt(200))).values('code')
----

Here are two more queries that look for things that meet a specific criteria. The
first finds routes where the distance is exactly 100 miles and returns the source and
destination airport codes. The first query uses 'as' and 'select' while the second
one uses 'path' and includes the distance in the result.

[source,groovy]
----
// List ten (or less) routes where the distance is exactly 100 miles
g.V().as('a').outE().has('dist',eq(100)).limit(10).inV().as('b').
      select('a','b').by('code')

[a:IAD,b:RIC]
[a:HNL,b:OGG]
[a:OGG,b:HNL]
[a:SJO,b:LIR]
[a:SVG,b:KRS]
[a:RIC,b:IAD]
[a:LIR,b:SJO]
[a:KRS,b:SVG]
[a:CYB,b:GCM]
[a:GCM,b:CYB]
----

Similar to the prior query but using 'path' and displaying the distance as well as
the airport codes.

[source,groovy]
----
g.V().outE().has('dist',eq(100)).limit(10).inV().path().by('code').by('dist')

[IAD,100,RIC]
[HNL,100,OGG]
[OGG,100,HNL]
[SJO,100,LIR]
[SVG,100,KRS]
[RIC,100,IAD]
[LIR,100,SJO]
[KRS,100,SVG]
[CYB,100,GCM]
[GCM,100,CYB]
----

This query looks for any airports that have an elevation above 10,000 feet. Two ways
of achieving the more or less the same result are shown. The first uses 'valueMap'
and the second uses a 'project' step instead.

[source,groovy]
----
// Airports above 10,000ft sorted by ascending elevation
g.V().has('airport','elev', gt(10000)).
      order().by('elev',asc).valueMap('city','elev')


g.V().has('airport','elev', gt(10000)).order().by('elev',asc).
      project('city','elevation').by('city').by('elev')
----

If we ran the query that uses the 'project' step here is what we should get back.

[source,groovy]
----
[city:Xiahe,elevation:10510]
[city:Leh,elevation:10682]
[city:Shangri-La,elevation:10761]
[city:Cusco,elevation:10860]
[city:Jauja,elevation:11034]
[city:Andahuaylas,elevation:11300]
[city:Jiuzhaigou,elevation:11327]
[city:Navoi,elevation:11420]
[city:Hongyuan,elevation:11598]
[city:Lhasa,elevation:11713]
[city:Oruro,elevation:12152]
[city:Xigaze,elevation:12408]
[city:Golog,elevation:12427]
[city:Juliaca,elevation:12552]
[city:Yushu,elevation:12816]
[city:Potos,elevation:12913]
[city:Quijarro,elevation:12972]
[city:La Paz / El Alto,elevation:13355]
[city:Shiquanhe,elevation:14022]
[city:Kangding,elevation:14042]
[city:Bangda,elevation:14219]
[city:Daocheng,elevation:14472]
----

The next query finds any routes between Austin and Sydney that only require one
stop.The 'by' step offers a clean way of doing this query by combining it with
'path'.

[source,groovy]
----
g.V().has('code','AUS').out().out().has('code','SYD').path().by('code')
----

The following three queries all achieve the same result. They find flights from any
airport in Africa to any airport in the United States. These queries are interesting
as the continent information is represented in the graph as edges connecting an
airport vertex with a continent vertex. This is about as close as Gremlin gets to a 
SQL join statement!

The first query starts by looking at airports the second starts from the vertex that
represents Africa. The third query uses 'where' to show an alternate way of achieving
the same result.

[source,groovy]
----

g.V().hasLabel('airport').as('a').in('contains').has('code','AF').
      select('a').out().has('country','US').as('b').select('a','b').by('code')

g.V().hasLabel('continent').has('code','AF').out().as('a').
      out().has('country','US').as('b').
      select('a','b').by('code')

g.V().hasLabel('airport').where(__.in('contains').has('code','AF')).as('a').
      out().has('country','US').as('b').select('a','b').by('code')
----

If we run the query we should get results that look like this.

[source,groovy]
----
[a:CPT,b:EWR]
[a:JNB,b:ATL]
[a:JNB,b:JFK]
[a:JNB,b:EWR]
[a:NBO,b:JFK]
[a:CAI,b:JFK]
[a:ADD,b:IAD]
[a:ADD,b:EWR]
[a:LOS,b:ATL]
[a:LOS,b:IAD]
[a:LOS,b:IAH]
[a:LOS,b:JFK]
[a:ACC,b:IAD]
[a:ACC,b:JFK]
[a:CMN,b:IAD]
[a:CMN,b:JFK]
[a:CMN,b:MIA]
[a:GCK,b:DFW]
[a:SID,b:IAD]
[a:DKR,b:IAD]
[a:DKR,b:JFK]
[a:ABJ,b:EWR]
[a:LFW,b:IAH]
[a:LFW,b:LAX]
[a:LFW,b:EWR]
[a:RAI,b:BOS]
[a:DSS,b:IAD]
----

The query below shows how to use the 'project' step that was introduced in TinkerPop
3, along with 'order' and 'select' to produce a sorted table of airports you can fly
to from AUSTIN along with their runway counts. The 'limit' step is used to only
return the top ten results. You will find several examples elsewhere in this book
that use variations of this collection of steps.

[source,groovy]
----
g.V().has('code','AUS').out().project('ap','rw').by('code').by('runways').
      order().by(select('rw'),desc).limit(10)
----

Here are the results we get from running the query.

[source,groovy]
----
[ap:DFW,rw:7]
[ap:ORD,rw:7]
[ap:DTW,rw:6]
[ap:BOS,rw:6]
[ap:DEN,rw:6]
[ap:AMS,rw:6]
[ap:MKE,rw:5]
[ap:MDW,rw:5]
[ap:ATL,rw:5]
[ap:IAH,rw:5]
----

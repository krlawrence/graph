// vim: set tw=85 cc=+1 wrap spell redrawtime=20000:

[[gs]]
== GETTING STARTED

In this chapter you will set up the Gremlin Console, load the air-routes sample 
graph, and run your first Gremlin traversals against it. You will learn how to start 
and stop the console, adjust a few useful settings, and verify that the sample data 
has been loaded correctly. By the end of the chapter you should be comfortable using
the console as a workspace for experimenting with the examples used throughout the 
rest of the book.

[[tpintro]]
=== What is Apache TinkerPop?

Apache TinkerPop is a graph computing framework and top-level project hosted by the
Apache Software Foundation. The homepage for the project is located at this URL:
http://tinkerpop.apache.org/

.The project includes the following components:
Gremlin::
- A graph traversal (query) language
Gremlin Console::
- An interactive shell for working with local or remote graphs.
- http://tinkerpop.apache.org/docs/current/reference/#gremlin-console
Gremlin Server::
- Allows hosting of graphs remotely via an HTTP/Web Sockets connection.
- http://tinkerpop.apache.org/docs/current/reference/#gremlin-server
TinkerGraph::
- A small in-memory graph implementation that is great for learning.
- http://tinkerpop.apache.org/docs/current/reference/#tinkergraph-gremlin
Programming Interfaces::
- A set of programming interfaces written in Java
- http://tinkerpop.apache.org/javadocs/current/full/
Documentation::
- A user guide, a tutorial and programming API documentation.
- http://tinkerpop.apache.org/docs/current/
- http://tinkerpop.apache.org/docs/current/reference/
Useful Recipes::
- A set of examples or "recipes" showing how to perform common graph oriented tasks 
using Gremlin queries.
- http://tinkerpop.apache.org/docs/current/recipes/

The programming interfaces allow providers of graph databases to build systems that
are TinkerPop enabled and allow application programmers to write programs that talk
to those systems.

Any TinkerPop enabled graph databases can be accessed using the Gremlin query
language and corresponding API. We can also use the TinkerPop API to write client
code, in languages like Java, that can talk to a TinkerPop enabled graph. For most of
this book we will be working within the Gremlin Console with a local graph. However
in Chapters 7 and 8 we take a look at Gremlin Server and some other TinkerPop enabled
environments. Most of Apache TinkerPop has been developed using Java but there are
also bindings available for many other programming languages such as Groovy, Python,
Go, Javascript and C#. These bindings help make Gremlin feel comfortable to you as
you can work with Gremlin in the idioms of the programming language that you are most
familiar with.

Even though this book focuses on Gremlin written with Groovy, you should remember 
that whatever examples you see in Groovy can easily be converted to any other 
supported programming language. You just need to understand the idioms of the
language you are using and converting should be straightforward. For example, Python
prefers snake case compared to Groovy preferring camel-case. Therefore, a Groovy query
of 'g.addV("person")' just converts to 'g.add_v("person")' in Python. You will read
more about Gremlin translation in the "<<translators>>" section.

The queries used as examples in this book have been tested with Apache TinkerPop
version {tpvercheck} as well as some prior releases where appropriate. Tests were
performed using the TinkerGraph in memory graph and the Gremlin console, as well as
other TinkerPop enabled graph stores.

[[gconsole]]
=== The Gremlin Console

The Gremlin Console is an interactive shell for running Gremlin traversals against a
graph. In this book it serves as the main workspace for experimenting with the 
air-routes graph, trying out examples, and exploring variations of your own. It is
based on the Groovy Shell and if you have used any of the other console
environments such as those found with Scala, Python and Ruby you will feel right at
home here. The console offers a low overhead (you can set it up in seconds) and low
barrier of entry way to start to play with graphs on your local computer. The
console can actually work with graphs that are running locally or remotely but for
the majority of this book we will keep things simple and focus on local graphs.

To follow along with this tutorial you will need to have installed the Gremlin
console or have access to a TinkerPop/Gremlin enabled graph store such as
TinkerGraph or JanusGraph.

Regardless of the environment you use, if you work with Apache TinkerPop enabled
graphs, the console should always be installed on your machine!

[[gremlininstall]]
==== Download, install and launch the Gremlin Console

You can download the Gremlin Console from the official Apache TinkerPop website at 
http://tinkerpop.apache.org/

It only takes a few minutes to get the console installed and running. You just 
download the ZIP, 'unzip' it and you are all set. TinkerPop also requires Java to be
at version 11 or higher.

NOTE: For more information on the compatability of Gremlin with versions of Java and
other languages, please see the https://tinkerpop.apache.org/docs/current/upgrade/[official documentation].

The Console download also includes all of the JAR files that are needed to write a 
standalone Java or Groovy TinkerPop application but that is a topic for later!

When you start the console you will be presented with a banner/logo and a prompt that
will look something like this. Don't worry about the plugin messages yet we will talk
about those a bit later.

[source,text]
----
$ ./gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
plugin activated: tinkerpop.server
plugin activated: tinkerpop.utilities
plugin activated: tinkerpop.tinkergraph
gremlin>
----

You can get a list of the available commands by typing ':help'. Note that all
commands to the console itself are prefixed by a colon '":"'. This enables the
console to distinguish them as special and different from actual Gremlin and
Groovy commands.

[source,text]
----
gremlin> :help

For information about Groovy, visit:
    http://groovy-lang.org

Available commands:
  :help       (:h  ) Display this help message
  ?           (:?  ) Alias to: :help
  :exit       (:x  ) Exit the shell
  :quit       (:q  ) Alias to: :exit
  import      (:i  ) Import a class into the namespace
  :display    (:d  ) Display the current buffer
  :clear      (:c  ) Clear the buffer and reset the prompt counter
  :show       (:S  ) Show variables, classes or imports
  :inspect    (:n  ) Inspect a variable or the last result with the GUI object browser
  :purge      (:p  ) Purge variables, classes, imports or preferences
  :edit       (:e  ) Edit the current buffer
  :load       (:l  ) Load a file or URL into the buffer
  .           (:.  ) Alias to: :load
  :save       (:s  ) Save the current buffer to a file
  :record     (:r  ) Record the current session to a file
  :history    (:H  ) Display, manage and recall edit-line history
  :alias      (:a  ) Create an alias
  :grab       (:g  ) Add a dependency to the shell environment
  :register   (:rc ) Register a new command with the shell
  :doc        (:D  ) Open a browser window displaying the doc for the argument
  :set        (:=  ) Set (or list) preferences
  :uninstall  (:-  ) Uninstall a Maven library and its dependencies from the Gremlin Console
  :install    (:+  ) Install a Maven library and its dependencies into the Gremlin Console
  :plugin     (:pin) Manage plugins for the Console
  :remote     (:rem) Define a remote connection
  :submit     (:>  ) Send a Gremlin script to Gremlin Server
  :bytecode   (:bc ) Gremlin bytecode helper commands
  :cls        (:C  ) Clear the screen.

For help on a specific command type:
    :help command

----

TIP: Of all the commands listed above :clear (:c for short) is an important one to
remember. If the console starts acting strangely or you find yourself stuck with a
prompt like "......1>" , typing ':clear' will reset things nicely.

It is worth noting that as mentioned above, the console is based on the Groovy Shell
and as such you can enter valid Groovy code directly into the console. So as well as
using it to experiment with Graphs and Gremlin you can use it as, for example, a 
desktop calculator should you so desire!

[source,groovy]
----
gremlin> 2+3
==>5

gremlin> a = 5
==>5

gremlin> println "The number is ${a}"
The number is 5

gremlin> for (a in 1..5) {print "${a} "};println()
1 2 3 4 5
----

NOTE: The console does a very nice job of only showing you a nice and tidy set of 
query results. If you are working with a graph system that supports TinkerPop 3 but
not via the console (an example of this would be talking to a Gremlin Server using 
the HTTP REST API) then what you will get back is going to be a JSON document that 
you will need to write some code to parse. We will explore that topic much later in 
the book.

If you want to see lots of examples of the output from running various queries you
will find plenty in the "<<msc>>" section of this book where we have tried to go
into more depth on various topics.

Mostly you will run the console in its interactive mode. However you can also pass 
the name of a file as a command line parameter, preceded by the '-e' flag and
Gremlin will execute the file and exit. For example if you had a file called
"mycode.groovy" you could execute it directly from your command line window or
terminal window as follows:

[source,text]
----
$ ./gremlin.sh -e mycode.groovy
----

If you wanted to have the console run your script and not exit afterwards, you can
use the '-i' option instead of '-e'.

You can get help on all of the command line options for the console by typing
'gremlin --help'. You should get back some help text that looks like this

[source,text]
----
$ ./gremlin.sh --help

Usage: gremlin.sh [-CDhlQvV] [-e=<SCRIPT ARG1 ARG2 ...>]... [-i=<SCRIPT ARG1
                  ARG2 ...>...]...
  -C, --color     Disable use of ANSI colors
  -D, --debug     Enabled debug Console output
  -e, --execute=<SCRIPT ARG1 ARG2 ...>
                  Execute the specified script (SCRIPT ARG1 ARG2 ...) and close
                    the console on completion
  -h, --help      Display this help message
  -i, --interactive=<SCRIPT ARG1 ARG2 ...>...
                  Execute the specified script and leave the console open on
                    completion
  -l              Set the logging level of components that use standard logging
                    output independent of the Console
  -Q, --quiet     Suppress superfluous Console output
  -v, --version   Display the version
  -V, --verbose   Enable verbose Console output
----

If you ever want to check which version of TinkerPop you have installed you can enter
the following command from inside the console.

[source,groovy]
----
// What version of the console am I running?
gremlin>  Gremlin.version()
==>3.8.0
----

One thing that is not at all obvious or apparent is that the console quietly imports
a large number of Java Classes and Enums on your behalf as it starts up. This makes
writing queries within the console simpler. However, as we shall explore in the
"<<javastatics>>" section later, once you start writing standalone programs in Java
or other languages, you need to actually know what the console did on your behalf. 
Reading through that section will help familiarize you with the classes you need to
import to your application code.

[[gremlinsave]]
==== Saving output from the Gremlin Console to a file

Sometimes it is useful to save part or all of a Gremlin Console session to a file so
that you can review it later, compare different traversals, or share it with others. 
The console provides a simple way to start and stop recording, which captures both 
the commands you type and the results that are displayed.

In the following example, we turn session recording on using 
':record start mylog.txt' which will force all commands entered and their output to 
be written to the file 'mylog.txt' until the command ':record stop' is entered. The 
command 'g.V().count().next()' just counts how many vertices (nodes) are in the 
graph. We will explain the Gremlin graph traversal and query language in detail 
starting in the next section.

[source,groovy]
----
gremlin> :record start mylog.txt
Recording session to: "mylog.txt"

gremlin> g.V().count().next()
==>3749
gremlin> :record stop
Recording stopped; session saved as: "mylog.txt" (157 bytes)
----

If we were to look at the 'mylog.txt' file, this is what it now contains.

----
// OPENED: Tue Sep 12 10:43:40 CDT 2017
// RESULT: mylog.txt
g.V().count().next()
// RESULT: 3618
:record stop
// CLOSED: Tue Sep 12 10:43:50 CDT 2017

----

For the remainder of this book we are not going to show the 'gremlin>' prompt or
the '==>' output identifier as part of each example, just to reduce clutter a bit.
You can assume that each command was entered and tested using the console however.

TIP: If you want to learn more about the console itself you can refer to the official
TinkerPop documentation and, even better, have a play with the console and the built
in help.

[[consolepreferences]]
==== Setting up console preferences

There are a number of preferences that can be established within the Gremlin Console
to make it more suitable for your needs. The ':set' command is used to establish 
various preference values. Let's look at a few helpful configurations. 

The first option to know is 'max-iteration'. The console will only display the first
100 lines of output for any command by default. If you'd like to see more you would 
need to increase this value.

[source,text]
----
:set max-iteration 1000
----

TIP: Set the 'max-iteration' to '-1' to have no limit in the number of lines 
displayed.

If you are on a system that can display colors, there are a wide range of color 
options you can modify to suit your needs. The various color settings take a comma
separated combinatin of a foreground, background and attribute.

[source,text]
----
:set error.color black,bg_black,underline
----

If you'd like to remove console configurations you can use the ':purge preferences'
command.

TIP: The full list of available preferences can be found in the Apache TinkerPop
reference documentation https://tinkerpop.apache.org/docs/current/reference/#console-preferences

[[tgintro]]
=== Introducing TinkerGraph

TinkerGraph is the in-memory reference implementation that ships with Apache 
TinkerPop and is included with the Gremlin Console download. It runs inside a single
JVM process, stores its data in memory, and is designed primarily for learning, 
experimentation, and small test graphs, but does have use cases for production 
workloads in some scenarios. 

This book was mostly developed using TinkerGraph The nice thing about TinkerGraph is 
that for learning and testing things you can run everything you need on your laptop 
or desktop computer and be up and running very quickly. We will also explain how to 
get started with the console and TinkerGraph a bit later in this section.

TinkerPop defines a number of capabilities that a graph store should support. Some
are optional others are not. If supported, you can query any TinkerPop enabled graph
store to see which features are supported using a command such as 'graph.features()'
once you have established the 'graph' object. We will look at how to do that soon.
The following list shows the features supported by TinkerGraph. This is what you
would get back should you call the 'features' method provided by TinkerGraph. We have
arranged the list in two columns to aid readability. Don't worry if not all of these
terms make sense right away - we'll get there soon!

.Output from graph.features()
[source,text]
----
> GraphFeatures                          > VertexPropertyFeatures
>-- ConcurrentAccess: false              >-- UserSuppliedIds: true
>-- ThreadedTransactions: false          >-- StringIds: true
>-- Persistence: true                    >-- RemoveProperty: true
>-- Computer: true                       >-- AddProperty: true
>-- Transactions: false                  >-- NumericIds: true
> VariableFeatures                       >-- CustomIds: false
>-- Variables: true                      >-- AnyIds: true
>-- LongValues: true                     >-- UuidIds: true
>-- SerializableValues: true             >-- Properties: true
>-- FloatArrayValues: true               >-- LongValues: true
>-- UniformListValues: true              >-- SerializableValues: true
>-- ByteArrayValues: true                >-- FloatArrayValues: true
>-- MapValues: true                      >-- UniformListValues: true
>-- BooleanArrayValues: true             >-- ByteArrayValues: true
>-- MixedListValues: true                >-- MapValues: true
>-- BooleanValues: true                  >-- BooleanArrayValues: true
>-- DoubleValues: true                   >-- MixedListValues: true
>-- IntegerArrayValues: true             >-- BooleanValues: true
>-- LongArrayValues: true                >-- DoubleValues: true
>-- StringArrayValues: true              >-- IntegerArrayValues: true
>-- StringValues: true                   >-- LongArrayValues: true
>-- DoubleArrayValues: true              >-- StringArrayValues: true
>-- FloatValues: true                    >-- StringValues: true
>-- IntegerValues: true                  >-- DoubleArrayValues: true
>-- ByteValues: true                     >-- FloatValues: true
> VertexFeatures                         >-- IntegerValues: true
>-- AddVertices: true                    >-- ByteValues: true
>-- DuplicateMultiProperties: true       > EdgePropertyFeatures
>-- MultiProperties: true                >-- Properties: true
>-- RemoveVertices: true                 >-- LongValues: true
>-- MetaProperties: true                 >-- SerializableValues: true
>-- UserSuppliedIds: true                >-- FloatArrayValues: true
>-- StringIds: true                      >-- UniformListValues: true
>-- RemoveProperty: true                 >-- ByteArrayValues: true
>-- AddProperty: true                    >-- MapValues: true
>-- NumericIds: true                     >-- BooleanArrayValues: true
>-- CustomIds: false                     >-- MixedListValues: true
>-- AnyIds: true                         >-- BooleanValues: true
>-- UuidIds: true                        >-- DoubleValues: true
> EdgeFeatures                           >-- IntegerArrayValues: true
>-- RemoveEdges: true                    >-- LongArrayValues: true
>-- AddEdges: true                       >-- StringArrayValues: true
>-- UserSuppliedIds: true                >-- StringValues: true
>-- StringIds: true                      >-- DoubleArrayValues: true
>-- RemoveProperty: true                 >-- FloatValues: true
>-- AddProperty: true                    >-- IntegerValues: true
>-- NumericIds: true                     >-- ByteValues: true
>-- CustomIds: false
>-- AnyIds: true
>-- UuidIds: true
----

TinkerGraph is really useful while learning to work with Gremlin and great for
testing things out. One common use case where TinkerGraph can be very useful is to
create a sub-graph of a large graph and work with it locally. TinkerGraph can even be
used in production deployments if an all in memory graph fits the bill. Typically,
TinkerGraph is used to explore static (unchanging) graphs but you can also use it
from a programming language like Java and mutate its contents if you want to.
However, TinkerGraph does not support some of the more advanced features you will
find in implementations like JanusGraph such as an advanced transaction system 
(though it does have basic transactions that are helpful to certain use cases as of 
3.7.0) and external indexes. One other thing worth noting in the list above is 
that 'UserSuppliedIds' is set to true for vertex and edge ID values. This means that 
if you load a graph file, such as a GraphML format file, that specifies ID values for
vertices and edges then TinkerGraph will honor those IDs and use them. As we shall
see later this is not the case with some other graph database systems.

When running in the console, support for TinkerGraph should be on by default. If for
any reason you find it to be off, you can enable it by issuing the following command.

[source,groovy]
----
:plugin use tinkerpop.tinkergraph
----

Once the TinkerGraph plugin is enabled you will need to close and re-load the Gremlin
console. After doing that, you can create a new TinkerGraph instance from the console
as follows

[source,groovy]
----
g = TinkerGraph.open().traversal()
----

which is shorthand for

[source,groovy]
----
graph = TinkerGraph.open()
g = traversal().with(graph)
----

The shorthand is helpful to save a bit of typing, but you lose reference to the 
graph instance which might be helpful when accessing 'graph.features()', creating
indices or initiating close operations on the graph itself. The longer form generally
tends to be preferable for this reason. You will read more about this in the 
"<<deepdivetraversals>>" section.

In some cases you will want to pass parameters to the 'open' method providing more
information on how the graph is to be configured. We will explore those options later
on. The variable called 'g' created above is known as a 'graph traversal source' and
will be used throughout the book at the start of each query we write.

NOTE: Throughout the remainder of this book the variable name 'g' will be used for
any object that represents an instance of a graph traversal source object.

[[air]]
=== Introducing the air-routes graph

The examples in this book use a sample dataset called the air-routes graph. It models
airports as vertices, flight routes as edges, and includes properties such as airport
codes, city and country names, geographic coordinates, and distances between 
airports. This graph is large enough to be interesting, but still small enough to 
explore comfortably from the Gremlin Console.

NOTE: The `air-routes.graphml` file can be downloaded from the `sample-data` folder
located in the GitHub repository at the following URL:
https://github.com/krlawrence/graph/tree/main/sample-data

While the air-routes graph was built from actual real-world data, routes are added 
and deleted by airlines all the time so please don't use this graph to plan your next
vacation or business trip! However, as a learning tool we hope you will find it 
useful and easy to relate to. If you feel so inclined you can load the file into a 
text editor and examine how it is laid out. As you work with graphs you will want to
become familiar with popular graph serialization formats. Two common ones are GraphML
and GraphSON. The latter is a JSON format that is defined by Apache TinkerPop and 
heavily used in that environment. GraphML is widely recognized by TinkerPop and many
other tools as well such as Gephi, a popular open source tool for visualizing graph 
data. A lot of graph ingestion tools also still use comma separated values (CSV) 
format files.

We will briefly look at loading and saving graph data in Sections 2 and 4. We take a
look at different ways to work with graph data stored in text format
files including importing and exporting graph data in the "<<serialize>>" section
towards the end of the book.

The 'air-routes' graph contains several vertex types that are specified using labels.
The most common ones being 'airport' and 'country'. There are also vertices for each
of the seven continents ('continent') and a single 'version' vertex that we provided
as a way to test which version of the graph you are using.

Routes between airports are modeled as edges. These edges carry the 'route' label and
include the distance between the two connected airport vertices as a property called
'dist'. Connections between countries and airports are modeled using an edge with a
'contains' label.

Each airport vertex has many properties associated with it giving various details
about that airport including its IATA and ICAO codes, its description, the city it is
in and its geographic location.

Specifically, each airport vertex has a unique ID, a label of 'airport' and contains
the following properties. The word in parenthesis indicates the type of the property.

[source,text]
----
 type    (string) : Vertex type. Will be 'airport' for airport vertices
 code    (string) : The three letter IATA code like AUS or LHR
 icao    (string) : The four letter ICAO code or none. Example KAUS or EGLL
 desc    (string) : A text description of the airport
 region  (string) : The geographical region like US-TX or GB-ENG
 runways (int)    : The number of available runways
 longest (int)    : Length of the longest runway in feet
 elev    (int)    : Elevation in feet above sea level
 country (string) : Two letter ISO country code such as US, FR or DE.
 city    (string) : The name of the city the airport is in
 lat     (double) : Latitude of the airport
 lon     (double) : Longitude of the airport
----

We can use Gremlin once the air route graph is loaded to show us what properties an
airport vertex has. As an example here is what the Austin airport vertex looks
like. We will explain the steps that make up the Gremlin query shortly. First we need
to dig a little bit into how to load the data and configure a few preferences.

[source,groovy]
----
// Query the properties of vertex 3
g.V().has('code','AUS').valueMap(true).unfold()

id=3
label=airport
type=[airport]
code=[AUS]
icao=[KAUS]
desc=[Austin Bergstrom International Airport]
region=[US-TX]
runways=[2]
longest=[12250]
elev=[542]
country=[US]
city=[Austin]
lat=[30.1944999694824]
lon=[-97.6698989868164]
----

Even though the airport vertex label is 'airport' we chose to also have a property
called 'type' that also contains the string 'airport'. This was done to aid with
indexing when working with other graph database systems and is explained in more
detail later in this book.

You may have noticed that the values for each property are represented as lists (or
arrays if you prefer), even though each list only contains one element. The reasons
for this will be explored later in this book but the quick explanation is that
this is because TinkerPop allows us to associate a list of values with any vertex
property. We will explore ways that you can take advantage of this capability in the
"<<listprop>>" section.

The full details of all the features contained in the 'air-routes' graph can be
learned by reading the comments at the start of the `air-routes.graphml` file or
reading the `README.txt` file.

The graph currently contains a total of 3,619 vertices and 50,148 edges. Of these
3,374 vertices are airports, and 43,400 of the edges represent routes. While in big
data terms this is really a tiny graph, it is plenty big enough for us to build up
and experiment with some very interesting Gremlin queries.

Lastly, here are some statistics and facts about the 'air-routes' graph. If you
want to see a lot more statistics check the `README.txt` file that is included with
the 'air-routes' graph.

[source,text]
----
Air Routes Graph (v1.0, 2025-Oct-22) contains:
  3,504 airports
  50,637 routes
  237 countries (and dependent areas)
  7 continents
  3,749 total nodes
  57,645 total edges

Additional observations:
  Longest route is between SIN and JFK (9,526 miles)
  Shortest route is between WRY and PPW (2 miles)
  Average route distance is 1,212.918 miles.
  Longest runway is 18,045ft (BPX)
  Shortest runway is 1,300ft (SAB)
  Average number of runways is 1.42123
  Furthest North is LYR (latitude: 78.2461013793945)
  Furthest South is USH (latitude: -54.8433)
  Furthest East is SVU (longitude: 179.341003418)
  Furthest West is TVU (longitude: -179.876998901)
  Closest to the Equator is MDK (latitude: 0.0226000007242)
  Closest to the Greenwich meridian is LDE (longitude: -0.006438999902457)
  Highest elevation is DCY (14,472 feet)
  Lowest elevation is GUW (-72 feet)
  Maximum airport node degree (routes in and out) is 620 (FRA)
  Region with the most airports: US-AK (150)
  Country with the most airports: United States (586)
  Continent with the most airports: North America (989)
  Average degree (airport nodes) is 28.902
  Average degree (all nodes) is 28.891
----

Here are the Top 15 airports sorted by overall number of routes (in and out). In
graph terminology this is often called the degree of the vertex or just 
'vertex degree'.

[source,text]
----
    POS  ID   CODE  TOTAL     DETAILS

     1	  52   FRA  (620)  out:310 in:310
     2	 161   IST  (618)  out:309 in:309
     3	  51   CDG  (587)  out:293 in:294
     4	  70   AMS  (568)  out:283 in:285
     5	  80   MUC  (541)  out:270 in:271
     6	  18   ORD  (529)  out:265 in:264
     7	   8   DFW  (506)  out:253 in:253
     8	  64   PEK  (497)  out:248 in:249
     9	  58   DXB  (496)  out:248 in:248
    10	   1   ATL  (484)  out:242 in:242
    11	 102   DME  (465)  out:232 in:233
    12	  50   LGW  (464)  out:232 in:232
    13	  49   LHR  (442)  out:221 in:221
    14	  31   DEN  (434)  out:217 in:217
    15	  84   MAN  (431)  out:216 in:215
----

Throughout this book you will find Gremlin queries that can be used to generate many
of these statistics.

NOTE: The source code in this section comes from the 'graph-stats.groovy' sample
located in: https://github.com/krlawrence/graph/tree/main/sample-code/groovy.

[[airrouteupdates]]
==== Updated versions of the air route data

Over time the air-routes graph has evolved, and several versions of the data files 
are included with the book sources. The examples in this book assume that you are 
using the 1.0 version of the air-routes data. Unless a section explicitly asks you to
load a different file, you should use that default version when following along.

NOTE: Even though no further releases of the dataset are expected, the GitHub
repository still maintains a "latest" version. It is also 1.0. You can download it
from
https://github.com/krlawrence/graph/blob/main/sample-data/air-routes-latest.graphml

[[ld]]
=== Loading the air-routes graph using the Gremlin Console

The easiest way to load the air routes graph is to use the prepackaged version of the
dataset that comes with TinkerGraph. We can demonstrate this in the Gremlin Console
as follows.

[source,groovy]
----
graph = TinkerFactory.createAirRoutes()
g = traversal().with(graph)
----

NOTE: You must be using TinkerPop 3.8.0 or later to make use of this shortcut.

That's it! The graph is now loaded with the 1.0 version of the dataset. These two
lines simplify a longer set of manual steps which we will go through as an
explanatory next step so that you can understand the details.

The following code loads the air routes graph using the console by putting it into a
file and using ':load' to load and run it or by entering each line into the console
manually. These commands will setup the console environment, create a TinkerGraph 
and load the `air-routes.graphml` file into it. Some extra console features are also
enabled.

These commands create an in-memory TinkerGraph which will use LONG values for the
vertex, edge and vertex property IDs. As part of loading a graph we need to setup
a 'graph traversal source' object called 'g' which we will then refer to in our
subsequent queries of the graph. We discussed the ':set max-iteration' command in
<<consolepreferences>>.

If you are using a different graph environment and GraphML import is supported, you
can still load the `air-routes.graphml` file by following the instructions specific
to that system. Once loaded, the queries below should still work either unchanged or
with minor modifications.

NOTE: There is a file called `load-air-routes.groovy`, that contains the commands
shown below, available in the `/sample-data` directory.
https://github.com/krlawrence/graph/tree/main/sample-data

.load-air-routes.groovy
[source,groovy]
----
conf = new BaseConfiguration()
conf.setProperty("gremlin.tinkergraph.vertexIdManager","LONG")
conf.setProperty("gremlin.tinkergraph.edgeIdManager","LONG")
conf.setProperty("gremlin.tinkergraph.vertexPropertyIdManager","LONG")
graph = TinkerGraph.open(conf)
g = traversal().with(graph)

// Change the path below to point to wherever you put the graphml file
g.io('/mydata/air-routes.graphml').read()
:set max-iteration 1000
----

NOTE: Setting the ID manager as shown above is important. If you do not do this, by
default, when using TinkerGraph, ID values will have to be specified as strings such
as '"3"' rather than just the numeral '3'.

[source,groovy]
----
:load load-air-routes.groovy
----

TIP: As a best practice, you should use the full path to the location where the
GraphML file resides if at all possible to make sure that the GraphML reading code
can find it.

Once you have the console up and running and have the graph loaded, if you feel like
it you can cut-and-paste queries from this book directly into it to see them run.

Once the 'air-routes' graph is loaded, you can enter the following command and you
will get back information about the graph. In the case of a TinkerGraph you will get 
back a useful message telling you how many vertices and edges the graph contains. 
Note that the contents of this message will vary from one graph system to another and
should not be relied upon as a way to keep track of vertex and edge counts. We will 
look at some other ways of counting things a bit later.

[source,groovy]
----
// Tell me something about my graph
graph.toString()
----

When using TinkerGraph, the message you get back will look something like this.

[source,groovy]
----
tinkergraph[vertices:3749 edges:57645]
----

[[off]]
=== Turning off some of the Gremlin Console's output

Sometimes, especially when assigning a result to a variable and you are not
interested in seeing all the steps that Gremlin took to get there, the Gremlin
console displays more output than is desirable. An easy way to prevent this is to
just add an empty list ";[]" to the end of your query as follows.

[source,groovy]
----
a=g.V().has('code','AUS').out().toList();[]
----

[[indexschema]]
=== A word about indexes and schemas

Before going much further, it is worth briefly mentioning indexes and schemas. For 
now, you will be working with TinkerGraph, which does not enforce a formal schema and
offers only simple in-memory indexing. That is sufficient for the examples in this 
chapter, but later chapters will return to these topics in more detail and show how 
indexes and schemas can have a big impact on query performance and data quality.

As most of the examples in this book are intended to work just fine with only a basic
TinkerGraph the subject of indexes is not covered in detail until Chapter 6
"<<beyond>>" . However, as TinkerGraph does have some indexing capability, we have
also included some discussion of it in the "<<tinkerindex>>" section. You should
always refer to the specific documentation for the graph system you are using to 
decide what you need to do about creating an index and schema for your graph. 

TIP: In general for any graph database, regardless of whether it is optional or not,
use of an index should be considered a best practice.

When working with TinkerGraph there is no need to define a schema ahead of time. The
types of each property are derived at creation time. This is a really convenient 
feature and allows us to get productive and do some experimenting really quickly.

NOTE: In production systems, especially those where the graphs are large, the task of
creating and managing indexes may include use of additional software components; such
as Apache Solr or Elasticsearch.


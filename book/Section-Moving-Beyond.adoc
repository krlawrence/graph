// vim: set tw=85 cc=+1 wrap spell redrawtime=20000:
[[beyond]]
MOVING BEYOND THE GREMLIN CONSOLE
---------------------------------

The focus of this book so far has been to teach the Gremlin query language, using the
Gremlin Console and TinkerGraph as our learning environment. This is indeed a great
way to learn, and that environment can be setup quickly, as we have seen, on a single
laptop, or desktop, computer. Even as you move towards more sophisticated
environments, keeping the Gremlin Console nearby is recommended as an easy way to
experiment with new ideas.

As we start to think about using graphs to solve problems in a production
environment, we need some additional tools. We have to consider things such as
programming language interfaces, persistent storage, making graphs available using
servers, and more advanced indexing. Those topics are the focus of this chapter, and
the two that follow. Hopefully this will whet your appetite for moving beyond the
Gremlin Console, and into the world of graph application programming and graph system
deployment! 

In this chapter we start the journey by introducing ways to access TinkerGraph
directly, embedded with your application code, from programming languages such as
Java and Groovy. Later, we introduce ways to use these same programming
languages, and others, to connect to a Gremlin Server and other remotely hosted graph
databases. First, let's take a look at the Apache TinkerPop Java API. 

[[javatinker]]
Working with TinkerGraph from a Java Application
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

So far in this book we have looked at many ways of working with a TinkerGraph from
within the Gremlin Console. As you start to create more sophisticated applications,
you will find that the Gremlin Console is just one of the tools to keep in your
toolbox. It is very likely, if not certain, that you will want to write standalone
applications that can work with graph data. There are a number of different
programming language bindings currently available for TinkerPop. One of the most
widely used is the Java API. Apache TinkerPop itself is coded mostly in Java.

NOTE: You will find several Java samples at the GitHub repository associated with
this book. https://github.com/krlawrence/graph

When building a commercial application, you may need capabilities such as high
availability and durability, and would not use TinkerGraph as your graph database in
those cases. There are however, places where TinkerGraph may be just what you need.
One example might be doing analysis on a static graph that can fit into memory on
your laptop. The 'air-routes' graph is a good example of such a graph. You might also
have a large graph stored on a server, but just need to export part of it to do local
analysis. As a first step towards writing standalone applications that use different
graph database implementations, lets look at a few examples of how you can create a
Java application that uses Gremlin and TinkerGraph.

[[tpinterfaces]]
The Apache TinkerPop interfaces and classes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There are a number of Java interfaces and classes, defined by the Apache TinkerPop
project, that you will want to become familiar with. The most recent JavaDoc format
API documentation is always available at
http://tinkerpop.apache.org/javadocs/current/full

The TinkerPop JavaDoc is a bit lacking in terms of English prose but is still a
useful source of reference information when it comes to methods, parameters and
types. Once you have coded up a couple of test programs and got them running, you
should find it gets easier to make progress faster. To that end, we recommend you
take a look at the sample code included with the book.

When using the Gremlin Console, your environment is pre-configured for you so, for
the most pat, you do not have to import any classes or interfaces. However, as soon
as you move to the domain of the standalone Java application you will need to start
importing the classes that your application needs. You will probably discover a few
other things that the Gremlin Console was doing on your behalf.

By way of a reasonable start, some of the most common imports needed by a Java
application working with Gremlin, are listed below below. As you add more
capabilities to your application you will of course need to add the appropriate
import statements.

Take particular note of the rather odd import of the class called +++"__"+++
(underscore underscore) on the second line. This is required to enable calling
methods such as 'in' and 'out' in a traversal where there is no prior step
to "dot" attach them to (such as inside of a 'repeat' step). If you prefer you
can statically import the +++"__"+++ class which will make explicit use of
+++".__"+++ in your code unnecessary except where you are faced with reserved
word conflicts as discussed in prior chapters.

[source,java]
----
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__;
import org.apache.tinkerpop.gremlin.process.traversal.Path;
import org.apache.tinkerpop.gremlin.process.traversal.*;
import org.apache.tinkerpop.gremlin.structure.Edge;
import org.apache.tinkerpop.gremlin.structure.Vertex;
import org.apache.tinkerpop.gremlin.structure.io.IoCore;
import org.apache.tinkerpop.gremlin.tinkergraph.structure.*;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.Set;
----

[[javatp1]]
Writing our first TinkerPop Java program
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now that we have some imports in place, we can start to craft the basic outline of a
Java application. The code below defines a class called 'TinkerGraphTest', and 
defines a 'main' method that creates an in memory TinkerGraph and loads the air 
routes GraphML data. Note that as we are now going to be running as a Java program we
have to catch exceptions. This is another thing that is hidden from you when you are 
working within the Gremlin Console.

NOTE: The source code in this section comes from the 'TinkerGraphTest.java' sample
located at https://github.com/krlawrence/graph/tree/main/sample-code/java.

Lastly in this initial class definition we create a 'GraphTraversalSource' and we
make a Gremlin query to get the property 'valueMap' for the Austin airport vertex and
print it. The 'toString' method provided by the 'Map' should give us some useful
output. Take note of the call to 'next'. This terminates the graph traversal and
causes the result to be returned. If this call is left off you will not get back what
you were expecting!

[source,java]
----
public class TinkerGraphTest
{
  public static void main(String[] args)
  {
    TinkerGraph graph = TinkerGraph.open();
    GraphTraversalSource g = traversal().with(graph);

    try
    {
      g.io("./air-routes.graphml").read().iterate();
    }
    catch( IOException e )
    {
      System.out.println("File not found");
      System.exit(1);
    }

    Map<String,?> aus = g.V().has("code","AUS").valueMap().next();
    System.out.println(aus);
  }
}
----

[[javacompile]]
Compiling our code
^^^^^^^^^^^^^^^^^^

Before we can test our program we of course need to compile it. The easiest way to do
this while experimenting is to setup the Java 'classpath' to include the TinkerPop 
JAR files. Once you get into writing bigger solutions you will most likely be using a
tool like Apache Maven to control your build. For the purpose of our experiments
here, simple use of the 'classpath' will suffice.

The following lines of Bash shell script will setup what you need to both build and
run our small test program. Note that the 'GREMLIN' variable should be set to point
to the root directory of wherever your TinkerPop JAR files are. Later when we start
using JanusGraph you will see that rather than TinkerGraph we will need to adjust
these settings to point to the JanusGraph JAR files.

----
# Root directory for Gremlin Console install
GREMLIN=...

# Path to Gremlin core JARs
LIBPATH=$GREMLIN/lib/*

# Path to TinkerGraph JARs
EXTPATH=$GREMLIN/ext/*

#Path to additional JARs
ADDL=$GREMLIN/ext/tinkergraph-gremlin/lib/*

# Classpath
export CP=$CLASSPATH:$LIBPATH:$EXTPATH:$ADDL


# Compile
javac -cp $CP TinkerGraphTest.java
----

Assuming everything we have coded so far compiled OK, then we can run it using the
same 'classpath' that we created previously.

----
# Run
java -cp $CP TinkerGraphTest
----

The output we get back should look something like the following. If it does, take 30
seconds to celebrate as you have just successfully built and run your first TinkerPop
aware Java app!

[source,java]
----
{country=[US], code=[AUS], longest=[12250], city=[Austin], elev=[542], icao=[KAUS], lon=[-97.6698989868164], type=[airport], region=[US-TX], runways=[2], lat=[30.1944999694824], desc=[Austin Bergstrom International Airport]}
----

[[javaadd]]
Adding to our Java program
^^^^^^^^^^^^^^^^^^^^^^^^^^

Now that we have a basic skeleton application that compiles and runs, we can start to
add more experiments to it. If we add the two lines below we can extract the city
name from the value map that we just generated. From now on as we add to our program
we are just going to show the lines that we add and the additional output that those
new lines will generate.

[source,java]
----
List city = (List)(aus.get("city"));
System.out.println("The AUS airport is in " + city.get(0));
----

So when we compile and run again we should now see this additional line of output.

[source,console]
----
The AUS airport is in Austin
----

If we wanted to nicely print out all of the values returned in our value map we could
do it as follows.

[source,java]
----
aus.forEach( (k,v) -> System.out.println("Key: " + k + ": Value: " + v));
----

Which will generate this output.

[source,java]
----
Key: country: Value: [US]
Key: code: Value: [AUS]
Key: longest: Value: [12250]
Key: city: Value: [Austin]
Key: elev: Value: [542]
Key: icao: Value: [KAUS]
Key: lon: Value: [-97.6698989868164]
Key: type: Value: [airport]
Key: region: Value: [US-TX]
Key: runways: Value: [2]
Key: lat: Value: [30.1944999694824]
Key: desc: Value: [Austin Bergstrom International Airport]
----

So we now know one way to get the property values from a vertex and manipulate them.
Let's now add something a bit more interesting to our program. The following two
lines count the number of airports you can fly to non stop starting at Dallas Fort 
Worth (DFW) and print out that result for us.

[source,java]
----
Long n = g.V().has("code","DFW").out().count().next();
System.out.println("There are " + n + " routes from Dallas");
----

[source,console]
----
There are 221 routes from Dallas
----

Let's now add some code to retrieve the airport IATA codes of these 221 airports that 
we can fly to non stop from DFW. Note that this time we ended our query with a call 
to the 'toList' method. This will terminate the traversal, and as the name implies,
return the results to us in a list. An 'order' step is used in the traversal so that
we get the airport codes back in ascending order.

[source,java]
----
List fromDfw = g.V().has("code","DFW").out().
                     order().by("code").values("code").toList();

System.out.println(fromDfw);
----

The new output that we get back should look like this.

[source,java]
----
[ABI, ABQ, ACT, AEX, AGU, AMA, AMS, ANC, ASE, ATL, AUH, AUS, BDL, BHM, BIL, BIS, BJX, BKG, BMI, BNA, BOG, BOI, BOS, BPT, BRO, BTR, BWI, BZE, BZN, CAE, CCS, CDG, CHA, CHS, CID, CLE, CLL, CLT, CMH, CMI, CNM, COS, COU, CRP, CUN, CUU, CVG, CVN, CZM, DAY, DCA, DEN, DOH, DRO, DSM, DTW, DUS, DXB, EGE, ELP, EVV, EWR, EZE, FAR, FAT, FCO, FLL, FRA, FSD, FSM, FWA, GCK, GCM, GDL, GEG, GGG, GIG, GJT, GLH, GPT, GRI, GRK, GRR, GRU, GSO, GSP, GUA, GUC, HDN, HKG, HNL, HOU, HSV, IAD, IAH, ICN, ICT, IND, JAC, JAN, JAX, JFK, JLN, KOA, LAS, LAW, LAX, LBB, LCH, LEX, LFT, LGA, LHR, LIM, LIR, LIT, LRD, MAD, MAF, MBJ, MCI, MCO, MEI, MEM, MEX, MFE, MGA, MGM, MHK, MIA, MID, MKE, MLI, MLM, MLU, MOB, MSN, MSP, MSY, MTJ, MTY, MYR, MZT, NAS, NRT, OAK, OGG, OKC, OMA, ONT, ORD, ORF, PBC, PBI, PDX, PEK, PHL, PHX, PIA, PIB, PIT, PLS, PNS, PSP, PTY, PUJ, PVG, PVR, QRO, RAP, RDU, RIC, RNO, ROW, RSW, RTB, SAF, SAL, SAN, SAT, SAV, SBA, SCL, SDF, SEA, SFO, SGF, SHV, SJC, SJD, SJO, SJT, SJU, SLC, SLP, SMF, SNA, SPI, SPS, STL, SUX, SWO, SYD, TLH, TPA, TRC, TUL, TUS, TVC, TXK, TYR, TYS, UIO, VPS, XNA, YEG, YUL, YVR, YYC, YYZ, ZCL]
----

The next lines will find all routes from London Heathrow to any airport in the United
States. A list of paths will be returned where each path contains the airport codes
and the distance between them.

[source,java]
----
List <Path> lhrToUsa = g.V().has("code","LHR").outE().inV().
                             has("country","US").
                             path().by("code").by("dist").toList();

lhrToUsa.forEach((k) -> System.out.println(k));
----

The output should look like this. We arranged the results in columns to aid
readability.

[source,java]
----
[LHR, 4896, PDX]     [LHR, 4820, IAH]    [LHR, 3665, IAD]
[LHR, 3980, CLT]     [LHR, 4414, MIA]    [LHR, 3860, RDU]
[LHR, 3254, BOS]     [LHR, 4001, MSP]    [LHR, 4783, SEA]
[LHR, 3622, BWI]     [LHR, 3440, JFK]    [LHR, 3939, ORD]
[LHR, 4198, ATL]     [LHR, 5439, LAX]    [LHR, 5255, PHX]
[LHR, 4901, AUS]     [LHR, 5469, SAN]    [LHR, 5350, SFO]
[LHR, 4736, DFW]     [LHR, 4850, SLC]    [LHR, 3753, DTW]
[LHR, 5352, SJC]     [LHR, 3453, EWR]    [LHR, 4655, DEN]
[LHR, 4616, MSY]     [LHR, 5213, LAS]    [LHR, 3533, PHL]
----

The final part of our first Java program shows how to perform a simple 'repeat'
operation. The code below will look for any cities in the UK that you can get to from
Austin with one stop on the way. A key thing to note here is that we have to prefix
the call to 'out' with the strangely named class +++"__."+++ that we mentioned at
the start of this discussion of using Java with TinkerPop. If you do not include the
+++"__."+++ prefix you will get a compilation error as the compiler does not know
where the 'out' step is from.

[source,java]
----
List <Object> eng =
      g.V().has("code","AUS").repeat(__.out()).times(2).
            has("region","GB-ENG").values("city").dedup().toList();

System.out.println("\nPlaces in England I can get to with one stop from AUS.\n");
eng.forEach( (p) -> System.out.print(p + " "));
----

The code we just added should generate output that looks like this.

[source,console]
----
Places in England I can get to with one stop from AUS.

Birmingham Bristol London Manchester Leeds Newcastle
----

[[javastatics]]
Important Classes and Enums to be aware of
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When you are using the Gremlin Console, as we have already mentioned, a few things
are done for you that you need to take care of yourself when writing standalone Java
code. A key area that we have found that people making the jump from the console to
Java find confusing is figuring out which Classes and Enums have been statically
imported "behind the scenes" and how to access those same capabilities from Java. You
should also bookmark the TinkerPop javadoc pages as you can find more detail on all
of the classes and enums covered below there. The latest javadoc is always available
at http://tinkerpop.apache.org/javadocs/current/full/

NOTE: The source code in this section comes from the 'TestImports.java' sample
located at https://github.com/krlawrence/graph/tree/main/sample-code/java and
demonstrates these constructs being used.

The tables below show some commonly used Gremlin keywords in the left column. The
second column shows how you would reference those same keywords explicitly from a
Java program. The third column shows an example of the context in which they might be
used in a Java program. You may chose to statically import some of these classes into
your code. We prefer to use the explicit prefix but that is a matter of personal
preference in many cases. There is a table of all the available predicates in the
"<<tranges>>" section. For the special +++".__"+++ class we have just shown a few
examples. In general you use this prefix when you have nothing prior in the query
that you can "dot chain" to.

If you need to specify how a property value should be treated when added to a vertex
you can use one of the keywords defined as part of the 'Cardinality' enum
which is part of the 'VertexProperty' interface.

.Cardinality
[cols="1,1,3"]
|==============================================================================
|single  | Cardinality.local | property(Cardinality.single,"mykey","ABC")
|list    | Cardinality.list  | property(Cardinality.list,"mykey","ABC")
|set     | Cardinality.set   | property(Cardinality.set,"mykey","ABC")
|==============================================================================

When local scope needs to be specified as a parameter or sort order direction needs
to be specified the statics defined in the  'Scope' and 'Order' Enums can be used.

.Scope and ordering
[cols="1,1,3"]
|==============================================================================
|local   | Scope.local    | order(Scope.local)
|global  | Scope.global   | order(Scope.global)
|desc    | Order.desc     | order().by(Order.desc)
|asc     | Order.asc      | order().by(Order.asc)
|shuffle | Order.shuffle  | order().by(Order.shuffle)
|==============================================================================

If you need to access the keys or values from a map data structure you can use the
statics defined in the 'Column' enum.

.Keys and values
[cols="1,1,3"]
|==============================================================================
|keys    | Column.keys    | order().by(Column.keys)
|values  | Column.values  | order().by(Column.values)
|==============================================================================

When accessing the 'id' and 'label' values from a 'valueMap' you need to use the
statics defined in the 'T' Enum. The same is true if you want to access the keys and
values from a set of properties.

.Label and id
[cols="1,1,3"]
|==============================================================================
|label   | T.label        | valueMap(true).next().get(T.label)
|id      | T.id           | valueMap(true).next().get(T.id)
|key     | T.key          | properties().order().by(T.key)
|value   | T.value        | properties().order().by(T.value)
|==============================================================================

When there is no previous step to "dot chain" to then we can use the +++".__"+++
class as our prefix. If you look at the javadoc for the class you will see it defines
static methods that we can use to call Gremlin functionality in cases like the ones
shown below.

.Anonymous references
[cols="1,1,3"]
|==============================================================================
|out     | +++__+++.out         | repeat(+++__+++.out())
|in      | +++__+++.in          | order().by(+++__+++.in("contains"))
|constant| +++__+++.constant    | union(+++__+++.constant("b"),+++__+++.constant("a"))
|==============================================================================

Whenever we need to use a predicate to perform a test, we can use the static methods
defined in the 'P' class. Not all the methods defined are shown below.

.Predicates
[cols="1,1,3"]
|==============================================================================
|gt      | P.gt           | has("runways",P.gt(3))
|gte     | P.gte          | has("runways",P.gte(5))
|lt      | P.lt           | has("runways",P.lt(2))
|lte     | P.lte          | has("runways",P.lte(2))
|eq      | P.eq           | has("city",P.eq("Dallas"))
|neq     | P.neq          | has("city",P.neq("Dallas"))
|within  | P.within       | has("city",P.within("Dallas","Austin"))
|without | P.without      | has("city",P.without("Dallas"))
|inside  | P.inside       | has("runways",P.inside(3,5))
|outside | P.outside      | has("runways",P.outside(2,5))
|between | P.between      | has("runways",P.between(2,5))
|==============================================================================

The 'TextP' class exposes text search based predicates.

.Text Predicates
[cols="1,1,3"]
|==============================================================================
|startingWith    | TextP.startingWith     | has("city",TextP.startingWith("Dal"))
|endingWith      | TextP.endingWith       | has("city",TextP.endingWith("as"))
|containing      | TextP.containing       | has("city",TextP.containing("all"))
|notStartingWith | TextP.notStartingWith  | has("city",TextP.notStartingWith("Dal"))
|notEndingWith   | TextP.notEndingWith    | has("city",TextP.notEndingWith("as"))
|notContaining   | TextP.notContaining    | has("city",TextP.notContaining("all"))
|regex           | TextP.regex            | has("city",TextP.regex("D.*"))
|notRegex        | TextP.notRegex         | has("city",TextP.notRegex("D.*"))
|==============================================================================

If a traversal path has multiple values associated with a single label, such as '"x"'
then you can use the 'first', 'last' , 'all' and 'mixed' statics that are defined as
part of the 'Pop' Enum. As the name suggest, 'first' returns the first item in a
collection. Specifying 'last' returns the last item and 'all' returns all of the
items in a collection. Specifying 'mixed' will return a 'List' if the collection has
more than one item. Otherwise an 'Object' will be returned.

.First, last, all and mixed
[cols="1,1,3"]
|==============================================================================
|first   | Pop.first      | select(Pop.first,"x")
|last    | Pop.last       | select(Pop.last,"x")
|all     | Pop.all        | select(Pop.all,"x")
|mixed   | Pop.mixed      | select(Pop.mixed,"x")
|==============================================================================

When working with a 'sack' the operators like 'sum' and 'assign' are defined in the
'Operator' Enum.

.Operators
[cols="1,1,3"]
|==============================================================================
|sum     | Operator.sum   | sack(Operator.sum)
|minus   | Operator.minus | sack(Operator.minus)
|mult    | Operator.mult  | sack(Operator.mult)
|div     | Operator.div   | sack(Operator.div)
|assign  | Operator.assign| sack(Operator.assign).by(constant(0))
|min     | Operator.min   | sack(Operator.min)
|max     | Operator.max   | sack(Operator.max)
|addAll  | Operator.addAll| sack(Operator.addAll)
|and     | Operator.and   | sack(Operator.and)
|or      | Operator.or    | sack(Operator.or)
|==============================================================================

The 'Direction' Enum defines constants that are used in association with edge
direction. Note that 'from' and 'to' are friendly aliases of 'OUT' and 'IN' that
can help make Gremlin read more fluidly at times.

.Direction
[cols="1,1,3"]
|==============================================================================
|IN      | Direction.IN   | V().to(Direction.IN)
|OUT     | Direction.OUT  | V().to(Direction.OUT)
|BOTH    | Direction.BOTH | V().to(Direction.BOTH)
|from    | Direction.from | mergeE([(Direction.from):1, ...])
|to      | Direction.to   | mergeE([(Direction.to):2, ...])
|==============================================================================

The 'Pick' Enum defines constants that are used in association with the 'branch',
`choose` and `option` steps.

.Pick
[cols="1,1,3"]
|==============================================================================
|none    | Pick.none      | option(none,constant('no match'))
|any     | Pick.any       | option(any,constant('any picked'))
|==============================================================================

The 'Merge' Enum has constants that are associated to the `mergeV` and `mergeE`
steps. 'onCreate' and 'onMatch' relate to the events triggered by these steps and
'outV' and 'inV' are used to specify a way to late-bind in and out vertices for these
operations.

.Merge
[cols="1,1,3"]
|==============================================================================
|onCreate    | Merge.onCreate | option(Merge.onCreate,[name:'alice'])
|onMatch     | Merge.onMatch  | option(Merge.onMatch,[name:'alice'])
|outV        | Merge.outV     | option(Merge.outV,select('v'))
|inV         | Merge.inV      | option(Merge.inV,select('v'))
|==============================================================================

The 'DT' Enum provides constants representing units of time for the 'dateAdd' step.

.Dates
 [cols="1,1,3"]
 |==============================================================================
 |second    | Date.second  | dateAdd(Date.second, 10)
 |minute    | Date.minute  | dateAdd(Date.second, 10)
 |hour      | Date.hour    | dateAdd(Date.second, 10)
 |day       | Date.day     | dateAdd(Date.second, 10)
 |==============================================================================

Another useful tip, that was shared on the Gremlin Users mailing list, is that you
can ask the Gremlin Console to show you a list of everything that has been imported
on your behalf "behind the scenes" using the command ':show imports'. What might
typically be returned is shown below and may change from version to version.

Here is the list of imports that the Gremlin Console has setup for us quietly behind
the scenes when we started it. Take particular note of the ones that are 'static'
imports as those are the ones that contain the definitions we discussed above.

[source,groovy]
----
gremlin> :show imports
Custom imports:
  org.apache.tinkerpop.gremlin.structure.*
  org.apache.tinkerpop.gremlin.structure.util.*
  org.apache.tinkerpop.gremlin.structure.util.reference.*
  org.apache.tinkerpop.gremlin.process.traversal.*
  org.apache.tinkerpop.gremlin.process.traversal.step.*
  org.apache.tinkerpop.gremlin.process.traversal.step.util.*
  org.apache.tinkerpop.gremlin.process.remote.*
  org.apache.tinkerpop.gremlin.structure.util.empty.*
  org.apache.tinkerpop.gremlin.structure.io.*
  org.apache.tinkerpop.gremlin.structure.io.graphml.*
  org.apache.tinkerpop.gremlin.structure.io.graphson.*
  org.apache.tinkerpop.gremlin.structure.io.gryo.*
  org.apache.commons.configuration.*
  org.apache.tinkerpop.gremlin.process.traversal.strategy.decoration.*
  org.apache.tinkerpop.gremlin.process.traversal.strategy.optimization.*
  org.apache.tinkerpop.gremlin.process.traversal.strategy.finalization.*
  org.apache.tinkerpop.gremlin.process.traversal.strategy.verification.*
  org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.*
  org.apache.tinkerpop.gremlin.process.traversal.util.*
  org.apache.tinkerpop.gremlin.process.computer.*
  org.apache.tinkerpop.gremlin.process.computer.traversal.step.map.*
  org.apache.tinkerpop.gremlin.process.computer.clustering.connected.*
  org.apache.tinkerpop.gremlin.process.computer.clone.*
  org.apache.tinkerpop.gremlin.process.computer.bulkdumping.*
  org.apache.tinkerpop.gremlin.process.computer.bulkloading.*
  org.apache.tinkerpop.gremlin.process.computer.clustering.peerpressure.*
  org.apache.tinkerpop.gremlin.process.computer.traversal.*
  org.apache.tinkerpop.gremlin.process.computer.ranking.pagerank.*
  org.apache.tinkerpop.gremlin.process.computer.search.path.*
  org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.optimization.*
  org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.decoration.*
  org.apache.tinkerpop.gremlin.util.*
  org.apache.tinkerpop.gremlin.util.iterator.*
  org.apache.tinkerpop.gremlin.util.function.*
  java.util.*
  java.sql.*
  static org.apache.tinkerpop.gremlin.structure.io.IoCore.*
  static org.apache.tinkerpop.gremlin.process.traversal.P.*
  static org.apache.tinkerpop.gremlin.process.traversal.AnonymousTraversalSource.*
  static org.apache.tinkerpop.gremlin.process.traversal.TextP.*
  static org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__.*
  static org.apache.tinkerpop.gremlin.process.computer.Computer.*
  static org.apache.tinkerpop.gremlin.util.TimeUtil.*
  static org.apache.tinkerpop.gremlin.util.function.Lambda.*
  static org.apache.tinkerpop.gremlin.process.traversal.SackFunctions.Barrier.*
  static org.apache.tinkerpop.gremlin.structure.VertexProperty.Cardinality.*
  static org.apache.tinkerpop.gremlin.structure.Column.*
  static org.apache.tinkerpop.gremlin.structure.Direction.*
  static org.apache.tinkerpop.gremlin.process.traversal.Operator.*
  static org.apache.tinkerpop.gremlin.process.traversal.Order.*
  static org.apache.tinkerpop.gremlin.process.traversal.Pop.*
  static org.apache.tinkerpop.gremlin.process.traversal.Scope.*
  static org.apache.tinkerpop.gremlin.structure.T.*
  static org.apache.tinkerpop.gremlin.process.traversal.step.TraversalOptionParent.Pick.*
  org.apache.tinkerpop.gremlin.driver.*
  org.apache.tinkerpop.gremlin.driver.exception.*
  org.apache.tinkerpop.gremlin.driver.message.*
  org.apache.tinkerpop.gremlin.driver.ser.*
  org.apache.tinkerpop.gremlin.driver.remote.*
  org.apache.tinkerpop.gremlin.tinkergraph.structure.*
  org.apache.tinkerpop.gremlin.tinkergraph.process.computer.*
----

As discussed earlier, you can always use the 'getClass' method or simply '.class'
while using the Gremlin Console to, in many cases, find out where something is
defined. As we saw in the examples earlier in this section, lot of the keywords such
as  'values', 'id' and 'local' are defined as Enums so you can use 'getClass' on them
directly. A few examples are shown below.

[source,groovy]
----
gremlin> label.getClass()
==>class org.apache.tinkerpop.gremlin.structure.T$1
gremlin> key.getClass()
==>class org.apache.tinkerpop.gremlin.structure.T$3
gremlin> keys.getClass()
==>class org.apache.tinkerpop.gremlin.structure.Column$1
gremlin> values.getClass()
==>class org.apache.tinkerpop.gremlin.structure.Column$2
gremlin> local.getClass()
==>class org.apache.tinkerpop.gremlin.process.traversal.Scope
gremlin> Order.class
==>class org.apache.tinkerpop.gremlin.process.traversal.Order
gremlin> Column.class
==>class org.apache.tinkerpop.gremlin.structure.Column
----

If you compare this output to the tables above you can see that we have been able to
verify that, for example, that 'label' and 'key' are defined in the 'T' Enum. We can
also see that 'keys' and 'values' are indeed defined in the 'Column' Enum. Lastly, we
can see that 'local' is, as we expected, defined in the 'Scope' Enum.

[[javapredicates]]
Using Gremlin predicates in a Java application
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As discussed in the previous section, when you use a Gremlin predicate such as 'eq'
or 'neq' from a Java program you need to prefix it with a '"P."' which is a reference
to the TinkerPop class of the same name where a set of static methods, representing
the Gremlin predicates, are defined.

NOTE: The source code in this section comes from the 'GraphRegion.java' sample
located at https://github.com/krlawrence/graph/tree/main/sample-code/java.

Take a look at the code below. A method called 'findByRegion' is defined that takes
a String representing a three character airport IATA code as input. The method then
uses a Gremlin query to figure out which geographical region the specified airport is
in and then returns all airports also in that region. Note the use of 'P.eq' as part
of the 'where' step. This is another case of where, because we are not running inside
the Gremlin console, we have to more precisely specify things.

[source,java]
----
// Find all airports in the region of the specified airport
public void findByRegion(String iata)
{
  System.out.println("\nRegion code lookup for " + iata );

  List<List<Object>> list =
  g.V().has("code",iata).values("region").as("r").
    V().hasLabel("airport").as("a").values("region").
        where(P.eq("r")).by().
        local(__.select("a").values("city","code","region").fold()).toList();

  for(List t : list)
  {
    System.out.println(t);
  }
}
----

If we were to call the 'findByRegion' method, passing in a parameter of 'DEN',
representing the airport in Denver Colorado, the following output should be returned.

[source,console]
----
Region code lookup for DEN
[COS, Colorado Springs, US-CO]
[DEN, Denver, US-CO]
[DRO, Durango, US-CO]
[GJT, Grand Junction, US-CO]
[EGE, Eagle, US-CO]
[HDN, Hayden, US-CO]
[APA, Denver, US-CO]
[TEX, Telluride, US-CO]
[ASE, Aspen, US-CO]
[ALS, Alamosa, US-CO]
[CEZ, Cortez, US-CO]
[GUC, Gunnison, US-CO]
[MTJ, Montrose, US-CO]
[PUB, Pueblo, US-CO]
----


[[javacheck]]
Checking to see if a query returned a result
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is often important to know if a query returned a result before trying to reference
it to avoid those pesky Java Null Pointer Exceptions. Without worrying about Java for
a second consider the query below purely from a Gremlin point of view.

[source,groovy]
----
g.V().has("code","AUS").outE().as("edge").inV().has("code","SYD").
                        select("edge").by("dist")
----

The query finds the Austin (AUS) airport and then looks for an outgoing edge
connecting Austin with Sydney (SYD) and then returns the distance value from that
edge. The problem here is that there is no direct route between Austin and Sydney and
therefore no edge to retrieve the distance from. In other words, this query returns 
no result. Now, within the Gremlin Console this is not a problem as we just get 
nothing back and life goes on. However, take a look at the code below which is a 
first attempt at moving the query into Java code.


[source,java]
----
Long result =
      g.V().has("code","AUS").outE().as("edge").inV().has("code","SYD").
            select("edge").by("dist").next();
----

On the surface, this looks fine. However, were we to execute this code we would get a
Null Pointer Exception as when we try to call 'next' there is no result to process as
there is no edge between Austin and Sydney and hence no distance value to process.

NOTE: The source code in this section comes from the 'GraphSearch2.java' sample
located at https://github.com/krlawrence/graph/tree/main/sample-code/java.

So we need a way to check to see if we go a valid result. One such way is to store
the result of the query into a list. Then, worst case, if no results are found, we
will get an empty list back. So, we can rewrite the query as follows.

[source,java]
----
List result =
      g.V().has("code","AUS").outE().as("edge").inV().has("code","SYD").
            select("edge").by("dist").toList();
----

Now that the result is in a list we can safely check to see if we got any results.

[source,java]
----
if (result.isEmpty())
{
  System.out.println("No results were found");
}
else
{
  System.out.println("The distance is " + result.get(0));
}
----


If we wanted a "pure Gremlin" solution, without using a List and without doing some
post processing, one way we could do it is to use the 'coalesce' step and return a
special constant value, in this case minus one, to indicate that there were no
results found.

[source,java]
----
Integer d = (Integer)
    g.V().has("code","AUS").outE().as("edge").inV().has("code","SYD").
          select("edge").by("dist").fold().
          coalesce(__.unfold(),__.constant(-1)).next();
----

If the route exists the distance will be found and returned, otherwise a value of
'"-1"' will be returned. This is really using the same concept as the 'toList'
example except in this case we generate the list using the 'fold' step within the
query itself. The 'unfold' will return a result if the list is not null, otherwise
the constant value will be returned as 'coalesce' returns the first to yield a
result.

There are of course many other ways that you might come up with to solve this problem
but using lists often provides a fairly easy to use solution.

[[javacreate]]
Creating a new graph from a Java application
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The code below creates a new (empty) TinkerGraph instance, creates a graph traversal
source object and then uses a traversal to create a small graph.

NOTE: The source code in this section comes from the 'CreateGraph.java' sample
located at https://github.com/krlawrence/graph/tree/main/sample-code/java.

Note the call to 'iterate' at the end of the traversal. When running as a
standalone application this is necessary. This is another of those little things that
the Gremlin Console does for you without you realizing it that we have to remember to
do ourselves when not running inside the console.

[source,java]
----
// Create a new (empty) TinkerGraph
TinkerGraph graph = TinkerGraph.open() ;

// Create a Traversal source object
GraphTraversalSource g = traversal().with(graph);

// Add some nodes and vertices - Note the use of "iterate".
g.addV("airport").property("code","AUS").as("aus").
  addV("airport").property("code","DFW").as("dfw").
  addV("airport").property("code","LAX").as("lax").
  addV("airport").property("code","JFK").as("jfk").
  addV("airport").property("code","ATL").as("atl").
  addE("route").from("aus").to("dfw").
  addE("route").from("aus").to("atl").
  addE("route").from("atl").to("dfw").
  addE("route").from("atl").to("jfk").
  addE("route").from("dfw").to("jfk").
  addE("route").from("dfw").to("lax").
  addE("route").from("lax").to("jfk").
  addE("route").from("lax").to("aus").
  addE("route").from("lax").to("dfw").iterate();
----

Having created a new graph we can run some queries to make sure it looks correct.
Firstly, let's check that the vertices were created and look at the IDs that were
allocated to them. As with prior examples, a call to 'valueMap' with a parameter of
'true' will return what we need. What we will get back from this code is a list of
maps, with each map containing keys for the airport code, the vertex ID and the
vertex label.

[source,java]
----
List<Map<Object,Object>> vm = new ArrayList<Map<Object,Object>>() ;

vm = g.V().valueMap(true).toList();
----

Having got our list of maps back we can process them. Note that to get the 'id' and
'label' values from the map we had to prefix the key name with a '"T."'. This is
because while most of property keys are Strings, IDs and labels are a special case.
If you look at the TinkerPop documentation you will see that T is a Java Enum that
contains definitions for 'T.id', 'T.label', 'T.value' and 'T.key'. When working with
Gremlin in Java it is important to remember that we need to use the '"T."' prefix in
cases where when using the Gremlin Console we would not have to.

[source,java]
----
// Display the code property as well as the label and id.
for( Map m : vm)
{
  System.out.println(((List)(m.get("code"))).get(0) + " " +
                             m.get(T.id) + " " + m.get(T.label));
}
----

If all has gone well during graph creation, we should get back a list like the one
below that shows us the ID that has been given to each vertex.

[source,java]
----
AUS 0 airport
DFW 2 airport
LAX 4 airport
JFK 6 airport
ATL 8 airport
----

Finally, let's check that the edges were created correctly by displaying all of the
paths between vertices in our new graph.

[source,java]
----
// Display the routes in the graph we just created

List<Path> paths = new ArrayList<Path>();

paths = g.V().out().path().by("code").toList();

for (Path p : paths)
{
  System.out.println(p.toString());
}
----

Once again, if everything has worked as expected, here is what we should get back.

[source,java]
----
[AUS, DFW]
[AUS, ATL]
[DFW, JFK]
[DFW, LAX]
[LAX, JFK]
[LAX, AUS]
[LAX, DFW]
[ATL, DFW]
[ATL, JFK]
----

[[javasave]]
Saving a graph from a Java application
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Having created our new graph, we may want to save it. The code below shows how to
save the graph as either GraphSON (TinkerPop's JSON format) or as GraphML (XML). This
is another instance where we have to do a bit more work as we are running in a
standalone program and not inside the Gremlin Console. Our attempts to save our data
have to catch any exceptions that may occur. This code is also included as part of
the CreateGraph.java sample program.

[source,java]
----
// Save the graph we just created as GraphML (XML) or GraphSON (JSON)
try {
  // If you want to save the graph as GraphML uncomment the next line. Since this
  // is Java code it is important to include the iterate() terminal step to execute
  // the traversal
  g.io("mygraph.xml").write().iterate();

  // If you want to save the graph as JSON uncomment the next line
  //g.io("mygraph.json").write().iterate();
} catch (IOException ioe) {
  System.out.println("Graph failed to save");
}
----

It's worth adding that with TinkerGraph there is a second way to save your data that
allows it to happen a bit more automatically. If you configure your TinkerGraph at
startup to include a 'graphLocation' and 'graphFormat', TinkerGraph will 
automatically save the graph on a call to the 'close'. Earlier, the graph was created
with the following code:

[source,java]
----
// Create a new (empty) TinkerGraph
TinkerGraph graph = TinkerGraph.open();
----

The 'open' method has the option to accept a 'Configuration' object. In that 
configuration we would add those two settings.

[source,java]
----
// Create a new (empty) TinkerGraph with a configuration
Configuration conf = new BaseConfiguration();
conf.setProperty("gremlin.tinkergraph.graphLocation", "mygraph.xml");
conf.setProperty("gremlin.tinkergraph.graphLocation", "graphml");
TinkerGraph graph = TinkerGraph.open(configuration);

...

// call close() to save as GraphML to a file called mygraph.xml
try {
    graph.close();
} catch (Exception ex) {
  System.out.println("Graph failed to save");
}
----

NOTE: 'Configuration' refers to the Apache Configuration library.

[[groovyapp]]
Working with TinkerGraph from a Groovy application
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Earlier in this book, in the "<<grv>>" section we explored the ways that you can
use Groovy code within the Gremlin Console. However, we have not yet looked at how
you can use a standalone Groovy application to work with a TinkerGraph.

NOTE: You will find several Groovy samples at the GitHub repository associated with
this book. https://github.com/krlawrence/graph

In this section we will rewrite parts of the test application we coded in Java
earlier in Groovy. A lot of what was covered in the "<<javatinker>>" section is
equally relevant here and we have not duplicated that material. So even if you are
writing a Groovy application please also give that section a read.

NOTE: The source code in this section comes from the 'TinkerGraphTest.groovy' sample
located at https://github.com/krlawrence/graph/tree/main/sample-code/groovy.

It is assumed that you have downloaded and installed Groovy for your environment and
have set the PATH to point to wherever the Groovy binaries are located. Just as in
the Java example, the first thing we need to do is pull in via 'import' all of the
TinkerPop classes that our program will use.

[source,groovy]
----
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__
import org.apache.tinkerpop.gremlin.process.traversal.Path
import org.apache.tinkerpop.gremlin.process.traversal.*
import org.apache.tinkerpop.gremlin.structure.Edge
import org.apache.tinkerpop.gremlin.structure.Vertex
import org.apache.tinkerpop.gremlin.structure.io.IoCore
import org.apache.tinkerpop.gremlin.tinkergraph.structure.*
import org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph
import org.apache.tinkerpop.gremlin.util.Gremlin
import java.io.IOException
----

Having imported the classes we need, we can make a start on our application.
Initially we are just going to display the version of TinkerPop that we are using.

[source,groovy]
----
println "The Gremlin version is ${Gremlin.version()}"

def graph = TinkerGraph.open()
def g = traversal()
----

We are now ready to create a new TinkerGraph instance, 'GraphTraversalSource' named
"g" and try to load the air routes graph. We can do this in Groovy just like we did
in the Java example. Unlike Java, however, Groovy does not require you to catch
exceptions that may get thrown but as a best practice it is probably a good idea to
still do so when you need to take some specific action if an exception does happen.

[source,groovy]
----
println "Loading the air-routes graph...\n"

// Load the air-routes graph
try
{
  g.io("air-routes.graphml").read().iterate()
}
catch (IOException e)
{
  println "Could not load the graph file"
  System.exit(0)
}
----

First we just do a simple query to find the vertex representing the AUS airport and
use 'println' to display some information about it.

[source,groovy]
----
def aus = g.V().has('code','AUS').valueMap().next()

println aus
----

NOTE: Just as when we were looking at building a Java application, you need to
terminate your query with a step such as 'next', 'toList' or 'fill' to make sure you
get back the results that you expect.

Now we have the beginnings of an application it's time to make sure we can compile
it. The key thing we need to do is make sure we pickup the TinkerPop specific JAR
files as shown in the next section.

[[groovyc]]
Compiling our Groovy application
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In the Java example, we included the CLASSPATH on the 'javac' invocation using the
'-cp' flag. That can also be done when using Groovy, however, if you are using
Microsoft Windows as your build environment you may find that using '-cp' gives
unexpected errors. Therefore, it is recommended to define the CLASSPATH variable in
your environment before running the Groovy compiler.

The commands below work in a Bash shell but could be easily ported to other
environments. The GREMLIN variable should point to wherever you have installed and
unzipped the Gremlin Console download

----
# Root directory for Gremlin Console install
GREMLIN=...

# Path to Gremlin core JARs
LIBPATH=$GREMLIN/lib/*

# Path to TinkerGraph JARs
EXTPATH=$GREMLIN/ext/*

#Path to additional JARs
ADDL=$GREMLIN/ext/tinkergraph-gremlin/lib/*

# Classpath
export CLASSPATH=$CLASSPATH:$LIBPATH:$EXTPATH:$ADDL

# Compile
groovyc TinkerGraphTest.groovy
----

Running our Groovy application
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Assuming everything compiled cleanly we can now run our Groovy application.

[source,groovy]
----
groovy TinkerGraphTest
----

And here is the sort of output we should get back.

[source,groovy]
----
Gremlin version is 4.0.0
Loading the air-routes graph...

[country:[US], code:[AUS], longest:[12250], city:[Austin], elev:[542], icao:[KAUS], lon:[-97.6698989868164], type:[airport], region:[US-TX], runways:[2], lat:[30.1944999694824], desc:[Austin Bergstrom International Airport]]
----

Now that we have a small skeleton of a test program running, we can start to add a
few more interesting features to it.


Adding to our Groovy application
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The code below demonstrates how to work with the 'valueMap' for the Austin vertex
that we created a few lines back in our program.

[source,groovy]
----
// Retrieve the city name property and display it
def city = aus['city']
println "\nThe AUS airport is in ${city[0]}\n"

// Iterate through the keys we got back and print them along with their values
aus.each {println "${it.key} : ${it.value[0]}"}
----

If we were to re-compile and run our program now, the lines that we added will
generate the following output.

[source,groovy]
----
The AUS airport is in Austin

country : US
code : AUS
longest : 12250
city : Austin
elev : 542
icao : KAUS
lon : -97.6698989868164
type : airport
region : US-TX
runways : 2
lat : 30.1944999694824
desc : Austin Bergstrom International Airport
----

As we did in our Java program earlier, we can add a query to see how many routes
there are that originate at the DFW airport.

[source,groovy]
----
def n = g.V().has("code","DFW").out().count().next()
println "\nThere are  ${n} routes from Dallas"

There are  221 routes from Dallas
----

Next we can add some code to find the IATA codes representing the places that we can
fly to from DFW.

[source,groovy]
----
// Where can I fly to from DFW?
def fromDfw = g.V().has("code","DFW").out().values("code").toList()
println "\nHere are the places you can fly to from DFW\n"
println fromDfw
----

When we run the code we should get back some results that look like this.

[source,groovy]
----
Here are the places you can fly to from DFW

[CID, HNL, HOU, SAN, SNA, SLC, LAS, DEN, SAT, MSY, EWR, DTW, ELP, SJU, CLE, OAK, TUS, SAF, PHL, GEG, BZN, JAC, GCM, MEI, PIB, KOA, SUX, SBA, ASE, CVN, BKG, BIS, GUC, MTJ, TVC, CNM, GLH, SWO, BIL, MAF, BDL, RAP, SDF, SHV, BOI, LBB, RNO, CMH, ICT, ACT, CLL, ABI, SGF, RIC, CCS, TXK, PIA, LEX, GUA, CRP, MTY, AMA, BJX, BMI, BOG, BPT, DSM, MYR, AEX, CZM, AGU, COU, DAY, CUU, DRO, BRO, BTR, BZE, CAE, CHA, CHS, CMI, GCK, GDL, GGG, GJT, GPT, EVV, FAR, FAT, FSD, FSM, FWA, JAN, JLN, YYZ, LAW, YVR, LCH, LHR, LFT, CDG, LIR, GRI, GRK, GRR, GSO, GSP, MLI, PEK, MLM, PVG, MLU, FCO, MOB, AMS, MSN, MAD, MZT, RSW, PBC, FRA, LRD, NRT, MFE, SYD, MGM, DXB, MHK, HKG, QRO, ICN, ROW, GIG, SAL, GRU, SAV, EZE, SJD, LIM, SJT, SCL, SLP, MEX, SPI, YUL, PLS, YEG, PNS, YYC, PTY, DOH, OKC, TYS, ONT, VPS, AUH, XNA, CLT, ZCL, CUN, EGE, PSP, HDN, MEM, UIO, CVG, MID, TYR, ATL, ANC, TLH, SPS, PIT, TRC, PDX, ABQ, MKE, OMA, TUL, PVR, OGG, DUS, LGA, NAS, STL, JFK, LAX, AUS, IND, MGA, BNA, MCI, BOS, BWI, DCA, FLL, IAD, IAH, JAX, PUJ, SJO, SMF, RTB, COS, SJC, HSV, TPA, BHM, LIT, ORF, SFO, MCO, MBJ, MIA, MSP, ORD, PBI, PHX, RDU, SEA]
----

The code below will discover all of the airports in the United States that you can
fly to from London's Heathrow airport (LHR). Only the first 10 results are selected
using a 'limit' step. A 'path' step is used to nicely return the airport pairs and
the distance between them. What we get back is a list of paths so we can use a simple
Groovy 'each' loop to print the results.

[source,groovy]
----
def lhrToUsa = g.V().has("code","LHR").outE().inV().
                     has("country","US").limit(10).
                     path().by("code").by("dist").toList()

println "\nFrom LHR to airports in the USA (only 10 shown)\n"

lhrToUsa.each {println it}
----

Here are the 10 routes that were returned when we ran the code having added this new
query.

[source,groovy]
----
From LHR to airports in the USA (only 10 shown)

[LHR, 4896, PDX]
[LHR, 3980, CLT]
[LHR, 4198, ATL]
[LHR, 4901, AUS]
[LHR, 3254, BOS]
[LHR, 3622, BWI]
[LHR, 4736, DFW]
[LHR, 3665, IAD]
[LHR, 4820, IAH]
[LHR, 3440, JFK]
----

Finally, lets write the code to find the airports in England that you can get to from
Austin with no more than one stop.

[source,groovy]
----
def eng = g.V().has("code","AUS").repeat(__.out()).emit().times(2).
                has("region","GB-ENG").dedup().values("code").toList();

println "\nAirports in England reachable with no more than one stop from AUS"
println "\n${eng}\n"
----

Here are the results, looks like we can get to a total of nine different airports if
we make no more than one stop on the way.

[source,groovy]
----
Airports in England reachable with no more than one stop from AUS

[LHR, BRS, LGW, STN, MAN, BHX, LBA, NCL, LCY]
----

Now that we have a somewhat interesting Groovy application up and running, should you
so choose, you can build upon this foundation just as we did in the "<<javatinker>>"
section.


[[groovypredicates]]
Using Gremlin predicates in a Groovy application
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Just as we had to do when writing a standalone Java application, when you use a
Gremlin predicate such as 'eq' or 'neq' from a Groovy program you need to prefix it
with a '"P."' which references the TinkerPop class of the same name where a
set of static methods, representing the Gremlin predicates, are defined.

NOTE: The source code in this section comes from the 'GraphRegion.groovy' sample
located at https://github.com/krlawrence/graph/tree/main/sample-code/groovy.

In the code below, the 'findByRegion' method that we wrote in Java earlier has been
ported to Groovy. As before a String representing a three character airport IATA code
is expected as input. The method then uses a Gremlin query to figure out which
geographical region the specified airport is in and then returns all airports also in
that region. Once again, note the use of 'P.eq' as part of the 'where' step.

[source,groovy]
----
def findByRegion(iata)
{
  println("\nRegion code lookup for " + iata )

  def list =
    g.V().has("code",iata).values("region").as("r").
      V().hasLabel("airport").as("a").values("region").
          where(P.eq("r")).by().
          local(__.select("a").values("city","code","region").fold()).toList()

  list.each {println it}
}
----




// vim: set tw=85 cc=+1 wrap spell redrawtime=20000:
[[janusgraph]]
INTRODUCING JANUS GRAPH
-----------------------

This chapter could also be called "Moving beyond TinkerGraph", as that is what we are
going to focus on next. TinkerGraph has served us well in our journey thus far, but
there comes a time when you need to evaluate options for a graph database that
supports concepts such as persistent storage, high availability, data durability,
ACID transactions, advanced indexing, schema definition and enforcement, and remote
access. 

There are several open source and commercial options available these days.
One of the open source choices that supports most of the features listed above, is
JanusGraph, and that is be the technology we focus on in this chapter. 

NOTE: While the Apache TinkerPop 3.7.0 release did introduce a version of TinkerGraph
that supports transactions, most of the other features on our list fall outside the
design scope of TinkerGraph.

[[janusintro]]
Getting started with JanusGraph
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The JanusGraph project was created at the Linux Foundation in 2016 as a fork of the
open source Titan graph database, and has since become popular amongst graph database
users. JanusGraph offers a broad feature set, and significant flexibility in terms of
integration with storage backends and external indexing technologies.

NOTE: We have attempted to provide a reasonable coverage of many JanusGraph features,
but it is still recommended to become familiar with the official documentation where
you will find more in depth discussions of advanced topics and configuration options.

Just like TinkerGraph, JanusGraph can easily be run on a laptop, which is useful for
learning and experimenting, but it is designed for much more complex cases, and  to
handle very large graphs with billions of nodes and edges, stored on distributed
clusters. JanusGraph is designed to work with a variety of persistent storage options
including Apache Cassandra, and Apache HBase, as well as external indexing
technologies such as Apache Solr, and Elasticsearch.

.Here are some useful JanusGraph resources
Runtime download (JAR files and more)::
http://janusgraph.org/
Documentation::
http://docs.janusgraph.org/.
API Documentation::
http://javadoc.io/doc/org.janusgraph/janusgraph-core/

In the following sections we will take an in depth look at JanusGraph and other
technologies that, when combined, provide a way to build and deploy a massively
scalable graph database solution. We will start by quickly looking at how to install
JanusGraph and access it from the Gremlin Console before getting into more advanced
topics including how to create and manage both schemas and indexes and how to use the
transactional capabilities provided by JanusGraph.

It is also recommended that you read and get familiar with the official JanusGraph
documentation as well as reading what is presented below.

[[janusinstall]]
Installing JanusGraph
^^^^^^^^^^^^^^^^^^^^^

JanusGraph itself is very easy to install. You just have to download the ZIP file
and unzip it into a convenient location. Having done that you can immediately begin
to experiment with it if you use the 'inmemory' option which is explained more in the
"<<janusinmemory>>" section below. However, for a production deployment you will
probably be using JanusGraph in conjunction with some sort of persistent storage, an
indexing service and other components that will also have to be installed. We will
get into that a bit later on. The download page has information regarding versions of
related technologies like Apache Cassandra and Apache Solr that JanusGraph has been
tested with.

NOTE: It is important to remember that JanusGraph does not have its own process, it
is not a delivered as a service that you run, rather it is a set of Java libraries
that have to be invoked either from your own code, the Gremlin Console, or the
JanusGraph Server available in the install package.

The install package for JanusGraph is located at
https://github.com/JanusGraph/janusgraph/releases and is a single ZIP file.
'JanusGraph-version.zip' contains the JanusGraph core libraries, the JanusGraph
server, and the Gremlin console. 'JanusGraph-full-version.zip' in addition contains
Apache Cassandra and Elasticsearch binaries which are the recommended default storage
and indexing backends for you to try out. Once you have it downloaded and unzipped
you are ready to experiment using the Gremlin Console.  As will be discussed below,
when working with JanusGraph, you must use the version of the Gremlin Console that is
packaged as part of the JanusGraph download.

[[janusconsole]]
Using JanusGraph from the Gremlin Console
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A version of the Gremlin Console is included as part of the JanusGraph download. The
only major difference between this version of the console and the one you get as part
of the standard Apache TinkerPop download is that the console has been preconfigured
to recognize and find the JanusGraph specific classes. A good example of one such
class is 'JanusGraphFactory' that is used from the Console to create a new JanusGraph
instance.

NOTE: When working with JanusGraph you must use the version of the Gremlin Console
that is packaged as part of the JanusGraph download.

As mentioned above, JanusGraph is not a standalone service, it is a set of Java
classes that still need to be invoked by a calling process. The Gremlin Console can
play that role. After you have unzipped JanusGraph you will find the `gremlin.sh` and
`gremlin.bat` scripts in the `bin` directory under the JanusGraph parent directory.
Once you have started the Gremlin Console you can, as we will explore in the next few
sections, tell JanusGraph about the environment you will be operating in in terms of
store backend and index backend.

[[janusinmemory]]
Using JanusGraph with the 'inmemory' option
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For almost all production use cases, you will be using JanusGraph along with a
persistent storage backend such as Apache Cassandra, Apache HBase, Google Cloud 
BigTable, ScyllaDB, Oracle Berkeley DB, DataStax Astra, Amazon Keyspace, etc. However 
while experimenting with JanusGraph it is incredibly useful to be able to get up and
running quickly without having to worry about configuring all of the back end storage
components. This is made possible by the 'inmemory' option that JanusGraph provides. 
This essentially allows us to use JanusGraph in the same way as we have been using 
TinkerGraph with all of our graph data stored in the memory of the computer. The one
big difference however is that JanusGraph, even while using the 'inmemory' storage 
model, allows us to experiment with features that TinkerGraph does not offer, such 
as schemas and external indices. If you want to host your graph on a single machine 
and you don't need persistence support, you could also use 'inmemory' storage model 
in production. We will get into those topics a bit later on. First, let's create an
instance of JanusGraph from the Gremlin console that uses the 'inmemory' storage 
model.

Creating a JanusGraph instance is very similar to the way we created a TinkerGraph
instance earlier in the book. The only difference is that we use the
'JanusGraphFactory' to create the graph and in this case we specify 'inmemory' as the
only parameter to tell JanusGraph that we want to use the all in memory storage
model. We create our graph traversal object 'g' in just the same way as before.

[source,groovy]
----
graph = JanusGraphFactory.open('inmemory')
g = traversal().with(graph)
----

Note that the 'open' command above is a shorthand form of the command shown below.

[source,groovy]
----
graph = JanusGraphFactory.build().set("storage.backend","inmemory").open()
g = traversal().with(graph)
----

Now that we have a graph instance created, just like with TinkerGraph, we can query
which features the graph supports. Earlier in the book in the "<<tgintro>>"
section we looked at the features offered by TinkerGraph. If we compare those
features to what JanusGraph offers we can spot some key differences.

We can get the feature set back by calling the 'features' method as shown below. The
first thing that stands out is that the various features that involve transactions
are now set to 'true' indicating that JanusGraph supports transactions. We will take
a look at how to use these transactional capabilities in the next section. Note that
'Persistence' still shows as 'false' as we are using the 'inmemory' mode. Another
thing to note is that, unlike with TinkerGraph, 'UserSuppliedIds' is set to false,
indicating that JanusGraph will create its own ID values and ignore any that we
provide by default. Note that since 1.0.0, JanusGraph allows us to provide vertex ids
in long and string types, but this functionality has to be explicitly enabled. The
list is formatted in two columns to aid readability.

.JanusGraph features
----
graph.features()

> GraphFeatures                            > VertexPropertyFeatures
>-- Transactions: true                     >-- AddProperty: true
>-- Computer: true                         >-- RemoveProperty: true
>-- ConcurrentAccess: true                 >-- NumericIds: false
>-- ThreadedTransactions: true             >-- StringIds: true
>-- Persistence: false                     >-- UuidIds: false
> VariableFeatures                         >-- CustomIds: true
>-- Variables: true                        >-- AnyIds: false
>-- LongValues: true                       >-- UserSuppliedIds: false
>-- BooleanArrayValues: true               >-- Properties: true
>-- ByteArrayValues: true                  >-- LongValues: true
>-- DoubleArrayValues: true                >-- BooleanArrayValues: true
>-- FloatArrayValues: true                 >-- ByteArrayValues: true
>-- IntegerArrayValues: true               >-- DoubleArrayValues: true
>-- StringArrayValues: true                >-- FloatArrayValues: true
>-- LongArrayValues: true                  >-- IntegerArrayValues: true
>-- StringValues: true                     >-- StringArrayValues: true
>-- MapValues: true                        >-- LongArrayValues: true
>-- MixedListValues: false                 >-- StringValues: true
>-- SerializableValues: false              >-- MapValues: true
>-- UniformListValues: false               >-- MixedListValues: false
>-- BooleanValues: true                    >-- SerializableValues: false
>-- ByteValues: true                       >-- UniformListValues: false
>-- DoubleValues: true                     >-- BooleanValues: true
>-- FloatValues: true                      >-- ByteValues: true
>-- IntegerValues: true                    >-- DoubleValues: true
> VertexFeatures                           >-- FloatValues: true
>-- MetaProperties: true                   >-- IntegerValues: true
>-- AddVertices: true                      > EdgePropertyFeatures
>-- RemoveVertices: true                   >-- Properties: true
>-- MultiProperties: true                  >-- LongValues: true
>-- AddProperty: true                      >-- BooleanArrayValues: true
>-- RemoveProperty: true                   >-- ByteArrayValues: true
>-- NumericIds: true                       >-- DoubleArrayValues: true
>-- StringIds: false                       >-- FloatArrayValues: true
>-- UuidIds: false                         >-- IntegerArrayValues: true
>-- CustomIds: false                       >-- StringArrayValues: true
>-- AnyIds: false                          >-- LongArrayValues: true
>-- UserSuppliedIds: false                 >-- StringValues: true
> EdgeFeatures                             >-- MapValues: true
>-- RemoveEdges: true                      >-- MixedListValues: false
>-- AddEdges: true                         >-- SerializableValues: false
>-- AddProperty: true                      >-- UniformListValues: false
>-- RemoveProperty: true                   >-- BooleanValues: true
>-- NumericIds: false                      >-- ByteValues: true
>-- StringIds: false                       >-- DoubleValues: true
>-- UuidIds: false                         >-- FloatValues: true
>-- CustomIds: true                        >-- IntegerValues: true
>-- AnyIds: false
>-- UserSuppliedIds: false
----

Now that we have an empty instance of an 'inmemory' JanusGraph we can use it from
the Gremlin Console just as we did with TinkerGraph in our prior examples. Notice
that the ID values that JanusGraph generates look quite different (as in they don't
start at zero) from what we might expect from TinkerGraph. The id generation
scheme is non-deterministic, meaning you probably won't get the same ID values as
shown in the example.

[source,groovy]
----
g.addV('person').property('name','Kelvin')
v[4232]

g.V().has('name','Kelvin')
v[4232]

g.V().has('name','Kelvin').id()
4232
----

Before we experiment too much more with JanusGraph there are three important subjects
we need to discuss. One is transactions, another is defining a schema and indexes for
our vertices, edges and properties and the third is the JanusGraph management API. We
will cover each of these key subjects in the following sections.

[[janustrans]]
JanusGraph transactions
^^^^^^^^^^^^^^^^^^^^^^^

JanusGraph is a production-ready graph database that supports many billions of
vertices and edges.
As such, a typical use case for JanusGraph is storing and mutating (updating) a very
large graph persisted by a storage backend. In such an environment, support for
transactions is very important. If you are used to other databases that
offer transactional support, and as the JanusGraph documentation points out, you
should not rely on JanusGraph transactions being fully Atomic, Consistent, Isolated
and Durable (ACID). The amount of ACID support will depend on the backend store being
used. We will take a look at some of the backend storage options in the
"<<janusstorage>>" section.

NOTE: The official JanusGraph documentation includes detailed coverage of how
transactions are processed and techniques to use based on different usage scenarios.
You will always find the latest version here:
https://docs.janusgraph.org/basics/transactions/

In many cases, when using JanusGraph, you do not have to explicitly open a new
transaction. Instead, it will be opened for you as needed. Take a look at the example
below. A transaction is opened when 'addV' is called and remains open until
'commit' is called. Note also that in order to access the JanusGraph transaction
capabilities, we use the 'tx' method associated with our 'g' instance. The examples 
below assume you have the Gremlin Console connected to a JanusGraph instance. The 
'inmemory' JanusGraph we created earlier will work fine for these examples as 
transactions are supported even with 'inmemory' JanusGraph instances. Note that we 
have not shown the warning message that JanusGraph will display reminding us that we
have not created an index for our new property. We will explore how to create an 
index in the "<<jaindexintro>>" section.

[source,groovy]
----
// Start a new transaction
g.addV().property('name','XYZ')

v[4216]

// Commit the transaction
graph.tx().commit()

// Check to make sure our new vertex was created
g.V().has('name','XYZ')

v[4216]
----

Sometimes, it may be necessary to undo or 'rollback' what we have done rather than
continue and 'commit' the transaction. This can be achieved calling the 'rollback'
method as shown below.

[source,groovy]
----
// Start a new transaction
g.addV().property('name','ABC')

// Rollback the transaction
graph.tx().rollback()

// Nothing will be returned
g.V().has('name','ABC')
----

Note that the JanusGraph Management system, that is the subject of the next section,
has its own transaction system that is used when creating schema entries and
otherwise configuring a graph.

[[janusmgmt]]
The JanusGraph management API
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

JanusGraph includes a management API that is made available via the 
'ManagementSystem' class. You can use the management API to perform various important
functions that include querying metadata about the graph, defining the edge, vertex 
and property schema types and creating and updating the index.

You can create an instance of the ManagementSystem object using the 'openManagement'
method call as shown below.

[source,groovy]
----
mgmt = graph.openManagement()
----

In the following sections we will show how to use the management API to create both a
schema and an index for the 'air-routes' graph and then load it. Before we do that we
should take a few minutes to introduce the JanusGraph Management API. For the
time being, assume we have created an in memory JanusGraph instance and loaded the
'air-routes' graph into it but have not defined an index or a schema. In this
situation, JanusGraph will give us the best defaults it can as it loads the graph
for schema types.

The example below uses the Management API to get a list of all the vertex labels
currently defined in graph.

[source,groovy]
----
mgmt.getVertexLabels()

version
airport
country
continent
----

This query similarly finds all of the currently defined edge labels.

[source,groovy]
----
mgmt.getRelationTypes(EdgeLabel.class)

route
contains
----

This query will find all of the currently defined property keys. Note that this
list will include both vertex and edge property key names

[source,groovy]
----
mgmt.getRelationTypes(PropertyKey.class)

lat
dist
date
code
author
type
desc
country
longest
city
elev
icao
lon
region
runways
----

We can query the cardinality of a property.

[source,groovy]
----
mgmt.getPropertyKey('code').cardinality()

SINGLE
----

Note that as we have not so far defined a schema for the 'air-routes' graph. if we
query the dataType for any of the already loaded properties we will get back
the data type that JanusGraph infers.

[source,groovy]
----
mgmt.getPropertyKey('code').dataType()

class java.lang.String
----

We can also test for the existence of a label definition in the graph.

[source,groovy]
----
mgmt.containsEdgeLabel('route')

true

mgmt.containsEdgeLabel('travels')

false
----

[[cardlist]]
Creating a property with cardinality LIST
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Using the JanusGraph Management API it is possible to specify that a property can
accept as list of values. This can be done by specifying a cardinality of 'LIST' when
the property key is created. Unless we explicitly do this, whenever a property is
created the cardinality will default to 'SINGLE'. The code below can be run from a
Gremlin Console connected to a JanusGraph instance. A property key called 'mylist' is
created that can accept 'String' values. Before the key is created, its cardinality
is specified as 'LIST'. Always remember to 'commit' the management transaction when 
you are done making changes.

[source,groovy]
----
mgmt = graph.openManagement()
maker = mgmt.makePropertyKey('mylist')
maker.dataType(String.class)
maker.cardinality(LIST)
maker.make()
mgmt.commit()
----

Note that the previous steps could be chained together as shown below.

[source,groovy]
----
mgmt = graph.openManagement()
mgmt.makePropertyKey('mylist').dataType(String.class).cardinality(LIST).make()
mgmt.commit()
----

Now that we have created a new key, when can use the Management API to check that its
cardinality is indeed set to 'LIST'. As always, whenever we are done using the API we
should close the transaction with a call to 'commit'.

[source,groovy]
----
mgmt = graph.openManagement()
mgmt.getPropertyKey('mylist').cardinality()

LIST

mgmt.commit()
----

We can now create a new vertex and add some values using our new 'mylist' property.
Note that as our cardinality is 'LIST' and not 'SET' that we can have duplicate 
values associated with our new property.

[source,groovy]
----
n = g.addV().property('mylist','one').property('mylist','two').next()

v[3043568]

g.V(n).property(list,'mylist','one')
g.V(n).valueMap()

// Duplicates allowed
[mylist:[one,one,two]]

graph.tx().commit()
----

[[cardset]]
Creating a property with cardinality SET
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Using the JanusGraph Management API we can also specify that a property can contain a
'SET' of values. The difference between a cardinality of 'SET' and a cardinality of
'LIST' is that sets do not allow duplicate values.

Let's create a new property key called 'numbers' that will accept a set of integer
values.

[source,groovy]
----
mgmt = graph.openManagement()
mgmt.makePropertyKey('numbers').dataType(Integer.class).cardinality(SET).make()
----

As before we can double check the cardinality of our new property.

[source,groovy]
----
mgmt.getPropertyKey('numbers').cardinality()

SET
----

Also as before once we are done making changes we need to commit our management
transaction.

[source,groovy]
----
mgmt.commit()
----

Let's now create a new vertex and do some testing to make sure that JanusGraph does
enforce the rules we expect from a set. First of all we create a new vertex and put
the values 1,2 and 3 into the property. This works as expected.

[source,groovy]
----
n = g.addV().property('numbers',1).property('numbers',2).property('numbers',3).next()

v[2846792]

g.V(n).valueMap()

[numbers:[1,2,3]]
----

Now let's try adding a second value of 2 and see what happens. As you can see, our
second 2 was not added to our set as there was already a 2 present.

[source,groovy]
----
g.V(n).property(set,'numbers',2)
g.V(n).valueMap()

// Duplicates not allowed
[numbers:[1,2,3]]
----

Let's try adding a 4 instead. This works as there is no existing value of 4 already
in the set.

[source,groovy]
----
g.V(n).property(set,'numbers',4)
g.V(n).valueMap()

[numbers:[1,2,3,4]]
----

Finally we can commit our graph transaction as we are all done creating properties.

[source,groovy]
----
g.tx().commit()
----

[[janusschema]]
Defining a JanusGraph schema for the air-routes graph
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You are not required to define the types and labels of your edges, vertices and
properties ahead of time but it is strongly recommended that you do so. If you do not
define anything and load the air routes data for example, it will work fine but 
JanusGraph will make assumptions about various things. Without a schema being
defined, JanusGraph will default the usage constraint or 'multiplicity' setting on
all edges to 'MULTI'. We will explain what that means in a minute but in essence it
means there is no restriction by default on how many edges with the same label that
can exist between two vertices.

You can use the Management API do define your schema. You can add additional property
types at any time but once defined you cannot change their types. The only thing you
can do once they have been created is to change the names of the keys.

A best practice when working with JanusGraph is to define your labels and property
types before you load any data into the graph. As the graph grows if you find you
need to add additional property types or labels you are allowed to do that.

Using the management API you can define the labels that will be used by vertices and
edges. These values must be unique across the graph. You can also define the type and
cardinality ('SINGLE', 'LIST' or 'SET') of each property key and for edges you can 
specify the allowed usage of edges for any given label ('MULTI', 'MANY2ONE', 
'ONE2MANY', 'ONE2ONE' or 'SIMPLE'). Property key names must also be unique across the
graph.

Before we can define a schema for our edge labels we need to understand what each
option allows and decide on the best fit for each of our edge types.

.The multiplicity options provide the following constraints:
MULTI::
- This is the default option if no multiplicity has been defined for an edge with
a given label. This setting permits multiple edges of the same label between any
pair of vertices. The 'air-routes' graph uses a multiplicity of 'MULTI' for the
'routes' edges between airports.

SIMPLE::
- This setting permits at most one edge of a given label between any pair of
  vertices. In the 'air-routes' graph this setting is used for the edges between a
  continent and an airport as an airport cannot be in more than one continent. The
  same is used for the edges between airports and countries.
MANY2ONE::
- This setting permits at most one outgoing edge of a given label name from any 
  vertex in the graph but places no constraint on the number of incoming edges with 
  this label.
ONE2MANY::
- This setting permits at most one incoming edge of a given label to any vertex in 
  the graph but places no constraint on the number of outgoing edges
ONE2ONE::
- This setting permits at most one incoming and one outgoing edge of a given label to
  and from any vertex in the graph.

Defining edge labels and usage
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's look at how we can use the JanusGraph Management API to specify the
multiplicity for the 'route' and 'contains' edges used by the 'air-routes' graph.

[source,groovy]
----
// Define edge labels and usage
mgmt = graph.openManagement()
mgmt.makeEdgeLabel('route').multiplicity(MULTI).make()
mgmt.makeEdgeLabel('contains').multiplicity(SIMPLE).make()
mgmt.commit()
----

Defining vertex labels
^^^^^^^^^^^^^^^^^^^^^^

Now let's tell JanusGraph about the vertex labels that we are going to be using. The
'air-routes' graph has four different vertex types, namely, 'version', 'airport',
'country' and 'continent' so we will create a label for each of those.

[source,groovy]
----
// Define vertex labels
mgmt = graph.openManagement()
mgmt.makeVertexLabel('version').make()
mgmt.makeVertexLabel('airport').make()
mgmt.makeVertexLabel('country').make()
mgmt.makeVertexLabel('continent').make()
mgmt.commit()
----

Defining vertex property keys
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Next we need to define the property keys and data types that our vertices will be
using. The 'air-routes' graph only uses properties that have a cardinality of 
'SINGLE'.

[source,groovy]
----
// Define vertex property keys
mgmt = graph.openManagement()
mgmt.makePropertyKey('code').dataType(String.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('icao').dataType(String.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('type').dataType(String.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('city').dataType(String.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('country').dataType(String.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('region').dataType(String.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('desc').dataType(String.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('runways').dataType(Integer.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('elev').dataType(Integer.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('lat').dataType(Double.class).cardinality(Cardinality.SINGLE).make()
mgmt.makePropertyKey('lon').dataType(Double.class).cardinality(Cardinality.SINGLE).make()
mgmt.commit()
----

Defining edge property keys
^^^^^^^^^^^^^^^^^^^^^^^^^^^

We also need to define the property keys and data types that will be used on edges.
Currently the 'air-routes' graph only has one edge property, 'dist' that is used to
store the distance between two airports.

[source,groovy]
----
// Define edge property keys
mgmt = graph.openManagement()
mgmt.makePropertyKey('dist').dataType(Integer.class).cardinality(Cardinality.SINGLE).make()
mgmt.commit()
----

Now that we have defined our schema, we can use the management API to double check
that everything we just did looks correct. The snippet of code below can be run from
within the Gremlin console and will display the property keys along with their data
types and cardinality settings.


[source,groovy]
----
// Look at the properties
mgmt = graph.openManagement()
mgmt.printSchema()
mgmt.commit()
----


This is the output we should get back if our schema creation has succeeded. Note that
both the edge and vertex property keys are displayed. You can see Graph Index
(Vertex), Graph Index (Edge), and Relation Index (VCI) sections are empty, because
we haven't defined any index yet.

[source,groovy]
----
---------------------------------------------------------------------------------------------------
Vertex Label Name              | Partitioned | Static                                             |
---------------------------------------------------------------------------------------------------
version                        | false       | false                                              |
airport                        | false       | false                                              |
country                        | false       | false                                              |
continent                      | false       | false                                              |
---------------------------------------------------------------------------------------------------
Edge Label Name                | Directed    | Unidirected | Multiplicity                         |
---------------------------------------------------------------------------------------------------
route                          | true        | false       | MULTI                                |
contains                       | true        | false       | SIMPLE                               |
---------------------------------------------------------------------------------------------------
Property Key Name              | Cardinality | Data Type                                          |
---------------------------------------------------------------------------------------------------
lat                            | SINGLE      | class java.lang.Double                             |
lon                            | SINGLE      | class java.lang.Double                             |
dist                           | SINGLE      | class java.lang.Integer                            |
code                           | SINGLE      | class java.lang.String                             |
icao                           | SINGLE      | class java.lang.String                             |
type                           | SINGLE      | class java.lang.String                             |
city                           | SINGLE      | class java.lang.String                             |
country                        | SINGLE      | class java.lang.String                             |
region                         | SINGLE      | class java.lang.String                             |
desc                           | SINGLE      | class java.lang.String                             |
runways                        | SINGLE      | class java.lang.Integer                            |
elev                           | SINGLE      | class java.lang.Integer                            |
---------------------------------------------------------------------------------------------------
Graph Index (Vertex)           | Type        | Unique    | Backing        | Key:           Status |
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
Graph Index (Edge)             | Type        | Unique    | Backing        | Key:           Status |
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
Relation Index (VCI)           | Type        | Direction | Sort Key       | Order    |     Status |
---------------------------------------------------------------------------------------------------
----

[[janusload]]
Loading air-routes into a JanusGraph instance
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now that we know how to create a schema for the 'air-routes' graph we can use the 
same basic steps to load it into a JanusGraph instance that we used with TinkerGraph.
Note that after loading the graph from the XML file we then call 'commit' to finalize
the transaction.

[source,groovy]
----
g.io('air-routes.graphml').read().iterate()
graph.tx().commit()
----

Note that had we not defined a schema before loading the 'air-routes' graph that
JanusGraph would have still created the vertices, edges and properties but using
default types and settings. A bit later we will look at creating an index for the
'air-routes' graph as well. It is strongly recommended to create the index as well as
the schema before loading the data but let's examine a few more things before we
discuss how to do that.

Unlike TinkerGraph, JanusGraph does not support user
provided vertex ID values by default, and does not support edge ID values as of now.
Instead it creates its own ID values as vertices and edges are added to the graph.
You may have noticed from earlier in the book or from the `air-routes.graphml` file
if you happened to look in there, that the ID provided for Austin in the GraphML
markup is 3. However, having loaded 'air-routes' into JanusGraph if we query the ID
for the Austin vertex we can see that it is no longer 3. There is a setting that can
be changed to force JanusGraph to accept user provided ID values. If you want to try
out this option, please refer to the JanusGraph documentation:
https://docs.janusgraph.org/advanced-topics/custom-vertex-id.

[source,groovy]
----
g.V().has('code','AUS').id()

4240
----

If necessary, as discussed earlier, we can always store important ID values in a
variable for later use.

[source,groovy]
----
ausid = g.V().has('code','AUS').id().next()

g.V(ausid).values('city','desc','region').join(', ')

Austin Bergstrom International Airport, Austin, US-TX
----

Note that property values are not necessarily returned in the order you requested.
That can be seen by looking at the example above. Our 'values' step had 'city' first
but in fact the 'desc' properties value was returned first. Gremlin makes no
guarantees that items will be returned in the specific order you requested. They are
returned in the order in which they are found during a traversal. You should not
build in dependencies to your queries on the order things are returned in. If you
need a specific ordering you should sort or otherwise manipulate the returned results
of a query to match your needs.

[[jaindexintro]]
JanusGraph indexes
~~~~~~~~~~~~~~~~~~

JanusGraph supports two different types of indexing known as 'graph indexes' and
'relation indexes' (also known as 'vertex centric indexes', or 'VCI') respectively.
Graph indexes can be stored at the primary storage backend (known as 'composite
indexes') as well as external indexing backend (known as 'mixed indexes'). All of
these concepts will be discussed and explained in the following sections. Using an
index will greatly improve performance of your graph queries and is something you
should get familiar with doing for any graphs that you create or manage. While in
many cases use of an index is optional by default, we strongly recommend that you
view it as mandatory. The JanusGraph documentation provides some fairly in depth
coverage of indexing and can be read by visiting the following URL:
https://docs.janusgraph.org/schema/index-management/index-performance/

[[graphindexes]]
Graph indexes
^^^^^^^^^^^^^

If you have used other types of database such as a relational database, you may
already be familiar with the concept of using an index to speed up random access to
the entire database. When using JanusGraph that is the role played by a 'graph
index'. The main job of a 'graph index' is to get you to the starting point of your
query as efficiently as possible without having to first search the entire graph to
find the vertices or edges that you are looking for.

You should always establish a 'graph index' for the property keys, or combinations of
keys, you will use regularly in your queries when working with JanusGraph. In some
situations you will also need to create 'vertex centric indexes', a subject we will
discuss next, but most likely this will be part of tuning the performance of your
graph rather than from the start. Conversely, You should plan on creating your
'graph indexes' along with your initial graph schema. The simplest form of 'graph
index' is the composite index that we will see how to create and use soon.

[[vciintro]]
Vertex centric indexes
^^^^^^^^^^^^^^^^^^^^^^

A vertex centric index, as the name suggests is an index associated with a vertex.
These are typically used when the number of incident edges on a given vertex becomes
significantly large such that it can impact performance. It's also known as relation
index, as it's used to speed up relation look ups. As mentioned above, it is likely
that when you first create your graph and graph schema that you will just create a
set of 'graph indexes' and only create 'vertex centric indexes' as the need arises.

[[compositeintro]]
Introducing 'composite' indexes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A composite index can be used to speed up queries where an exact match with the value
for a given property key is sufficient. For example, the query below could take
advantage of a composite index as we are only looking for exact matches where the
value associated with the 'city' key is the value 'Paris'.

[source,groovy]
----
g.V().has('city','Paris')
----

A composite index can be defined to support queries that use more than one key. For
example we could create an index that can be used for queries that look at the 'city'
and 'country' property keys to help with a query like the one below that will find
the vertex for the airport in the city of London in Ontario, Canada, but not the ones
in London, England.

[source,groovy]
----
g.V().has('city','London').has('country','CA')
----

A composite index will not help if we want to get more sophisticated and look for
partial matches, use predicates other than 'equal to' or use regular expressions in
our queries. That is where the 'mixed index' comes in to play. So for example, a
composite index would not help with the following query that looks for airports in
the 'air-routes' graph with more than five runways.

[source,groovy]
----
g.V().has('runways',gt(5))
----

[[mixedintro]]
Introducing 'mixed' indexes
^^^^^^^^^^^^^^^^^^^^^^^^^^^

As mentioned above, if the queries that you expect to be writing require more than a
simple test for equality then you will need to create what is referred to as a 'mixed
index'. Once you decide to create a mixed index you will also need to configure an
indexing backend such as Apache Solr or Elasticsearch. We will explore the
use of mixed indexes in the "<<extindex>>" section.

[[compositeindex]]
Building a composite index to speed up exact match searching
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is strongly recommended that you create graph indexes for any property keys that
you are likely to be using regularly in queries. An index can greatly speed up
searching a graph as without an index being present JanusGraph has to search your
entire graph each time you issue a query looking for one or more specific properties,
unless your query looks up by vertex ID. If you issue a query that uses property keys
that have not been indexed, the query will still work but unless warnings have been
turned off, JanusGraph will remind you that you should consider creating an index to
improve the performance of your query.

NOTE: You should be aware that some graph systems running JanusGraph may have
disabled the ability to do a full graph search thus requiring that you always have an
index for any property keys that you use in your queries.

Take a look at the example below. We issue a simple query looking for the airport
with a 'code' property containing the value 'LHR'. Because we have not yet created an
index for that property key, JanusGraph gives us a warning before also returning the
vertex that we are looking for. If the administrator of the JanusGraph system you are
using has disabled the ability to do full graph searches (a feature that is on by
default but can be disabled) the query below will fail with an error message.

[source,groovy]
----
g.V().has('code','LHR')

WARN  org.janusgraph.graphdb.transaction.StandardJanusGraphTx
    - Query requires iterating over all vertices [(code = LHR)].
      For better performance, use indexes

v[32904]
----

If an index is present, before looking at the graph itself, JanusGraph will look at
the index. If the property key being searched for has been indexed, there will be
entries in the index pointing to each occurrence of that property key within the
graph. This enables JanusGraph to directly fetch those elements without having to
search the entire graph looking for them. With a large graph this can provide a very
substantial performance improvement. Depending on your indexing needs you may or may
not need to also use an external indexing technology such as Apache Solr or
Elasticsearch. The subject of using an external index is discussed a bit later.
First of all let's take a look at the types of index that you can create that
JanusGraph can manage by itself without needing help from an external index.

Using JanusGraph you can create and manipulate an index using the Management API. It
is strongly recommended that you always close all open transactions before you start
to create an index to avoid schema staleness problems.

The example below shows how to use the Management API to create a new composite index
for the airport 'code' property in the 'air-routes' graph.

[source,groovy]
----
// Make sure no other transactions are active
graph.getOpenTransactions().each{tx -> tx.rollback()}

// Open a new management transaction
mgmt = graph.openManagement()

// Create a composite index for the code key for use with vertices
idx = mgmt.buildIndex('airportIndex',Vertex.class)
iata = mgmt.getPropertyKey('code')
idx.addKey(iata).buildCompositeIndex()

// All done commit our changes to end the transaction
mgmt.commit()
----

Having created the index it is important to wait until it is available before trying
to do anything else. We can do that by calling the 'awaitGraphIndexStatus' method
that is also part of the JanusGraph Management API.

[source,groovy]
----
mgmt.awaitGraphIndexStatus(graph, 'airportIndex').
     status(SchemaStatus.REGISTERED).call()
----

If we already have data in the graph we now also need to tell JanusGraph to perform a
re-index. Once again we use the Management API to do this but this time using the
'updateIndex' method.

[source,groovy]
----
mgmt = graph.openManagement()
mgmt.updateIndex(mgmt.getGraphIndex("airportIndex"), SchemaAction.REINDEX).get()
mgmt.commit()
----

The above process could be very slow if you have a lot of data, in which case you 
could use MapReduce to reindex existing data in parallel: 
https://docs.janusgraph.org/schema/index-management/index-reindexing/.

If we re-run the same query we used earlier and got the warning about using indexes 
from JanusGraph, this time we get the same result but without the warning. This tells
us that JanusGraph was able to satisfy our query using the index that we just 
created.

[source,groovy]
----
g.V().has('code','LHR')

v[32904]
----

We can also use the JanusGraph Management API to query information about the index
that we just defined. As you can see below, as we have only created one index so far,
that is all that is returned.

[source,groovy]
----
mgmt = graph.openManagement()
// you could also use mgmt.printSchema() to display the entire schema
mgmt.printIndexes()
mgmt.commit()
----

[source,groovy]
----
---------------------------------------------------------------------------------------------------
Graph Index (Vertex)           | Type        | Unique    | Backing        | Key:           Status |
---------------------------------------------------------------------------------------------------
airportIndex                   | Composite   | false     | internalindex  | code:         ENABLED |
---------------------------------------------------------------------------------------------------
Graph Index (Edge)             | Type        | Unique    | Backing        | Key:           Status |
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
Relation Index (VCI)           | Type        | Direction | Sort Key       | Order    |     Status |
---------------------------------------------------------------------------------------------------
----

It is also possible to define an index that will support a query containing more than
one key. For example we might want to create an index that would be used to help with
queries like the one below which is essentially a query looking for any vertex that
has a 'city' property with a value of 'London' AND a country property with a value
of 'CA'.

[source,groovy]
----
g.V().has('city','London').has('country','CA')
----

We could define an index to support such a query using the code that follows. Note
that the only differences from the prior example are that we add two keys rather than
one to the index. Note also that the 'addKey' methods are called with the 'country'
key coming before the 'city' key which is the reverse order to which we expect the
Gremlin query to use the keys.

[source,groovy]
----
// Make sure no other transactions are active
graph.getOpenTransactions().each{tx -> tx.rollback()}

// Start a new management transaction
mgmt = graph.openManagement()

// Find the property keys that we need to index
city = mgmt.getPropertyKey('city')
country = mgmt.getPropertyKey('country')

// Create a new index and add our keys
index = mgmt.buildIndex('byCityAndCountry', Vertex.class)
index.addKey(country).addKey(city).buildCompositeIndex()

// All done
mgmt.commit()

// Wait for the index to be active
mgmt.awaitGraphIndexStatus(graph, 'byCityAndCountry').call()

// Force a re-index
mgmt = graph.openManagement()
mgmt.updateIndex(mgmt.getGraphIndex("byCityAndCountry"), SchemaAction.REINDEX).get()
mgmt.commit()
----

We can use the Gremlin 'profile' step to verify that JanusGraph is indeed now using
our new index. We have truncated some of the output so it will fit on the page but
you can see from the output that the query did indeed use our new index.

[source,groovy]
----
g.V().has('city','London').has('country','CA').profile()
----

Here is the output returned by the query.

[source,console]
----
Traversal Metrics
Step                                              Traversers  Time (ms)
========================================================================
JanusGraphStep([],[city.eq(London), country.eq(...    1          26.059
  constructGraphCentricQuery                                     11.676
  GraphCentricQuery                                               5.962
    \_condition=(city = London AND country = CA)
    \_orders=[]
    \_isFitted=true
    \_isOrdered=true
    \_query=multiKSQ[1]
    \_index=byCityAndCountry
    backend-query                                                 3.709
      \_query=byCityAndCountry:multiKSQ[1]
                                            >TOTAL    -          26.059
----

A script to automate schema creation, indexing and graph loading
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In the sample code directory of our GitHub project for this book you will find a
small Gremlin (Groovy) script in a file called 'janusgraph-inmemory.groovy'. You can
get to the file by visiting this URL:
https://github.com/krlawrence/graph/blob/main/sample-code/groovy/janus-inmemory.groovy.

The script will create an 'inmemory' JanusGraph instance, define the schema, create
several indexes and load the `air-routes.graphml` file so that you can try some
queries using the Gremlin Console. You might find that a good way to experiment with
the concepts that we have covered in this discussion of JanusGraph so far.

[[janpred]]
Additional JanusGraph text search predicates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We have already looked, in the "<<tranges>> section, at the predicates TinkerPop
defines such as 'neq', 'gte' and 'lte'. JanusGraph offers an additional set of
predicates that can be used when looking for specific patterns within text in a
graph.

The methods that include the word 'Contains' in their name look for whole words that
match the specified search pattern. The methods that do not include 'Contains' in the
name look at the entire string being inspected for matches.

The table below summarizes the additional text search predicates that JanusGraph
provides.

.Additional JanusGraph text search predicates
[cols="^1,4"]
|==============================================================================
|textContains           | True if a whole word matches the search string provided.
|textContainsPrefix     | True if at least one word starts with the search string provided.
|textContainsRegex      | True if at least one word matches the regular expression provided.
|textContainsFuzzy      | True if a word matches the fuzzy search text provided.
|textContainsPhrase     | True if the text string does contain the sequence of words in the search string provided.
|textPrefix             | True if the string being inspected starts with the search text.
|textRegex              | True if the string being inspected matches the regular expression provided.
|textFuzzy              | True if the string being inspected matches the fuzzy search text.
|==============================================================================

Let's take a look at each of these predicates and what they offer with examples of
each being used. First off, the query below will find any vertex that has a 'desc'
(description) property that contains the word '"Dallas"'. Note that this matches
'Dallas' followed by any word break character such as a space or a forward slash.

Text comparison predicates
^^^^^^^^^^^^^^^^^^^^^^^^^^

The simplest of the search predicates allow you to specify an exact match that string
must be present either as a whole word (complete word match) or as part of the entire
text being examined. These searches are *not* case sensitive.

[source,groovy]
----
g.V().has('desc',textContains("Dallas")).values('desc')
----

Here is what the query should return.

[source,console]
----
Dallas/Fort Worth International Airport
Dallas Love Field
----

The word being searched for using 'textContains' does not have to be the first word
within the string. It just has to exist as a whole word. The query below looks for
the word '"Love"' appearing anywhere in the 'desc' property.

[source,groovy]
----
g.V().has('desc',textContains("Love")).values('desc')
----

Here is what the query returns.

[source,console]
----
Dallas Love Field
Ernest A. Love Field
----

In this example the word 'fort' is found no matter where it occurs in the 'city'
name so long as it occurs as a standalone word.

[source,groovy]
----
g.V().has('city',textContains("fort")).values('city')
----

As you can see in the results below 'Vieux Fort' was found as well as all of the
cities with names that start with 'Fort'.

[source,console]
----
Fort Myers           Fort Worth
Fort-de-France       Fort McMurray
Fort Lauderdale      Fort Sandeman
Fort Wayne           Fort Smith
Fort St.John         Fort Yukon
Fort Nelson          Fort Albany
Fort Chipewyan       Fort Hood/Killeen
Fort Mcpherson       Vieux Fort
Fort Smith           Fort Good Hope
Fort Severn          Fort Frances
Fort Simpson         Fort Hope
Fort Leonard Wood    Fort Dodge
----


The query below does not match any whole word in any description anywhere in the
graph so no results will be returned.

[source,groovy]
----
// Matches no whole word so no results
g.V().has('desc',textContains("Dalla")).values('desc')
----

If we use 'textContainsPrefix' instead of 'textContains', the search will look for
whole words that start with the specified text and we will get some results. Take a
look at the next query and the results it generates.

TIP: Searches using 'textContains' and 'textContainsPrefix' are *not* case sensitive.

[source,groovy]
----
g.V().has('desc',textContainsPrefix("dalla")).values('desc')
----

Here is what the query returns. This time we got some results as 'Dallas' starts with
the characters 'dalla'. Again, remember these are case insensitive queries.

[source,console]
----
Dallas/Fort Worth International Airport
Dallas Love Field
----

We could use a 'textContains' query to find airports that have the
word 'Regional' as part of their description. An example of such a query is given
below. Only the first five matching airport descriptions found are returned.

[source,groovy]
----
g.V().has('desc',textContains('Regional')).values('desc').limit(5)
----

Here are the descriptions returned by the query.

[source,console]
----
Rapid City Regional Airport
Abilene Regional Airport
Grand Junction Regional Airport
San Luis County Regional Airport
Liberal Mid-America Regional Airport
----

We could adjust the regional airport query we did above to use  'textContainsPrefix'
if we wanted to be a bit less specific and look for any airport with 'Reg' at the
start of any word in its description.

[source,groovy]
----
g.V().has('desc',textContainsPrefix('Reg')).values('desc').limit(5)
----

We still get the same five results back.

[source,console]
----
Rapid City Regional Airport
Abilene Regional Airport
Grand Junction Regional Airport
San Luis County Regional Airport
Liberal Mid-America Regional Airport
----

The 'textPrefix' predicate will look at the entire string being inspected and compare
it to the string you provide and only return a result if the string starts with the
specified pattern. So in this case we look at just the start of the whole string and
not at individual words within it. The query below looks for any cities whose name
starts with the characters 'Los'.

[source,groovy]
----
g.V().has('city',textPrefix('Los')).values('city')
----

TIP: Searches using 'textPrefix' *are* case sensitive.

This is what we get back from the query.

[source,console]
----
Los Alamos
Los Angeles
Los Mochis
Losuia
----

Notice how the query did not find the city of 'Chapelco/San Martin de los Andes' as
in this case the 'Los' is not at the start of the name. If we did want to also have
that city discovered we could use 'textContainsPrefix' instead as shown below.

[source,groovy]
----
g.V().has('city',textContainsPrefix('Los')).values('city')
----

As you can see this time we also found 'Chapelco/San Martin de los Ande' and it is
part of the results returned. As before the case of the search term is ignored.

[source,console]
----
Los Alamos
Chapelco/San Martin de los Andes
Los Angeles
Los Mochis
Losuia
----

Regular expression predicates
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is worth considering a bit of history when discussing regular expression
predicates for JanusGraph. JanusGraph introduced text-based predicates many years
before TinkerPop added them to Gremlin in version 3.6.0. As a result, there are
text predicates that are JanusGraph specific which have similar functionality to the
ones officially exposed by Gremlin itself. This section describes the
JanusGraph-specific text predicates. You can learn more about the official Gremlin
text predicates in the "<<regex>>" section.

The JanusGraph regular expression predicates recognize the syntax defined as part of
the Java 1.8 Pattern class that is documented at
https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Pattern.html.
The Java regular expression syntax may be different than the one you are used to so
it is worth taking a few minutes to study the documentation at that URL.

The query below uses a 'textContainsRegex' predicate to search for any city name that
contains a word starting with 'for', while ignoring case.

[source,groovy]
----
g.V().has('city',textContainsRegex("(?i)for.*")).values('city')
----

Notice how names that start with 'For' such as 'Fort Myers' as well as city names
containing words that start with the text 'For' in a subsequent word are found. For
example 'La Fortuna'  and 'View Fort' are also found.

[source,console]
----
Fort Myers                Fort Worth
La Fortuna/San Carlos     Fort McMurray
Fort-de-France            Fort Sandeman
Fort Lauderdale           Fortaleza
Fort Wayne                Fort Smith
Jerez de la Forntera      Fort Yukon
Fort St.John              Fort Albany
Fort Nelson               Fort Hood/Killeen
Fort Chipewyan            Vieux Fort
Formosa                   Fort Good Hope
Fort Mcpherson            Grand Forks
Fort Smith                Fort Frances
Juiz de Fora              Fort Hope
Fort Severn               Fort Dodge
Fort Simpson              Fort Leonard Wood
----

The query below shows another way of searching for the word 'dallas' at the start of
a string of text while ignoring case. This time we use a very simple regular
expression. Of course, in reality, this yields the same result that we could achieve
by simply using 'textContainsPrefix'.

[source,groovy]
----
// Matches dallas ignoring case
g.V().has('city',textRegex("(?i)dallas")).valueMap('code','city')
----

As we can see the query worked as expected.

[source,console]
----
[code:[DFW],city:[Dallas]]
[code:[DAL],city:[Dallas]]

----

If we wanted to expand our search a bit we could modify the regular expression, as
shown below, to find an city name that starts with the characters 'dal'.

[source,groovy]
----
// Matches any city that contains dal followed by anything, ignoring case.
g.V().has('city',textRegex('(?i)dal.*')).values('city')
----

This time we get some additional cities back.

[source,console]
----
Dallas
Dallas
Dalcahue
Dalat
Dalaman
Dalanzadgad
Dalian
----

If we instead wanted to get more specific we could again adjust the regular
expression. This time we look for any city name that starts with any three characters
followed by the characters 'cah' followed by any number of other characters.

[source,groovy]
----
// Anything that matches 3 characters followed by 'cah' followed by anything.
g.V().has('city',textRegex(".{3}cah.*")).values('city')
----

Using our modified, and much more specific search pattern we find just one city that
matches the pattern.

[source,console]
----
Dalcahue
----

Here is another example that looks for a city name that starts with any three
characters followed by either 'cah' or 'anz' followed by any number of characters.

[source,groovy]
----
g.V().has('city',textRegex(".{3}(cah|anz).*")).values('city')
----

Here is what we get back using this regular expression.

[source,console]
----
Dalcahue
Dalanzadgad
----

Here is another query that uses a regular expression to find airports that have a
region code that starts with the characters 'US-' followed by any of 'O', 'R' or 'D'
followed by any number of characters.

[source,groovy]
----
g.V().has('region',textRegex("US-[ORD].*")).
      local(values('code','region').fold()).fold()
----

Here is what this query returns.

[source,groovy]
----
[[PVD,US-RI],[LMT,US-OR],[SWO,US-OK],[PDX,US-OR],[EUG,US-OR],[MFR,US-OR],[TOL,US-OH],[PDT,US-OR],[CMH,US-OH],[OTH,US-OR],[YNG,US-OH],[OKC,US-OK],[DAY,US-OH],[LAW,US-OK],[LCK,US-OH],[LUK,US-OH],[RDM,US-OR],[DCA,US-DC],[CLE,US-OH],[TUL,US-OK],[CAK,US-OH],[ILG,US-DE],[BID,US-RI]]

----

Here is a slightly more complicated query that uses a regular expression. The pattern
matches any airport description containing a word that starts with any character
followed by 'al', optionally followed by another 'l' and then followed by any
character that is not one of '"s,k,e,i"' ignoring case.

[source,groovy]
----
g.V().has('desc',textContainsRegex("(?i).all?[^(s|k|e|i)]")).values('desc')
----

Here is the list of airport descriptions that the query returns.

[source,console]
----
Dinard-Pleurtuit-Saint-Malo Airport
Walla Walla Regional Airport
Salt Lake City
Palm Springs International Airport
Eduardo Falla Solano Airport
Palm Beach International Airport
Salt Cay Airport
Melville Hall Airport
Hall Beach Airport
----

Fuzzy search predicates
^^^^^^^^^^^^^^^^^^^^^^^

These predicates use the
https://en.wikipedia.org/wiki/Levenshtein_distance[Levenshtein distance] method to
decide if a piece of text is 'close enough' to the pattern being looked for. This is
based on assessing how many characters would have to change in the pattern word to
achieve a match in the text being inspected. For example 'pall' would match 'palm',
'paul' and 'palm' with Levenshtein distance being one. JanusGraph uses different 
Levenshtein distance criteria for string of different lengths. It uses 0 for strings
of one or two characters (exact match), 1 for strings of three, four or five 
characters, and 2 for strings of more than five characters.

The query below uses a fuzzy sort to find any words that are close to the word
'pall'.

[source,groovy]
----
g.V().has('desc',textContainsFuzzy("pall")).values('desc')
----

Here are the results from running the query. You can see that airport descriptions
that contain the whole words 'Paul', 'Palm' and 'Hall' have been found.

[source,console]
----
Minneapolis-St.Paul International Airport
Palm Beach International Airport
Palm Springs International Airport
John Paul II International Airport Krakow-Balice Airport
Melville Hall Airport
Hall Beach Airport
St Paul Island Airport
----

This query uses 'textFuzzy' to find cities whose names are close to Dublin.
[source,groovy]
----
g.V().has('city',textFuzzy('Dublin')).values('city')
----

Here is what the query returns. You can see that the method used by 'fuzzy' searches
is more than just single character replacement. Note that not all of the city names
returned are of the same length. To better understand the 'fuzzy search' algorithm it
is recommended to look at the Wikipedia page mentioned above.

[source,console]
----
Yulin
Hubli
Dublin
Lublin
Dubois
Dubai
----

[[janusgeo]]
The JanusGraph GeoSpatial API
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Earlier, in the "<<latlonmanual>>" section, we provided a few examples of how we
could write some queries that took advantage of the fact that the airports in the
'air-routes' graph include their latitude and longitude among their properties. When
working with JanusGraph there are some additional built in capabilities that we can
take advantage of.

NOTE: The official JanusGraph API documentation is a good place to read up on the
GeoShape class and related classes. That documentation can always be found by
starting here: https://javadoc.io/doc/org.janusgraph/janusgraph-core/latest/index.html

The example below shows one way that we could use the GeoSpatial API to find airports
within a circle having a 100 kilometer radius with London Heathrow (LHR) at the
center of that circle. A key class to be aware of is the 'Geoshape' class. It can be
used to create areas that we can use when testing for other coordinates falling
within that area.

Notice in the code below that for each airport in the graph a 'point' is created
based on the latitude and longitude of that airport. A test is then performed to see
if that 'point' lies within our 100km circle. Only airports that do are passed on to
the 'valueMap' step. Notice also how a 'map' step is used so that we can do some
calculations inside of a closure while creating the 'point'.

[source,groovy]
----
// Get the lat/lon for LHR
lon = g.V().has('code','LHR').values('lon').next()
lat = g.V().has('code','LHR').values('lat').next()

// Create a 100km radius circle with LHR at the center
boundary = Geoshape.circle(lat,lon,100)

// Find other airports that are within that circle
g.V().hasLabel('airport').
      where(map{a=it.get().value('lat');
                b=it.get().value('lon');
                Geoshape.point(a,b).within(boundary)}.is(true)).
                valueMap('code','lat','lon')
----

Below is the output that you might bet back from running the above query. The query
can be run as-is from the Gremlin Console connected to a JanusGraph instance
containing the 'air-routes' graph.

[source,groovy]
----
[code:[LGW],lon:[-0.190277993679047],lat:[51.1481018066406]]
[code:[BZZ],lon:[-1.58361995220184],lat:[51.749964]]
[code:[STN],lon:[0.234999999404],lat:[51.8849983215]]
[code:[LTN],lon:[-0.368333011865616],lat:[51.874698638916]]
[code:[SOU],lon:[-1.35679996013641],lat:[50.9502983093262]]
[code:[LHR],lon:[-0.461941003799],lat:[51.4706001282]]
[code:[LCY],lon:[0.055278],lat:[51.505278]]
[code:[SEN],lon:[0.695555984973907],lat:[51.5713996887207]]
----

There are many ways we could optimize our query to avoid creating a 'point' for every
single airport in the graph. In this particular case, we might decide, for example,
that we are only interested in airports in England. To do this we could add a check
to our query to make sure that only airports with a region code of 'GB-ENG' are
tested. Here is the query modified with that check added.

[source,groovy]
----
// Find other airports that within 100km of LHR
g.V().has('airport','region','GB-ENG').
      where(map{a=it.get().value('lat');
                b=it.get().value('lon');
                Geoshape.point(a,b).within(boundary)}.is(true)).
                valueMap('code','lat','lon')
----

Here is the output from running the query again. Other than the order in which
results were returned being different we got the same results. However this query is
more efficient as it is able to take advantage of the index that we created earlier
for the 'region' property to filter out all airports not in the region 'GB-ENG'.

[source,groovy]
----
[code:[LGW],lon:[-0.190277993679047],lat:[51.1481018066406]]
[code:[LHR],lon:[-0.461941003799],lat:[51.4706001282]]
[code:[LCY],lon:[0.055278],lat:[51.505278]]
[code:[STN],lon:[0.234999999404],lat:[51.8849983215]]
[code:[LTN],lon:[-0.368333011865616],lat:[51.874698638916]]
[code:[SOU],lon:[-1.35679996013641],lat:[50.9502983093262]]
[code:[SEN],lon:[0.695555984973907],lat:[51.5713996887207]]
[code:[BZZ],lon:[-1.58361995220184],lat:[51.749964]]
----

Using the GeoSpatial API we can create shapes representing different geographic
regions and compare them. The example below shows how to create a 100km circle with
Longdon heathrow (LHR) at the center and a second circle with Manchester (MAN) at the
center. The 'intersect' method is then used to see if any points appear in both
circles.

[source,groovy]
----
// Create a 100km radius circle with LHR at the center

lon_lhr = g.V().has('code','LHR').values('lon').next()
lat_lhr = g.V().has('code','LHR').values('lat').next()

lhr_circ = Geoshape.circle(lat_lhr,lon_lhr,100)

// Create a 100km radius circle with MAN at the center

lat_man = g.V().has('code','MAN').values('lat').next()
lon_man = g.V().has('code','MAN').values('lon').next()

man_circ = Geoshape.circle(lat_man,lon_man,100)

// Do any points in the two circles intersect?

lhr_circ.intersect(man_circ)

false
----

As you can see the test returns 'false' indicating that there are no shared points.
To prove that the tests work when points do overlap, let's create another 100km
circle with Liverpool (LPL) in the middle and compare that one with the Manchester
circle.

[source,groovy]
----
// Create a 100km radius circle with LPL at the center

lat_lpl = g.V().has('code','LPL').values('lat').next()
lon_lpl = g.V().has('code','LPL').values('lon').next()

lpl_circ = Geoshape.circle(lat_lpl,lon_lpl,100)

// Do any points in the two circles intersect?

lpl_circ.intersect(man_circ)

true
----

The 'Geoshape' class provides a number of useful methods. If we wanted to verify that
the latitude and longitude values we got back from the LHR vertex were valid, meaning
they do indeed represent a point somewhere on Earth, we could do so as follows.

[source,groovy]
----
Geoshape.isValidCoordinate(lat,lon)

true
----

Earlier, in the "<<latlonmanual>>" section we demonstrated the query below. The query
finds all airports within a conceptual rectangle around the London Heathrow (LHR)
airport. The rectangle is defined by adding or subtracting one degree of latitude and
longitude to the opposite diagonals with LHR at the center.

[source,groovy]
----
lat = g.V().has('code','LHR').values('lat').next()
lon = g.V().has('code','LHR').values('lon').next()

g.V().hasLabel('airport').has('lon',between(lon-1,lon+1)).
                          has('lat',between(lat-1,lat+1)).
                          valueMap('code','lat','lon')
----

Here is the output that query produced.

[source,groovy]
----
[code:[LHR],lon:[-0.461941003799],lat:[51.4706001282]]
[code:[LGW],lon:[-0.190277993679047],lat:[51.1481018066406]]
[code:[LCY],lon:[0.055278],lat:[51.505278]]
[code:[STN],lon:[0.234999999404],lat:[51.8849983215]]
[code:[LTN],lon:[-0.368333011865616],lat:[51.874698638916]]
[code:[SOU],lon:[-1.35679996013641],lat:[50.9502983093262]]
----

We can use the JanusGraph Geoshape class to rewrite the query as shown below. Instead
of using a 'circle' this time we will create a 'box' representing a geographical
region around London Heathrow (LHR).

[source,groovy]
----
// Define a box around LHR with opposite diagonal corners
// each one degree from LHR.
box = Geoshape.box(lat_lhr-1,lon_lhr-1,lat_lhr+1,lon_lhr+1)

// Find other airports that within the box
g.V().has('airport','region','GB-ENG').
      where(map{a=it.get().value('lat');
                b=it.get().value('lon');
                Geoshape.point(a,b).within(box)}.is(true)).
                valueMap('code','lat','lon')
----

The results from running our new query are shown below. As you can see the same
airports were found.

[source,groovy]
----
[code:[LGW],lon:[-0.190277993679047],lat:[51.1481018066406]]
[code:[LHR],lon:[-0.461941003799],lat:[51.4706001282]]
[code:[LCY],lon:[0.055278],lat:[51.505278]]
[code:[STN],lon:[0.234999999404],lat:[51.8849983215]]
[code:[LTN],lon:[-0.368333011865616],lat:[51.874698638916]]
[code:[SOU],lon:[-1.35679996013641],lat:[50.9502983093262]]
----

We have just shown a few examples of the many things that you can do using the
JanusGraph GeoSpatial API. If this is an area that interests you, we recommend
reading the API documentation for the 'Geoshape' and related classes.

[[janusstorage]]
Choosing a persistent storage technology for JanusGraph
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

So far we have concentrated on examples where the graph data resides in the memory of
the computer system. The only form of persistence we have so far looked at is saving
an entire graph as JSON or XML and reading it back into memory at a future date.
Clearly, for many production systems, we need a better story for data persistence. As
delivered, JanusGraph supports a number of different back end databases that can be
used to persist graph data. A bit later, in the "<<dockercass>>" section, we will
explore a simple way to experiment with one of these database options.

Once JanusGraph has been downloaded and installed (unzipped) you will find a
directory called /conf below the directory where JanusGraph was installed. In this
directory you will find a number of Java properties files that can be used to connect
JanusGraph to different back end data stores. Depending upon your configuration these
property files may work unchanged or may need to be edited. Each property file has
detailed comments that explain what the various setting do.

NOTE: The official JanusGraph documentation provides detailed configuration
information for each of the currently supported back end stores:
https://docs.janusgraph.org/storage-backend/

Let's now take a brief look at some of the persistent storage options available to us
when using JanusGraph.

[[berkeleyintro]]
Oracle Berkeley DB
^^^^^^^^^^^^^^^^^

Oracle Berkeley DB may be a good choice if your application runs on a single machine
but needs a persistent store. All data is persisted to the same local disk of the
system where your application runs. Berkeley DB is popular with developers who want 
to develop and test graph applications on a single machine using more than an 
in-memory back end. Assuming you are developing an application using Java or Groovy, 
the Java version of Berkeley DB, known as Berkeley DB Java Edition, is provided as a 
set of libraries that you embed with your application and run using the same JVM as 
your application. Because Berkeley DB JE runs on a single machine, the amount of 
graph data that you can store will depend on the size of the disk available on that 
machine.

For production systems that only need a modest sized graph this may also be a valid
choice. If your application is likely to generate very large graphs in excess of 100
million vertices you will probably need to investigate some of the other, multi node
cluster capable, storage options that we will discuss next. Berkeley DB is probably
not a good choice if you need multiple users to be accessing and changing the graph
concurrently.

The JanusGraph '/conf' directory contains a file called
'janusgraph-berkleyje.properties' that can be used to create a new instance of a
JanusGraph backed by Berkeley as follows.

[source,groovy]
----
graph = JanusGraphFactory.open("conf/janusgraph-berkleyje.properties")
----

Alternatively, as there is not much to configure when using Berkeley DB, you could
decide to pass the properties directly to JanusGraph as follows. The second 'set'
command specifies where your data will be stored on the disk.

[source,groovy]
----
graph = JanusGraphFactory.build().
          set("storage.backend","berkleyje").
          set("storage.directory","/mydata").
          open()
----

Oracle Berkeley DB can be downloaded from the Oracle web site from the following URL.
http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/overview/index.html


[[cassandraintro]]
Apache Cassandra
^^^^^^^^^^^^^^^^

If a single machine storage solution, such as that offered by Berkeley DB, is
insufficient for your needs then there are several other choices that offer
horizontal scaling and high availability. Apache Cassandra is one such choice. Which
storage solution you chose will depend on many factors that go beyond the scope of
this book. However, if you already have Apache Cassandra deployed in your
organization or data center and have people that know how to manage and configure it,
it might be the right choice for your JanusGraph back end storage needs. Like any big
data system Apache Cassandra requires tuning and maintenance to get the best
performance for your workload type. That potentially requires developing new skills
and doing some experimentation. Apache Cassandra is written in Java and it is
important to keep a careful eye on the amount of garbage collection taking place
within the virtual machines that are running your Cassandra instances. Excessive
garbage collection can significantly impact your graph's performance. There are many
ways that Cassandra can be deployed ranging from a single instance on your local
machine to a multi node cluster. How you deploy it will depend on your scalability
and redundancy needs. Note that Cassandra, like Berkeley DB can, if needed, also run
in embedded mode.

NOTE: For detailed configuration information you should refer to the official
JanusGraph documentation located at stores:
https://docs.janusgraph.org/storage-backend/cassandra/.

A bit later, in the "<<dockercass>>" section, we will take a look at deploying a
single node instance of Cassandra using Docker containers which provides a nice
environment for development and testing.

The JanusGraph '/conf' directory contains several property files that can be used
when working with Apache Cassandra. Which one you use will depend on the way you
chose to deploy Cassandra. Later on we will look at the additional steps you need to
take to configure your environment when external indexes are used. However, if you
were using Cassandra without an external index being needed you might connect to it
as follows.


[source,groovy]
----
graph = JanusGraphFactory.open("conf/janusgraph-cassandra.properties")
----

You will need to edit the properties file to contain the host name and IP address of
your Cassandra system. By default the properties file is configured for use with
'localhost'.


Apache Cassandra can be downloaded from the Apache web site from the following
URL. http://cassandra.apache.org/

[[scyllaintro]]
ScyllaDB
^^^^^^^^

ScyllaDB is API compatible with Apache Cassandra but implemented in C++. The same
configuration files that you use when working with Apache Cassandra should also work
with ScyllaDB.

ScyllaDB can be downloaded from the following URL. http://www.scylladb.com/

[[hbaseintro]]
Apache HBase
^^^^^^^^^^^^

If you already have a Hadoop and HDFS environment setup or are planning to deploy
one, then Apache HBase may be a good choice for your JanusGraph data store. Apache
HBase, like Apache Cassandra, is a database that supports very large tables. There
are several properties files in the '/conf' directory that can be used to connect
JanusGraph to an Apache HBase store.

NOTE: For detailed configuration information you should refer to the official
JanusGraph documentation located at https://docs.janusgraph.org/storage-backend/hbase/.

Which properties file you use will depend on whether or not you need to use an
external index. However, if you were using HBase without an external index being
needed you might connect to it as follows.

[source,groovy]
----
graph = JanusGraphFactory.open("conf/janusgraph-hbase.properties")
----

As with the Cassandra properties file, The HBase properties file is preconfigured to
connect to 'localhost'. You will need to edit it and update the hostname and IP
address as appropriate before calling 'open' if you want to connect to a different
machine.

Apache HBase can be downloaded from the Apache web site at the following
URL. https://hbase.apache.org/

Google Bigtable
^^^^^^^^^^^^^^^

All of the options discussed so far are open source alternatives that you could
download and run in-house. For the sake of completeness we are including a few
pointers to some "for fee" alternatives to hosting your JanusGraph data in house.
Google Bigtable is API compatible with Apache HBase. It offers a hosted alternative
to hosting your own HBase cluster for use with JanusGraph. Of course you will have to
decide if paying for a hosted database service is the way you want to go versus
hosting your graph data in house or setting up your own environment that you manage
on a hosting service of your choice.

You can read more about Google Bigtable at the following URL. https://cloud.google.com/bigtable/


Other TinkerPop compatible products and services
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There are now several other products and cloud hosted environments that do not offer
JanusGraph support per-se but do offer TinkerPop and Gremlin support backed by other
stores. There are a selection of both hosted and in-house options to choose from. The
Apache TinkerPop project maintains a list of TinkerPop compatible graph stores. You
can find that list here http://tinkerpop.apache.org/providers.html.

What is really good to see is that Apache TinkerPop, and in particular the Gremlin
query and traversal language, has become one of the primary ways that people are
building and interacting with, graph databases.


[[dockercass]]
Using Docker to experiment with Cassandra and JanusGraph
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We find that using Docker containers can be a great way to quickly get things running
when you are experimenting with new ideas or new technology, or as if often the case,
both at the same time! There is a very useful containerized implementation of Apache
Cassandra available that you can download and get running in a few seconds and use to
test things with JanusGraph. In this section we will walk you through the steps that
we use to get a single Cassandra node up and running and use it with JanusGraph to
setup the 'air-routes' graph. We are going to make the assumption that you have
already downloaded and installed the necessary Docker runtime for your platform. We
do most of our Docker testing using Linux systems but there are runtimes available
for Windows and Mac OS as well. Assuming you have docker installed, Cassandra can be
installed using a simple 'docker pull' command as shown below.

Note that to make it clearer where commands need to be entered, commands that need to
be entered into the Linux terminal shell are prefixed with  '"sh>"' and commands
that are entered into the Gremlin Console have the '"gremlin>"' prefix.

[source,console]
----
sh> docker pull cassandra
----

[[cassstart]]
Starting the Cassandra container
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Once Docker has downloaded the Cassandra image for you, it is quite simple to get a
single instance of Cassandra up and running. There are different ways that you can
use to configure Docker. To keep things simple we are going to just use command line
parameters. The command does several things as shown in the notes below it. We split
the command over four lines to make it easier to read.

[source,console]
----
sh> docker run -d -p 7001:7001 -p 7199:7199 -p 9042:9042 -p 9160:9160 \  <1> <2> <3>
-v  /var/lib/cassandra:/var/lib/cassandra \  <4>
--name cass  cassandra   <5>
----
<1> Starts a new instance of the Cassandra container.
<2> Runs the command in the background using the '"-d"' flag.
<3> Exposes the key ports that Cassandra uses so that JanusGraph can connect to this
Cassandra instance ('"-p"' flags).
<4> Maps (mounts) the Cassandra volume to the local disk. This is where the data will
be stored. If we did not do this the data would be lost whenever the container gets
deleted ('"-v"' flag).
<5> Names the container "cass" which makes it easier for us to refer to it later.


If you want to check on the progress of your new container at any time you can just
check the logs using the command below.

[source,console]
----
sh> docker logs cass
----

As with other Docker containers, our Cassandra container can be stopped and started
as needed using the following commands. Care should be taken not to stop the
container if JanusGraph is still busy writing data.

[source,console]
----
sh> docker stop cass

sh> docker start cass
----

[[cassconnect]]
Connecting JanusGraph to Cassandra
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now that we have an instance of a Cassandra running, it's time to start the Gremlin
Console that is included with the JanusGraph download and connect to Cassandra.

NOTE: The source code in this section comes from the 'janus-cassandra.groovy' sample
located at https://github.com/krlawrence/graph/tree/main/sample-code/groovy. The
script will automate everything that we are about to discuss in this section and you
are encouraged to study it.

A number of properties files are included with the JanusGraph download. They are
located in the '/conf' folder below the root of the JanusGraph folder. The properties
files can be used to help connect JanusGraph to a number of different back end
technologies. These properties files can be edited as needed but so long as you are
using the default Cassandra ports with Cassandra running on your local machine
(localhost) you should not have to edit anything for the purpose of this discussion.

NOTE: If you decide to run Cassandra on a remote machine, you will need to edit the
properties file, or create a new one, so that it contains the appropriate host names
and IP addresses of the remote system.

The protocol JanusGraph uses to communicate with Cassandra is called CQL. To get 
started, you can use the 'janusgraph-cql.properties' file as shown below.

[source,groovy]
----
gremlin> graph = JanusGraphFactory.open('conf/janusgraph-cql.properties')
----

If all goes well you should see something
like the output below after the command has run. This shows that we have a CQL
connection to our Cassandra instance running on or local machine at 127.0.0.1.

[source,groovy]
----
graphtraversalsource[standardjanusgraph[cql:[127.0.0.1]], standard]
----

The first time you connect to a brand new (empty) Cassandra instance you should first
define the graph's schema by creating key definitions and create any indexes that you
need before creating any vertices, edges or properties. If you would like to
experiment with the 'air-routes' data using Cassandra as the backing store, the
script called `janus-cassandra.groovy` from the `sample-code/groovy` folder can be
used for this. If you prefer you can experiment yourself from the console using the
JanusGraph management API to create keys and indexes and creating a traversal source
object before adding any vertices and edges.

If you choose run the `janus-cassandra.groovy` script it will create the keys and
indexes needed and then load the 'air-routes' graph and also run a few tests to make
sure everything is working. Note that you only need to do this setup step once as
next time the data will have already been loaded and the schema defined.

NOTE: As we are storing our graph into an instance of Cassandra where the data is
being persisted on our local file system, the next time you start JanusGraph and
re-connect to Cassandra your data will be waiting for you!

To run the script from the Gremlin Console you can just use the ':load' command to
load it as shown below.

[source,groovy]
----
gremlin> :load janus-cassandra.groovy
----

If the script works as expected you should now be able to query the graph.

[source,groovy]
----
gremlin> g.V().has('type','airport').count()

==>3379
----

Whenever you are finished working with the graph, it is a good idea to close it. Once
closed you will have to reconnect using one of the two 'open' steps shown above 
before you can start working with it again.

[source,groovy]
----
gremlin> graph.close()
----

If you are reconnecting to your graph, having previously loaded some data and closed
it, you can use the following commands.

[source,groovy]
----
// Reconnect using CQL
gremlin> graph = JanusGraphFactory.open('conf/janusgraph-cql.properties')

gremlin> g = traversal().with(graph)
----

A common requirement when testing and experimenting is to throw everything away and
start again. The easiest way to do this is to use the command shown below. This will
remove all of your data, indexes and schema definitions so only do this if you really
want to start over.

[source,groovy]
----
gremlin> JanusGraphFactory.drop(graph)
----

Having done a 'drop' operation, if you previously loaded the 'air-routes' data using
the janus-cassandra.groovy script, you will need to run the script again to get the
data, indexes and schema back.

One other thing to realize is that using the techniques shown in this section we are
connecting the Gremlin Console and JanusGraph directly to Cassandra. This means that
we can issue commands directly from the Gremlin Console without needing to use any
additional configuration or setup steps other than telling JanusGraph how to connect
to Cassandra using a properties file. Later in the book we will introduce the Gremlin
Server that allows you to front end a graph with an HTTP server. Remember also that
JanusGraph is really a set of Java libraries (JAR files). It does not create any
processes of its own and does not run as a service. So in this instance JanusGraph is
running on the process of the Gremlin Console. Cassandra of course is running as a
standalone service.

[[nodetool]]
Finding nodetool
^^^^^^^^^^^^^^^^

If for any reason you need to check on Cassandra settings or overall status, you
typically use the 'nodetool' command. Because in this case we are using a
containerized version of the Cassandra code, to run 'nodetool' you need to start a
shell session inside the container. This can be done using the 'docker exec' command
as shown below. Once you are inside the container you will find 'nodetool' available
on the default path. The examples below show how to start a bash session and enter a
few 'nodetool' commands. Finally we exit the session.

[source,console]
----
sh> docker exec -it cass bash
----

Once the shell process has started the prompt will change and you are now running
inside the context of the container.

[source,console]
----
root@115ed53ef189:/
----

We can now enter 'nodetool' commands. We have truncated the output a bit to aid
reading. First, let's check the version of Cassandra we are running.

[source,console]
----
root@115ed53ef189:/ nodetool version

ReleaseVersion: 3.11.11
----

If you want more information about the overall state of things you can use the
'nodetool info' command. We have truncated this output.

[source,console]
----
root@115ed53ef189:/ nodetool info

ID                     : 094e9a8c-99af-4d32-94da-49ed8c61b9fd
Gossip active          : true
Thrift active          : false
Native Transport active: true
Load                   : 3.64 MiB
Generation No          : 1517842270
Uptime (seconds)       : 2636
Heap Memory (MB)       : 102.43 / 1956.00
Off Heap Memory (MB)   : 0.03
Data Center            : datacenter1
Rack                   : rack1
Exceptions             : 0
----

Once we are done with the container typing 'exit' will return us to the Linux
terminal session we entered the container from.

[source,console]
----
root@115ed53ef189:/ exit

sh>
----


[[extindex]]
Using an external index with JanusGraph
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

JanusGraph allows an external index to be created using a technology such as
Apache Lucene, ElasticSearch or Apache Solr. You would create such an index in cases 
where you need to do more sophisticated pattern matching as part of a graph query. 
This topic is currently a little beyond the main focus of this book which is to give 
a detailed introduction to the Gremlin Query and Traversal language and some of the 
ways that technology can be deployed. You can find a detailed explanation of how to 
create an external index in the JanusGraph documentation which is located at the 
following URLs: 
https://docs.janusgraph.org/schema/index-management/index-performance/#mixed-index and https://docs.janusgraph.org/index-backend/.
